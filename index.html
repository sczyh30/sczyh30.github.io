<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="sczyh30" />


    
    


<meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「浮生若梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/index.html">
<meta property="og:site_name" content="「浮生若梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「浮生若梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="「浮生若梦」 - sczyh30&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>「浮生若梦」 - sczyh30&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="http://7xkkgd.com1.z0.glb.clouddn.com/blog-default-lambda-avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMQP/">AMQP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/APT/">APT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Akka/">Akka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-14/">C++ 14</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/">CAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CE3/">CE3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPS/">CPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/">Cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Category-Theory/">Category Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Continuation/">Continuation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DI/">DI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Engine/">Engine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Euterpea/">Euterpea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Loop/">Event Loop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GDB/">GDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game/">Game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC/">JUC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Klass-oop/">Klass-oop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda-Calculus/">Lambda Calculus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIDI/">MIDI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mathematical-Logic/">Mathematical Logic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metaspace/">Metaspace</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netflix-Hystrix/">Netflix Hystrix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-Model/">Object Model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PLT/">PLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Play-Framework/">Play Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quorum/">Quorum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reflection/">Reflection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheme/">Scheme</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slick/">Slick</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sort/">Sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Summary/">Summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Class/">Type Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Lambda/">Type Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-System/">Type System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Theory/">Type Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UE4/">UE4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中间件/">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云服务/">云服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存区域/">内存区域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式计算/">分布式计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息系统/">消息系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/滑动窗口/">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程安全/">线程安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/限流降级/">限流降级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高可用架构/">高可用架构</a></li></ul>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Distributed System/Deep Learning/PLT</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="http://7xkkgd.com1.z0.glb.clouddn.com/blog-default-lambda-avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-netflix-hystrix-1-5-sliding-window" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/高可用架构/netflix-hystrix-1-5-sliding-window/" class="article-date">
      <time datetime="2017-12-03T16:00:00.000Z" itemprop="datePublished">2017-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/高可用架构/netflix-hystrix-1-5-sliding-window/">Hystrix 1.5 滑动窗口实现原理总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="总览">总览</h1><p>Netflix Hystrix 通过类似滑动窗口的数据结构来统计调用的指标数据。Hystrix 1.5 将滑动窗口设计成了数据流（reactive stream, RxJava 中的 <code>Observable</code>）的形式。通过消费数据流的形式利用滑动窗口，并对数据流进行变换后进行后续的操作，可以让开发者更加灵活地去使用。由于 Hystrix 里大量使用了 RxJava，再加上滑动窗口本质就是不断变换的数据流，滑动窗口中每个桶的数据都来自于源源不断的事件，因此滑动窗口非常适合用观察者模式和响应式编程思想的 RxJava 实现。使用 RxJava 实现有一大好处：可以通过 RxJava 的一系列操作符来实现滑动窗口，从而可以依赖 RxJava 的线程模型来保证数据写入和聚合的线程安全，将这一系列的机制交给 RxJava。所有的操作都是在 RxJava 的后台线程上进行的，RxJava 会保证操作的有序性和线程安全（参见 <a href="http://reactivex.io/documentation/contract.html" target="_blank" rel="external">The Observable Contract</a>）。</p>
<p>这里我们就以 Hystrix 熔断器依赖的记录调用情况统计的 <code>HealthCountsStream</code> 为例来看一下 Hystrix 1.5 是如何利用 RxJava 将滑动窗口抽象并实现成 reactive stream 的，以及如何去消费对应的数据流。</p>
<p>滑动窗口的实现都位于 <code>com.netflix.hystrix.metric.consumer</code> 包下，这里只挑 <code>BucketedRollingCounterStream</code> 这条线的实现来分析。首先先看一下类的继承结构：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/hystrix/BucketedRollingCounterStream-hierarchy.png" alt="Class hierarchy of BucketedRollingCounterStream"></p>
<p>最顶层的 <code>BucketedCounterStream</code> 抽象类提供了基本的桶计数器实现，按配置的时间间隔将所有事件聚合成桶；<code>BucketedRollingCounterStream</code> 抽象类在其基础上实现滑动窗口，并聚合成指标数据；而最底下一层的类则是各种具体的实现，比如 <code>HealthCountsStream</code> 最终会聚合成健康检查数据（<code>HystrixCommandMetrics.HealthCounts</code>，统计调用成功和失败的计数），供 <code>HystrixCircuitBreaker</code> 使用。</p>
<h1 id="BucketedCounterStream">BucketedCounterStream</h1><h2 id="总览-1">总览</h2><p><code>BucketedCounterStream</code> 抽象类提供了基本的桶计数器实现。用户在使用 Hystrix 的时候一般都要配两个值：<code>timeInMilliseconds</code> 和 <code>numBuckets</code>，前者代表滑动窗口的长度（时间间隔），后者代表滑动窗口中桶的个数，那么每个桶对应的窗口长度就是 <code>bucketSizeInMs = timeInMilliseconds / numBuckets</code>（记为一个单元窗口周期）。<code>BucketedCounterStream</code> 每隔一个单元窗口周期（<code>bucketSizeInMs</code>）就把这段时间内的所有调用事件聚合到一个桶内。我们来看一下它的实现，首先来看一下它的泛型定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketedCounterStream</span>&lt;<span class="title">Event</span> <span class="keyword">extends</span> <span class="title">HystrixEvent</span>, <span class="title">Bucket</span>, <span class="title">Output</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>BucketedCounterStream</code> 的泛型里接受三个类型参数，其中第一个 <code>Event</code> 类型代表 Hystrix 中的调用事件，如命令开始执行、命令执行完成等。这种事件驱动的设计也非常符合 RxJava 的思想，每个调用者都向订阅者发布事件，订阅者将事件聚合成调用指标；第二个 <code>Bucket</code> 类型代表桶的类型，第三个 <code>Output</code> 类型代表数据聚合的最终输出类型。</p>
<p><code>BucketedCounterStream</code> 核心代码在构造函数里（为了可读性起见，将所有可以用 lambda expression 的地方都转换成了 lambda expression，下同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> numBuckets;</div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Observable&lt;Bucket&gt; bucketedStream;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Func1&lt;Observable&lt;Event&gt;, Observable&lt;Bucket&gt;&gt; reduceBucketToSummary;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BucketedCounterStream</span><span class="params">(<span class="keyword">final</span> HystrixEventStream&lt;Event&gt; inputEventStream, <span class="keyword">final</span> <span class="keyword">int</span> numBuckets, <span class="keyword">final</span> <span class="keyword">int</span> bucketSizeInMs,</span></span></div><div class="line">                                <span class="keyword">final</span> Func2&lt;Bucket, Event, Bucket&gt; appendRawEventToBucket) &#123;</div><div class="line">    <span class="keyword">this</span>.numBuckets = numBuckets;</div><div class="line">    <span class="keyword">this</span>.reduceBucketToSummary = eventBucket -&gt; eventBucket.reduce(getEmptyBucketSummary(), appendRawEventToBucket);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> List&lt;Bucket&gt; emptyEventCountsToStart = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numBuckets; i++) &#123;</div><div class="line">        emptyEventCountsToStart.add(getEmptyBucketSummary());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.bucketedStream = Observable.defer(() -&gt; &#123;</div><div class="line">        <span class="keyword">return</span> inputEventStream</div><div class="line">                .observe()</div><div class="line">                .window(bucketSizeInMs, TimeUnit.MILLISECONDS) <span class="comment">//bucket it by the counter window so we can emit to the next operator in time chunks, not on every OnNext</span></div><div class="line">                .flatMap(reduceBucketToSummary)                <span class="comment">//for a given bucket, turn it into a long array containing counts of event types</span></div><div class="line">                .startWith(emptyEventCountsToStart);           <span class="comment">//start it with empty arrays to make consumer logic as generic as possible (windows are always full)</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>bucketedStream</code> 即为本次得到的数据流（类型为 RxJava 中的 <code>Observable</code>，即观察者模式中的 Publisher，会源源不断地产生事件/数据），里面最核心的逻辑就是如何将一个一个的事件按一段时间聚合成一个桶。我们可以看到 <code>bucketedStream</code> 是经事件源 <code>inputEventStream</code> 变换而成的，事件源的类型为 <code>HystrixEventStream&lt;Event&gt;</code>，它代表事件流接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HystrixEventStream</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">HystrixEvent</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Observable&lt;E&gt; <span class="title">observe</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>observe</code> 方法返回这个事件流对应的发布者 <code>Observable</code>，订阅者可以对事件进行变换并消费。</p>
<h2 id="事件流的写入">事件流的写入</h2><p>Hystrix 中执行函数以命令模式封装成了一个一个命令（<code>Command</code>），每个命令执行时都会触发某个事件，其中命令执行完成事件（<code>HystrixCommandCompletion</code>）是 Hystrix 中最核心的事件，它可以代表某个命令执行成功、超时、异常等等的各种的状态，与服务调用的熔断息息相关。熔断器的计数依赖于 <code>HystrixCommandCompletion</code> 事件，因此这里我们只关注这个事件对应的事件流，其余类型的事件流原理类似。</p>
<p>那么这个事件流中的事件是从哪里发布的呢？我们来看一下相关的具体实现 - <code>HystrixCommandCompletionStream</code>（仅核心代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCommandCompletionStream</span> <span class="keyword">implements</span> <span class="title">HystrixEventStream</span>&lt;<span class="title">HystrixCommandCompletion</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCommandKey commandKey;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;HystrixCommandCompletion, HystrixCommandCompletion&gt; writeOnlySubject;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observable&lt;HystrixCommandCompletion&gt; readOnlyStream;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, HystrixCommandCompletionStream&gt; streams = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HystrixCommandCompletionStream&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixCommandCompletionStream <span class="title">getInstance</span><span class="params">(HystrixCommandKey commandKey)</span> </span>&#123;</div><div class="line">        <span class="comment">// 此段代码略，大致逻辑为：若对应的 CommandKey 的事件流已创建就从缓存中取出，否则就新创建并缓存起来，保证每个 CommandKey 只有一个实例</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    HystrixCommandCompletionStream(<span class="keyword">final</span> HystrixCommandKey commandKey) &#123;</div><div class="line">        <span class="keyword">this</span>.commandKey = commandKey;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.writeOnlySubject = <span class="keyword">new</span> SerializedSubject&lt;HystrixCommandCompletion, HystrixCommandCompletion&gt;(PublishSubject.&lt;HystrixCommandCompletion&gt;create());</div><div class="line">        <span class="keyword">this</span>.readOnlyStream = writeOnlySubject.share();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">        streams.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(HystrixCommandCompletion event)</span> </span>&#123;</div><div class="line">        writeOnlySubject.onNext(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;HystrixCommandCompletion&gt; <span class="title">observe</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> readOnlyStream;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码里我们可以看到 <code>write</code> 方法里通过向某个 <code>Subject</code> 发布事件来实现了发布的逻辑，那么 <code>Subject</code> 又是什么呢？简单来说，<a href="http://reactivex.io/documentation/subject.html" target="_blank" rel="external"><code>Subject</code></a> 就像是一个桥梁，既可以作为发布者 <code>Observable</code>，又可以作为订阅者 <code>Observer</code>。它可以作为发布者和订阅者之间的一个“代理”，提供额外的功能（如流量控制、缓存等）。这里的 <code>writeOnlySubject</code> 是经过 <code>SerializedSubject</code> 封装的 <code>PublishSubject</code>。<code>PublishSubject</code> 可以看做 hot observable。为了保证调用的顺序（根据 <a href="http://reactivex.io/documentation/contract.html" target="_blank" rel="external">The Observable Contract</a>，每个事件的产生需要满足顺序上的偏序关系，即使是在不同线程产生），需要用 <code>SerializedSubject</code> 封装一层来保证事件真正地串行地产生。这里还有一个问题，就是不同的发布者调用 <code>write</code> 方法发布事件时，线程上下文可能都不同，那么如何保证其线程安全呢？Hystrix 1.5 通过使用 ThreadLocal 来保证每个线程都有一份 <code>Subject</code> 的实例，确保事件发布的线程安全。相关代码位于 <code>HystrixThreadEventStream</code> 内（已略去其它事件的代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixThreadEventStream</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> threadId;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String threadName;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;HystrixCommandExecutionStarted, HystrixCommandExecutionStarted&gt; writeOnlyCommandStartSubject;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;HystrixCommandCompletion, HystrixCommandCompletion&gt; writeOnlyCommandCompletionSubject;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;HystrixCollapserEvent, HystrixCollapserEvent&gt; writeOnlyCollapserSubject;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;HystrixThreadEventStream&gt; threadLocalStreams = <span class="keyword">new</span> ThreadLocal&lt;HystrixThreadEventStream&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> HystrixThreadEventStream <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HystrixThreadEventStream(Thread.currentThread());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Action1&lt;HystrixCommandCompletion&gt; writeCommandCompletionsToShardedStreams = commandCompletion -&gt; &#123;</div><div class="line">        HystrixCommandCompletionStream commandStream = HystrixCommandCompletionStream.getInstance(commandCompletion.getCommandKey());</div><div class="line">        commandStream.write(commandCompletion);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (commandCompletion.isExecutedInThread() || commandCompletion.isResponseThreadPoolRejected()) &#123;</div><div class="line">            HystrixThreadPoolCompletionStream threadPoolStream = HystrixThreadPoolCompletionStream.getInstance(commandCompletion.getThreadPoolKey());</div><div class="line">            threadPoolStream.write(commandCompletion);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/* package */</span> HystrixThreadEventStream(Thread thread) &#123;</div><div class="line">        <span class="keyword">this</span>.threadId = thread.getId();</div><div class="line">        <span class="keyword">this</span>.threadName = thread.getName();</div><div class="line">        writeOnlyCommandCompletionSubject = PublishSubject.create();</div><div class="line"></div><div class="line">        writeOnlyCommandCompletionSubject</div><div class="line">                .onBackpressureBuffer()</div><div class="line">                .doOnNext(writeCommandCompletionsToShardedStreams)</div><div class="line">                .unsafeSubscribe(Subscribers.empty());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixThreadEventStream <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> threadLocalStreams.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        writeOnlyCommandStartSubject.onCompleted();</div><div class="line">        writeOnlyCommandCompletionSubject.onCompleted();</div><div class="line">        writeOnlyCollapserSubject.onCompleted();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 执行完毕/异常/超时都会调用此方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executionDone</span><span class="params">(ExecutionResult executionResult, HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey)</span> </span>&#123;</div><div class="line">        HystrixCommandCompletion event = HystrixCommandCompletion.from(executionResult, commandKey, threadPoolKey);</div><div class="line">        writeOnlyCommandCompletionSubject.onNext(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 Hystrix 通过 ThreadLocal 为每个不同的线程都创建了不同的 <code>HystrixThreadEventStream</code>，里面的 <code>Subject</code> 都是 write-only, thread-safe 的。Hystrix 在这里额外加了一层 <code>writeOnlyCommandCompletionSubject</code>，提供额外的流量控制机制（<code>onBackpressureBuffer</code>），消费者太慢时这里会积压。其中会调用 <code>HystrixCommandCompletionStream</code> 的 <code>write</code> 方法产生对应的事件。</p>
<p><code>executionDone</code> 方法最后会经 <code>HystrixCommandMetrics</code> 类的 <code>markCommandDone</code> 方法进行调用。<code>HystrixCommandMetrics</code> 是 Hystrix 中另一个重要的类，从中可以获取各种指标数据的流的实例。最后 Hystrix 会在对应命令执行完毕后，调用 <code>markCommandDone</code> 进行数据记录，并发布对应的事件。相关代码位于 <a href="https://github.com/Netflix/Hystrix/blob/master/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L947" target="_blank" rel="external"><code>AbstractCommand</code></a> 类内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCommandEnd</span><span class="params">(<span class="keyword">boolean</span> commandExecutionStarted)</span> </span>&#123;</div><div class="line">    Reference&lt;TimerListener&gt; tl = timeoutTimer.get();</div><div class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span>) &#123;</div><div class="line">        tl.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> userThreadLatency = System.currentTimeMillis() - commandStartTimestamp;</div><div class="line">    executionResult = executionResult.markUserThreadCompletion((<span class="keyword">int</span>) userThreadLatency);</div><div class="line">    <span class="keyword">if</span> (executionResultAtTimeOfCancellation == <span class="keyword">null</span>) &#123;</div><div class="line">        metrics.markCommandDone(executionResult, commandKey, threadPoolKey, commandExecutionStarted);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        metrics.markCommandDone(executionResultAtTimeOfCancellation, commandKey, threadPoolKey, commandExecutionStarted);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (endCurrentThreadExecutingCommand != <span class="keyword">null</span>) &#123;</div><div class="line">        endCurrentThreadExecutingCommand.call();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AbstractCommand</code> 类是 Hystrix 命令模式执行模型的实现，整合了资源隔离、熔断器等各种高可用机制，是整个 Hystrix 的核心。</p>
<h2 id="共享的事件流">共享的事件流</h2><p>上面我们探究了事件流的发布原理，以及如何保证写的线程安全。那么事件流写入到 <code>writeOnlySubject</code> 以后，如何被订阅者消费呢？如何保证多个订阅者都可以对事件流进行消费，并且序列一致呢？我们回到之前的 <code>observe</code> 方法，<code>observe</code> 方法返回的是一个 <code>readOnlyStream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Observable&lt;HystrixCommandCompletion&gt; <span class="title">observe</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> readOnlyStream;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>readOnlyStream</code> 是 <code>writeOnlySubject</code> 的只读版本，它是通过 <code>share</code> 操作符产生的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.readOnlyStream = writeOnlySubject.share();</div></pre></td></tr></table></figure>
<p>Hystrix 通过 RxJava 的 <a href="http://reactivex.io/documentation/operators/refcount.html" target="_blank" rel="external"><code>share</code></a> 操作符产生一种特殊的 <code>Observable</code>：当有一个订阅者去消费事件流时它就开始产生事件，可以有多个订阅者去订阅，同一时刻收到的事件是一致的；直到最后一个订阅者取消订阅以后，事件流才停止产生事件。其底层实现非常有意思：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">share</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> publish().refCount();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在执行 <code>publish</code> 的时候，<code>Observable</code> 会被变换成为一个 <code>ConnectableObservable</code>。这种 <code>ConnectableObservable</code> 只会在进行连接操作（<code>connect</code>）以后才会产生数据（连接后行为类似于 hot observable）。而 <code>share</code> 操作底层的 <code>refCount</code> 操作符就帮我们做了这样的操作：<code>refCount</code> 底层维护着一个引用计数器，代表绑定的订阅者数目。当第一个订阅者去消费事件流的时候，引用计数大于 0，<code>refCount</code> 底层会自动进行 <code>connect</code>，从而触发事件流产生事件；当最后一个订阅者取消订阅以后，引用计数归零，<code>refCount</code> 底层就会自动进行 <code>disconnect</code>，事件流停止产生事件。也就是说，这样的一个可以被多个订阅者共享的事件流，底层是基于引用计数法来管理事件的产生的，和智能指针的思想类似。</p>
<p><img src="http://reactivex.io/documentation/operators/images/publishRefCount.png" alt="Reactive stream of refCount"></p>
<h2 id="事件流聚合为桶">事件流聚合为桶</h2><p>上面我们研究完了事件流是如何产生的，接下来就回归到事件流聚合为桶的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.bucketedStream = Observable.defer(() -&gt; &#123; <span class="comment">// defer 的意思是 lazy 创建</span></div><div class="line">    <span class="keyword">return</span> inputEventStream</div><div class="line">            .observe()</div><div class="line">            .window(bucketSizeInMs, TimeUnit.MILLISECONDS) <span class="comment">// 按单元窗口长度来将某个时间段内的调用事件聚集起来</span></div><div class="line">            .flatMap(reduceBucketToSummary)                <span class="comment">// 将每个单元窗口内聚集起来的事件集合聚合成桶</span></div><div class="line">            .startWith(emptyEventCountsToStart);           <span class="comment">// 为了保证窗口的完整性，开始的时候先产生一串空的桶</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其中的核心是 <a href="http://reactivex.io/documentation/operators/window.html" target="_blank" rel="external"><code>window</code></a> 操作符，它可以按单元窗口长度来将某个时间段内的调用事件聚集起来，此时数据流里每个对象都是一个集合：<code>Observable&lt;Event&gt;</code>，所以需要将其聚集成桶类型以将其扁平化。Hystrix 通过 RxJava 的 <code>reduce</code> 操作符进行“归纳”操作，将一串事件归纳成一个桶：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.reduceBucketToSummary = eventBucket -&gt; eventBucket.reduce(getEmptyBucketSummary(), appendRawEventToBucket);</div></pre></td></tr></table></figure>
<p>其中我们需要提供桶的初值（即空桶），并要提供聚合函数来进行聚合，类型为 <code>Bucket -&gt; Event -&gt; Bucket</code>（代表对于每个 <code>Event</code>，都将其聚合到 <code>Bucket</code> 中，并返回聚合后的 <code>Bucket</code>）。不同的实现对应的 <code>Bucket</code> 和规约函数不同，比如熔断器依赖的 <code>HealthCountsStream</code> 就以 <code>long[]</code> 来作为每个桶。</p>
<blockquote>
<p>注：此处的 <code>window(timespan, unit)</code> 操作符属于计算型操作符，默认会在 <code>Schedulers.computation()</code> 调度器下执行（CPU 密集型），其底层本质是线程数为 CPU 核数的线程池。RxJava 会确保其线程安全。</p>
</blockquote>
<h1 id="BucketedRollingCounterStream">BucketedRollingCounterStream</h1><p><code>BucketedRollingCounterStream</code> 按照滑动窗口的大小对每个单元窗口产生的桶进行聚合，这也是 Hystrix 1.5 中滑动窗口的抽象实现。其核心实现仍然位于构造函数内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketedRollingCounterStream</span>&lt;<span class="title">Event</span> <span class="keyword">extends</span> <span class="title">HystrixEvent</span>, <span class="title">Bucket</span>, <span class="title">Output</span>&gt; <span class="keyword">extends</span> <span class="title">BucketedCounterStream</span>&lt;<span class="title">Event</span>, <span class="title">Bucket</span>, <span class="title">Output</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> Observable&lt;Output&gt; sourceStream;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isSourceCurrentlySubscribed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BucketedRollingCounterStream</span><span class="params">(HystrixEventStream&lt;Event&gt; stream, <span class="keyword">final</span> <span class="keyword">int</span> numBuckets, <span class="keyword">int</span> bucketSizeInMs,</span></span></div><div class="line">                                           <span class="keyword">final</span> Func2&lt;Bucket, Event, Bucket&gt; appendRawEventToBucket,</div><div class="line">                                           <span class="keyword">final</span> Func2&lt;Output, Bucket, Output&gt; reduceBucket) &#123;</div><div class="line">        <span class="keyword">super</span>(stream, numBuckets, bucketSizeInMs, appendRawEventToBucket);</div><div class="line">        Func1&lt;Observable&lt;Bucket&gt;, Observable&lt;Output&gt;&gt; reduceWindowToSummary = window -&gt; window.scan(getEmptyOutputValue(), reduceBucket).skip(numBuckets);</div><div class="line">        <span class="keyword">this</span>.sourceStream = bucketedStream      <span class="comment">// 数据流，每个对象代表单元窗口产生的桶</span></div><div class="line">                .window(numBuckets, <span class="number">1</span>)          <span class="comment">// 按照滑动窗口桶的个数进行桶的聚集</span></div><div class="line">                .flatMap(reduceWindowToSummary) <span class="comment">// 将一系列的桶聚集成最后的数据对象</span></div><div class="line">                .doOnSubscribe(() -&gt; isSourceCurrentlySubscribed.set(<span class="keyword">true</span>))</div><div class="line">                .doOnUnsubscribe(() -&gt; isSourceCurrentlySubscribed.set(<span class="keyword">false</span>))</div><div class="line">                .share()                        <span class="comment">// 不同的订阅者看到的数据是一致的</span></div><div class="line">                .onBackpressureDrop();          <span class="comment">// 流量控制，当消费者消费速度过慢时就丢弃数据，不进行积压</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;Output&gt; <span class="title">observe</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sourceStream;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* package-private */</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isSourceCurrentlySubscribed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isSourceCurrentlySubscribed.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造函数后两个参数参数分别代表两个函数：将事件流聚合成桶的函数（<code>appendRawEventToBucket</code>） 以及 将桶聚合成输出对象的函数（<code>reduceBucket</code>）。</p>
<p>我们看到 <code>BucketedRollingCounterStream</code> 实现了 <code>observe</code> 方法，返回了一个 <code>Observable&lt;Output&gt;</code> 类型的发布者 <code>sourceStream</code>，供订阅者去消费。这里的 <code>sourceStream</code> 应该就是滑动窗口的终极形态了，那么它是如何变换得到的呢？这里面的核心还是 <code>window</code> 和 <code>flatMap</code> 算子。这里的 <code>window</code> 算子和之前的版本不同，它可以将数据流中的一定数量的数据聚集成一个集合，它的第二个参数 <code>skip=1</code> 的意思就是按照步长为 1 在数据流中滑动，不断聚集对象，这即为滑动窗口的真正实现。到这里每个窗口都已经形成了，下一步就是要对窗口进行聚合了。注意这里聚合操作没有用 <code>reduce</code>，而是用了 <code>scan</code> + <code>skip(numBuckets)</code> 的组合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Func1&lt;Observable&lt;Bucket&gt;, Observable&lt;Output&gt;&gt; reduceWindowToSummary = window -&gt; window.scan(getEmptyOutputValue(), reduceBucket).skip(numBuckets);</div></pre></td></tr></table></figure>
<p>这里每个集合的大小都是 <code>numBuckets</code>，看起来用 <code>reduce</code> 和 <code>scan</code> + <code>skip(numBuckets)</code> 没有什么区别，但是注意当数据流终结时，最后面的窗口大小都不满 <code>numBuckets</code>，这时候就需要把这些不完整的窗口给过滤掉来确保数据不缺失。这个地方也是开发的时候容易忽略的地方，很值得思考。</p>
<p>聚合完毕以后，基本的滑动窗口数据就OK了，为了支持多订阅者，还要进行 <code>share</code>；并且利用 <code>onBackpressureDrop</code> 操作符实现流量控制，此处当消费者跟不上的时候就直接丢掉数据，不进行积压。</p>
<p><img src="https://github.com/Netflix/Hystrix/wiki/images/rolling-stats-640.png" alt="Rolling status"></p>
<h1 id="HealthCountsStream">HealthCountsStream</h1><p>前面滑动窗口的抽象实现都已经分析完了，现在我们就来看一下其中的一个具体实现 - <code>HealthCountsStream</code>，它提供实时的健康检查数据（<code>HystrixCommandMetrics.HealthCounts</code>，统计调用成功和失败的计数）。</p>
<p>之前我们提到 <code>BucketedRollingCounterStream</code> 里面有三个类型参数和两个重要函数参数。<code>HealthCountsStream</code> 对应的三个类型参数分别为：</p>
<ul>
<li><code>Event</code>: <code>HystrixCommandCompletion</code>，代表命令执行完成。可以从中获取执行结果，并从中提取所有产生的事件（<code>HystrixEventType</code>）</li>
<li><code>Bucket</code>: 桶的类型为 <code>long[]</code>，里面统计了各种事件的个数。其中 index 为事件类型枚举对应的索引（<code>ordinal</code>），值为对应事件的个数</li>
<li><code>Output</code>: <code>HystrixCommandMetrics.HealthCounts</code>，里面统计了总的执行次数、失败次数以及失败百分比，供熔断器使用</li>
</ul>
<p>滑动窗口里用于将事件聚合成桶的函数实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Func2&lt;<span class="keyword">long</span>[], HystrixCommandCompletion, <span class="keyword">long</span>[]&gt; appendEventToBucket = (initialCountArray, execution) -&gt; &#123;</div><div class="line">    ExecutionResult.EventCounts eventCounts = execution.getEventCounts();</div><div class="line">    <span class="keyword">for</span> (HystrixEventType eventType: ALL_EVENT_TYPES) &#123;</div><div class="line">        <span class="keyword">switch</span> (eventType) &#123;</div><div class="line">            <span class="keyword">case</span> EXCEPTION_THROWN: <span class="keyword">break</span>; <span class="comment">//this is just a sum of other anyway - don't do the work here</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                initialCountArray[eventType.ordinal()] += eventCounts.getCount(eventType);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> initialCountArray;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>滑动窗口里用于将每个窗口聚合成最终的统计数据的的函数实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Func2&lt;HystrixCommandMetrics.HealthCounts, <span class="keyword">long</span>[], HystrixCommandMetrics.HealthCounts&gt; healthCheckAccumulator = HystrixCommandMetrics.HealthCounts::plus;</div><div class="line"></div><div class="line"><span class="comment">// 具体的实现，位于 HystrixCommandMetrics.HealthCounts 类内</span></div><div class="line"><span class="function"><span class="keyword">public</span> HealthCounts <span class="title">plus</span><span class="params">(<span class="keyword">long</span>[] eventTypeCounts)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> updatedTotalCount = totalCount; <span class="comment">// 之前的请求总数</span></div><div class="line">    <span class="keyword">long</span> updatedErrorCount = errorCount; <span class="comment">// 之前的失败个数</span></div><div class="line"></div><div class="line">    <span class="keyword">long</span> successCount = eventTypeCounts[HystrixEventType.SUCCESS.ordinal()];</div><div class="line">    <span class="keyword">long</span> failureCount = eventTypeCounts[HystrixEventType.FAILURE.ordinal()];</div><div class="line">    <span class="keyword">long</span> timeoutCount = eventTypeCounts[HystrixEventType.TIMEOUT.ordinal()];</div><div class="line">    <span class="keyword">long</span> threadPoolRejectedCount = eventTypeCounts[HystrixEventType.THREAD_POOL_REJECTED.ordinal()];</div><div class="line">    <span class="keyword">long</span> semaphoreRejectedCount = eventTypeCounts[HystrixEventType.SEMAPHORE_REJECTED.ordinal()];</div><div class="line"></div><div class="line">    <span class="comment">// 加上所有事件的总数</span></div><div class="line">    updatedTotalCount += (successCount + failureCount + timeoutCount + threadPoolRejectedCount + semaphoreRejectedCount);</div><div class="line">    <span class="comment">// 加上失败事件的总数（包括请求失败、超时、线程池满、信号量满）</span></div><div class="line">    updatedErrorCount += (failureCount + timeoutCount + threadPoolRejectedCount + semaphoreRejectedCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HealthCounts(updatedTotalCount, updatedErrorCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hystrix 熔断器里会实时地去消费每个窗口产生的健康统计数据，并根据指标来决定熔断器的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="class"><span class="keyword">class</span> <span class="title">HystrixCircuitBreakerImpl</span> <span class="keyword">implements</span> <span class="title">HystrixCircuitBreaker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCommandProperties properties;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCommandMetrics metrics;</div><div class="line"></div><div class="line">    <span class="keyword">enum</span> Status &#123;</div><div class="line">        CLOSED, OPEN, HALF_OPEN;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Status&gt; status = <span class="keyword">new</span> AtomicReference&lt;Status&gt;(Status.CLOSED);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong circuitOpened = <span class="keyword">new</span> AtomicLong(-<span class="number">1</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Subscription&gt; activeSubscription = <span class="keyword">new</span> AtomicReference&lt;Subscription&gt;(<span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HystrixCircuitBreakerImpl</span><span class="params">(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, <span class="keyword">final</span> HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.properties = properties;</div><div class="line">        <span class="keyword">this</span>.metrics = metrics;</div><div class="line"></div><div class="line">        <span class="comment">//On a timer, this will set the circuit between OPEN/CLOSED as command executions occur</span></div><div class="line">        Subscription s = subscribeToStream();</div><div class="line">        activeSubscription.set(s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Subscription <span class="title">subscribeToStream</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This stream will recalculate the OPEN/CLOSED status on every onNext from the health stream</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> metrics.getHealthCountsStream()</div><div class="line">                .observe()</div><div class="line">                .subscribe(<span class="keyword">new</span> Subscriber&lt;HealthCounts&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(HealthCounts hc)</span> </span>&#123;</div><div class="line">                        <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></div><div class="line">                        <span class="keyword">if</span> (hc.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</div><div class="line">                            <span class="comment">// we are not past the minimum volume threshold for the stat window,</span></div><div class="line">                            <span class="comment">// so no change to circuit status.</span></div><div class="line">                            <span class="comment">// if it was CLOSED, it stays CLOSED</span></div><div class="line">                            <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></div><div class="line">                            <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hc.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</div><div class="line">                                <span class="comment">//we are not past the minimum error threshold for the stat window,</span></div><div class="line">                                <span class="comment">// so no change to circuit status.</span></div><div class="line">                                <span class="comment">// if it was CLOSED, it stays CLOSED</span></div><div class="line">                                <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></div><div class="line">                                <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                <span class="comment">// our failure rate is too high, we need to set the state to OPEN</span></div><div class="line">                                <span class="keyword">if</span> (status.compareAndSet(Status.CLOSED, Status.OPEN)) &#123;</div><div class="line">                                    circuitOpened.set(System.currentTimeMillis());</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结">总结</h1><p>Hystrix 1.5 使用 RxJava 1.x 来实现滑动窗口，将滑动窗口抽象成响应式数据流的形式，既适合 Hystrix 事件驱动的特点，又易于实现和使用。滑动窗口的实现的要点就是每个桶的聚合以及滑动窗口的形成，Hystrix 巧妙地运用了 RxJava 中的 <a href="http://reactivex.io/documentation/operators/window.html" target="_blank" rel="external"><code>window</code></a> 操作符来将单位窗口时间内的事件，以及将一个窗口大小内的桶聚集到一起，并通过 <a href="http://reactivex.io/documentation/operators/reduce.html" target="_blank" rel="external"><code>reduce</code></a> 等折叠操作将事件集合聚集为桶，将滑动窗口内的桶聚集成指标数据，非常巧妙。同时，Hystrix 利用 ThreadLocal<subject> 作为一个线程安全的“代理”，可以确保多个发布者写的线程安全；通过 RxJava 的 <a href="http://reactivex.io/documentation/operators/refcount.html" target="_blank" rel="external"><code>share</code></a> 操作符可以确保多个订阅者从某个共享的 Observable 中观察的序列一致。</subject></p>
<p>最后用一张图来总结 Hystrix Metrics 事件驱动的流程：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/hystrix/hystrix-metrics-event-driven-flow.png" alt="Event driven flow of Hystrix"></p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring" target="_blank" rel="external">Metrics and Monitoring - Hystrix Wiki</a></li>
<li><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" target="_blank" rel="external">How it Works - Hystrix Wiki</a></li>
<li><a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">ReactiveX Operators</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/高可用架构/">高可用架构</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netflix-Hystrix/">Netflix Hystrix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/滑动窗口/">滑动窗口</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/限流降级/">限流降级</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高可用架构/">高可用架构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-call-with-current-continuation" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Functional-Programming/call-with-current-continuation/" class="article-date">
      <time datetime="2016-10-30T16:00:00.000Z" itemprop="datePublished">2016-10-31</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Functional-Programming/call-with-current-continuation/">call/cc总结 | Scheme</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Continuation">Continuation</h1><p>Continuation也是一个老生常谈的东西了，我们来回顾一下。首先我们看一下 <em>TSPL4</em> 中定义的表达式求值需要做的事：</p>
<blockquote>
<p>During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value.</p>
</blockquote>
<p>Continuation即为其中的(2)，即表达式被求值以后，<strong>接下来要对表达式做的计算</strong>。<em>R5RS</em> 中continuation的定义为：</p>
<blockquote>
<p>The continuation represents an entire (default) future for the computation.</p>
</blockquote>
<p>比如 <code>(+ (* 2 3) (+ 1 7))</code> 表达式中，<code>(* 2 3)</code>的continuation为：保存<code>(* 2 3)</code>计算出的值<code>6</code>，然后计算<code>(+ 1 7)</code>的值，最后将两表达式的值相乘，结束；<code>(+ 1 7)</code>的continuation为：保存<code>(+ 1 7)</code>的值<code>8</code>，将其与前面计算出的<code>6</code>相乘，结束。</p>
<p>Scheme中的continuation是first-class的，也就是说它可以被当做参数进行传递和返回；并且Scheme中可以将continuation视为一个procedure，也就是说可以调用continuation执行后续的运算。</p>
<h1 id="call/cc">call/cc</h1><p>每个表达式在求值的时候，都会有一个对应的 <strong>current continuation</strong>，它在等着当前表达式求值完毕然后把值传递给它。那么如何捕捉current continuation呢？这就要用到Scheme中强大的<code>call/cc</code>了。<code>call/cc</code>的全名是<code>call-with-current-continuation</code>，它可以捕捉当前环境下的current continuation并利用它做各种各样的事情，如改变控制流，实现非本地退出(non-local exit)、协程(coroutine)、多任务(multi-tasking)等，非常方便。注意这里的continuation将当前context一并打包保存起来了，而不只是保存程序运行的位置。下面我们来举几个例子说明一下<code>call/cc</code>的用法。</p>
<h2 id="current_continuation">current continuation</h2><p>我们先来看个最简单的例子 —— 用它来捕捉current continuation并作为procedure调用。<code>call/cc</code>接受一个函数，该函数接受一个参数，此参数即为current continuation。以之前<code>(+ (* 2 3) (+ 1 7))</code> 表达式中 <code>(* 2 3)</code>的continuation为例：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> cc <span class="literal">#f</span>)</div><div class="line">(<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">call/cc</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (return)</div><div class="line">                (<span class="name"><span class="builtin-name">set!</span></span> cc return)</div><div class="line">                (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">3</span>)))</div><div class="line">   (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">7</span>))</div></pre></td></tr></table></figure>
<p>我们将<code>(* 2 3)</code>的current continuation(用<code>(+ ? (+ 1 7))</code>表示)绑定给<code>cc</code>变量。现在<code>cc</code>就对应了一个continuation，它相当于过程<code>(define (cc x) (+ (x) (+ 1 7)))</code>，等待一个值然后进行后续的运算：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; cc</div><div class="line">#&lt;continuation&gt;</div><div class="line">&gt; (cc 10)</div><div class="line">18</div><div class="line">&gt; (cc (* 2 3))</div><div class="line">14</div></pre></td></tr></table></figure>
<p>这个例子很好理解，我们下面引入<code>call/cc</code>的本质 —— 控制流变换。在Scheme中，假设<code>call/cc</code>捕捉到的current continuation为<code>cc</code>(位于<code>lambda</code>中)，如果<code>cc</code>作为过程<strong>直接或间接地被调用</strong>（即给它传值），<code>call/cc</code>会立即返回，返回值即为传入<code>cc</code>的值。即一旦current continuation被调用，控制流会跳到<code>call/cc</code>处。因此，利用<code>call/cc</code>，我们可以摆脱顺序执行的限制，在程序中跳来跳去，非常灵活。下面我们举几个non-local exit的例子来说明。</p>
<h2 id="Non-local_exit">Non-local exit</h2><p>Scheme中没有<code>break</code>和<code>return</code>关键字，因此在循环中如果想<code>break</code>并提前返回的话就得借助<code>call/cc</code>。比如下面的例子寻找传入的<code>list</code>中是否包含<code>5</code>：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">do-with</span> element return)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> element <span class="number">5</span>)</div><div class="line">      (<span class="name">return</span> <span class="symbol">'find-five</span>)</div><div class="line">      (<span class="name">void</span>)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">check-lst</span> lst)</div><div class="line">  (<span class="name"><span class="builtin-name">call/cc</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (return)</div><div class="line">             (<span class="name"><span class="builtin-name">for-each</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (element)</div><div class="line">                        (<span class="name">do-with</span> element return)</div><div class="line">                        (<span class="name">printf</span> <span class="string">"~a~%"</span> element))</div><div class="line">                      lst)</div><div class="line">             <span class="symbol">'not-found</span>)))</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; (check-lst '(0 2 4))</div><div class="line">0</div><div class="line">2</div><div class="line">4</div><div class="line">'not-found</div><div class="line">&gt; (check-lst '(0 3 5 1))</div><div class="line">0</div><div class="line">3</div><div class="line">'find-five</div></pre></td></tr></table></figure>
<p><code>check-lst</code>过程会遍历列表中的元素，每次都会将current continuation传给<code>do-with</code>过程并进行调用，一旦<code>do-with</code>遇到<code>5</code>，我们就将结果传给current continuation(即<code>return</code>)，此时控制流会马上跳回<code>check-lst</code>过程中的<code>call/cc</code>处，这时候就已经终止遍历了（跳出了循环）。<code>call/cc</code>的返回值为<code>&#39;find-five</code>，所以最后会在控制台上打印出<code>&#39;find-five</code>。</p>
<p>我们再来看一个经典的generator的例子，它非常像Python和ES6中的<code>yield</code>，每次调用的时候都会返回list中的一个元素：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">generate-one-element-at-a-time</span> lst)</div><div class="line"></div><div class="line">  <span class="comment">;; Hand the next item from a-list to "return" or an end-of-list marker</span></div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">control-state</span> return)</div><div class="line">    (<span class="name"><span class="builtin-name">for-each</span></span></div><div class="line">     (<span class="name"><span class="builtin-name">lambda</span></span> (element)</div><div class="line">               (<span class="name"><span class="builtin-name">set!</span></span> return (<span class="name"><span class="builtin-name">call/cc</span></span></div><div class="line">                              (<span class="name"><span class="builtin-name">lambda</span></span> (resume-here)</div><div class="line">                                <span class="comment">;; Grab the current continuation</span></div><div class="line">                               (<span class="name"><span class="builtin-name">set!</span></span> control-state resume-here)</div><div class="line">                               (<span class="name">return</span> element)))))</div><div class="line">     lst)</div><div class="line">    (<span class="name">return</span> <span class="symbol">'you-fell-off-the-end</span>))</div><div class="line"></div><div class="line">  <span class="comment">;; This is the actual generator, producing one item from a-list at a time</span></div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">generator</span>)</div><div class="line">    (<span class="name"><span class="builtin-name">call/cc</span></span> control-state))</div><div class="line"></div><div class="line">  <span class="comment">;; Return the generator</span></div><div class="line">  generator)</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> generate-digit</div><div class="line">  (<span class="name">generate-one-element-at-a-time</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>)))</div></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; (generate-digit)</div><div class="line">0</div><div class="line">&gt; (generate-digit)</div><div class="line">1</div><div class="line">&gt; (generate-digit)</div><div class="line">2</div><div class="line">&gt; (generate-digit)</div><div class="line">'you-fell-off-the-end</div></pre></td></tr></table></figure>
<p>注意到这个例子里有两个<code>call/cc</code>，大家刚看到的时候可能会有点晕，其实这两个<code>call/cc</code>各司其职，互不干扰。第一个<code>call/cc</code>负责保存遍历的状态（从此处恢复），而<code>generator</code>中的<code>call/cc</code>才是真正生成值的地方（非本地退出）。其中一个需要注意的地方就是<code>control-state</code>，它在第一次调用的时候还是个procedure，在第一次调用的过程中它就被重新绑定成一个<code>continuation</code>，之后再调用<code>generator</code>生成器的时候，控制流就可以跳到之前遍历的位置继续执行下面的过程，从而达到生成器的效果。</p>
<h1 id="阴阳谜题">阴阳谜题</h1><p>continuation环境嵌套。后面有时间专开一篇分析～</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">let*</span></span> ((<span class="name">yin</span></div><div class="line">         ((<span class="name"><span class="builtin-name">lambda</span></span> (cc) (<span class="name"><span class="builtin-name">display</span></span> <span class="literal">#\@</span>) cc) (<span class="name"><span class="builtin-name">call-with-current-continuation</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (c) c))))</div><div class="line">       (<span class="name">yang</span></div><div class="line">         ((<span class="name"><span class="builtin-name">lambda</span></span> (cc) (<span class="name"><span class="builtin-name">display</span></span> <span class="literal">#\*</span>) cc) (<span class="name"><span class="builtin-name">call-with-current-continuation</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (c) c)))))</div><div class="line">    (<span class="name">yin</span> yang))</div></pre></td></tr></table></figure>
<h1 id="call/cc与数理逻辑">call/cc与数理逻辑</h1><p>这里简单提一下<code>call/cc</code>与类型系统和数理逻辑的联系。<code>call/cc</code>的类型是<code>((P → Q) → P) → P</code>，通过Curry-Howard 同构，它可以对应到经典逻辑中的<strong>Peirce’s law</strong>：</p>
<p>$$((P \to Q) \to P) \to P$$</p>
<p>Peirce’s law代表排中律 $P \land \lnot P$，这条逻辑无法在Lambda演算所对应的直觉逻辑中表示（直觉逻辑中双重否定不成立），因此<code>call/cc</code>无法用Lambda表达式定义。通常我们用扩展后的 $\lambda \mu \ calculus$ 来定义<code>call/cc</code>，$\lambda \mu \ calculus$  经Curry-Howard 同构可以得到经典逻辑。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://www.scheme.com/tspl4/" target="_blank" rel="external">The Scheme Programming Language, 4th Edition</a></li>
<li><a href="http://community.schemewiki.org/?call-with-current-continuation" target="_blank" rel="external">Short introduction to call-with-current-continuation</a></li>
<li><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/" target="_blank" rel="external">The Revised Revised Revised Revised Revised Report on the Algorithmic Language Scheme (R5RS)</a></li>
<li><a href="https://docs.racket-lang.org/guide/conts.html" target="_blank" rel="external">The Racket Guide, 10.3 Continuations</a></li>
<li><a href="https://en.wikipedia.org/wiki/Call-with-current-continuation" target="_blank" rel="external">Call-with-current-continuation, Wikipedia</a></li>
<li><a href="https://golem.ph.utexas.edu/category/2008/01/the_continuation_passing_trans.html#c044523" target="_blank" rel="external">The Continuation Passing Transform and the Yoneda Embedding</a></li>
<li><a href="https://www.quora.com/What-is-continuation-passing-style-in-functional-programming" target="_blank" rel="external">What is continuation-passing style in functional programming? - Quora</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Functional-Programming/">Functional Programming</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CPS/">CPS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Continuation/">Continuation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mathematical-Logic/">Mathematical Logic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PLT/">PLT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scheme/">Scheme</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-distributed-computing-system-gc-osdi16-yak" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Distributed-System/distributed-computing-system-gc-osdi16-yak/" class="article-date">
      <time datetime="2016-10-16T16:00:00.000Z" itemprop="datePublished">2016-10-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Distributed-System/distributed-computing-system-gc-osdi16-yak/">分布式计算系统中的GC问题 | Yak(OSDI 2016) 学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近一直在关注OSDI 2016，发现了这篇关于分布式计算系统内存管理的论文：<a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-nguyen.pdf" target="_blank" rel="external">Yak: A High-Performance Big-Data-Friendly. Garbage Collector</a>，感觉比较有趣，拿来总结总结~</p>
<p>Yak是一个JVM平台上的针对大数据场景（分布式计算框架）设计、优化的Garbage Collector。</p>
<h1 id="背景">背景</h1><p>在传统的基于分代模型的垃圾回收算法中，小对象首先被划分到Young Generation（新生代）；如果对象经历过一定阈值的GC还会存活后，它就会被晋升至Old Generation（老年代）；大对象可以直接进入老年代。</p>
<p>对于分布式计算框架而言，这样的模型有一定的弊端：没有考虑分布式计算情景下对象的生命周期。分布式计算中控制过程(Control Path)与数据处理过程(Data Path)界限明显，如果全都用统一的GC模型的话，会导致频繁请求GC数据，扫描全堆，最后实际回收的很少，导致Full GC(STW)。因此，像Apache Spark在1.5版本以后已经放弃使用JVM的GC进行内存管理，而是直接利用unsafe包进行内存管理。这样十分麻烦还容易出错。</p>
<p>Yak就是为了解决这样的问题而诞生的。既然分布式计算过程中控制过程与数据处理过程界限明显，Yak针对这两种过程中的数据划分了两种不同的空间(space):</p>
<ul>
<li>Control Space (CS)</li>
<li>Data Space (DS)</li>
</ul>
<p>对于控制过程（比如任务的调度、日志记录等），其内存布局与传统的一致，GC还是采用分代模型，分YoungGen/OldGen/Metaspace。控制过程产生的对象小、生命周期短暂，符合分代假设。</p>
<p>而对于数据处理过程，其中的对象通常都是很大的、在计算周期中一直需要访问的，因此Yak提出了Epoch Region，数据对象的生命周期依赖于每个epoch。每个epoch的start与end需要用户来设置（但是很简单）。</p>
<h1 id="时域抽象">时域抽象</h1><blockquote>
<p>Epoch hypothesis: many data-path objects have the same life span and can be reclaimed together at the end of an epoch.</p>
</blockquote>
<p>时域抽象(Epoch Region): 抽象成semilattice(半格)，用于描述nested epoches之间的偏序关系。见论文Figure 5。(Order Theory在这里非常有用)</p>
<p>如何正确地回收某个特定的Region</p>
<p>如果有的对象生命周期超出此epoch，如何将其迁移至“安全地带”？</p>
<ul>
<li>思考点1：标记escaping objects</li>
<li>思考点2：决定escaping objects的迁移终点并且执行复制</li>
</ul>
<p>对于标记的过程，可以以cross-region/space references为根节点来遍历对象图并且标记其中的escaping objects（传递闭包）</p>
<p>对于决定其destination的过程，需要计算出对象O的引用region的上确界(via semilattice)。</p>
<p>如果对应的region具有继承关系，则应选择最上面的（上确界）。如果是不同线程执行的，那么对应的上确界则为CS。</p>
<blockquote>
<p>TODO: 待详细总结</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper/">Paper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式计算/">分布式计算</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-spark-rdd-paper-summary" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Distributed-System/spark-rdd-paper-summary/" class="article-date">
      <time datetime="2016-09-26T16:00:00.000Z" itemprop="datePublished">2016-09-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Distributed-System/spark-rdd-paper-summary/">Distributed System | Spark RDD 论文总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本篇文章是对Spark RDD论文的总结，中间会穿插一些Spark的内部实现总结，对应Spark版本为2.0。</p>
<h1 id="RDD">RDD</h1><h2 id="Motivation">Motivation</h2><p>传统的分布式计算框架(如MapReduce)在执行计算任务时，中间结果通常会存于磁盘中，这样带来的IO消耗是非常大的，尤其是对于各种机器学习算法，它们需要复用上次计算的结果进行迭代，如果每次结果都存到磁盘上再从磁盘读取，耗时会很大。因此Spark这篇论文提出了一种新的分布式数据抽象 —— <strong>RDD</strong>。</p>
<h2 id="设计思想及特点">设计思想及特点</h2><p><strong>Resilient Distributed Dataset</strong>(RDD)是Apache Spark中数据的核心抽象，它是一种只读的、分区的数据记录集合。</p>
<p>RDD的特点：</p>
<ul>
<li>Lazy evaluation，只在需要的时候才进行计算</li>
<li>RDD里面的数据是分区的，每一块数据都可能分布在集群内不同的节点上；支持并行计算</li>
<li>Resilient: 借助RDD lineage graph，Spark可以重新执行之前失败的计算任务而不用整体上重新计算，保证了容错性而且非常灵活，实现了fault-tolerance</li>
</ul>
<p>那么如何操作、处理数据呢？Spark提供了一组函数式编程风格的API，可以很方便地对RDD进行操作、变换，就像操作集合一样。比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> rdd = sc.parallelize(<span class="number">1</span> to <span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> result = rdd.map(_ + <span class="number">10</span>)</div><div class="line">  .filter(_ &gt; <span class="number">15</span>)</div><div class="line">  .map(x =&gt; (x, <span class="number">1</span>))</div><div class="line">  .reduceByKey(_+_)</div><div class="line">  .collect</div></pre></td></tr></table></figure>
<p>并且开发者可以根据需要自己编写相应的RDD以及RDD之间的操作，非常方便。可以这么理解，RDD就相当于抽象的数据表示，而operation就相当于一套DSL用于对RDD进行变换或者求值。</p>
<h2 id="RDD的表示">RDD的表示</h2><p>Spark中的RDD主要包含五部分信息：</p>
<ul>
<li><code>partitions()</code>: partition集合</li>
<li><code>dependencies()</code>: 当前RDD的dependency集合</li>
<li><code>iterator(split, context)</code>: 对每个partition进行计算或读取操作的函数</li>
<li><code>partitioner()</code>: 分区方式，如<code>HashPartitioner</code>和<code>RangePartitioner</code></li>
<li><code>preferredLocations(split)</code>: 访问某个partition最快的节点</li>
</ul>
<p>所有的RDD都继承抽象类<code>RDD</code>。几种常见的操作：</p>
<ul>
<li><code>sc#textFile</code>: 生成<code>HadoopRDD</code>，代表可以从HDFS中读取数据的RDD</li>
<li><code>sc#parallelize</code>: 生成<code>ParallelCollectionRDD</code>，代表从Scala集合中生成的RDD</li>
</ul>
<ul>
<li><code>map</code>, <code>flatMap</code>, <code>filter</code>: 生成<code>MapPartitionsRDD</code>，其partition与parent RDD一致，同时会对parent RDD中<code>iterator</code>函数返回的数据进行对应的操作(lazy)</li>
<li><code>union</code>: 生成<code>UnionRDD</code>或<code>PartitionerAwareUnionRDD</code></li>
<li><code>reduceByKey</code>, <code>groupByKey</code>: 生成<code>ShuffledRDD</code>，需要进行shuffle操作</li>
<li><code>cogroup</code>, <code>join</code>: 生成<code>CoGroupedRDD</code></li>
</ul>
<h1 id="Operations">Operations</h1><p>Spark里面对RDD的操作分为两种：<strong>transformation</strong> 和 <strong>action</strong>。</p>
<ul>
<li>transformation是lazy的，仅仅会保存计算步骤并返回一个新的RDD，而不会立刻执行计算操作</li>
<li>action会依次执行计算操作并且得到结果</li>
</ul>
<p>这些transformation和action在FP中应该是很常见的，如<code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>reduce</code>, <code>count</code>, <code>sum</code>。</p>
<p>对单个数据操作的transformation函数都在<code>RDD</code>抽象类内，而对tuple操作的transformation都在<code>PairRDDFunctions</code>包装类中。<code>RDD</code>可以通过implicit函数在符合类型要求的时候自动转换为<code>PairRDDFunctions</code>类，从而可以进行<code>reduceByKey</code>之类的操作。对应的implicit函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">rddToPairRDDFunctions</span></span>[<span class="type">K</span>, <span class="type">V</span>](rdd: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)])</div><div class="line">  (<span class="keyword">implicit</span> kt: <span class="type">ClassTag</span>[<span class="type">K</span>], vt: <span class="type">ClassTag</span>[<span class="type">V</span>], ord: <span class="type">Ordering</span>[<span class="type">K</span>] = <span class="literal">null</span>): <span class="type">PairRDDFunctions</span>[<span class="type">K</span>, <span class="type">V</span>] = &#123;</div><div class="line">  <span class="keyword">new</span> <span class="type">PairRDDFunctions</span>(rdd)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Dependency">Dependency</h1><p>上面我们提到，RDD只会在需要的时候计算结果，调用那些transformation方法以后，对应的transformation信息只是被简单地存储起来，直到调用某个action才会真正地去执行计算。Spark中RDD之间是有联系的，RDD之间会形成依赖关系，也就是形成lineage graph(依赖图)。Dependency大致分两种：narrow dependency和wide dependency。</p>
<ul>
<li>Narrow dependency(<code>NarrowDependency</code>): Parent RDD中的每个partition最多被child RDD中的一个partition使用，即一对一的关系。比如<code>map</code>, <code>flatMap</code>, <code>filter</code>等transformation都是narrow dependency</li>
<li>Wide dependency(<code>ShuffleDependency</code>)：Parent RDD中的每个partition会被child RDD中的多个partition使用，即一对多的关系。比如<code>join</code>生成的RDD一般是wide dependency(不同的partitioner)</li>
</ul>
<p>论文中的图例很直观地表示了RDD间的依赖关系：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-paper-dependency-image.png" alt="Spark RDD Dependency"></p>
<p>这样划分dependency的原因：</p>
<ol>
<li>Narrow dependency可以方便地以流水线的形式执行计算，即从头到尾一串chain下来。而wide dependency必须要等所有的parent RDD的结果都准备好以后再执行计算</li>
<li>Narrow dependency失败以后，Spark只需要重新计算失败的parent RDD即可；而对于wide dependency来说，一失败可能导致某些分区丢失，必须整体重新进行计算</li>
</ol>
<h1 id="Shuffle">Shuffle</h1><p>Spark中的shuffle操作与MapReduce中类似，在计算wide dependency对应的RDD的时候（即ShuffleMapStage）会触发。</p>
<p>首先来回顾一下为什么要进行shuffle操作。以<code>reduceByKey</code>操作为例，Spark要按照key把这些具有相同key的tuple聚集到一块然后进行计算操作。然而这些tuple可能在不同的partition中，甚至在不同的集群节点中，要想计算必须先把它们聚集起来。因此，Spark用一组map task来将每个分区写入到临时文件中，然后下一个stage端(reduce task)会根据编号获取临时文件，然后将partition中的tuple按照key聚集起来并且进行相应的操作。这里面还包括着排序操作（可能在map side也可能在reduce side进行）。</p>
<p>Shuffle是Spark的主要性能瓶颈之一（涉及磁盘IO,数据序列化和网络IO），其优化一直是个难题。</p>
<ul>
<li>Shuffle write(map task): <code>SortShuffleWriter#write</code></li>
<li>Shuffle read(reduce task): <code>ShuffleRDD#compute</code></li>
</ul>
<h1 id="Persistence">Persistence</h1><h2 id="Checkpointing">Checkpointing</h2><p>Checkpoint的目的是保存那些计算耗时较长的RDD数据(long lineage chains)，执行Checkpoint的时候会新提交一个Job，因此最好先<code>persist</code>后<code>checkpoint</code>。</p>
<h2 id="Cache/Persist">Cache/Persist</h2><p><code>cache</code>和<code>persist</code>用于缓存一些经常使用的RDD结果（但是不能太大）。</p>
<ul>
<li><code>persist</code>方法的主要作用是改变<code>StorageLevel</code>以在<code>compute</code>的时候通过<code>BlockManager</code>进行相应的持久化操作</li>
<li><code>cache</code>方法相当于设置存储级别为<code>MEMORY_ONLY</code></li>
</ul>
<h1 id="Job_Scheduling">Job Scheduling</h1><p>简单来说，Spark会将提交的计算划分为不同的stages，形成一个有向无环图(<strong>DAG</strong>)。Spark的调度器会按照DAG的次序依次进行计算每个stage，最终得到计算结果。执行计算的几个重要的类或接口如下：</p>
<ul>
<li><code>DAGScheduler</code></li>
<li><code>ActiveJob</code></li>
<li><code>Stage</code></li>
<li><code>Task</code></li>
<li><code>TaskScheduler</code></li>
<li><code>SchedulerBackend</code></li>
</ul>
<p>这里面最为重要的就是 <strong>DAGScheduler</strong> 了，它会将<strong>逻辑执行计划</strong>（即RDD lineage）转化为<strong>物理执行计划</strong>（stage/task）。之前我们提到过，当开发者对某个RDD执行action的时候，Spark才会执行真正的计算过程。当开发者执行action的时候，<code>SparkContext</code>会将当前的逻辑执行计划传给<code>DAGScheduler</code>，<code>DAGScheduler</code>会根据给定的逻辑执行计划生成一个Job(对应<code>ActiveJob</code>类)并提交。每执行一个acton都会生成一个<code>ActiveJob</code>。</p>
<p>提交Job的过程中，<code>DAGScheduler</code>会进行stage的划分。Spark里是按照<code>shuffle</code>操作来划分stage的，也就是说stage之间都是wide dependency，每个stage之内的dependency都是narrow dependency。这样划分的好处是尽可能地把多个narrow dependency的RDD放到同一个stage之内以便于进行pipeline计算，而wide dependency中child RDD必须等待所有的parent RDD计算完成并且<code>shuffle</code>以后才能接着计算，因此这样划分stage是最合适的。</p>
<p>划分好的stages会形成一个DAG，<code>DAGScheduler</code>会根据DAG中的顺序先提交parent stages（如果存在的话），再提交当前stage，以此类推，最先提交的是没有parent stage的stage。从执行角度来讲，一个stage的parent stages执行完以后，该stage才可以被执行。最后一个stage是产生最终结果的stage，对应<code>ResultStage</code>，而其余的stage都是<code>ShuffleMapStage</code>。下面是论文中stage划分的一个图例，非常直观：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-paper-stage-figure.png" alt="DAG of stages"></p>
<p>提交stage的时候，Spark会根据stage的类型生成一组对应类型的<code>Task</code>(<code>ResultTask</code>或<code>ShuffleMapTask</code>)，然后将这些<code>Task</code>包装成<code>TaskSet</code>提交到<code>TaskScheduler</code>中。一个<code>Task</code>对应某个RDD中的某一个partition，即一个<code>Task</code>只负责某个partition的计算：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> tasks: <span class="type">Seq</span>[<span class="type">Task</span>[_]] = <span class="keyword">try</span> &#123;</div><div class="line">  stage <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</div><div class="line">      partitionsToCompute.map &#123; id =&gt;</div><div class="line">        <span class="keyword">val</span> locs = taskIdToLocations(id)</div><div class="line">        <span class="keyword">val</span> part = stage.rdd.partitions(id)</div><div class="line">        <span class="keyword">new</span> <span class="type">ShuffleMapTask</span>(stage.id, stage.latestInfo.attemptId,</div><div class="line">          taskBinary, part, locs, stage.latestInfo.taskMetrics, properties)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</div><div class="line">      <span class="keyword">val</span> job = stage.activeJob.get</div><div class="line">      partitionsToCompute.map &#123; id =&gt;</div><div class="line">        <span class="keyword">val</span> p: <span class="type">Int</span> = stage.partitions(id)</div><div class="line">        <span class="keyword">val</span> part = stage.rdd.partitions(p)</div><div class="line">        <span class="keyword">val</span> locs = taskIdToLocations(id)</div><div class="line">        <span class="keyword">new</span> <span class="type">ResultTask</span>(stage.id, stage.latestInfo.attemptId,</div><div class="line">          taskBinary, part, locs, id, properties, stage.latestInfo.taskMetrics)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">  <span class="comment">// 此处代码略...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>TaskScheduler</code>会向执行任务的后端(<code>SchedulerBackend</code>，可以是Local, Mesos, Hadoop YARN或者其它集群管理组件)发送<code>ReviveOffers</code>消息，对应的执行后端接收到消息以后会将<code>Task</code>封装成<code>TaskRunner</code>(<code>Runnable</code>接口的实例)，然后提交到底层的<code>Executor</code>中，并行执行计算任务。</p>
<p><code>Executor</code>中的线程池定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> threadPool = <span class="type">ThreadUtils</span>.newDaemonCachedThreadPool(<span class="string">"Executor task launch worker"</span>)</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">newDaemonCachedThreadPool</span></span>(prefix: <span class="type">String</span>): <span class="type">ThreadPoolExecutor</span> = &#123;</div><div class="line">  <span class="keyword">val</span> threadFactory = namedThreadFactory(prefix)</div><div class="line">  <span class="type">Executors</span>.newCachedThreadPool(threadFactory).asInstanceOf[<span class="type">ThreadPoolExecutor</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到底层执行task的线程池实际上是JUC中的<code>CachedThreadPool</code>，按需创建新线程，同时会复用线程池中已经建好的线程。</p>
<p>最后用一幅图总结一下Job, Stage和Task的关系（图来自 <em>Mastering Apache Spark 2.0</em>）：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-stage-tasks-jobs.png" alt="Stage, Job and Task in Spark"></p>
<p>整个Spark Context执行task的步骤图：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-run-job-diagram.png" alt=""></p>
<h1 id="Memory_Management">Memory Management</h1><p>Spark中RDD的存储方式有两种：in memory和on disk，默认是in memory的。进行分布式计算的时候通常会读入大量的数据，并且通常还需要重用这些数据，如果简单地把内存管理交给GC的话，很容易导致回收失败从而cause full GC，影响性能。</p>
<p>Spark 1.5开始不再通过GC管理内存。Spark 1.5实现了一个内存管理器用于手动管理内存(Project Tungsten)，底层通过<code>Unsafe</code>类来直接分配和回收内存。</p>
<p>另外，分布式计算系统的GC方面还可以参考OSDI 2016的一篇论文: <em>Yak: A High-Performance Big-Data-Friendly Garbage Collector</em>。</p>
<h1 id="PageRank实例">PageRank实例</h1><p>下面在Spark中跑一个PageRank来观察一下生成的Stage DAG。PageRank的公式比较简单：</p>
<p>$$PageRank (p_i) = \frac{1-d}{N} + d \sum_{p_j \in M(p_i)} \frac{PageRank (p_j)}{L(p_j)} $$</p>
<p>这里我们选择damping factor=0.85，初始的rank值为1.0；PageRank算法可以用马尔科夫矩阵进行优化，但是这里迭代次数较小，可以直接进行迭代计算。对应代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> iters = <span class="number">10</span></div><div class="line"><span class="keyword">val</span> data = sc.textFile(<span class="string">"data.txt"</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> links = data.map &#123; s =&gt;</div><div class="line">  <span class="keyword">val</span> parts = s.split(<span class="string">"\\s+"</span>)</div><div class="line">  (parts(<span class="number">0</span>), parts(<span class="number">1</span>))</div><div class="line">&#125;.distinct().groupByKey().cache()</div><div class="line"><span class="keyword">var</span> ranks = links.mapValues(v =&gt; <span class="number">1.0</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to iters) &#123;</div><div class="line">  <span class="keyword">val</span> contribs = links.join(ranks).values.flatMap &#123; <span class="keyword">case</span> (urls, rank) =&gt;</div><div class="line">    <span class="keyword">val</span> size = urls.size</div><div class="line">    urls.map(url =&gt; (url, rank / size))</div><div class="line">  &#125;</div><div class="line">  ranks = contribs.reduceByKey(_ + _).mapValues(<span class="number">0.15</span> + <span class="number">0.85</span> * _)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> output = ranks.collect()</div></pre></td></tr></table></figure>
<p>对应的Stage DAG:</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-simple-rankpage-dag.png" alt="DAG of stages in PageRank Algorithm"></p>
<p>其中Stage 3中的RDD dependencies如下：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-simple-rankpage-one-stage-dag.png" alt="One stage in PageRank Algorithm"></p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://people.csail.mit.edu/matei/papers/2012/nsdi_spark.pdf" target="_blank" rel="external">M. Zaharia, <em>et al</em>. <em>Resilient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing</em>.</a></li>
<li><a href="https://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="external">Jeffrey Dean, Sanjay Ghemawat. <em>MapReduce: Simplified Data Processing on Large Clusters</em>.</a></li>
<li><a href="https://www.gitbook.com/book/jaceklaskowski/mastering-apache-spark" target="_blank" rel="external">Mastering Apache Spark 2.0</a></li>
<li><a href="https://github.com/JerryLead/SparkInternals" target="_blank" rel="external">Spark Internals</a></li>
<li><a href="http://spark.apache.org/docs/latest/programming-guide.html" target="_blank" rel="external">Spark Programming Guide</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper/">Paper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spark/">Spark</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式计算/">分布式计算</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vertx-advanced-demystifying-thread-model" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-demystifying-thread-model/" class="article-date">
      <time datetime="2016-09-24T16:00:00.000Z" itemprop="datePublished">2016-09-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-demystifying-thread-model/">Vert.x 技术内幕 | 解道 Vert.x 线程模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="线程模型概述">线程模型概述</h1><p>Vert.x 的线程模型设计的非常巧妙。总的来说，Vert.x中主要有两种线程：<strong>Event Loop 线程</strong> 和 <strong>Worker 线程</strong>。其中，Event Loop 线程结合了 Netty 的 <code>EventLoop</code>，用于处理事件。每一个 <code>EventLoop</code> 都与唯一的线程相绑定，这个线程就叫 Event Loop 线程。Event Loop 线程不能被阻塞，否则事件将无法被处理。</p>
<p>Worker 线程用于执行阻塞任务，这样既可以执行阻塞任务而又不阻塞 Event Loop 线程。</p>
<p>如果像 Node.js 一样只有单个 Event Loop 的话就不能充分利用多核CPU的性能了。为了充分利用多核CPU的性能，Vert.x 中提供了一组 Event Loop 线程。每个 Event Loop 线程都可以处理事件。为了保证线程安全，防止资源争用，Vert.x 保证了某一个<code>Handler</code>总是被同一个Event Loop 线程执行，这样不仅可以保证线程安全，而且还可以在底层对锁进行优化提升性能。所以，只要开发者遵循Vert.x的线程模型，开发者就不需要再担心线程安全的问题，这是非常方便的。</p>
<p>本篇文章将底层的角度来解析 Vert.x 的线程模型。对应的 Vert.x 版本为 <strong>3.3.3</strong>。</p>
<h1 id="Event_Loop_线程">Event Loop 线程</h1><p>首先回顾一下Event Loop线程，它会不断地轮询获取事件，并将获取到的事件分发到对应的事件处理器中进行处理：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertx-event-loop-xx.png" alt="Vert.x Event Loop"></p>
<p>Vert.x线程模型中最重要的一点就是：<strong>永远不要阻塞Event Loop线程</strong>。因为一旦处理事件的线程被阻塞了，事件就会一直积压着不能被处理，整个应用也就不能正常工作了。</p>
<p>Vert.x中内置一种用于检测Event Loop是否阻塞的线程：<code>vertx-blocked-thread-checker</code>。一旦Event Loop处理某个事件的时间超过一定阈值（默认为2000ms）就会警告，如果阻塞的时间过长就会抛出异常。Block Checker的实现原理比较简单，底层借助了JUC的<code>TimerTask</code>，定时计算每个Event Loop线程的处理事件消耗的时间，如果超时就进行相应的警告。</p>
<h1 id="Vert-x_Thread">Vert.x Thread</h1><p>Vert.x中的Event Loop线程及Worker线程都用<code>VertxThread</code>类表示，并通过<code>VertxThreadFactory</code>线程工厂来创建。<code>VertxThreadFactory</code>创建Vert.x线程的过程非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">  VertxThread t = <span class="keyword">new</span> VertxThread(runnable, prefix + threadCount.getAndIncrement(), worker, maxExecTime);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (checker != <span class="keyword">null</span>) &#123;</div><div class="line">    checker.registerThread(t);</div><div class="line">  &#125;</div><div class="line">  addToMap(t);</div><div class="line"></div><div class="line">  t.setDaemon(<span class="keyword">false</span>);</div><div class="line">  <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了创建<code>VertxThread</code>线程之外，<code>VertxThreadFactory</code>还会将此线程注册至Block Checker线程中以监视线程的阻塞情况，并且将此线程添加至内部的<code>weakMap</code>中。这个<code>weakMap</code>作用只有一个，就是在注销对应的Verticle的时候可以将每个<code>VertxThread</code>中的<code>Context</code>实例清除(unset)。为了保证资源不被一直占用，这里使用了<code>WeakHashMap</code>来存储每一个<code>VertxThread</code>。当里面的<code>VertxThread</code>的引用不被其他实例持有的时候，它就会被标记为可清除的对象，等待GC。</p>
<p>至于<code>VertxThread</code>，它其实就是在普通线程的基础上存储了额外的数据（如对应的Vert.x Context，最大执行时长，当前执行时间，是否为Worker线程等），这里就不多讲了。</p>
<h1 id="Vert-x_Context">Vert.x Context</h1><p>Vert.x底层中一个重要的概念就是<code>Context</code>，每个<code>Context</code>都会绑定着一个Event Loop线程（而一个Event Loop线程可以对应多个<code>Context</code>）。我们可以把<code>Context</code>看作是控制一系列的<code>Handler</code>的执行作用域及顺序的上下文对象。</p>
<p>每当Vert.x底层将事件分发至<code>Handler</code>的时候，Vert.x都会给此<code>Handler</code>钦点一个<code>Context</code>用于处理任务：</p>
<ul>
<li>如果当前线程是Vert.x线程(<code>VertxThread</code>)，那么Vert.x就会复用此线程上绑定的<code>Context</code>；如果没有对应的<code>Context</code>就创建新的</li>
<li>如果当前线程是普通线程，就创建新的<code>Context</code></li>
</ul>
<p>Vert.x中存在三种<code>Context</code>，与之前的线程种类相对应：</p>
<ul>
<li><code>EventLoopContext</code></li>
<li><code>WorkerContext</code></li>
<li><code>MultiThreadedWorkerContext</code></li>
</ul>
<h2 id="Event_loop_context">Event loop context</h2><p>每个Event Loop Context都会对应着唯一的一个<code>EventLoop</code>，即一个Event Loop Context只会在同一个Event Loop线程上执行任务。在创建<code>Context</code>的时候，Vert.x会自动根据轮询策略选择对应的<code>EventLoop</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ContextImpl</span><span class="params">(VertxInternal vertx, WorkerPool internalBlockingPool, WorkerPool workerPool, String deploymentID, JsonObject config,</span></span></div><div class="line">                        ClassLoader tccl) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    EventLoopGroup group = vertx.getEventLoopGroup();</div><div class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.eventLoop = group.next();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.eventLoop = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>在Netty中，<code>EventLoopGroup</code>代表一组<code>EventLoop</code>，而从中获取<code>EventLoop</code>的方法则是<code>next</code>方法。<code>EventLoopGroup</code>中<code>EventLoop</code>的数量由CPU内核数目所确定。Vert.x这里使用了Netty NIO对应的<code>NioEventLoop</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(options.getEventLoopPoolSize(), eventLoopThreadFactory);</div><div class="line">eventLoopGroup.setIoRatio(NETTY_IO_RATIO);</div></pre></td></tr></table></figure>
<p>对应的轮询算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTowEventExecutorChooser(executors);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，正常情况下Netty会用轮询策略选择<code>EventLoop</code>。特别地，如果<code>EventLoop</code>的个数是2的倍数的话，选择的会快一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTowEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以在Embedded模式下测试一下Event Loop线程的分配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">System.out.println(Thread.currentThread());</div><div class="line">Vertx vertx = Vertx.vertx();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</div><div class="line">  <span class="keyword">int</span> index = i;</div><div class="line">  vertx.setTimer(<span class="number">1</span>, t -&gt; &#123;</div><div class="line">    System.out.println(index + <span class="string">":"</span> + Thread.currentThread());</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>运行结果（不同机器运行顺序、Event Loop线程数可能不同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Thread[main,<span class="number">5</span>,main]</div><div class="line"><span class="number">0</span>:Thread[vert.x-eventloop-thread-<span class="number">0</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">1</span>:Thread[vert.x-eventloop-thread-<span class="number">1</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">2</span>:Thread[vert.x-eventloop-thread-<span class="number">2</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">3</span>:Thread[vert.x-eventloop-thread-<span class="number">3</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">5</span>:Thread[vert.x-eventloop-thread-<span class="number">5</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">6</span>:Thread[vert.x-eventloop-thread-<span class="number">6</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">8</span>:Thread[vert.x-eventloop-thread-<span class="number">8</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">7</span>:Thread[vert.x-eventloop-thread-<span class="number">7</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">10</span>:Thread[vert.x-eventloop-thread-<span class="number">10</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">9</span>:Thread[vert.x-eventloop-thread-<span class="number">9</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">4</span>:Thread[vert.x-eventloop-thread-<span class="number">4</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">11</span>:Thread[vert.x-eventloop-thread-<span class="number">11</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">12</span>:Thread[vert.x-eventloop-thread-<span class="number">12</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">13</span>:Thread[vert.x-eventloop-thread-<span class="number">13</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">14</span>:Thread[vert.x-eventloop-thread-<span class="number">14</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">16</span>:Thread[vert.x-eventloop-thread-<span class="number">0</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">17</span>:Thread[vert.x-eventloop-thread-<span class="number">1</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">15</span>:Thread[vert.x-eventloop-thread-<span class="number">15</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">18</span>:Thread[vert.x-eventloop-thread-<span class="number">2</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">19</span>:Thread[vert.x-eventloop-thread-<span class="number">3</span>,<span class="number">5</span>,main]</div></pre></td></tr></table></figure>
<p>可以看到尽管每个<code>Context</code>对应唯一的Event Loop线程，而每个Event Loop线程却可能对应多个<code>Context</code>。</p>
<p>Event Loop Context会在对应的<code>EventLoop</code>中执行<code>Handler</code>进行事件的处理（IO事件，非阻塞）。Vert.x会保证同一个<code>Handler</code>会一直在同一个Event Loop线程中执行，这样可以简化线程模型，让开发者在写<code>Handler</code>的时候不需要考虑并发的问题，非常方便。</p>
<p>我们来粗略地看一下<code>Handler</code>是如何在<code>EventLoop</code>上执行的。<code>EventLoopContext</code>中实现了<code>executeAsync</code>方法用于包装<code>Handler</code>中事件处理的逻辑并将其提交至对应的<code>EventLoop</code>中进行执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</div><div class="line">  <span class="comment">// No metrics, we are on the event loop.</span></div><div class="line">  nettyEventLoop().execute(wrapTask(<span class="keyword">null</span>, task, <span class="keyword">true</span>, <span class="keyword">null</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里Vert.x使用了<code>wrapTask</code>方法将<code>Handler</code>封装成了一个<code>Runnable</code>用于向<code>EventLoop</code>中提交。代码比较直观，大致就是检查当前线程是否为Vert.x线程，然后记录事件处理开始的时间，给当前的Vert.x线程设置<code>Context</code>，并且调用<code>Handler</code>里面的事件处理方法。具体请参考源码，这里就不贴出来了。</p>
<p>那么把封装好的task提交到<code>EventLoop</code>以后，<code>EventLoop</code>是怎么处理的呢？这就需要更多的Netty相关的知识了。根据Netty的模型，Event Loop线程需要处理IO事件，普通事件（即我们的<code>Handler</code>）以及定时事件（比如Vert.x的<code>setTimer</code>）。Vert.x会提供一个<code>NETTY_IO_RATIO</code>给Netty代表<code>EventLoop</code>处理IO事件时间占用的百分比（默认为50，即IO事件时间占用:非IO事件时间占用=1:1）。当<code>EventLoop</code>启动的时候，它会不断轮询IO时间及其它事件并进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</div><div class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</div><div class="line">                    select(wakenUp.getAndSet(<span class="keyword">false</span>));</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</div><div class="line">                        selector.wakeup();</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="comment">// fallthrough</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            cancelledKeys = <span class="number">0</span>;</div><div class="line">            needsToSelectAgain = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</div><div class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</div><div class="line">                processSelectedKeys();</div><div class="line">                runAllTasks();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</div><div class="line"></div><div class="line">                processSelectedKeys();</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</div><div class="line">                runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</div><div class="line">                closeAll();</div><div class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="comment">// process the error</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面Netty会调用<code>processSelectedKeys</code>方法进行IO事件的处理，并且会计算出处理IO时间所用的事件然后计算出给非IO事件处理分配的时间，然后调用<code>runAllTasks</code>方法执行所有的非IO任务（这里面就有我们的各个<code>Handler</code>）。</p>
<p><code>runAllTasks</code>会按顺序从内部的任务队列中取出任务(<code>Runnable</code>)然后进行安全执行。而我们刚才调用的<code>NioEventLoop</code>的<code>execute</code>方法其实就是将包装好的<code>Handler</code>置入<code>NioEventLoop</code>内部的任务队列中等待执行。</p>
<h2 id="Worker_context">Worker context</h2><p>顾名思义，Worker Context用于跑阻塞任务。与Event Loop Context相似，每一个<code>Handler</code>都只会跑在固定的Worker线程下。</p>
<p>Vert.x还提供一种Multi-threaded worker context可以在多个Worker线程下并发执行任务，这样就会出现并发问题，需要开发者自行解决并发问题。因此一般情况下我们用不到Multi-threaded worker context。</p>
<h1 id="Verticle">Verticle</h1><p>我们再来讨论一下<code>Verticle</code>中的<code>Context</code>。在部署<code>Verticle</code>的时候，Vert.x会根据配置来创建<code>Context</code>并绑定到Verticle上，此后此Verticle上所有绑定的<code>Handler</code>都会在此<code>Context</code>上执行。相关实现位于<code>doDeploy</code>方法，这里摘取核心部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (Verticle verticle: verticles) &#123;</div><div class="line">  WorkerExecutorImpl workerExec = poolName != <span class="keyword">null</span> ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize()) : <span class="keyword">null</span>;</div><div class="line">  WorkerPool pool = workerExec != <span class="keyword">null</span> ? workerExec.getPool() : <span class="keyword">null</span>;</div><div class="line">  <span class="comment">// 根据配置创建Context</span></div><div class="line">  ContextImpl context = options.isWorker() ? vertx.createWorkerContext(options.isMultiThreaded(), deploymentID, pool, conf, tccl) :</div><div class="line">    vertx.createEventLoopContext(deploymentID, pool, conf, tccl);</div><div class="line">  <span class="keyword">if</span> (workerExec != <span class="keyword">null</span>) &#123;</div><div class="line">    context.addCloseHook(workerExec);</div><div class="line">  &#125;</div><div class="line">  context.setDeployment(deployment);</div><div class="line">  deployment.addVerticle(<span class="keyword">new</span> VerticleHolder(verticle, context));</div><div class="line">  <span class="comment">// 此Verticle上的Handler都会在创建的context作用域内执行</span></div><div class="line">  context.runOnContext(v -&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      verticle.init(vertx, context);</div><div class="line">      Future&lt;Void&gt; startFuture = Future.future();</div><div class="line">      <span class="comment">// 大家熟悉的start方法的执行点</span></div><div class="line">      verticle.start(startFuture);</div><div class="line">      startFuture.setHandler(ar -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (ar.succeeded()) &#123;</div><div class="line">          <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">            parent.addChild(deployment);</div><div class="line">            deployment.child = <span class="keyword">true</span>;</div><div class="line">          &#125;</div><div class="line">          vertx.metricsSPI().verticleDeployed(verticle);</div><div class="line">          deployments.put(deploymentID, deployment);</div><div class="line">          <span class="keyword">if</span> (deployCount.incrementAndGet() == verticles.length) &#123;</div><div class="line">            reportSuccess(deploymentID, callingContext, completionHandler);</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!failureReported.get()) &#123;</div><div class="line">          reportFailure(ar.cause(), callingContext, completionHandler);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">      reportFailure(t, callingContext, completionHandler);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这样一种方式，Vert.x保证了<code>Verticle</code>的线程安全 —— 即某个<code>Verticle</code>上的所有<code>Handler</code>都会在同一个Vert.x线程上执行，这样也保证了<code>Verticle</code>内部成员的安全（没有race condition问题）。比如下面Verticle中处理IO及事件的处理都一直是在同一个Vert.x线程下执行的，每次打印出的线程名称应该是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    vertx.createNetClient().connect(<span class="number">6666</span>, <span class="string">"localhost"</span>, ar -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (ar.succeeded()) &#123;</div><div class="line">        NetSocket socket = ar.result();</div><div class="line">        System.out.println(Thread.currentThread().getName());</div><div class="line">        socket.handler(buffer -&gt; &#123;</div><div class="line">          i++;</div><div class="line">          System.out.println(Thread.currentThread().getName());</div><div class="line">          System.out.println(<span class="string">"Net client receiving: "</span> + buffer.toString(<span class="string">"UTF-8"</span>));</div><div class="line">        &#125;);</div><div class="line">        socket.write(<span class="string">"+1s\n"</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ar.cause().printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="线程池">线程池</h1><h2 id="Event_Loop线程池">Event Loop线程池</h2><p>之前我们已经提到过，Event Loop线程池的类型为Netty中的<code>NioEventLoopGroup</code>，里面的线程通过Vert.x自己的线程工厂<code>VertxThreadFactory</code>进行创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eventLoopThreadFactory = <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-eventloop-thread-"</span>, checker, <span class="keyword">false</span>, options.getMaxEventLoopExecuteTime());</div><div class="line">eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(options.getEventLoopPoolSize(), eventLoopThreadFactory);</div><div class="line">eventLoopGroup.setIoRatio(NETTY_IO_RATIO);</div></pre></td></tr></table></figure>
<p>其中Event Loop线程的数目可以在配置中指定。</p>
<h2 id="Worker线程池">Worker线程池</h2><p>在之前讲<code>executeBlocking</code>底层实现的文章中我们已经提到过Worker线程池，它其实就是一种Fixed Thread Pool:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService workerExec = Executors.newFixedThreadPool(options.getWorkerPoolSize(),</div><div class="line">    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-worker-thread-"</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime()));</div><div class="line">PoolMetrics workerPoolMetrics = isMetricsEnabled() ? metrics.createMetrics(workerExec, <span class="string">"worker"</span>, <span class="string">"vert.x-worker-thread"</span>, options.getWorkerPoolSize()) : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</div></pre></td></tr></table></figure>
<p>Worker线程同样由<code>VertxThreadFactory</code>构造，类型为<code>VertxThread</code>，用于执行阻塞任务。我们同样可以在配置中指定其数目。</p>
<h2 id="内部阻塞线程池">内部阻塞线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ExecutorService internalBlockingExec = Executors.newFixedThreadPool(options.getInternalBlockingPoolSize(),</div><div class="line">    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-internal-blocking-"</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime()));</div><div class="line">PoolMetrics internalBlockingPoolMetrics = isMetricsEnabled() ? metrics.createMetrics(internalBlockingExec, <span class="string">"worker"</span>, <span class="string">"vert.x-internal-blocking"</span>, options.getInternalBlockingPoolSize()) : <span class="keyword">null</span>;</div><div class="line">internalBlockingPool = <span class="keyword">new</span> WorkerPool(internalBlockingExec, internalBlockingPoolMetrics);</div></pre></td></tr></table></figure>
<p>Internal Blocking Pool可能设计用于内部使用，在<code>executeBlocking(Action&lt;T&gt; action, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</code>这个版本的方法中就使用了它。</p>
<h2 id="Acceptor_Event_Loop线程池">Acceptor Event Loop线程池</h2><p>大家可能会发现<code>VertxImpl</code>类中还有一个<code>acceptorEventLoopGroup</code>。顾名思义，它是Netty中的Acceptor线程池，负责处理客户端的连接请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">acceptorEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, acceptorEventLoopThreadFactory);</div><div class="line">acceptorEventLoopGroup.setIoRatio(<span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>由于系统只有一个服务端端口需要监听，因此这里只需要一个线程。</p>
<p>Vert.x中的<code>HttpServer</code>就利用了<code>acceptorEventLoopGroup</code>处理客户端的连接请求，具体的实现后边会另起一篇介绍。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Event-Loop/">Event Loop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vertx-advanced-execute-blocking-internal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-execute-blocking-internal/" class="article-date">
      <time datetime="2016-09-08T16:00:00.000Z" itemprop="datePublished">2016-09-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-execute-blocking-internal/">Vert.x 技术内幕 | executeBlocking 实现原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="引入">引入</h1><p>大家都知道，Vert.x中的<code>executeBlocking</code>方法用于执行阻塞任务，并且有两种模式：有序执行和无序执行。下面我们来看两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">vertx.setPeriodic(<span class="number">1000</span>, t -&gt; &#123;</div><div class="line">  vertx.executeBlocking(future -&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep(<span class="number">200</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    System.out.println(Thread.currentThread().getName());</div><div class="line">    future.complete();</div><div class="line">  &#125;, r -&gt; &#123;&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">vertx.setPeriodic(<span class="number">1000</span>, t -&gt; &#123;</div><div class="line">  vertx.executeBlocking(future -&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep(<span class="number">2000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    System.out.println(Thread.currentThread().getName());</div><div class="line">    future.complete();</div><div class="line">  &#125;, r -&gt; &#123;&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们思考一下，每段代码每次执行的时候使用的线程相同么？正常情况下大家都知道<code>executeBlocking</code>底层使用了Worker线程池，因此貌似两种情况没什么区别，都是轮询Worker线程池，每次可能用不同的Worker线程。但是我们测一下：</p>
<p>第一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-1</div><div class="line">vert.x-worker-thread-2</div><div class="line">vert.x-worker-thread-3</div><div class="line">vert.x-worker-thread-4</div></pre></td></tr></table></figure>
<p>第二段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-0</div></pre></td></tr></table></figure>
<p>额。。。两段代码每次执行的线程居然有差异？第二次为什么每次都用相同的Worker线程？其实，大家可能忽略了一点：<code>executeBlocking</code>方法默认<strong>顺序执行</strong>提交的阻塞任务。今天我们就来探究一下<code>executeBlocking</code>内部的实现。</p>
<h1 id="Worker线程池">Worker线程池</h1><p>我们来回顾一下Vert.x底层的Worker线程池，它在创建<code>VertxImpl</code>实例的时候进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService workerExec = Executors.newFixedThreadPool(options.getWorkerPoolSize(),</div><div class="line">    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-worker-thread-"</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime()));</div><div class="line">PoolMetrics workerPoolMetrics = isMetricsEnabled() ? metrics.createMetrics(workerExec, <span class="string">"worker"</span>, <span class="string">"vert.x-worker-thread"</span>, options.getWorkerPoolSize()) : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</div></pre></td></tr></table></figure>
<p>可以看到底层的Worker线程池本质上是一种<code>FixedThreadPool</code>，里面的线程由<code>VertxThreadFactory</code>控制生成，对应的线程类型为<code>VertxThread</code>。Vert.x内部用<code>WorkerPool</code>类对线程池以及线程池相关的Metrics类进行了封装。</p>
<h1 id="阻塞任务在哪里执行？">阻塞任务在哪里执行？</h1><p>有了Worker线程池的基础，我们来看一下<code>Vertx</code>实例中的<code>executeBlocking</code>方法，它的过程很简单：获取当前的Vert.x Context（没有就创建），然后委托调用<code>Context</code>里的<code>executeBlocking</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, <span class="keyword">boolean</span> ordered,</span></span></div><div class="line">                                Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler) &#123;</div><div class="line">  ContextImpl context = getOrCreateContext();</div><div class="line">  context.executeBlocking(blockingCodeHandler, ordered, asyncResultHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler,</span></span></div><div class="line">                                Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler) &#123;</div><div class="line">  executeBlocking(blockingCodeHandler, <span class="keyword">true</span>, asyncResultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此方法中可以看到，<code>ordered</code>标志位默认为<code>true</code>，即默认按提交的次序执行阻塞任务。</p>
<p>我们再来看一下<code>ContextImpl</code>类中的<code>executeBlocking</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, <span class="keyword">boolean</span> ordered, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</span> </span>&#123;</div><div class="line">  executeBlocking(<span class="keyword">null</span>, blockingCodeHandler, resultHandler, ordered ? workerExec : workerPool.executor(), workerPool.metrics());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Action&lt;T&gt; action, Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler,</span></span></div><div class="line">    Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler,</div><div class="line">    Executor exec, PoolMetrics metrics) &#123;</div><div class="line">  Object queueMetric = metrics != <span class="keyword">null</span> ? metrics.submitted() : <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    exec.execute(() -&gt; &#123;</div><div class="line">      Object execMetric = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</div><div class="line">        execMetric = metrics.begin(queueMetric);</div><div class="line">      &#125;</div><div class="line">      Future&lt;T&gt; res = Future.future();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (blockingCodeHandler != <span class="keyword">null</span>) &#123;</div><div class="line">          ContextImpl.setContext(<span class="keyword">this</span>);</div><div class="line">          blockingCodeHandler.handle(res);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          T result = action.perform();</div><div class="line">          res.complete(result);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        res.fail(e);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</div><div class="line">        metrics.end(execMetric, res.succeeded());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (resultHandler != <span class="keyword">null</span>) &#123;</div><div class="line">        runOnContext(v -&gt; res.setHandler(resultHandler));</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">catch</span> (RejectedExecutionException ignore) &#123;</div><div class="line">    <span class="comment">// Pool is already shut down</span></div><div class="line">    <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</div><div class="line">      metrics.rejected(queueMetric);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它调用了另一个具体版本的<code>executeBlocking</code>方法，其中第四个参数即为要执行阻塞任务的线程池。如果要有序执行(<code>ordered</code>为true)，底层就使用<code>context</code>实例里的<code>workerExec</code>线程池；如果无序执行，就调用<code>workerPool</code>的<code>executor</code>方法获取另一种线程池。</p>
<p>看到这里，我们大致已经想到了，有序执行和无序执行两种模式使用不同的线程池，因此底层实现肯定有差异。我们来看一下前面提到的两个线程池，它们都是<code>ContextImpl</code>类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> WorkerPool workerPool;</div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Executor workerExec;</div></pre></td></tr></table></figure>
<p>在通过<code>Vertx</code>实例创建<code>Context</code>的时候，这几个变量会被初始化，其来源就是之前我们看过的<code>VertxImpl</code>实例中的Worker线程池。看一下<code>ContextImpl</code>类的构造函数就一目了然了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.workerPool = workerPool;</div><div class="line"><span class="keyword">this</span>.workerExec = workerPool.createOrderedExecutor();</div></pre></td></tr></table></figure>
<p>嗯。。。有序执行对应的线程池通过<code>workerPool</code>的<code>createOrderedExecutor</code>方法获得，而无序执行对应的线程池通过<code>workerPool</code>的<code>executor</code>方法获得。因此，<code>WorkerPool</code>类是一个关键点，我们稍后就看一下其实现。</p>
<p>注意Vert.x规定,<code>blockingCodeHandler</code>中的逻辑（即阻塞任务）在Worker线程内执行，而<code>resultHandler</code>内的逻辑（结果处理）需要在Vert.x Conext中执行，因此前面需要预先设置当前使用的Worker线程的<code>Context</code>为<code>this</code>以便后面调用<code>runOnContext</code>方法执行结果处理逻辑。</p>
<p>下面就来看一下有序执行和无序执行这两种线程池的具体区别。</p>
<h1 id="无序执行">无序执行</h1><p>我们看一下<code>WorkerPool</code>类的源码中获取无序执行线程池的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ExecutorService <span class="title">executor</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> pool;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>executor</code>方法直接返回了内部的<code>pool</code>线程池，而<code>pool</code>线程池其实就是<code>VertxImpl</code>中的<code>workerExec</code>线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</div></pre></td></tr></table></figure>
<p>OK！如果大家熟悉并发的话，大家应该对无序执行对应的线程池 —— Worker线程池的行为非常清楚了。它属于一种<code>FixedThreadPool</code>，底层通过阻塞队列<code>LinkedBlockingQueue</code>实现。底层通过轮询算法获取Worker线程执行任务。</p>
<h1 id="有序执行">有序执行</h1><p>下面是时候看有序执行对应的逻辑了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OrderedExecutorFactory orderedFact;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolMetrics metrics;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">WorkerPool</span><span class="params">(ExecutorService pool, PoolMetrics metrics)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.orderedFact = <span class="keyword">new</span> OrderedExecutorFactory(pool);</div><div class="line">  <span class="keyword">this</span>.pool = pool;</div><div class="line">  <span class="keyword">this</span>.metrics = metrics;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Executor <span class="title">createOrderedExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> orderedFact.getExecutor();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到有序执行对应的线程池是通过<code>OrderedExecutorFactory</code>创建的。其实，<code>OrderedExecutorFactory</code>类会生成真正的有序执行线程池<code>OrderedExecutor</code>，它其实是对Worker线程池<code>pool</code>的一个简单包装，仅仅添加了有序执行相关的逻辑，最后还是委托Worker线程池进行任务处理。</p>
<p>那么<code>OrderedExecutor</code>是如何实现顺序执行的呢？<code>OrderedExecutor</code>内部维护着一个任务队列。每当调用<code>executeBlocking</code>方法执行阻塞过程的时候，Vert.x会将阻塞过程包装成<code>Runnable</code>然后置入<code>OrderedExecutor</code>中的任务队列中；同时如果<code>OrderedExecutor</code>没有开始执行任务，就委托内部的Worker线程池执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (tasks) &#123;</div><div class="line">    tasks.add(command);</div><div class="line">    <span class="keyword">if</span> (!running) &#123;</div><div class="line">      running = <span class="keyword">true</span>;</div><div class="line">      parent.execute(runner);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，最后委托Worker线程池执行的线程其实是又包装了一层的<code>runner</code>线程。<code>runner</code>的逻辑不难想：不断地从任务队列中取出队首的<code>Runnable</code>然后调用其<code>run</code>方法执行（相当于执行了此任务，只不过在runner对应的线程中）；如果没有任务了就结束本线程。</p>
<p>这里就出现了一种情况：大批量提交阻塞任务的时候，线程池的状态<code>running</code>一直为<code>true</code>，此时所有的任务都积压到任务队列中，而执行所有任务的线程只有一个 —— <code>runner</code>对应的线程。这种情况其实很好想，因为要保证有序执行，就只能让它一个接一个地在同个线程中执行。如果在不同线程中依次执行则不好调度，如果直接并行执行则不能保证有序性。</p>
<p>所以，根据<code>OrderedExecutor</code>线程池的内部实现，只要提交任务的间隔时间小于任务执行的时间，底层其实就仅执行了一次<code>runner</code>，也就是说所有提交的阻塞任务都只在一个线程下跑（running标志位控制）。</p>
<p>这样就可以很好地解释我们一开始提出的问题了。当<code>sleep(200), setPeriodic(1000)</code>的时候，提交任务的间隔时间大于任务执行的时间，这样每次的<code>runner</code>就可以在下一个任务提交之前执行完，因此每次所用的线程会不同（轮询策略）；而<code>sleep(2000), setPeriodic(1000)</code>的时候，提交任务的间隔时间小于任务执行的时间，底层最后都归结到一个<code>runner</code>中执行了，因此所有过程都是在同一个Worker线程执行的（很好想，保证有序就要串行执行）。</p>
<p>当然，如果不想有序执行，可以用<code>void executeBlocking(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, boolean ordered, Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler)</code>这个版本的<code>executeBlocking</code>方法，并将<code>ordered</code>标志位设为<code>false</code>。根据上面的源码，底层会直接使用Worker线程池而不是<code>OrderedExecutor</code>线程池，这样就不会有上面<code>OrderedExecutor</code>的情况了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vertx-advanced-async-rpc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-async-rpc/" class="article-date">
      <time datetime="2016-09-06T16:00:00.000Z" itemprop="datePublished">2016-09-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-async-rpc/">Vert.x 技术内幕 | 异步RPC实现原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>经常有一些开发者在group中问到，如何利用Vert.x进行RPC通信。其实，Vert.x提供了一个组件 —— <strong>Vert.x Service Proxy</strong>，专门用于进行异步RPC通信（通过Event Bus）。Vert.x Service Proxy会自动生成代理类进行消息的包装与解码、发送与接收以及超时处理，可以为我们省掉不少代码。之前我在Vert.x Blueprint中已经详细讲解了<strong>Vert.x Service Proxy</strong>的使用，大家可以参考 <a href="http://www.sczyh30.com/vertx-blueprint-job-queue/cn/kue-core/index.html#异步rpc">Vert.x Kue 文档</a> 中的相关部分。本篇文章中我们将探索一下通过<strong>Vert.x Service Proxy</strong>生成的代理类进行异步RPC的原理，对应的Vert.x版本为<strong>3.3.2</strong>。</p>
<p>传统的RPC想必大家都不陌生，但是传统的RPC有个缺陷：传统的RPC都是阻塞型的，当调用者远程调用服务时需要阻塞着等待调用结果，这与Vert.x的异步开发模式相违背；而且，传统的RPC未对容错而设计。</p>
<p>因此，Vert.x提供了Service Proxy用于进行异步RPC，其底层依托Clustered Event Bus进行通信。我们只需要按照规范编写我们的服务接口（一般称为Event Bus服务），并加上<code>@ProxyGen</code>注解，Vert.x就会自动为我们生成相应的代理类在底层处理RPC。有了Service Proxy，我们只需给异步方法提供一个回调函数<code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>，在调用结果发送过来的时候会自动调用绑定的回调函数进行相关的处理，这样就与Vert.x的异步开发模式相符了。由于<code>AsyncResult</code>本身就是为容错而设计的（两个状态），因此这里的RPC也具有了容错性。</p>
<h1 id="原理简介">原理简介</h1><p>假设有一个Event Bus服务接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ProxyGen</span></div><div class="line"><span class="meta">@VertxGen</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeService</span> </span>&#123;</div><div class="line"></div><div class="line">  String SERVICE_ADDRESS = <span class="string">"service.example"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> SomeService <span class="title">createService</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SomeServiceImpl(vertx, config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> SomeService <span class="title">createProxy</span><span class="params">(Vertx vertx)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ProxyHelper.createProxy(SomeService.class, vertx, SERVICE_ADDRESS);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">SomeService <span class="title">process</span><span class="params">(String id, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; resultHandler)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里定义了一个异步方法<code>process</code>，其异步调用返回的结果是<code>AsyncResult&lt;JsonObject&gt;</code>类型的。由于异步RPC底层通过Clustered Event Bus进行通信，我们需要给器指定一个通信地址<code>SERVICE_ADDRESS</code>。<code>@Fluent</code>注解代表此方法返回自身，便于进行组合。我们同时还提供了两个辅助方法：<code>createService</code>方法用于创建服务实例，而<code>createProxy</code>方法则通过<code>ProxyHelper</code>辅助类创建服务代理实例。</p>
<p>假设服务提供端A注册了一个<code>SomeService</code>类型的服务代理，服务调用端B需要通过异步RPC调用服务的<code>process</code>方法，此时调用端B可以利用<code>ProxyHelper</code>获取服务实例并进行服务调用。B中获取的服务其实是一个<strong>服务代理类</strong>，而真正的服务实例在A处。何为服务代理？服务代理可以帮助我们向服务提供端发送调用请求，并且响应调用结果。那么如何发送调用请求呢？相信大家能想到，是调用端B将调用参数和方法名称等必要信息包装成集群消息(<code>ClusteredMessage</code>)，然后通过<code>send</code>方法将请求通过Clustered Event Bus发送至服务提供端A处（需要提供此服务的通信地址）。A在注册服务的时候会创建一个<code>MessageConsumer</code>监听此服务的地址来响应调用请求。当接收到调用请求的时候，A会在本地调用方法，并将结果回复至调用端。所以异步RPC本质上其实是一个基于<strong>代理模式</strong>的 <strong>Request/Response</strong> 消息模式。</p>
<p>用时序图来描述一下上述过程：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertx-async-rpc-sequence.png" alt="Sequence Diagram of Async RPC"></p>
<h1 id="引入">引入</h1><p>以之前的<code>SomeService</code>接口为例，我们可以在集群中的一个节点上注册服务实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SomeService service = SomeService.createService(vertx, config);</div><div class="line">ProxyHelper.registerService(SomeService.class, vertx, service, SomeService.SERVICE_ADDRESS);</div></pre></td></tr></table></figure>
<p>然后在另一个节点上获取此服务实例的代理，并进行服务调用。调用的时候看起来就像在本地调用(LPC)一样，其实是进行了RPC通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SomeService proxyService = SomeService.createProxy(vertx);</div><div class="line"></div><div class="line"><span class="comment">// invoke the service</span></div><div class="line">proxyService.process(<span class="string">"fuck"</span>, ar -&gt; &#123;</div><div class="line">  <span class="comment">// process the result...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其实，这里获取到的<code>proxyService</code>实例的真正类型是Vert.x自动生成的服务代理类<code>SomeServiceVertxEBProxy</code>类，里面封装了通过Event Bus进行通信的逻辑。我们首先来讲一下Service Proxy生成代理类的命名规范。</p>
<h1 id="代理类命名规范">代理类命名规范</h1><p>Vert.x Service Proxy在生成代理类时遵循一定的规范。假设有一Event Bus服务接口<code>SomeService</code>，Vert.x会自动为其生成代理类以及代理处理器：</p>
<ul>
<li>代理类的命名规范为 <strong>接口名</strong> + <code>VertxEBProxy</code>。比如<code>SomeService</code>接口对应的代理类名称为<code>SomeServiceVertxEBProxy</code></li>
<li>代理类会继承原始的服务接口并实现所有方法的代理逻辑</li>
<li>代理处理器的命名规范为 <strong>接口名</strong> + <code>VertxProxyHandler</code>。比如<code>SomeService</code>接口对应的代理处理器名称为<code>SomeServiceVertxProxyHandler</code></li>
<li>代理处理器会继承<code>ProxyHandler</code>抽象类</li>
</ul>
<p><code>ProxyHelper</code>辅助类中注册服务以及创建代理都是遵循了这个规范。</p>
<h1 id="在Event_Bus上注册服务">在Event Bus上注册服务</h1><p>我们通过<code>ProxyHelper</code>辅助类中的<code>registerService</code>方法来向Event Bus上注册Event Bus服务，来看其具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MessageConsumer&lt;JsonObject&gt; <span class="title">registerService</span><span class="params">(Class&lt;T&gt; clazz, Vertx vertx, T service, String address,</span></span></div><div class="line">                                                              <span class="keyword">boolean</span> topLevel,</div><div class="line">                                                              <span class="keyword">long</span> timeoutSeconds) &#123;</div><div class="line">  String handlerClassName = clazz.getName() + <span class="string">"VertxProxyHandler"</span>;</div><div class="line">  Class&lt;?&gt; handlerClass = loadClass(handlerClassName, clazz);</div><div class="line">  Constructor constructor = getConstructor(handlerClass, Vertx.class, clazz, <span class="keyword">boolean</span>.class, <span class="keyword">long</span>.class);</div><div class="line">  Object instance = createInstance(constructor, vertx, service, topLevel, timeoutSeconds);</div><div class="line">  ProxyHandler handler = (ProxyHandler) instance;</div><div class="line">  <span class="keyword">return</span> handler.registerHandler(address);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先根据约定生成对应的代理<code>Handler</code>的名称，然后通过类加载器加载对应的<code>Handler</code>类，再通过反射来创建代理<code>Handler</code>的实例，最后调用<code>handler</code>的<code>registerHandler</code>方法注册服务地址。</p>
<p><code>registerHandler</code>方法的实现在Vert.x生成的各个代理处理器中。以之前的<code>SomeService</code>为例，我们来看一下其对应的代理处理器<code>SomeServiceVertxProxyHandler</code>实现。首先是注册并订阅地址的<code>registerHandler</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MessageConsumer&lt;JsonObject&gt; <span class="title">registerHandler</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">  MessageConsumer&lt;JsonObject&gt; consumer = vertx.eventBus().&lt;JsonObject&gt;consumer(address).handler(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">this</span>.setConsumer(consumer);</div><div class="line">  <span class="keyword">return</span> consumer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>registerHandler</code>方法的实现非常简单，就是通过<code>consumer</code>方法在<code>address</code>地址上绑定了<code>SomeServiceVertxProxyHandler</code>自身。那么<code>SomeServiceVertxProxyHandler</code>是如何处理来自服务调用端的服务调用请求，并将调用结果返回到请求端呢？在回答这个问题之前，我们先来看看代理端（调用端）是如何发送服务调用请求的，这就要看对应的服务代理类的实现了。</p>
<h1 id="服务调用">服务调用</h1><p>我们来看一下服务调用端是如何发出服务调用请求的消息的。之前已经介绍过，服务调用端是通过Event Bus的<code>send</code>方法发送调用请求的，并且会提供一个<code>replyHandler</code>来等待方法调用的结果。调用的方法名称会存放在消息中名为<code>action</code>的header中。以之前<code>SomeService</code>的代理类<code>SomeServiceVertxEBProxy</code>中<code>process</code>方法的请求为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SomeService <span class="title">process</span><span class="params">(String id, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; resultHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (closed) &#123;</div><div class="line">    resultHandler.handle(Future.failedFuture(<span class="keyword">new</span> IllegalStateException(<span class="string">"Proxy is closed"</span>)));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  JsonObject _json = <span class="keyword">new</span> JsonObject();</div><div class="line">  _json.put(<span class="string">"id"</span>, id);</div><div class="line">  DeliveryOptions _deliveryOptions = (_options != <span class="keyword">null</span>) ? <span class="keyword">new</span> DeliveryOptions(_options) : <span class="keyword">new</span> DeliveryOptions();</div><div class="line">  _deliveryOptions.addHeader(<span class="string">"action"</span>, <span class="string">"process"</span>);</div><div class="line">  _vertx.eventBus().&lt;JsonObject&gt;send(_address, _json, _deliveryOptions, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.failed()) &#123;</div><div class="line">      resultHandler.handle(Future.failedFuture(res.cause()));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      resultHandler.handle(Future.succeededFuture(res.result().body()));</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到代理类把此方法传入的参数都放到一个<code>JsonObject</code>中了，并将要调用的方法名称存放在消息中名为<code>action</code>的header中。代理方法通过<code>send</code>方法将包装好的消息发送至之前注册的服务地址处，并且绑定<code>replyHandler</code>等待调用结果，然后使用我们传入到<code>process</code>方法中的<code>resultHandler</code>对结果进行处理。是不是很简单呢？</p>
<h1 id="服务提供端的调用逻辑">服务提供端的调用逻辑</h1><p>调用请求发出之后，我们的服务提供端就会收到调用请求消息，然后执行<code>SomeServiceVertxProxyHandler</code>中的处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;JsonObject&gt; msg)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    JsonObject json = msg.body();</div><div class="line">    String action = msg.headers().get(<span class="string">"action"</span>);</div><div class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"action not specified"</span>);</div><div class="line">    &#125;</div><div class="line">    accessed();</div><div class="line">    <span class="keyword">switch</span> (action) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">"process"</span>: &#123;</div><div class="line">        service.process((java.lang.String)json.getValue(<span class="string">"id"</span>), createHandler(msg));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">default</span>: &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid action: "</span> + action);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">    msg.reply(<span class="keyword">new</span> ServiceException(<span class="number">500</span>, t.getMessage()));</div><div class="line">    <span class="keyword">throw</span> t;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>handle</code>方法首先从消息header中获取方法名称，如果获取不到则调用失败；接着<code>handle</code>方法会调用<code>accessed</code>方法记录最后调用服务的时间戳，这是为了实现超时的逻辑，后面我们会讲。接着<code>handle</code>方法会根据方法名称分派对应的逻辑，在“真正”的服务实例上调用方法。注意异步RPC的过程本质是 <strong>Request/Response</strong> 模式，因此这里的异步结果处理函数<code>resultHandler</code>应该将调用结果发送回调用端。此<code>resultHandler</code>是通过<code>createHandler</code>方法生成的，逻辑很清晰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; Handler&lt;AsyncResult&lt;T&gt;&gt; createHandler(Message msg) &#123;</div><div class="line">  <span class="keyword">return</span> res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.failed()) &#123;</div><div class="line">      <span class="keyword">if</span> (res.cause() <span class="keyword">instanceof</span> ServiceException) &#123;</div><div class="line">        msg.reply(res.cause());</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        msg.reply(<span class="keyword">new</span> ServiceException(-<span class="number">1</span>, res.cause().getMessage()));</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (res.result() != <span class="keyword">null</span>  &amp;&amp; res.result().getClass().isEnum()) &#123;</div><div class="line">        msg.reply(((Enum) res.result()).name());</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        msg.reply(res.result());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，一旦在服务提供端的调用过程完成时，调用结果就会被发送回调用端。这样调用端就可以调用结果执行真正的处理逻辑了。</p>
<h1 id="超时处理">超时处理</h1><p>Vert.x自动生成的代理处理器内都封装了一个简单的超时处理逻辑，它是通过定时器定时检查最后的调用时间实现的。逻辑比较简单，直接放上相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SomeServiceVertxProxyHandler</span><span class="params">(Vertx vertx, SomeService service, <span class="keyword">boolean</span> topLevel, <span class="keyword">long</span> timeoutSeconds)</span> </span>&#123;</div><div class="line">  <span class="comment">// 前面代码略。。。</span></div><div class="line">  <span class="keyword">if</span> (timeoutSeconds != -<span class="number">1</span> &amp;&amp; !topLevel) &#123;</div><div class="line">    <span class="keyword">long</span> period = timeoutSeconds * <span class="number">1000</span> / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (period &gt; <span class="number">10000</span>) &#123;</div><div class="line">      period = <span class="number">10000</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.timerID = vertx.setPeriodic(period, <span class="keyword">this</span>::checkTimedOut);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.timerID = -<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  accessed();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkTimedOut</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">  <span class="keyword">long</span> now = System.nanoTime();</div><div class="line">  <span class="keyword">if</span> (now - lastAccessed &gt; timeoutSeconds * <span class="number">1000000000</span>) &#123;</div><div class="line">    close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦超时，就自动调用<code>close</code>方法终止定时器，注销响应服务调用请求的consumer并关闭代理。</p>
<h1 id="代码是如何生成的？">代码是如何生成的？</h1><p>大家可能会很好奇，这些服务代理类是怎么生成出来的？其实，这都是Vert.x Codegen的功劳。Vert.x Codegen的本质是一个 <strong>注解处理器</strong>(APT)，它可以扫描源码中是否包含要处理的注解，检查规范后根据响应的模板生成对应的代码，这就是注解处理器的作用(注解处理器于JDK 1.6引入)。为了让Codegen正确地生成代码，我们需要配置编译参数来确保注解处理器能够正常的工作，具体的可以参考 <a href="https://github.com/vert-x3/vertx-codegen/blob/master/README.md" target="_blank" rel="external">Vert.x Codegen的文档</a> （之前里面缺了Gradle相关的实例，我给补上了）。</p>
<p>Vert.x Codegen使用MVEL2作为生成代码的模板，扩展名为<code>*.templ</code>，比如代理类和代理处理器的模板就位于 <a href="https://github.com/vert-x3/vertx-service-proxy/tree/master/src/main/resources/serviceproxy/template" target="_blank" rel="external">vert-x3/vertx-service-proxy</a> 中，配置文件类似于这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"Proxy"</span>,</div><div class="line">  <span class="attr">"generators"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"kind"</span>: <span class="string">"proxy"</span>,</div><div class="line">      <span class="attr">"fileName"</span>: <span class="string">"ifaceFQCN + 'VertxEBProxy.java'"</span>,</div><div class="line">      <span class="attr">"templateFileName"</span>: <span class="string">"serviceproxy/template/proxygen.templ"</span></div><div class="line">    &#125;,&#123;</div><div class="line">      <span class="attr">"kind"</span>: <span class="string">"proxy"</span>,</div><div class="line">      <span class="attr">"fileName"</span>: <span class="string">"ifaceFQCN + 'VertxProxyHandler.java'"</span>,</div><div class="line">      <span class="attr">"templateFileName"</span>: <span class="string">"serviceproxy/template/handlergen.templ"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的代码生成逻辑还要涉及APT及MVEL2的知识，这里就不展开讲了，有兴趣的朋友可以研究研究Vert.x Codegen的源码。</p>
<h1 id="优点与缺点">优点与缺点</h1><p>Vert.x提供的这种Async RPC有着许多优点：</p>
<ul>
<li>通过Clustered Event Bus传输消息，不需引入其它额外的组件</li>
<li>自动生成代理类及代理处理器，可以帮助我们做消息封装、传输、编码解码以及超时处理等问题，省掉不少冗余代码，让我们可以以LPC的方式进行RPC通信</li>
<li>多语言支持(Polyglot support)。这是Vert.x的一大亮点。只要加上<code>@VertxGen</code>注解并在编译期依赖中加上对应语言的依赖(如<code>vertx-lang-ruby</code>)，Vert.x Codegen就会自动处理注解并生成对应语言的服务代理（通过调用Java版本的服务代理实现）。这样Async RPC可以真正地做到不限language</li>
</ul>
<p>当然Vert.x要求我们的服务接口必须是 <strong>基于回调的</strong>，这样写起来可能会不优雅。还好<code>@VertxGen</code>注解支持生成Rx版本的服务类，因此只要加上<code>vertx-rx-java</code>依赖，Codegen就能生成对应的Rx风格的服务类（异步方法返回<code>Observable</code>），这样我们就能以更reactive的风格来构建应用了，岂不美哉？</p>
<p>当然，为了考虑多语言支持的兼容性，Vert.x在传递消息的时候依然使用了传统的JSON，这样传输效率可能不如Protobuf高，但是不一定成为瓶颈。（看业务情况。真正的瓶颈一般还是在DB上）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-distributed-system-rpc-design" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Distributed-System/distributed-system-rpc-design/" class="article-date">
      <time datetime="2016-09-06T16:00:00.000Z" itemprop="datePublished">2016-09-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Distributed-System/distributed-system-rpc-design/">Distributed System | RPC模块设计与实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>RPC是分布式系统中不可缺少的一部分。之前接触过几种RPC模块，这里就总结一下常见RPC模块的设计思想和实现。最后我们来设计一个可以方便进行RPC调用的RPC模块。</p>
<h1 id="RPC模块设计需要考虑的问题">RPC模块设计需要考虑的问题</h1><p>RPC模块将网络通信的过程封装成了方法调用的过程。从使用者的角度来看，在调用端进行RPC调用，就像进行本地函数调用一样；而在背后，RPC模块会将先调用端的函数名称、参数等调用信息序列化，其中序列化的方式有很多种，比如Java原生序列化、JSON、Protobuf等。接着RPC模块会将序列化后的消息通过某种协议(如TCP, AMQP等)发送到被调用端，被调用端在收到消息以后会对其解码，还原成调用信息，然后在本地进行方法调用，然后把调用结果发送回调用端，这样一次RPC调用过程就完成了。在这个过程中，我们要考虑到一些问题：</p>
<ul>
<li>设计成什么样的调用模型？</li>
<li>调用信息通过什么样的方式序列化？通过哪种协议传输？性能如何？可靠性如何？</li>
<li>分布式系统中最关注的问题：出现failure如何应对？如何容错？</li>
</ul>
<p>我们一点一点来思考。第一点是设计成什么样的调用模型。常见的几种模型：</p>
<ul>
<li>服务代理。即实现一个服务接口，被调用端实现此服务接口，实现对应的方法逻辑，并写好RPC调用信息接收部分；调用端通过RPC模块获取一个服务代理实例，这个服务代理实例继承了服务接口并封装了相应的远程调用逻辑（包括消息的编码、解码、传输等）。调用端通过这个服务代理实例进行RPC调用。像Vert.x Service Proxy和grpc都是这种模型。这样的RPC模块需要具备生成服务代理类的功能</li>
<li>直接调用，即设计特定的API用于RPC调用。比如Go的rpc包，里面的<code>Client</code>就提供了一个<code>Call</code>方法用于任意RPC调用，调用者需要传入方法名称、参数以及返回值指针（异步模式下传入callback handler）</li>
</ul>
<p>我更倾向于选择服务代理这种模型，因为服务代理这种模型在进行RPC调用的时候就像直接LPC一样方便，但是需要RPC模块生成服务代理类，实现起来可能会麻烦些；当然Go的rpc包封装的也比较好，调用也比较方便，考虑到Go的类型系统，这已经不错了。。。</p>
<p>RPC调用耗时会包含通信耗时和本地调用耗时。当网络状况不好的时候，RPC调用可能会很长时间才能得到结果。对传统的同步RPC模式来说，这期间会阻塞调用者的调用线程。当需要进行大量RPC调用的时候，这种阻塞就伤不起了。这时候，异步RPC模式就派上用场了。我们可以对传统RPC模式稍加改造，把服务接口设计成异步模式的，即每个方法都要绑定一个回调函数，或利用Future-Promise模型返回一个<code>Future</code>。设计成异步模式以后，整个架构的灵活性就能得到很大的提升。</p>
<p>第二点是调用信息的序列化反序列化以及传输。序列化主要分为文本(如JSON, XML等)和二进制(如Thrift, Protocol等)两种，不同的序列化策略性能不同，因此我们应该尽量选择性能高，同时便于开发的序列化策略。在大型项目中我们常用Protobuf，性能比较好，支持多语言，但是需要单独定义<code>.proto</code>文件；有的时候我们会选择JSON，尽管效率不是很高但是方便，比如Vert.x Service Proxy就选择了JSON格式(底层依赖Event Bus)。另一点就是传输协议的选择。通常情况下我们会选择TCP协议(各种基于TCP的应用层协议，如HTTP/2)进行通信，当然用基于AMQP协议的消息队列也可以，两者都比较可靠。</p>
<p>这里还需提一点：如何高效地并发处理request/response，这依赖于通信模块的实现。拿Java来说，基于Netty NIO或者Java AIO的I/O多路复用都可以很好地并发处理请求；而像Go RPC则是来一个request就创建一个Goroutine并在其中处理请求(Goroutine作为轻量级用户态线程，创建性能消耗小)。</p>
<p>最后一点也是最重要的一点：实现容错，这也是分布式系统设计要考虑的一个核心。想象一下一次RPC调用过程中可能产生的各种failure：</p>
<ul>
<li>网络拥塞</li>
<li>丢包，通信异常</li>
<li>服务提供端挂了，调用端得不到response</li>
</ul>
<p>一种简单的应对方式是不断地超时重传，即 <em>at least once</em> 模式。调用端设置一个超时定时器，若一定时间内没有收到response就继续发送调用请求，直到收到response或请求次数达到阈值。这种模式会发送重复请求，因此只适用于幂等性的操作，即执行多次结果相同的操作，比如读取操作。当然服务提供端也可以实现对应的逻辑来检查重复的请求。</p>
<p>更符合我们期望的容错方案是 <em>at most once</em> 模式。<em>at most once</em> 模式要求服务提供端检查重复请求，如果检查到当前请求是重复请求则返回之前的调用结果。服务提供端需要缓存之前的调用结果。这里面有几点需要考虑：</p>
<ul>
<li>如何实现重传和重复请求检测？是依靠协议（如TCP的超时重传）还是自己实现？</li>
</ul>
<p>如果自己实现的话：</p>
<ul>
<li>如何检查重复请求？我们可以给每个请求生成一个独一无二的标识符(xid)，并且在重传请求的时候使用相同的xid进行重传。用伪代码可以表示为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (seen(xid)) &#123;</div><div class="line">  result = oldResult;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  result = call(...);</div><div class="line">  oldResult = result;</div><div class="line">  setCurrentId(xid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如何保证xid是独一无二的？可以考虑使用UUID或者不同seed下的随机数。</li>
<li>服务请求端需要在一个合适的时间丢弃掉保存的之前缓存的调用结果。</li>
<li>当某个RPC调用过程还正在执行时，如何应对另外的重复请求？这种情况可以设置一个flag用于标识是否正在执行。</li>
<li>如果服务调用端挂了并且重启怎么办？如果服务调用端将xid和调用结果缓存在内存中，那么保存的信息就丢失了。因此我们可以考虑将缓存信息定时写入硬盘，或者写入replication server中，当然这些情况就比较复杂了，涉及到高可用和一致性的问题。</li>
</ul>
<p>由此可见，虽然RPC模块看似比较简单，但是设计的时候要考虑的问题还是非常多的。尤其是在保证性能的基础上又要保证可靠性，还要保证开发者的易用性，这就需要细致地思考了。</p>
<h1 id="常见RPC模块实现">常见RPC模块实现</h1><p>这里我来简单总结一下用过的常见的几个RPC模块的使用及实现思路。</p>
<h2 id="Go_RPC">Go RPC</h2><p>Go的<code>rpc</code>包使用了Go自己的gob协议作为序列化协议(通过<code>encoding/gob</code>模块内的<code>Encoder</code>/<code>Decoder</code>进行编码和解码)，而传输协议可以直接使用TCP(<code>Dial</code>方法)或者使用HTTP(<code>DialHTTP</code>)方法。开发者需要在服务端定义struct并且实现各种方法，然后将struct注册到服务端。需要进行RPC调用的时候，我们就可以在调用端通过<code>Call</code>方法（同步）或者<code>Go</code>方法（异步）进行调用。同步模式下调用结果即为<code>reply</code>指针所指的对象，而异步模式则会在调用结果准备就绪后通知绑定的channel并执行处理。</p>
<p>在rpc包的实现中(<code>net/rpc/server.go</code>)，每个注册的服务类都被封装成了一个<code>service</code>结构体，而其中的每个方法则被封装成了一个<code>methodType</code>结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> methodType <span class="keyword">struct</span> &#123;</div><div class="line">	sync.Mutex <span class="comment">// protects counters</span></div><div class="line">	method     reflect.Method</div><div class="line">	ArgType    reflect.Type</div><div class="line">	ReplyType  reflect.Type</div><div class="line">	numCalls   <span class="keyword">uint</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</div><div class="line">	name   <span class="keyword">string</span>                 <span class="comment">// name of service</span></div><div class="line">	rcvr   reflect.Value          <span class="comment">// receiver of methods for the service</span></div><div class="line">	typ    reflect.Type           <span class="comment">// type of the receiver</span></div><div class="line">	method <span class="keyword">map</span>[<span class="keyword">string</span>]*methodType <span class="comment">// registered methods</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个服务端都被封装成了一个<code>Server</code>结构体，其中的<code>serviceMap</code>存储着各个服务类的元数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</div><div class="line">	mu         sync.RWMutex <span class="comment">// protects the serviceMap</span></div><div class="line">	serviceMap <span class="keyword">map</span>[<span class="keyword">string</span>]*service</div><div class="line">	reqLock    sync.Mutex <span class="comment">// protects freeReq</span></div><div class="line">	freeReq    *Request</div><div class="line">	respLock   sync.Mutex <span class="comment">// protects freeResp</span></div><div class="line">	freeResp   *Response</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RPC Server处理调用请求的默认路径是<code>/_goRPC_</code>。当请求到达时，Go就会调用<code>Server</code>结构体实现的<code>ServeHTTP</code>方法，经<code>ServeConn</code>方法传入gob codec预处理以后最终在<code>ServeCodec</code>方法内处理请求并进行调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeCodec</span><span class="params">(codec ServerCodec)</span></span> &#123;</div><div class="line">	sending := <span class="built_in">new</span>(sync.Mutex)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		service, mtype, req, argv, replyv, keepReading, err := server.readRequest(codec)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> debugLog &amp;&amp; err != io.EOF &#123;</div><div class="line">				log.Println(<span class="string">"rpc:"</span>, err)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> !keepReading &#123;</div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// send a response if we actually managed to read a header.</span></div><div class="line">			<span class="keyword">if</span> req != <span class="literal">nil</span> &#123;</div><div class="line">				server.sendResponse(sending, req, invalidRequest, codec, err.Error())</div><div class="line">				server.freeRequest(req)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">go</span> service.call(server, sending, mtype, req, argv, replyv, codec)</div><div class="line">	&#125;</div><div class="line">	codec.Close()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果成功读取请求数据，那么接下来RPC Server就会新建一个Goroutine用来在本地执行方法，并向调用端返回response：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">call</span><span class="params">(server *Server, sending *sync.Mutex, mtype *methodType, req *Request, argv, replyv reflect.Value, codec ServerCodec)</span></span> &#123;</div><div class="line">	mtype.Lock()</div><div class="line">	mtype.numCalls++</div><div class="line">	mtype.Unlock()</div><div class="line">	function := mtype.method.Func</div><div class="line">	<span class="comment">// Invoke the method, providing a new value for the reply.</span></div><div class="line">	returnValues := function.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)</div><div class="line">	<span class="comment">// The return value for the method is an error.</span></div><div class="line">	errInter := returnValues[<span class="number">0</span>].Interface()</div><div class="line">	errmsg := <span class="string">""</span></div><div class="line">	<span class="keyword">if</span> errInter != <span class="literal">nil</span> &#123;</div><div class="line">		errmsg = errInter.(error).Error()</div><div class="line">	&#125;</div><div class="line">	server.sendResponse(sending, req, replyv.Interface(), codec, errmsg)</div><div class="line">	server.freeRequest(req)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在执行调用的过程中应该注意并发问题，防止资源争用，修改数据时需要对数据加锁；至于方法的执行就是利用了Go的反射机制。调用完以后，RPC Server接着调用<code>sendResponse</code>方法发送response，其中写入response的时候同样需要加锁，防止资源争用。</p>
<h2 id="grpc">grpc</h2><p>grpc是Google开源的一个通用的RPC框架，支持C, Java和Go等语言。既然是Google出品，序列化协议必然用protobuf啦（毕竟高效），传输协议使用HTTP/2，非常不错。开发时需要在<code>.proto</code>文件里定义数据类型以及服务接口，然后配上protoc的grpc插件就能够自动生成各个语言的服务接口和代理类。粗略地看了下grpc-java的源码，底层利用Netty和OkHttp实现HTTP通信，性能应该不错。</p>
<h2 id="Vert-x_Service_Proxy">Vert.x Service Proxy</h2><p>Vert.x Service Proxy是Vert.x的一个异步RPC组件，支持通过各种JVM语言(Java, Scala, JS, JRuby, Groovy等)进行RPC调用。使用Vert.x Service Proxy时我们只需要按照异步开发模式编写服务接口，加上相应的注解，Vert.x Service Proxy就会自动生成相应的服务代理类和服务调用处理类。Vert.x Service Proxy底层借助Event Bus进行通信，调用时将调用消息包装成JSON数据然后通过Event Bus传输到服务端，得到结果后再返回给调用端。Vert.x的一大特性就是异步、响应式编程，因此Vert.x Service Proxy的RPC模型为异步RPC，用起来非常方便。几个异步过程可以通过各种组合子串成一串，妥妥的reactive programming的风格~</p>
<p>更多的关于Vert.x Service Proxy的实现原理的内容可以看这一篇：<a href="http://www.sczyh30.com/posts/Vert-x/vertx-advanced-async-rpc/">Vert.x 技术内幕 | 异步RPC实现原理</a>。</p>
<p>PS: 我经常吐槽Vert.x Service Proxy这个名字，因为光看名字很多人不知道它可以用来实现RPC，导致了很多人以为Vert.x不能做RPC。。。应该改名叫Vert.x Async RPC比较合适。。。当然它还有很大的改进空间，主要是被Vert.x Event Bus的性能和可靠性给拖累了。。。</p>
<h2 id="Java_RMI">Java RMI</h2><p>Java RMI(Remote Method Invocation)是Java里的一种RPC编程接口，类似于服务代理的一种模式。用起来不是很方便。。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RPC/">RPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vertx-advanced-clustered-event-bus-internal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-clustered-event-bus-internal/" class="article-date">
      <time datetime="2016-09-04T16:00:00.000Z" itemprop="datePublished">2016-09-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-clustered-event-bus-internal/">Vert.x 技术内幕 | Event Bus 源码分析 (集群模式)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="http://www.sczyh30.com/posts/Vert-x/vertx-advanced-local-event-bus-internal/">上篇文章</a>中我们探索了Local模式下Event Bus的源码，在这篇文章中我们来探索一下Vert.x中的Clustered Event Bus是如何实现的。对应的Vert.x版本为<strong>3.3.2</strong>。</p>
<h1 id="集群模式介绍">集群模式介绍</h1><p>我们先来简单地介绍一下集群模式下Event Bus的基本原理。</p>
<p>我们可以通过集群模式下的Event Bus在不同的服务器之间进行通信，其本质为TCP通信。Vert.x集群模式需要一个集群管理器（默认为<code>HazelcastClusterManager</code>）来管理集群的状态，存储元数据。当我们在某个节点A给集群模式的Event Bus绑定一个对应地址<code>address</code>的<code>consumer</code>的时候，Event Bus会将此节点的<code>ServerID</code>（包含<code>host</code>和<code>port</code>信息）存储至集群管理器的共享Map中，<code>key</code>为绑定的地址<code>address</code>，value为绑定了此地址<code>address</code>的所有结点的<code>ServerID</code>集合（可以看作是具有负载均衡功能的<code>Set</code>）。集群中的所有节点都可以从集群管理器中获取Map记录。并且绑定consumer的同时节点A会建立一个<code>NetServer</code>接收数据。这样，我们再通过另一个结点B向此地址<code>address</code>发送消息的时候，B就会从集群管理器中取出此地址对应的<code>ServerID</code>集合，并根据是点对点发送还是发布，根据相应的策略创建<code>NetClient</code>执行消息分发逻辑。这样，对应的<code>NetServer</code>收到数据后会对其进行解码然后在本地进行消息的处理。</p>
<p>集群模式下我们还需要注意几个问题：</p>
<ul>
<li>某个节点挂了怎么办？</li>
<li>如何确保结点的高可用性？</li>
</ul>
<p>当某个节点挂掉的时候，其连接将会不可用，集群管理器就会将此节点的信息从集群中移除，并且传播到所有的节点删除对应缓存的信息，这样发消息的时候就不会发送到挂掉的无效节点处。至于高可用性，Vert.x提供了高可用管理器<code>HAManager</code>用于实现高可用性，在发生故障时能够快速failover，详情可见<a href="http://vertx.io/docs/vertx-core/java/#_high_availability_and_fail_over" target="_blank" rel="external">官方文档</a>。</p>
<p>好了，下面我们就来分析一下Clustered Event Bus的源码。集群模式下Event Bus的类型为<code>ClusteredEventBus</code>，它继承了单机模式的<code>EventBusImpl</code>类。其初始化过程与Local模式大同小异，因此这里就直接分析发送和接受消息相关的逻辑了。</p>
<h1 id="绑定MessageConsumer">绑定MessageConsumer</h1><p>我们还是先来看<code>consumer</code>方法的逻辑。前面的调用逻辑都和Local模式下相同，可以参考之前的文章。不同之处在添加记录的地方。Cluster模式下Event Bus需要将当前机器的位置存储至Map中并且传播至集群内的所有节点，因此<code>ClusteredEventBus</code>重写了四个参数版本的<code>addRegistration</code>方法（之前在<code>EventBusImpl</code>类中这个版本的方法用处不大，这里用处就大了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addRegistration</span><span class="params">(<span class="keyword">boolean</span> newAddress, String address,</span></span></div><div class="line">                                   <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly,</div><div class="line">                                   Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler) &#123;</div><div class="line">  <span class="keyword">if</span> (newAddress &amp;&amp; subs != <span class="keyword">null</span> &amp;&amp; !replyHandler &amp;&amp; !localOnly) &#123;</div><div class="line">    <span class="comment">// Propagate the information</span></div><div class="line">    subs.add(address, serverID, completionHandler);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    completionHandler.handle(Future.succeededFuture());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要绑定<code>MessageConsumer</code>对应的地址在本地中没有注册过，并且不是Event Bus自动生成的reply consumer，并且允许在集群范围内传播的话，Event Bus就会将当前机器的位置添加到集群内的记录<code>subs</code>中。<code>subs</code>的类型为<code>AsyncMultiMap</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> AsyncMultiMap&lt;String, ServerID&gt; subs;</div></pre></td></tr></table></figure>
<p>ClusteredEventBus启动时会对其进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">clusterManager.&lt;String, ServerID&gt;getAsyncMultiMap(SUBS_MAP_NAME, ar2 -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (ar2.succeeded()) &#123;</div><div class="line">    subs = ar2.result();</div><div class="line">    <span class="comment">// 其他代码暂略。。。</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 代码略。。。</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从名字就可以看出来，<code>AsyncMultiMap</code>允许<strong>一键多值</strong>，并且其变动可以<strong>在集群范围内传播</strong>。由于<code>AsyncMultiMap</code>是<strong>集群范围内</strong>的，因此对其操作都是异步的。在这里我们可以简单地把它看作是一个<code>Map&lt;String, ChoosableIterable&lt;ServerID&gt;&gt;</code>类型的键值对，其中<code>ChoosableIterable</code>与之前见到过的<code>Handlers</code>类似，属于可以通过轮询算法获取某一元素的集合。<code>subs</code>的key为绑定的地址，value为绑定此地址的机器位置的集合。机器的位置用<code>ServerID</code>表示，里面包含了该机器的<code>host</code>和<code>port</code>。这样，每当我们向某个地址绑定一个<code>MessageConsumer</code>的时候，绑定consumer的<code>ServerID</code>就会被记录到集群中并与地址相对应，其它机器在向此地址发送（或发布）消息的时候，Event Bus就可以从集群中获取在此地址上绑定了consumer的所有<code>ServerID</code>，再根据相应的策略选出合适的<code>ServerID</code>建立TCP通信将数据发送至对应机器中，对应机器收到消息后解码并在本地对其进行处理。</p>
<p>这里面还需要注意一点：我们可以在<code>EventBusOptions</code>中指定<code>ServerID</code>的<code>port</code>和<code>host</code>，若不指定则<code>port</code>将随机分配(<code>NetServer</code>的特性)。</p>
<p>剩下的过程也就大同小异了。至于<code>unregister</code>方法，无非就是将底层的<code>removeRegistration</code>方法重写，从<code>subs</code>中删除对应的<code>ServerID</code>并传播至其它节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeRegistration</span><span class="params">(HandlerHolder lastHolder, String address,</span></span></div><div class="line">                                      Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler) &#123;</div><div class="line">  <span class="keyword">if</span> (lastHolder != <span class="keyword">null</span> &amp;&amp; subs != <span class="keyword">null</span> &amp;&amp; !lastHolder.isLocalOnly()) &#123;</div><div class="line">    removeSub(address, serverID, completionHandler);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    callCompletionHandlerAsync(completionHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeSub</span><span class="params">(String subName, ServerID theServerID, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">  subs.remove(subName, theServerID, ar -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (!ar.succeeded()) &#123;</div><div class="line">      log.error(<span class="string">"Failed to remove sub"</span>, ar.cause());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (ar.result()) &#123;</div><div class="line">        <span class="keyword">if</span> (completionHandler != <span class="keyword">null</span>) &#123;</div><div class="line">          completionHandler.handle(Future.succeededFuture());</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (completionHandler != <span class="keyword">null</span>) &#123;</div><div class="line">          completionHandler.handle(Future.failedFuture(<span class="string">"sub not found"</span>));</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="消息的发送/发布">消息的发送/发布</h1><p>集群模式下的消息与本地模式下的消息不同。集群模式下的消息实体类型为<code>ClusteredMessage</code>，它继承了<code>MessageImpl</code>消息实体类，并且根据远程传输的特性实现了一种Wire Protocol用于远程传输消息，并负责消息的编码和解码。具体的实现就不展开说了，如果有兴趣的话可以阅读<code>ClusteredMessage</code>类中相关方法的实现。</p>
<p>我们上篇文章提到过，Event Bus底层通过<code>createMessage</code>方法创建消息。因此<code>ClusteredEventBus</code>里就对此方法进行了重写，当然改动就是把<code>MessageImpl</code>替换成了<code>ClusteredMessage</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> MessageImpl <span class="title">createMessage</span><span class="params">(<span class="keyword">boolean</span> send, String address, MultiMap headers, Object body, String codecName)</span> </span>&#123;</div><div class="line">  Objects.requireNonNull(address, <span class="string">"no null address accepted"</span>);</div><div class="line">  MessageCodec codec = codecManager.lookupCodec(body, codecName);</div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  ClusteredMessage msg = <span class="keyword">new</span> ClusteredMessage(serverID, address, <span class="keyword">null</span>, headers, body, codec, send, <span class="keyword">this</span>);</div><div class="line">  <span class="keyword">return</span> msg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就是消息的发送逻辑了。<code>ClusteredEventBus</code>重写了<code>sendOrPub</code>方法，此方法存在于<code>SendContextImpl</code>类中的<code>next</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (iter.hasNext()) &#123;</div><div class="line">    Handler&lt;SendContext&gt; handler = iter.next();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      handler.handle(<span class="keyword">this</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">      log.error(<span class="string">"Failure in interceptor"</span>, t);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    sendOrPub(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看一下<code>ClusteredEventBus</code>是如何进行集群内消息的分发的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendOrPub</span><span class="params">(SendContextImpl&lt;T&gt; sendContext)</span> </span>&#123;</div><div class="line">  String address = sendContext.message.address();</div><div class="line">  Handler&lt;AsyncResult&lt;ChoosableIterable&lt;ServerID&gt;&gt;&gt; resultHandler = asyncResult -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (asyncResult.succeeded()) &#123;</div><div class="line">      ChoosableIterable&lt;ServerID&gt; serverIDs = asyncResult.result();</div><div class="line">      <span class="keyword">if</span> (serverIDs != <span class="keyword">null</span> &amp;&amp; !serverIDs.isEmpty()) &#123;</div><div class="line">        sendToSubs(serverIDs, sendContext);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        metrics.messageSent(address, !sendContext.message.send(), <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">        deliverMessageLocally(sendContext);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      log.error(<span class="string">"Failed to send message"</span>, asyncResult.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">if</span> (Vertx.currentContext() == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// Guarantees the order when there is no current context</span></div><div class="line">    sendNoContext.runOnContext(v -&gt; &#123;</div><div class="line">      subs.get(address, resultHandler);</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    subs.get(address, resultHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Event Bus需要从传入的<code>sendContext</code>中获取要发送至的地址。接着Event Bus需要从集群管理器中获取在此地址上绑定consumer的所有<code>ServerID</code>，这个过程是异步的，并且需要在Vert.x Context中执行。如果获取记录成功，我们会得到一个可通过轮询算法获取<code>ServerID</code>的集合(类型为<code>ChoosableIterable&lt;ServerID&gt;</code>)。如果集合为空，则代表集群内其它节点没有在此地址绑定consumer（或者由于一致性问题没有同步），Event Bus就将消息通过<code>deliverMessageLocally</code>方法在本地进行相应的分发。<code>deliverMessageLocally</code>方法的逻辑之前我们已经详细讲过了，这里就不再细说了；如果集合不为空，Event Bus就调用<code>sendToSubs</code>方法进行下一步操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendToSubs</span><span class="params">(ChoosableIterable&lt;ServerID&gt; subs, SendContextImpl&lt;T&gt; sendContext)</span> </span>&#123;</div><div class="line">  String address = sendContext.message.address();</div><div class="line">  <span class="keyword">if</span> (sendContext.message.send()) &#123;</div><div class="line">    <span class="comment">// Choose one</span></div><div class="line">    ServerID sid = subs.choose();</div><div class="line">    <span class="keyword">if</span> (!sid.equals(serverID)) &#123;  <span class="comment">//We don't send to this node</span></div><div class="line">      metrics.messageSent(address, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">      sendRemote(sid, sendContext.message);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      metrics.messageSent(address, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">      deliverMessageLocally(sendContext);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Publish</span></div><div class="line">    <span class="keyword">boolean</span> local = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> remote = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span> (ServerID sid : subs) &#123;</div><div class="line">      <span class="keyword">if</span> (!sid.equals(serverID)) &#123;  <span class="comment">//We don't send to this node</span></div><div class="line">        remote = <span class="keyword">true</span>;</div><div class="line">        sendRemote(sid, sendContext.message);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        local = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    metrics.messageSent(address, <span class="keyword">true</span>, local, remote);</div><div class="line">    <span class="keyword">if</span> (local) &#123;</div><div class="line">      deliverMessageLocally(sendContext);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就到了分<code>send</code>和<code>publish</code>的时候了。如果发送消息的模式为点对点模式(<code>send</code>)，Event Bus会从给的的集合中通过轮询算法获取一个<code>ServerID</code>。然后Event Bus会检查获取到的<code>ServerID</code>是否与本机<code>ServerID</code>相同，如果相同则代表在一个机子上，直接记录metrics信息并且调用<code>deliverMessageLocally</code>方法往本地发送消息即可；如果不相同，Event Bus就会调用<code>sendRemote</code>方法执行真正的远程消息发送逻辑。发布订阅模式的逻辑与其大同小异，只不过需要遍历一下<code>ChoosableIterable&lt;ServerID&gt;</code>集合，然后依次执行之前讲过的逻辑。注意如果要在本地发布消息只需要发一次。</p>
<p>真正的远程消息发送逻辑在<code>sendRemote</code>方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRemote</span><span class="params">(ServerID theServerID, MessageImpl message)</span> </span>&#123;</div><div class="line">  ConnectionHolder holder = connections.get(theServerID);</div><div class="line">  <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</div><div class="line">    holder = <span class="keyword">new</span> ConnectionHolder(<span class="keyword">this</span>, theServerID, options);</div><div class="line">    ConnectionHolder prevHolder = connections.putIfAbsent(theServerID, holder);</div><div class="line">    <span class="keyword">if</span> (prevHolder != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// Another one sneaked in</span></div><div class="line">      holder = prevHolder;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      holder.connect();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  holder.writeMessage((ClusteredMessage)message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一开始我们就提到过，节点之间通过Event Bus进行通信的本质是TCP，因此这里需要创建一个<code>NetClient</code>作为TCP服务端，连接到之前获取的<code>ServerID</code>对应的节点然后将消息通过TCP协议发送至接收端。这里Vert.x用一个封装类<code>ConnectionHolder</code>对<code>NetClient</code>进行了一些封装。</p>
<p><code>ClusteredEventBus</code>中维持着一个<code>connections</code>哈希表对用于保存<code>ServerID</code>对应的连接<code>ConnectionHolder</code>。在<code>sendRemote</code>方法中,Event Bus首先会从<code>connections</code>中获取<code>ServerID</code>对应的连接。如果获取不到就创建连接并将其添加至<code>connections</code>记录中并调用对应<code>ConnectionHolder</code>的<code>connect</code>方法建立连接；最后调用<code>writeMessage</code>方法将消息编码后通过TCP发送至对应的接收端。</p>
<p>那么<code>ConnectionHolder</code>是如何实现的呢？我们来看一下其构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ConnectionHolder(ClusteredEventBus eventBus, ServerID serverID, EventBusOptions options) &#123;</div><div class="line">  <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">  <span class="keyword">this</span>.serverID = serverID;</div><div class="line">  <span class="keyword">this</span>.vertx = eventBus.vertx();</div><div class="line">  <span class="keyword">this</span>.metrics = eventBus.getMetrics();</div><div class="line">  NetClientOptions clientOptions = <span class="keyword">new</span> NetClientOptions(options.toJson());</div><div class="line">  ClusteredEventBus.setCertOptions(clientOptions, options.getKeyCertOptions());</div><div class="line">  ClusteredEventBus.setTrustOptions(clientOptions, options.getTrustOptions());</div><div class="line">  client = <span class="keyword">new</span> NetClientImpl(eventBus.vertx(), clientOptions, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>ConnectionHolder</code>初始化的时候会创建一个<code>NetClient</code>作为TCP请求端，而请求的对象就是接收端的<code>NetServer</code>(后边会讲)，客户端配置已经在<code>EventBusOptions</code>中事先配置好了。我们来看看<code>connect</code>方法是如何建立连接的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (connected) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already connected"</span>);</div><div class="line">  &#125;</div><div class="line">  client.connect(serverID.port, serverID.host, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      connected(res.result());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      close();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到这里很简单地调用了<code>NetClient#connect</code>方法建立TCP连接，如果建立连接成功的话会得到一个<code>NetSocket</code>对象。Event Bus接着将其传至<code>connected</code>方法中进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(NetSocket socket)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.socket = socket;</div><div class="line">  connected = <span class="keyword">true</span>;</div><div class="line">  socket.exceptionHandler(t -&gt; close());</div><div class="line">  socket.closeHandler(v -&gt; close());</div><div class="line">  socket.handler(data -&gt; &#123;</div><div class="line">    <span class="comment">// Got a pong back</span></div><div class="line">    vertx.cancelTimer(timeoutID);</div><div class="line">    schedulePing();</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// Start a pinger</span></div><div class="line">  schedulePing();</div><div class="line">  <span class="keyword">for</span> (ClusteredMessage message : pending) &#123;</div><div class="line">    Buffer data = message.encodeToWire();</div><div class="line">    metrics.messageWritten(message.address(), data.length());</div><div class="line">    socket.write(data);</div><div class="line">  &#125;</div><div class="line">  pending.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Event Bus通过<code>exceptionHandler</code>和<code>closeHandler</code>方法给连接对应的<code>NetSocket</code>绑定异常回调和连接关闭回调，触发的时候都调用<code>close</code>方法关闭连接；为了保证不丢失连接，消息发送方每隔一段时间就需要对消息接收方发送一次心跳包（<code>PING</code>），如果消息接收方在一定时间内没有回复，那么就认为连接丢失，调用<code>close</code>方法关闭连接。心跳检测的逻辑在<code>schedulePing</code>方法中，比较清晰，这里就不详细说了。大家会发现<code>ConnectionHolder</code>里也有个消息队列（缓冲区）<code>pending</code>，并且这里会将队列中的消息依次通过TCP发送至接收端。为什么需要这样呢？其实，这要从创建TCP客户端说起。创建TCP客户端这个过程应该是异步的，需要消耗一定时间，而<code>ConnectionHolder</code>中封装的<code>connect</code>方法却是同步式的。前面我们刚刚看过，通过<code>connect</code>方法建立连接以后会接着调用<code>writeMessage</code>方法发送消息，而这时候客户端连接可能还没建立，因此需要这么个缓冲区先存着，等着连接建立了再一块发送出去（存疑：为什么不将<code>connect</code>方法直接设计成异步的？）。</p>
<p>至于发送消息的<code>writeMessage</code>方法，其逻辑一目了然：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeMessage</span><span class="params">(ClusteredMessage message)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (connected) &#123;</div><div class="line">    Buffer data = message.encodeToWire();</div><div class="line">    metrics.messageWritten(message.address(), data.length());</div><div class="line">    socket.write(data);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (pending == <span class="keyword">null</span>) &#123;</div><div class="line">      pending = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    pending.add(message);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果连接已建立，Event Bus就会调用对应<code>ClusteredMessage</code>的<code>encodeToWire</code>方法将其转化为字节流<code>Buffer</code>，然后记录metrics信息，最后通过<code>socket</code>的<code>write</code>方法将消息写入到Socket中，这样消息就从发送端通过TCP发送到了接收端。如果连接未建立，就如之前讲的那样，先把消息存到消息队列中，等连接建立了再一块发出去。</p>
<p>这样，Clustered Event Bus下消息的发送逻辑就理清楚了。下面我们看一下接收端是如何接收消息并在本地进行消息的处理的。</p>
<h1 id="消息的接收">消息的接收</h1><p>一开始我们提到过，每个节点的Clustered Event Bus在启动时都会创建一个<code>NetServer</code>作为接收消息的TCP服务端。TCP Server的<code>port</code>和<code>host</code>可以在<code>EventBusOptions</code>中指定，如果不指定的话默认随机分配<code>port</code>，然后Event Bus会根据<code>NetServer</code>的配置来生成当前节点的<code>ServerID</code>。</p>
<p>创建TCP Server的逻辑在<code>start</code>方法中，与接受消息有关的逻辑就是这一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.connectHandler(getServerHandler());</div></pre></td></tr></table></figure>
<p>我们知道，<code>NetServer</code>的<code>connectHandler</code>方法用于绑定对服务端Socket的处理函数，而这里绑定的处理函数是由<code>getServerHandler</code>方法生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Handler&lt;NetSocket&gt; <span class="title">getServerHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> socket -&gt; &#123;</div><div class="line">    RecordParser parser = RecordParser.newFixed(<span class="number">4</span>, <span class="keyword">null</span>);</div><div class="line">    Handler&lt;Buffer&gt; handler = <span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</div><div class="line">      <span class="keyword">int</span> size = -<span class="number">1</span>;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buff)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (size == -<span class="number">1</span>) &#123;</div><div class="line">          size = buff.getInt(<span class="number">0</span>);</div><div class="line">          parser.fixedSizeMode(size);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          ClusteredMessage received = <span class="keyword">new</span> ClusteredMessage();</div><div class="line">          received.readFromWire(buff, codecManager);</div><div class="line">          metrics.messageRead(received.address(), buff.length());</div><div class="line">          parser.fixedSizeMode(<span class="number">4</span>);</div><div class="line">          size = -<span class="number">1</span>;</div><div class="line">          <span class="keyword">if</span> (received.codec() == CodecManager.PING_MESSAGE_CODEC) &#123;</div><div class="line">            <span class="comment">// Just send back pong directly on connection</span></div><div class="line">            socket.write(PONG);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            deliverMessageLocally(received);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    parser.setOutput(handler);</div><div class="line">    socket.handler(parser);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑非常清晰。这里Event Bus使用了<code>RecordParser</code>来获取发送过来的对应长度的<code>Buffer</code>，并将其绑定在<code>NetServer</code>的Socket上。真正的解析<code>Buffer</code>并处理的逻辑在内部的<code>handler</code>中。之前<code>ClusteredMessage</code>中的Wire Protocol规定<code>Buffer</code>的首部第一个<code>int</code>值为要发送<code>Buffer</code>的长度（逻辑见<code>ClusteredMessage#encodeToWire</code>方法），因此这里首先获取长度，然后给<code>parser</code>设定正确的fixed size，这样<code>parser</code>就可以截取正确长度的<code>Buffer</code>流了。下面Event Bus会创建一个空的<code>ClusteredMessage</code>，然后调用其<code>readFromWire</code>方法从<code>Buffer</code>中重建消息。当然这里还要记录消息已经读取的metrics信息。接着检测收到的消息实体类型是否为心跳检测包(<code>PING</code>)，如果是的话就发送回ACK消息(<code>PONG</code>)；如果不是心跳包，则代表是正常的消息，Event Bus就调用我们熟悉的<code>deliverMessageLocally</code>函数在本地进行分发处理，接下来的过程就和Local模式一样了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vertx-advanced-local-event-bus-internal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-local-event-bus-internal/" class="article-date">
      <time datetime="2016-09-02T16:00:00.000Z" itemprop="datePublished">2016-09-03</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-local-event-bus-internal/">Vert.x 技术内幕 | Event Bus 源码分析 (Local模式)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Event Bus是Vert.x的“神经系统”，是最为关键的几个部分之一。今天我们就来探索一下Event Bus的实现原理。本篇分析的是Local模式的Event Bus，对应的Vert.x版本为<strong>3.3.2</strong>。</p>
<p>本文假定读者有一定的并发编程基础以及Vert.x使用基础，并且对Vert.x的线程模型以及<a href="http://vertx.io/docs/vertx-core/java/#streams" target="_blank" rel="external">back-pressure</a>有所了解。</p>
<h1 id="Local_Event_Bus的创建">Local Event Bus的创建</h1><p>一般情况下，我们通过<code>Vertx</code>的<code>eventBus</code>方法来创建或获取一个<code>EventBus</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Vertx vertx = Vertx.vertx();</div><div class="line">EventBus eventBus = vertx.eventBus();</div></pre></td></tr></table></figure>
<p><code>eventBus</code>方法定义于<code>Vertx</code>接口中，我们来看一下其位于<code>VertxImpl</code>类中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">eventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (eventBus == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// If reading from different thread possibility that it's been set but not visible - so provide</span></div><div class="line">    <span class="comment">// memory barrier</span></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">return</span> eventBus;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> eventBus;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到此方法返回<code>VertxImpl</code>实例中的<code>eventBus</code>成员，同时需要注意并发可见性问题。那么<code>eventBus</code>成员是何时初始化的呢？答案在<code>VertxImpl</code>类的构造函数中。这里截取相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (options.isClustered()) &#123;</div><div class="line">  <span class="comment">// 集群模式相关逻辑</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.clusterManager = <span class="keyword">null</span>;</div><div class="line">  createAndStartEventBus(options, resultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>VertxImpl</code>内部是通过<code>createAndStartEventBus</code>方法来初始化<code>eventBus</code>的。我们来看一下其逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndStartEventBus</span><span class="params">(VertxOptions options, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (options.isClustered()) &#123;</div><div class="line">    eventBus = <span class="keyword">new</span> ClusteredEventBus(<span class="keyword">this</span>, options, clusterManager, haManager);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    eventBus = <span class="keyword">new</span> EventBusImpl(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  eventBus.start(ar2 -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (ar2.succeeded()) &#123;</div><div class="line">      <span class="comment">// If the metric provider wants to use the event bus, it cannot use it in its constructor as the event bus</span></div><div class="line">      <span class="comment">// may not be initialized yet. We invokes the eventBusInitialized so it can starts using the event bus.</span></div><div class="line">      metrics.eventBusInitialized(eventBus);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (resultHandler != <span class="keyword">null</span>) &#123;</div><div class="line">        resultHandler.handle(Future.succeededFuture(<span class="keyword">this</span>));</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      log.error(<span class="string">"Failed to start event bus"</span>, ar2.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到此方法通过<code>eventBus = new EventBusImpl(this)</code>将<code>eventBus</code>进行了初始化(Local模式为<code>EventBusImpl</code>)，并且调用<code>eventBus</code>的<code>start</code>方法对其进行一些额外的初始化工作。我们来看一下<code>EventBusImpl</code>类的<code>start</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (started) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already started"</span>);</div><div class="line">  &#125;</div><div class="line">  started = <span class="keyword">true</span>;</div><div class="line">  completionHandler.handle(Future.succeededFuture());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先初始化过程需要防止race condition，因此方法为<code>synchronized</code>的。该方法仅仅将<code>EventBusImpl</code>类中的一个<code>started</code>标志位设为<code>true</code>来代表Event Bus已启动。注意<code>started</code>标志位为<code>volatile</code>的，这样可以保证其可见性，确保其它线程通过<code>checkStarted</code>方法读到的<code>started</code>结果总是最新的。设置完<code>started</code>标志位后，Vert.x会接着调用传入的<code>completionHandler</code>处理函数，也就是上面我们在<code>createAndStartEventBus</code>方法中看到的 —— 调用<code>metrics</code>成员的<code>eventBusInitialized</code>方法以便Metrics类可以在Event Bus初始化完毕后使用它（不过默认情况下此方法的逻辑为空）。</p>
<p>可以看到初始化过程还是比较简单的，我们接下来先来看看订阅消息 —— <code>consumer</code>方法的逻辑。</p>
<h1 id="consume">consume</h1><p>我们来看一下<code>consumer</code>方法的逻辑，其原型位于<code>EventBus</code>接口中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address)</span></span>;</div><div class="line">&lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address, Handler&lt;Message&lt;T&gt;&gt; handler)</span></span>;</div></pre></td></tr></table></figure>
<p>其实现位于<code>EventBusImpl</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address, Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</div><div class="line">  Objects.requireNonNull(handler, <span class="string">"handler"</span>);</div><div class="line">  MessageConsumer&lt;T&gt; consumer = consumer(address);</div><div class="line">  consumer.handler(handler);</div><div class="line">  <span class="keyword">return</span> consumer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先要确保传入的<code>handler</code>不为空，然后Vert.x会调用只接受一个<code>address</code>参数的<code>consumer</code>方法获取对应的<code>MessageConsumer</code>，最后给获取到的<code>MessageConsumer</code>绑定上传入的<code>handler</code>。我们首先来看一下另一个<code>consumer</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">  checkStarted();</div><div class="line">  Objects.requireNonNull(address, <span class="string">"address"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HandlerRegistration&lt;&gt;(vertx, metrics, <span class="keyword">this</span>, address, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, -<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Vert.x会检查Event Bus是否已经启动，并且确保传入的地址不为空。然后Vert.x会传入一大堆参数创建一个新的<code>HandlerRegistration</code>类型的实例，并返回。可以推测<code>HandlerRegistration</code>是<code>MessageConsumer</code>接口的具体实现，它一定非常重要。所以我们来看一看<code>HandlerRegistration</code>类是个啥玩意。首先看一下<code>HandlerRegistration</code>的类体系结构：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertx-handlerregistration-ch.png" alt=""></p>
<p>可以看到<code>HandlerRegistration</code>类同时继承了<code>MessageConsumer&lt;T&gt;</code>以及<code>Handler&lt;Message&lt;T&gt;&gt;</code>接口，从其类名可以看出它相当于一个”Handler注册记录”，是非常重要的一个类。它有一堆的成员变量，构造函数对<code>vertx</code>, <code>metrics</code>, <code>eventBus</code>, <code>address</code>（发送地址）, <code>repliedAddress</code>（回复地址）, <code>localOnly</code>（是否在集群内传播）, <code>asyncResultHandler</code>等几个成员变量进行初始化，并且检查超时时间<code>timeout</code>，如果设定了超时时间那么设定并保存超时计时器（仅用于reply handler中），如果计时器时间到，代表回复超时。因为有一些函数还没介绍，超时的逻辑我们后边再讲。</p>
<blockquote>
<p>Note: 由于<code>MessageConsumer</code>接口继承了<code>ReadStream</code>接口，因此它支持back-pressure，其实现就在<code>HandlerRegistration</code>类中。我们将稍后解析back-pressure的实现。</p>
</blockquote>
<p>现在回到<code>consumer</code>方法中来。创建了<code>MessageConsumer</code>实例后，我们接着调用它的<code>handler</code>方法绑定上对应的消息处理函数。<code>handler</code>方法的实现位于<code>HandlerRegistration</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> MessageConsumer&lt;T&gt; <span class="title">handler</span><span class="params">(Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.handler = handler;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handler != <span class="keyword">null</span> &amp;&amp; !registered) &#123;</div><div class="line">    registered = <span class="keyword">true</span>;</div><div class="line">    eventBus.addRegistration(address, <span class="keyword">this</span>, repliedAddress != <span class="keyword">null</span>, localOnly);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.handler == <span class="keyword">null</span> &amp;&amp; registered) &#123;</div><div class="line">    <span class="comment">// This will set registered to false</span></div><div class="line">    <span class="keyword">this</span>.unregister();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，<code>handler</code>方法将此<code>HandlerRegistration</code>中的<code>handler</code>成员设置为传入的消息处理函数。<code>HandlerRegistration</code>类中有一个<code>registered</code>标志位代表是否已绑定消息处理函数。<code>handler</code>方法会检查传入的<code>handler</code>是否为空且是否已绑定消息处理函数。如果不为空且未绑定，Vert.x就会将<code>registered</code>标志位设为<code>true</code>并且调用<code>eventBus</code>的<code>addRegistration</code>方法将此consumer注册至Event Bus上；如果<code>handler</code>为空且已绑定消息处理函数，我们就调用<code>unregister</code>方法注销当前的consumer。我们稍后会分析<code>unregister</code>方法的实现。</p>
<p>前面提到过注册consumer的逻辑位于Event Bus的<code>addRegistration</code>方法中，因此我们来分析一下它的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; registration,</span></span></div><div class="line">                                   <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly) &#123;</div><div class="line">  Objects.requireNonNull(registration.getHandler(), <span class="string">"handler"</span>);</div><div class="line">  <span class="keyword">boolean</span> newAddress = addLocalRegistration(address, registration, replyHandler, localOnly);</div><div class="line">  addRegistration(newAddress, address, replyHandler, localOnly, registration::setResult);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>addRegistration</code>方法接受四个参数：发送地址<code>address</code>、传入的consumer <code>registration</code>、代表是否为reply handler的标志位<code>replyHandler</code>以及代表是否在集群范围内传播的标志位<code>localOnly</code>。首先确保传入的<code>HandlerRegistration</code>不为空。然后Vert.x会调用<code>addLocalRegistration</code>方法将此consumer注册至Event Bus上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">addLocalRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; registration,</span></span></div><div class="line">                                           <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly) &#123;</div><div class="line">  Objects.requireNonNull(address, <span class="string">"address"</span>);</div><div class="line"></div><div class="line">  Context context = Vertx.currentContext();</div><div class="line">  <span class="keyword">boolean</span> hasContext = context != <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">if</span> (!hasContext) &#123;</div><div class="line">    <span class="comment">// Embedded</span></div><div class="line">    context = vertx.getOrCreateContext();</div><div class="line">  &#125;</div><div class="line">  registration.setHandlerContext(context);</div><div class="line"></div><div class="line">  <span class="keyword">boolean</span> newAddress = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  HandlerHolder holder = <span class="keyword">new</span> HandlerHolder&lt;&gt;(metrics, registration, replyHandler, localOnly, context);</div><div class="line"></div><div class="line">  Handlers handlers = handlerMap.get(address);</div><div class="line">  <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</div><div class="line">    handlers = <span class="keyword">new</span> Handlers();</div><div class="line">    Handlers prevHandlers = handlerMap.putIfAbsent(address, handlers);</div><div class="line">    <span class="keyword">if</span> (prevHandlers != <span class="keyword">null</span>) &#123;</div><div class="line">      handlers = prevHandlers;</div><div class="line">    &#125;</div><div class="line">    newAddress = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  handlers.list.add(holder);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (hasContext) &#123;</div><div class="line">    HandlerEntry entry = <span class="keyword">new</span> HandlerEntry&lt;&gt;(address, registration);</div><div class="line">    context.addCloseHook(entry);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> newAddress;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先该方法要确保地址<code>address</code>不为空，接着它会获取当前线程下对应的Vert.x Context，如果获取不到则表明当前不在<code>Verticle</code>中（即Embedded），需要调用<code>vertx.getOrCreateContext()</code>来获取<code>Context</code>；然后将获取到的<code>Context</code>赋值给<code>registration</code>内部的<code>handlerContext</code>（代表消息处理对应的Vert.x Context）。</p>
<p>下面就要将给定的<code>registration</code>注册至Event Bus上了。这里Vert.x用一个<code>HandlerHolder</code>类来包装<code>registration</code>和<code>context</code>。接着Vert.x会从存储消息处理<code>Handler</code>的哈希表<code>handlerMap</code>中获取给定地址对应的<code>Handlers</code>，哈希表的类型为<code>ConcurrentMap&lt;String, Handlers&gt;</code>，key为地址，value为对应的<code>HandlerHolder</code>集合。注意这里的<code>Handlers</code>类代表一些<code>Handler</code>的集合，它内部维护着一个列表<code>list</code>用于存储每个<code>HandlerHolder</code>。<code>Handlers</code>类中只有一个<code>choose</code>函数，此函数根据轮询算法从<code>HandlerHolder</code>集合中选定一个<code>HandlerHolder</code>，这即是Event Bus发送消息时实现load-balancing的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handlers</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger pos = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> List&lt;HandlerHolder&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> HandlerHolder <span class="title">choose</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="keyword">int</span> size = list.size();</div><div class="line">      <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> p = pos.getAndIncrement();</div><div class="line">      <span class="keyword">if</span> (p &gt;= size - <span class="number">1</span>) &#123;</div><div class="line">        pos.set(<span class="number">0</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> list.get(p);</div><div class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">        <span class="comment">// Can happen</span></div><div class="line">        pos.set(<span class="number">0</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取到对应的<code>handlers</code>以后，Vert.x首先需要检查其是否为空，如果为空代表此地址还没有注册消息处理<code>Handler</code>，Vert.x就会创建一个<code>Handlers</code>并且将其置入<code>handlerMap</code>中，将<code>newAddress</code>标志位设为<code>true</code>代表这是一个新注册的地址，然后将其赋值给<code>handlers</code>。接着我们向<code>handlers</code>中的<code>HandlerHolder</code>列表<code>list</code>中添加刚刚创建的<code>HandlerHolder</code>实例，这样就将<code>registration</code>注册至Event Bus中了。</p>
<p>前面判断当前线程是否在Vert.x Context的标志位<code>hasContext</code>还有一个用途：如果当前线程在Vert.x Context下（比如在Verticle中），Vert.x会通过<code>addCloseHook</code>方法给当前的<code>context</code>添加一个钩子函数用于注销当前绑定的<code>registration</code>。当对应的<code>Verticle</code>被undeploy的时候，此Verticle绑定的所有消息处理<code>Handler</code>都会被unregister。Hook的类型为<code>HandlerEntry&lt;T&gt;</code>，它继承了<code>Closeable</code>接口，对应的逻辑在<code>close</code>函数中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerEntry</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String address;</div><div class="line">  <span class="keyword">final</span> HandlerRegistration&lt;T&gt; handler;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HandlerEntry</span><span class="params">(String address, HandlerRegistration&lt;T&gt; handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.address = address;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="comment">// Called by context on undeploy</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">    handler.unregister(completionHandler);</div><div class="line">    completionHandler.handle(Future.succeededFuture());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>close</code>函数会将绑定的<code>registration</code>从Event Bus的<code>handlerMap</code>中移除并执行<code>completionHandler</code>中的逻辑，<code>completionHandler</code>可由用户指定。</p>
<p>那么在哪里调用这些绑定的hook呢？答案是在<code>DeploymentManager</code>类中的<code>doUndeploy</code>方法中，通过<code>context</code>的<code>runCloseHooks</code>方法执行绑定的hook函数。相关代码如下（只截取相关逻辑）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doUndeploy</span><span class="params">(ContextImpl undeployingContext, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">  <span class="comment">// 前面代码略</span></div><div class="line">  context.runCloseHooks(ar2 -&gt; &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ar2.failed()) &#123;</div><div class="line">      <span class="comment">// Log error but we report success anyway</span></div><div class="line">      log.error(<span class="string">"Failed to run close hook"</span>, ar2.cause());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (ar.succeeded() &amp;&amp; undeployCount.incrementAndGet() == numToUndeploy) &#123;</div><div class="line">      reportSuccess(<span class="keyword">null</span>, undeployingContext, completionHandler);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ar.failed() &amp;&amp; !failureReported.get()) &#123;</div><div class="line">      failureReported.set(<span class="keyword">true</span>);</div><div class="line">      reportFailure(ar.cause(), undeployingContext, completionHandler);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// 后面代码略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再回到<code>addRegistration</code>方法中。刚才<code>addLocalRegistration</code>方法的返回值<code>newAddress</code>代表对应的地址是否为新注册的。接着我们调用另一个版本的<code>addRegistration</code>方法，传入了一大堆参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addRegistration</span><span class="params">(<span class="keyword">boolean</span> newAddress, String address,</span></span></div><div class="line">                                   <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly,</div><div class="line">                                   Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler) &#123;</div><div class="line">  completionHandler.handle(Future.succeededFuture());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好吧，传入的前几个参数没用到。。。最后一个参数<code>completionHandler</code>传入的是<code>registration::setResult</code>方法引用，也就是说这个方法调用了对应<code>registration</code>的<code>setResult</code>方法。其实现位于<code>HandlerRegistration</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(AsyncResult&lt;Void&gt; result)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.result = result;</div><div class="line">  <span class="keyword">if</span> (completionHandler != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (result.succeeded()) &#123;</div><div class="line">      metric = metrics.handlerRegistered(address, repliedAddress);</div><div class="line">    &#125;</div><div class="line">    Handler&lt;AsyncResult&lt;Void&gt;&gt; callback = completionHandler;</div><div class="line">    vertx.runOnContext(v -&gt; callback.handle(result));</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.failed()) &#123;</div><div class="line">    log.error(<span class="string">"Failed to propagate registration for handler "</span> + handler + <span class="string">" and address "</span> + address);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    metric = metrics.handlerRegistered(address, repliedAddress);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先先设置<code>registration</code>内部的<code>result</code>成员（正常情况下为<code>Future.succeededFuture()</code>）。接着Vert.x会判断<code>registration</code>是否绑定了<code>completionHandler</code>（与之前的<code>completionHandler</code>不同，这里的<code>completionHandler</code>是<code>MessageConsumer</code>注册成功时调用的<code>Handler</code>），若绑定则记录Metrics信息(<code>handlerRegistered</code>)并在Vert.x Context内调用<code>completionHandler</code>的逻辑；若未绑定<code>completionHandler</code>则仅记录Metrics信息。</p>
<p>到此为止，<code>consumer</code>方法的逻辑就分析完了。在分析<code>send</code>和<code>publish</code>方法的逻辑之前，我们先来看一下如何注销绑定的<code>MessageConsumer</code>。</p>
<h1 id="unregister">unregister</h1><p>我们通过调用<code>MessageConsumer</code>的<code>unregister</code>方法实现注销操作。Vert.x提供了两个版本的<code>unregister</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span></span>;</div></pre></td></tr></table></figure>
<p>其中第二个版本的<code>unregister</code>方法会在注销操作完成时调用传入的<code>completionHandler</code>。比如在cluster范围内注销consumer需要消耗一定的时间在集群内传播，因此第二个版本的方法就会派上用场。我们来看一下其实现，它们最后都是调用了<code>HandlerRegistration</code>类的<code>doUnregister</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler, <span class="keyword">boolean</span> callEndHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (timeoutID != -<span class="number">1</span>) &#123;</div><div class="line">    vertx.cancelTimer(timeoutID);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (endHandler != <span class="keyword">null</span> &amp;&amp; callEndHandler) &#123;</div><div class="line">    Handler&lt;Void&gt; theEndHandler = endHandler;</div><div class="line">    Handler&lt;AsyncResult&lt;Void&gt;&gt; handler = completionHandler;</div><div class="line">    completionHandler = ar -&gt; &#123;</div><div class="line">      theEndHandler.handle(<span class="keyword">null</span>);</div><div class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">        handler.handle(ar);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (registered) &#123;</div><div class="line">    registered = <span class="keyword">false</span>;</div><div class="line">    eventBus.removeRegistration(address, <span class="keyword">this</span>, completionHandler);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    callCompletionHandlerAsync(completionHandler);</div><div class="line">  &#125;</div><div class="line">  registered = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果设定了超时定时器(<code>timeoutID</code>合法)，那么Vert.x会首先将定时器关闭。接着Vert.x会判断是否需要调用<code>endHandler</code>。那么<code>endHandler</code>又是什么呢？前面我们提到过<code>MessageConsumer</code>接口继承了<code>ReadStream</code>接口，而<code>ReadStream</code>接口定义了一个<code>endHandler</code>方法用于绑定一个<code>endHandler</code>，当stream中的数据读取完毕时会调用。而在Event Bus中，消息源源不断地从一处发送至另一处，因此只有在某个consumer<br>被unregister的时候，其对应的stream才可以叫“读取完毕”，因此Vert.x选择在<code>doUnregister</code>方法中调用<code>endHandler</code>。</p>
<p>接着Vert.x会判断此consumer是否已注册消息处理函数<code>Handler</code>（通过检查<code>registered</code>标志位），若已注册则将对应的<code>Handler</code>从Event Bus中的<code>handlerMap</code>中移除并将<code>registered</code>设为<code>false</code>；若还未注册<code>Handler</code>且提供了注销结束时的回调<code>completionHandler</code>(注意不是<code>HandlerRegistration</code>类的成员变量<code>completionHandler</code>，而是之前第二个版本的<code>unregister</code>中传入的<code>Handler</code>，用同样的名字很容易混。。。)，则通过<code>callCompletionHandlerAsync</code>方法调用回调函数。</p>
<p>从Event Bus中移除<code>Handler</code>的逻辑位于<code>EventBusImpl</code>类的<code>removeRegistration</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; handler, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">  HandlerHolder holder = removeLocalRegistration(address, handler);</div><div class="line">  removeRegistration(holder, address, completionHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeRegistration</span><span class="params">(HandlerHolder handlerHolder, String address,</span></span></div><div class="line">                                      Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler) &#123;</div><div class="line">  callCompletionHandlerAsync(completionHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">HandlerHolder <span class="title">removeLocalRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; handler)</span> </span>&#123;</div><div class="line">  Handlers handlers = handlerMap.get(address);</div><div class="line">  HandlerHolder lastHolder = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (handlers) &#123;</div><div class="line">      <span class="keyword">int</span> size = handlers.list.size();</div><div class="line">      <span class="comment">// Requires a list traversal. This is tricky to optimise since we can't use a set since</span></div><div class="line">      <span class="comment">// we need fast ordered traversal for the round robin</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        HandlerHolder holder = handlers.list.get(i);</div><div class="line">        <span class="keyword">if</span> (holder.getHandler() == handler) &#123;</div><div class="line">          handlers.list.remove(i);</div><div class="line">          holder.setRemoved();</div><div class="line">          <span class="keyword">if</span> (handlers.list.isEmpty()) &#123;</div><div class="line">            handlerMap.remove(address);</div><div class="line">            lastHolder = holder;</div><div class="line">          &#125;</div><div class="line">          holder.getContext().removeCloseHook(<span class="keyword">new</span> HandlerEntry&lt;&gt;(address, holder.getHandler()));</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> lastHolder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其真正的<code>unregister</code>逻辑位于<code>removeLocalRegistration</code>方法中。首先需要从<code>handlerMap</code>中获取地址对应的<code>Handlers</code>实例<code>handlers</code>，如果<code>handlers</code>不为空，为了防止并发问题，Vert.x需要对其加锁后再进行操作。Vert.x需要遍历<code>handlers</code>中的列表，遇到与传入的<code>HandlerRegistration</code>相匹配的<code>HandlerHolder</code>就将其从列表中移除，然后调用对应<code>holder</code>的<code>setRemoved</code>方法标记其为已注销并记录Metrics数据（<code>handlerUnregistered</code>）。如果移除此<code>HandlerHolder</code>后<code>handlers</code>没有任何注册的<code>Handler</code>了，就将该地址对应的<code>Handlers</code>实例从<code>handlerMap</code>中移除并保存刚刚移除的<code>HandlerHolder</code>。另外，由于已经将此consumer注销，在undeploy verticle的时候不需要再进行unregister，因此这里还要将之前注册到context的hook移除。</p>
<p>调用完<code>removeLocalRegistration</code>方法以后，Vert.x会调用另一个版本的<code>removeRegistration</code>方法，调用<code>completionHandler</code>（用户在第二个版本的<code>unregister</code>方法中传入的处理函数）对应的逻辑，其它的参数都没什么用。。。</p>
<p>这就是<code>MessageConsumer</code>注销的逻辑实现。下面就到了本文的另一重头戏了 —— 发送消息相关的函数<code>send</code>和<code>publish</code>。</p>
<h1 id="send_&amp;_publish">send &amp; publish</h1><p><code>send</code>和<code>publish</code>的逻辑相近，只不过一个是发送至目标地址的某一消费者，一个是发布至目标地址的所有消费者。Vert.x使用一个标志位<code>send</code>来代表是否为点对点发送模式。</p>
<p>几个版本的<code>send</code>和<code>publish</code>最终都归结于生成消息对象然后调用<code>sendOrPubInternal</code>方法执行逻辑，只不过<code>send</code>标志位不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">EventBus <span class="title">send</span><span class="params">(String address, Object message, DeliveryOptions options, Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</div><div class="line">  sendOrPubInternal(createMessage(<span class="keyword">true</span>, address, options.getHeaders(), message, options.getCodecName()), options, replyHandler);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">publish</span><span class="params">(String address, Object message, DeliveryOptions options)</span> </span>&#123;</div><div class="line">  sendOrPubInternal(createMessage(<span class="keyword">false</span>, address, options.getHeaders(), message, options.getCodecName()), options, <span class="keyword">null</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个方法中都是通过<code>createMessage</code>方法来生成对应的消息对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> MessageImpl <span class="title">createMessage</span><span class="params">(<span class="keyword">boolean</span> send, String address, MultiMap headers, Object body, String codecName)</span> </span>&#123;</div><div class="line">  Objects.requireNonNull(address, <span class="string">"no null address accepted"</span>);</div><div class="line">  MessageCodec codec = codecManager.lookupCodec(body, codecName);</div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  MessageImpl msg = <span class="keyword">new</span> MessageImpl(address, <span class="keyword">null</span>, headers, body, codec, send, <span class="keyword">this</span>);</div><div class="line">  <span class="keyword">return</span> msg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createMessage</code>方法接受5个参数：<code>send</code>即上面提到的标志位，<code>address</code>为发送目标地址，<code>headers</code>为设置的header，<code>body</code>代表发送的对象，<code>codecName</code>代表对应的Codec（消息编码解码器）名称。<code>createMessage</code>方法首先会确保地址不为空，然后通过<code>codecManager</code>来获取对应的<code>MessageCodec</code>。如果没有提供Codec(即<code>codecName</code>为空)，那么<code>codecManager</code>会根据发送对象<code>body</code>的类型来提供内置的Codec实现（具体逻辑请见<a href="https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/eventbus/impl/CodecManager.java#L47" target="_blank" rel="external">此处</a>）。准备好<code>MessageCodec</code>后，<code>createMessage</code>方法就会创建一个<code>MessageImpl</code>实例并且返回。</p>
<p>这里我们还需要了解一下<code>MessageImpl</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageImpl</span><span class="params">(String address, String replyAddress, MultiMap headers, U sentBody,</span></span></div><div class="line">                   MessageCodec&lt;U, V&gt; messageCodec,</div><div class="line">                   <span class="keyword">boolean</span> send, EventBusImpl bus) &#123;</div><div class="line">  <span class="keyword">this</span>.messageCodec = messageCodec; <span class="comment">// Codec</span></div><div class="line">  <span class="keyword">this</span>.address = address; <span class="comment">// 发送目标地址</span></div><div class="line">  <span class="keyword">this</span>.replyAddress = replyAddress; <span class="comment">// 回复地址</span></div><div class="line">  <span class="keyword">this</span>.headers = headers; <span class="comment">// header</span></div><div class="line">  <span class="keyword">this</span>.sentBody = sentBody; <span class="comment">// 发送的对象</span></div><div class="line">  <span class="keyword">this</span>.send = send; <span class="comment">// 是否为点对点模式</span></div><div class="line">  <span class="keyword">this</span>.bus = bus; <span class="comment">// 相关的Event Bus实例</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createMessage</code>方法并没有设置回复地址<code>replyAddress</code>。如果用户指定了<code>replyHandler</code>的话，后边<code>sendOrPubInternal</code>方法会对此消息实体进行加工，设置<code>replyAddress</code>并生成回复逻辑对应的<code>HandlerRegistration</code>。</p>
<p>我们看一下<code>sendOrPubInternal</code>方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendOrPubInternal</span><span class="params">(MessageImpl message, DeliveryOptions options,</span></span></div><div class="line">                                   Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler) &#123;</div><div class="line">  checkStarted();</div><div class="line">  HandlerRegistration&lt;T&gt; replyHandlerRegistration = createReplyHandlerRegistration(message, options, replyHandler);</div><div class="line">  SendContextImpl&lt;T&gt; sendContext = <span class="keyword">new</span> SendContextImpl&lt;&gt;(message, options, replyHandlerRegistration);</div><div class="line">  sendContext.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它接受三个参数：要发送的消息<code>message</code>，发送配置选项<code>options</code>以及回复处理函数<code>replyHandler</code>。首先<code>sendOrPubInternal</code>方法要检查Event Bus是否已启动，接着如果绑定了回复处理函数，Vert.x就会调用<code>createReplyHandlerRegistration</code>方法给消息实体<code>message</code>包装上回复地址，并且生成对应的reply consumer。接着Vert.x创建了一个包装消息的<code>SendContextImpl</code>实例并调用了其<code>next</code>方法。</p>
<p>我们一步一步来解释。首先是<code>createReplyHandlerRegistration</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">HandlerRegistration&lt;T&gt; <span class="title">createReplyHandlerRegistration</span><span class="params">(MessageImpl message, DeliveryOptions options, Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (replyHandler != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">long</span> timeout = options.getSendTimeout();</div><div class="line">    String replyAddress = generateReplyAddress();</div><div class="line">    message.setReplyAddress(replyAddress);</div><div class="line">    Handler&lt;Message&lt;T&gt;&gt; simpleReplyHandler = convertHandler(replyHandler);</div><div class="line">    HandlerRegistration&lt;T&gt; registration =</div><div class="line">      <span class="keyword">new</span> HandlerRegistration&lt;&gt;(vertx, metrics, <span class="keyword">this</span>, replyAddress, message.address, <span class="keyword">true</span>, replyHandler, timeout);</div><div class="line">    registration.handler(simpleReplyHandler);</div><div class="line">    <span class="keyword">return</span> registration;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createReplyHandlerRegistration</code>方法首先检查传入的<code>replyHandler</code>是否为空（是否绑定了<code>replyHandler</code>，回复处理函数），如果为空则代表不需要处理回复，直接返回<code>null</code>；若<code>replyHandler</code>不为空，<code>createReplyHandlerRegistration</code>方法就会从配置中获取reply的最大超时时长(默认30s)，然后调用<code>generateReplyAddress</code>方法生成对应的回复地址<code>replyAddress</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong replySequence = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">generateReplyAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Long.toString(replySequence.incrementAndGet());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成回复地址的逻辑有点简单。。。。<code>EventBusImpl</code>实例中维护着一个<code>AtomicLong</code>类型的<code>replySequence</code>成员变量代表对应的回复地址。每次生成的时候都会使其自增，然后转化为String。也就是说生成的<code>replyAddress</code>都类似于”1”、”5”这样，而不是我们想象中的直接回复至sender的地址。。。</p>
<p>生成完毕以后，<code>createReplyHandlerRegistration</code>方法会将生成的<code>replyAddress</code>设定到消息对象<code>message</code>中。接着Vert.x会通过<code>convertHandler</code>方法对<code>replyHandler</code>进行包装处理并生成类型简化为<code>Handler&lt;Message&lt;T&gt;&gt;</code>的<code>simpleReplyHandler</code>，它用于绑定至后面创建的reply consumer上。接着Vert.x会创建对应的reply consumer。关于<code>reply</code>操作的实现，我们后边会详细讲述。下面Vert.x就通过<code>handler</code>方法将生成的回复处理函数<code>simpleReplyHandler</code>绑定至创建好的reply consumer中，其底层实现我们之前已经分析过了，这里就不再赘述。最后此方法返回生成的<code>registration</code>，即对应的reply consumer。注意这个reply consumer是<strong>一次性</strong>的，也就是说Vert.x会在其接收到回复或超时的时候自动对其进行注销。</p>
<p>OK，现在回到<code>sendOrPubInternal</code>方法中来。下面Vert.x会创建一个<code>SendContextImpl</code>实例并调用其<code>next</code>方法。<code>SendContextImpl</code>类实现了<code>SendContext</code>接口，它相当于一个消息的封装体，并且可以与Event Bus中的<code>interceptors</code>（拦截器）结合使用。</p>
<p><code>SendContext</code>接口定义了三个方法：</p>
<ul>
<li><code>message</code>: 获取当前<code>SendContext</code>包装的消息实体</li>
<li><code>next</code>: 调用下一个消息拦截器</li>
<li><code>send</code>: 代表消息的发送模式是否为点对点模式</li>
</ul>
<p>在Event Bus中，消息拦截器本质上是一个<code>Handler&lt;SendContext&gt;</code>类型的处理函数。Event Bus内部存储着一个<code>interceptors</code>列表用于存储绑定的消息拦截器。我们可以通过<code>addInterceptor</code>和<code>removeInterceptor</code>方法进行消息拦截器的添加和删除操作。如果要进行链式拦截，则在每个拦截器中都应该调用对应<code>SendContext</code>的<code>next</code>方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eventBus.addInterceptor(sc -&gt; &#123;</div><div class="line">  <span class="comment">// 一些处理逻辑</span></div><div class="line">  sc.next(); <span class="comment">// 调用下一个拦截器</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们来看一下<code>SendContextImpl</code>类中<code>next</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SendContextImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">SendContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> MessageImpl message;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> DeliveryOptions options;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> HandlerRegistration&lt;T&gt; handlerRegistration;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Handler&lt;SendContext&gt;&gt; iter;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SendContextImpl</span><span class="params">(MessageImpl message, DeliveryOptions options, HandlerRegistration&lt;T&gt; handlerRegistration)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.message = message;</div><div class="line">    <span class="keyword">this</span>.options = options;</div><div class="line">    <span class="keyword">this</span>.handlerRegistration = handlerRegistration;</div><div class="line">    <span class="keyword">this</span>.iter = interceptors.iterator();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Message&lt;T&gt; <span class="title">message</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (iter.hasNext()) &#123;</div><div class="line">      Handler&lt;SendContext&gt; handler = iter.next();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        handler.handle(<span class="keyword">this</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        log.error(<span class="string">"Failure in interceptor"</span>, t);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      sendOrPub(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> message.send();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，<code>SendContextImpl</code>类中维护了一个拦截器列表对应的迭代器。每次调用<code>next</code>方法时，如果迭代器中存在拦截器，就将下个拦截器取出并进行相关调用。如果迭代器为空，则代表拦截器都已经调用完毕，Vert.x就会调用<code>EventBusImpl</code>类下的<code>sendOrPub</code>方法进行消息的发送操作。</p>
<p><code>sendOrPub</code>方法仅仅在metrics模块中记录相关数据(<code>messageSent</code>)，最后调用<code>deliverMessageLocally(SendContextImpl&lt;T&gt;)</code>方法执行消息的发送逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">deliverMessageLocally</span><span class="params">(SendContextImpl&lt;T&gt; sendContext)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!deliverMessageLocally(sendContext.message)) &#123;</div><div class="line">    <span class="comment">// no handlers</span></div><div class="line">    metrics.replyFailure(sendContext.message.address, ReplyFailure.NO_HANDLERS);</div><div class="line">    <span class="keyword">if</span> (sendContext.handlerRegistration != <span class="keyword">null</span>) &#123;</div><div class="line">      sendContext.handlerRegistration.sendAsyncResultFailure(ReplyFailure.NO_HANDLERS, <span class="string">"No handlers for address "</span></div><div class="line">                                                             + sendContext.message.address);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面又套了一层。。。它最后其实是调用了<code>deliverMessageLocally(MessageImpl)</code>方法。此方法返回值代表发送消息的目标地址是否注册有<code>MessageConsumer</code>，如果没有(<code>false</code>)则记录错误并调用<code>sendContext</code>中保存的回复处理函数处理错误（如果绑定了<code>replyHandler</code>的话）。</p>
<p><code>deliverMessageLocally(MessageImpl)</code>方法是真正区分<code>send</code>和<code>publish</code>的地方，我们来看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">deliverMessageLocally</span><span class="params">(MessageImpl msg)</span> </span>&#123;</div><div class="line">  msg.setBus(<span class="keyword">this</span>);</div><div class="line">  Handlers handlers = handlerMap.get(msg.address());</div><div class="line">  <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (msg.send()) &#123;</div><div class="line">      <span class="comment">//Choose one</span></div><div class="line">      HandlerHolder holder = handlers.choose();</div><div class="line">      metrics.messageReceived(msg.address(), !msg.send(), isMessageLocal(msg), holder != <span class="keyword">null</span> ? <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">      <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</div><div class="line">        deliverToHandler(msg, holder);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Publish</span></div><div class="line">      metrics.messageReceived(msg.address(), !msg.send(), isMessageLocal(msg), handlers.list.size());</div><div class="line">      <span class="keyword">for</span> (HandlerHolder holder: handlers.list) &#123;</div><div class="line">        deliverToHandler(msg, holder);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    metrics.messageReceived(msg.address(), !msg.send(), isMessageLocal(msg), <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Vert.x需要从<code>handlerMap</code>中获取目标地址对应的处理函数集合<code>handlers</code>。接着，如果<code>handlers</code>不为空的话，Vert.x就会判断消息实体的<code>send</code>标志位。如果<code>send</code>标志位为<code>true</code>则代表以点对点模式发送，Vert.x就会通过<code>handlers</code>的<code>choose</code>方法(之前提到过)，按照轮询算法来获取其中的某一个<code>HandlerHolder</code>。获取到<code>HandlerHolder</code>之后，Vert.x会通过<code>deliverToHandler</code>方法将消息分发至<code>HandlerHolder</code>中进行处理；如果<code>send</code>标志位为<code>false</code>则代表向所有消费者发布消息，Vert.x就会对<code>handlers</code>中的每一个<code>HandlerHolder</code>依次调用<code>deliverToHandler</code>方法，以便将消息分发至所有注册到此地址的<code>Handler</code>中进行处理。</p>
<p>消息处理的真正逻辑就在<code>deliverToHandler</code>方法中。我们来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">deliverToHandler</span><span class="params">(MessageImpl msg, HandlerHolder&lt;T&gt; holder)</span> </span>&#123;</div><div class="line">  <span class="comment">// Each handler gets a fresh copy</span></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  Message&lt;T&gt; copied = msg.copyBeforeReceive();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (metrics.isEnabled()) &#123;</div><div class="line">    metrics.scheduleMessage(holder.getHandler().getMetric(), msg.isLocal());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  holder.getContext().runOnContext((v) -&gt; &#123;</div><div class="line">    <span class="comment">// Need to check handler is still there - the handler might have been removed after the message were sent but</span></div><div class="line">    <span class="comment">// before it was received</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!holder.isRemoved()) &#123;</div><div class="line">        holder.getHandler().handle(copied);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="keyword">if</span> (holder.isReplyHandler()) &#123;</div><div class="line">        holder.getHandler().unregister();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先<code>deliverToHandler</code>方法会复制一份要发送的消息，然后<code>deliverToHandler</code>方法会调用<code>metrics</code>的<code>scheduleMessage</code>方法记录对应的Metrics信息（计划对消息进行处理。此函数修复了<a href="https://github.com/eclipse/vert.x/issues/1480" target="_blank" rel="external">Issue 1480</a>）。接着<code>deliverToHandler</code>方法会从传入的<code>HandlerHolder</code>中获取对应的Vert.x Context，然后调用<code>runOnContext</code>方法以便可以让消息处理逻辑在Vert.x Context中执行。为防止对应的handler在处理之前被移除，这里还需要检查一下<code>holder</code>的<code>isRemoved</code>属性。如果没有移除，那么就从<code>holder</code>中获取对应的<code>handler</code>并调用其<code>handle</code>方法执行消息的处理逻辑。注意这里获取的<code>handler</code>实际上是一个<code>HandlerRegistration</code>。前面提到过<code>HandlerRegistration</code>类同时实现了<code>MessageConsumer</code>接口和<code>Handler</code>接口，因此它兼具这两个接口所期望的功能。另外，之前我们提到过Vert.x会自动注销接收过回复的reply consumer，其逻辑就在这个finally块中。Vert.x会检查<code>holder</code>中的<code>handler</code>是否为reply handler（reply consumer)，如果是的话就调用其<code>unregister</code>方法将其注销，来确保reply consumer为一次性的。</p>
<p>之前我们提到过<code>MessageConsumer</code>继承了<code>ReadStream</code>接口，因此<code>HandlerRegistration</code>需要实现flow control(back-pressure)的相关逻辑。那么如何实现呢？我们看到,<code>HandlerRegistration</code>类中有一个<code>paused</code>标志位代表是否还继续处理消息。<code>ReadStream</code>接口中定义了两个函数用于控制stream的通断：当处理速度小于读取速度(发生拥塞)的时候我们可以通过<code>pause</code>方法暂停消息的传递，将积压的消息暂存于内部的消息队列（缓冲区）<code>pending</code>中；当相对速度正常的时候，我们可以通过<code>resume</code>方法恢复消息的传递和处理。</p>
<p>我们看一下<code>HandlerRegistration</code>中<code>handle</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;T&gt; message)</span> </span>&#123;</div><div class="line">  Handler&lt;Message&lt;T&gt;&gt; theHandler;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (paused) &#123;</div><div class="line">      <span class="keyword">if</span> (pending.size() &lt; maxBufferedMessages) &#123;</div><div class="line">        pending.add(message);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (discardHandler != <span class="keyword">null</span>) &#123;</div><div class="line">          discardHandler.handle(message);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          log.warn(<span class="string">"Discarding message as more than "</span> + maxBufferedMessages + <span class="string">" buffered in paused consumer"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (pending.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">        pending.add(message);</div><div class="line">        message = pending.poll();</div><div class="line">      &#125;</div><div class="line">      theHandler = handler;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  deliver(theHandler, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然。。。<code>handle</code>方法在处理消息的基础上实现了拥塞控制的功能。为了防止资源争用，需要对自身进行加锁；首先<code>handle</code>方法会判断当前的<code>consumer</code>是否为<code>paused</code>状态，如果为<code>paused</code>状态，<code>handle</code>方法会检查当前缓冲区大小是否已经超过给定的最大缓冲区大小<code>maxBufferedMessages</code>，如果没超过，就将收到的消息push到缓冲区中；如果大于或等于阈值，Vert.x就需要丢弃超出的那部分消息。如果当前的<code>consumer</code>为正常状态，则如果缓冲区不为空，就将收到的消息push到缓冲区中并从缓冲区中pull队列首端的消息，然后调用<code>deliver</code>方法执行真正的消息处理逻辑。注意这里是在锁之外执行<code>deliver</code>方法的，这是为了保证在multithreaded worker context下可以并发传递消息（见<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=473714" target="_blank" rel="external">Bug 473714
</a>）。由于multithreaded worker context允许在不同线程并发执行逻辑（见<a href="http://vertx.io/docs/vertx-core/java/#_multi_threaded_worker_verticles" target="_blank" rel="external">官方文档</a>），如果将<code>deliver</code>方法置于<code>synchronized</code>块之内，其他线程必须等待当前锁被释放才能进行消息的传递逻辑，因而不能做到“delivery concurrently”。</p>
<p><code>deliver</code>方法是真正执行“消息处理”逻辑的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Handler&lt;Message&lt;T&gt;&gt; theHandler, Message&lt;T&gt; message)</span> </span>&#123;</div><div class="line">  checkNextTick();</div><div class="line">  <span class="keyword">boolean</span> local = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">if</span> (message <span class="keyword">instanceof</span> ClusteredMessage) &#123;</div><div class="line">    <span class="comment">// A bit hacky</span></div><div class="line">    ClusteredMessage cmsg = (ClusteredMessage)message;</div><div class="line">    <span class="keyword">if</span> (cmsg.isFromWire()) &#123;</div><div class="line">      local = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  String creditsAddress = message.headers().get(MessageProducerImpl.CREDIT_ADDRESS_HEADER_NAME);</div><div class="line">  <span class="keyword">if</span> (creditsAddress != <span class="keyword">null</span>) &#123;</div><div class="line">    eventBus.send(creditsAddress, <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    metrics.beginHandleMessage(metric, local);</div><div class="line">    theHandler.handle(message);</div><div class="line">    metrics.endHandleMessage(metric, <span class="keyword">null</span>);</div><div class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    log.error(<span class="string">"Failed to handleMessage"</span>, e);</div><div class="line">    metrics.endHandleMessage(metric, e);</div><div class="line">    <span class="keyword">throw</span> e;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Vert.x会调用<code>checkNextTick</code>方法来检查消息队列（缓冲区）中是否存在更多的消息等待被处理，如果有的话就取出队列首端的消息并调用<code>deliver</code>方法将其传递给<code>handler</code>进行处理。这里仍需要注意并发问题，相关实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkNextTick</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!pending.isEmpty()) &#123;</div><div class="line">    handlerContext.runOnContext(v -&gt; &#123;</div><div class="line">      Message&lt;T&gt; message;</div><div class="line">      Handler&lt;Message&lt;T&gt;&gt; theHandler;</div><div class="line">      <span class="keyword">synchronized</span> (HandlerRegistration.<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (paused || (message = pending.poll()) == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        theHandler = handler;</div><div class="line">      &#125;</div><div class="line">      deliver(theHandler, message);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查完消息队列以后，Vert.x会接着根据<code>message</code>判断消息是否仅在本地进行处理并给<code>local</code>标志位赋值，<code>local</code>标志位将在记录Metrics数据时用到。</p>
<p>接下来我们看到Vert.x从消息的<code>headers</code>中获取了一个地址<code>creditsAddress</code>，如果<code>creditsAddress</code>存在就向此地址发送一条消息，body为<code>1</code>。那么这个<code>creditsAddress</code>又是啥呢？其实，它与flow control有关，我们会在下面详细分析。发送完<code>credit</code>消息以后，接下来就到了调用<code>handler</code>处理消息的时刻了。在处理消息之前需要调用<code>metrics</code>的<code>beginHandleMessage</code>方法记录消息开始处理的metrics数据，在处理完消息以后需要调用<code>endHandleMessage</code>方法记录消息处理结束的metrics数据。</p>
<p>嗯。。。到此为止，消息的发送和处理过程就已经一目了然了。下面我们讲一讲之前代码中出现的<code>creditsAddress</code>到底是啥玩意～</p>
<h1 id="MessageProducer">MessageProducer</h1><p>之前我们提到过，Vert.x定义了两个接口作为 <strong>flow control aware object</strong> 的规范：<code>WriteStream</code>以及<code>ReadStream</code>。对于<code>ReadStream</code>我们已经不再陌生了，<code>MessageConsumer</code>就继承了它；那么大家应该可以想象到，有<code>MessageConsumer</code>就必有<code>MessageProducer</code>。不错，Vert.x中的<code>MessageProducer</code>接口对应某个<code>address</code>上的消息生产者，同时它继承了<code>WriteStream</code>接口，因此<code>MessageProducer</code>的实现类<code>MessageProducerImpl</code>同样具有flow control的能力。我们可以把<code>MessageProducer</code>看做是一个具有flow control功能的增强版的<code>EventBus</code>。我们可以通过<code>EventBus</code>接口的<code>publisher</code>方法创建一个<code>MessageProducer</code>。</p>
<p>对<code>MessageProducer</code>有了初步了解之后，我们就可以解释前面<code>deliver</code>方法中的<code>creditsAddress</code>了。<code>MessageProducer</code>接口的实现类 —— <code>MessageProducerImpl</code>类的流量控制功能是基于<code>credit</code>的，其内部会维护一个<code>credit</code>值代表“发送消息的能力”，其默认值等于<code>DEFAULT_WRITE_QUEUE_MAX_SIZE</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize = DEFAULT_WRITE_QUEUE_MAX_SIZE;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> credits = DEFAULT_WRITE_QUEUE_MAX_SIZE;</div></pre></td></tr></table></figure>
<p>在采用点对点模式发送消息的时候，<code>MessageProducer</code>底层会调用<code>doSend</code>方法进行消息的发送。发送依然利用Event Bus的<code>send</code>方法，只不过<code>doSend</code>方法中添加了flow control的相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> &lt;R&gt; <span class="function"><span class="keyword">void</span> <span class="title">doSend</span><span class="params">(T data, Handler&lt;AsyncResult&lt;Message&lt;R&gt;&gt;&gt; replyHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (credits &gt; <span class="number">0</span>) &#123;</div><div class="line">    credits--;</div><div class="line">    <span class="keyword">if</span> (replyHandler == <span class="keyword">null</span>) &#123;</div><div class="line">      bus.send(address, data, options);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      bus.send(address, data, options, replyHandler);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    pending.add(data);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与<code>MessageConsumer</code>类似，<code>MessageProducer</code>内部同样保存着一个消息队列（缓冲区）用于暂存堆积的消息。当<code>credits</code>大于<strong>0</strong>的时候代表可以发送消息（没有出现拥塞），Vert.x就会调用Event Bus的<code>send</code>方法进行消息的发送，同时<code>credits</code>要减1；如果<code>credits</code>小于等于0，则代表此时消息发送的速度太快，出现了拥塞，需要暂缓发送，因此将要发送的对象暂存于缓冲区中。大家可能会问，<code>credits</code>值不断减小，那么恢复消息发送能力（增大<code>credits</code>）的逻辑在哪呢？这就要提到<code>creditsAddress</code>了。我们看一下<code>MessageProducerImpl</code>类的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageProducerImpl</span><span class="params">(Vertx vertx, String address, <span class="keyword">boolean</span> send, DeliveryOptions options)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.vertx = vertx;</div><div class="line">  <span class="keyword">this</span>.bus = vertx.eventBus();</div><div class="line">  <span class="keyword">this</span>.address = address;</div><div class="line">  <span class="keyword">this</span>.send = send;</div><div class="line">  <span class="keyword">this</span>.options = options;</div><div class="line">  <span class="keyword">if</span> (send) &#123;</div><div class="line">    String creditAddress = UUID.randomUUID().toString() + <span class="string">"-credit"</span>;</div><div class="line">    creditConsumer = bus.consumer(creditAddress, msg -&gt; &#123;</div><div class="line">      doReceiveCredit(msg.body());</div><div class="line">    &#125;);</div><div class="line">    options.addHeader(CREDIT_ADDRESS_HEADER_NAME, creditAddress);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    creditConsumer = <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MessageProducerImpl</code>的构造函数中生成了一个<code>creditAddress</code>，然后给该地址绑定了一个<code>Handler</code>，当收到消息时调用<code>doReceiveCredit</code>方法执行解除拥塞，恢复消息发送的逻辑。<code>MessageProducerImpl</code>会将此<code>MessageConsumer</code>保存，以便在关闭消息生产者流的时候将其注销。接着构造函数会往<code>options</code>的<code>headers</code>中添加一条记录，保存对应的<code>creditAddress</code>，这也就是上面我们在<code>deliver</code>函数中获取的<code>creditAddress</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 位于HandlerRegistration类的deliver函数中</span></div><div class="line">String creditsAddress = message.headers().get(MessageProducerImpl.CREDIT_ADDRESS_HEADER_NAME);</div><div class="line"><span class="keyword">if</span> (creditsAddress != <span class="keyword">null</span>) &#123;</div><div class="line">  eventBus.send(creditsAddress, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，发送消息到<code>creditsAddress</code>的逻辑也就好理解了。由于<code>deliver</code>函数的逻辑就是处理消息，因此这里向<code>creditsAddress</code>发送一个 <strong>1</strong> 其实就是将对应的<code>credits</code>值加1。恢复消息发送的逻辑位于<code>MessageProducerImpl</code>类的<code>doReceiveCredit</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doReceiveCredit</span><span class="params">(<span class="keyword">int</span> credit)</span> </span>&#123;</div><div class="line">  credits += credit;</div><div class="line">  <span class="keyword">while</span> (credits &gt; <span class="number">0</span>) &#123;</div><div class="line">    T data = pending.poll();</div><div class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      credits--;</div><div class="line">      bus.send(address, data, options);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">final</span> Handler&lt;Void&gt; theDrainHandler = drainHandler;</div><div class="line">  <span class="keyword">if</span> (theDrainHandler != <span class="keyword">null</span> &amp;&amp; credits &gt;= maxSize / <span class="number">2</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.drainHandler = <span class="keyword">null</span>;</div><div class="line">    vertx.runOnContext(v -&gt; theDrainHandler.handle(<span class="keyword">null</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑一目了然。首先给<code>credits</code>加上发送过来的值（正常情况下为1），然后恢复发送能力，将缓冲区的数据依次取出、发送然后减小<code>credits</code>。同时如果<code>MessageProducer</code>绑定了<code>drainHandler</code>(消息流不拥塞的时候调用的逻辑，详见<a href="http://vertx.io/docs/vertx-core/java/#_writestream" target="_blank" rel="external">官方文档</a>)，并且<code>MessageProducer</code>发送的消息不再拥塞（<code>credits &gt;= maxSize / 2</code>），那么就在Vert.x Context中执行<code>drainHandler</code>中的逻辑。</p>
<p>怎么样，体会到Vert.x中flow control的强大之处了吧！官方文档中<code>MessageProducer</code>的篇幅几乎没有，只在介绍<code>WriteStream</code>的时候提了提，因此这部分也可以作为<code>MessageProducer</code>的参考。</p>
<h1 id="reply">reply</h1><p>最后就是消息的回复逻辑 —— <code>reply</code>方法了。<code>reply</code>方法的实现位于<code>MessageImpl</code>类中，最终调用的是<code>reply(Object, DeliveryOptions, Handler&lt;AsyncResult&lt;Message&lt;R&gt;&gt;&gt;)</code>这个版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function"><span class="keyword">void</span> <span class="title">reply</span><span class="params">(Object message, DeliveryOptions options, Handler&lt;AsyncResult&lt;Message&lt;R&gt;&gt;&gt; replyHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (replyAddress != <span class="keyword">null</span>) &#123;</div><div class="line">    sendReply(bus.createMessage(<span class="keyword">true</span>, replyAddress, options.getHeaders(), message, options.getCodecName()), options, replyHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里<code>reply</code>方法同样调用<code>EventBus</code>的<code>createMessage</code>方法创建要回复的消息实体，传入的<code>replyAddress</code>即为之前讲过的生成的非常简单的回复地址。然后再将消息实体、配置以及对应的<code>replyHandler</code>（如果有的话）传入<code>sendReply</code>方法进行消息的回复。最后其实是调用了Event Bus中的四个参数的<code>sendReply</code>方法，它的逻辑与之前讲过的<code>sendOrPubInternal</code>非常相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendReply</span><span class="params">(MessageImpl replyMessage, MessageImpl replierMessage, DeliveryOptions options,</span></span></div><div class="line">                             Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler) &#123;</div><div class="line">  <span class="keyword">if</span> (replyMessage.address() == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"address not specified"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    HandlerRegistration&lt;T&gt; replyHandlerRegistration = createReplyHandlerRegistration(replyMessage, options, replyHandler);</div><div class="line">    <span class="keyword">new</span> ReplySendContextImpl&lt;&gt;(replyMessage, options, replyHandlerRegistration, replierMessage).next();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数中<code>replyMessage</code>代表回复消息实体，<code>replierMessage</code>则代表回复者自身的消息实体(sender)。</p>
<p>如果地址为空则抛出异常；如果地址不为空，则先调用<code>createReplyHandlerRegistration</code>方法创建对应的<code>replyHandlerRegistration</code>。<code>createReplyHandlerRegistration</code>方法的实现之前已经讲过了。注意这里的<code>createReplyHandlerRegistration</code>其实对应的是此replier的回复，因为Vert.x中的 <strong>Request-Response</strong> 消息模型不限制相互回复（通信）的次数。当然如果没有指定此replier的回复的<code>replyHandler</code>，那么此处的<code>replyHandlerRegistration</code>就为空。最后<code>sendReply</code>方法会创建一个<code>ReplySendContextImpl</code>并调用其<code>next</code>方法。</p>
<p><code>ReplySendContextImpl</code>类同样是<code>SendContext</code>接口的一个实现（继承了<code>SendContextImpl</code>类）。<code>ReplySendContextImpl</code>比起其父类就多保存了一个<code>replierMessage</code>。<code>next</code>方法的逻辑与父类逻辑非常相似，只不过将回复的逻辑替换成了另一个版本的<code>sendReply</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (iter.hasNext()) &#123;</div><div class="line">    Handler&lt;SendContext&gt; handler = iter.next();</div><div class="line">    handler.handle(<span class="keyword">this</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    sendReply(<span class="keyword">this</span>, replierMessage);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而。。。<code>sendReply</code>方法并没有用到传入的<code>replierMessage</code>，所以这里最终还是调用了<code>sendOrPub</code>方法（尼玛，封装的<code>ReplySendContextImpl</code>貌似并没有什么卵用，可能为以后的扩展考虑？）。。。之后的逻辑我们都已经分析过了。</p>
<p>这里再强调一点。当我们发送消息同时指定<code>replyHandler</code>的时候，其内部为reply创建的reply consumer(类型为<code>HandlerRegistration</code>)指定了<code>timeout</code>。这个定时器从<code>HandlerRegistration</code>创建的时候就开始计时了。我们回顾一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (timeout != -<span class="number">1</span>) &#123;</div><div class="line">  timeoutID = vertx.setTimer(timeout, tid -&gt; &#123;</div><div class="line">    metrics.replyFailure(address, ReplyFailure.TIMEOUT);</div><div class="line">    sendAsyncResultFailure(ReplyFailure.TIMEOUT, <span class="string">"Timed out after waiting "</span> + timeout + <span class="string">"(ms) for a reply. address: "</span> + address);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计时器会在超时的时候记录错误并强制注销当前consumer。由于reply consumer是<strong>一次性的</strong>，当收到reply的时候，Vert.x会自动对reply consumer调用<code>unregister</code>方法对其进行注销（实现位于<code>EventBusImpl#deliverToHandler</code>方法中），而在注销逻辑中会关闭定时器（参见前面对<code>doUnregister</code>方法的解析）；如果超时，那么计时器就会触发，Vert.x会调用<code>sendAsyncResultFailure</code>方法注销当前reply consumer并处理错误。</p>
<h1 id="synchronized的性能问题">synchronized的性能问题</h1><p>大家可能看到为了防止race condition，Vert.x底层大量使用了<code>synchronized</code>关键字（重量级锁）。这会不会影响性能呢？其实，如果开发者遵循Vert.x的线程模型和开发规范（使用Verticle）的话，有些地方的<code>synchronized</code>对应的锁会被优化为 <strong>偏向锁</strong> 或 <strong>轻量级锁</strong>（因为通常都是同一个Event Loop线程获取对应的锁），这样性能总体开销不会太大。当然如果使用Multi-threaded worker verticles就要格外关注性能问题了。。。</p>
<h1 id="总结">总结</h1><p>我们来简略地总结一下Event Bus的工作原理。当我们调用<code>consumer</code>绑定一个<code>MessageConsumer</code>时，Vert.x会将它保存至Event Bus实例内部的Map中；当我们通过<code>send</code>或<code>publish</code>向对应的地址发送消息的时候，Vert.x会遍历Event Bus中存储consumer的Map，获取与地址相对应的consumer集合，然后根据相应的策略传递并处理消息(<code>send</code>通过轮询策略获取任意一个consumer并将消息传递至consumer中，<code>publish</code>则会将消息传递至所有注册到对应地址的consumer中)。同时，<code>MessageConsumer</code>和<code>MessageProducer</code>这两个接口的实现都具有flow control功能，因此它们也可以用在<code>Pump</code>中。</p>
<p>Event Bus是Vert.x中最为重要的一部分之一，探索Event Bus的源码可以加深我们对Event Bus工作原理的理解。作为开发者，只会使用框架是不够的，能够理解内部的实现原理和精华，并对其进行改进才是更为重要的。本篇文章分析的是Local模式下的Event Bus，下篇文章我们将来探索一下生产环境中更常用的 <strong>Clustered Event Bus</strong> 的实现原理，敬请期待！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2017 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30 <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 7;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>