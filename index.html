<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>「千载弦歌，芳华如梦」 - sczyh30&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--<meta name="keywords" content="sczyh30, blog"/>-->
  <meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/index.html">
<meta property="og:site_name" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">
  
    <link rel="alternative" href="/atom.xml" title="「千载弦歌，芳华如梦」 - sczyh30&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/AIO/" style="font-size: 10px;">AIO</a> <a href="/tags/AMQP/" style="font-size: 10px;">AMQP</a> <a href="/tags/APT/" style="font-size: 10px;">APT</a> <a href="/tags/Akka-Actor/" style="font-size: 10px;">Akka Actor</a> <a href="/tags/Algorithm/" style="font-size: 13px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 16px;">C++</a> <a href="/tags/C-11/" style="font-size: 10px;">C++ 11</a> <a href="/tags/CE3/" style="font-size: 10px;">CE3</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Category-Theory/" style="font-size: 10px;">Category Theory</a> <a href="/tags/Chemistry/" style="font-size: 11px;">Chemistry</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Docker/" style="font-size: 11px;">Docker</a> <a href="/tags/Engine/" style="font-size: 10px;">Engine</a> <a href="/tags/Euterpea/" style="font-size: 10px;">Euterpea</a> <a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/FRP/" style="font-size: 10px;">FRP</a> <a href="/tags/Functional-Programming/" style="font-size: 18px;">Functional Programming</a> <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/GC/" style="font-size: 13px;">GC</a> <a href="/tags/GDB/" style="font-size: 10px;">GDB</a> <a href="/tags/Game/" style="font-size: 11px;">Game</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/Haskell/" style="font-size: 14px;">Haskell</a> <a href="/tags/HotSpot/" style="font-size: 12px;">HotSpot</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 19px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Klass-oop/" style="font-size: 10px;">Klass-oop</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/MIDI/" style="font-size: 10px;">MIDI</a> <a href="/tags/Mathematical-Logic/" style="font-size: 10px;">Mathematical Logic</a> <a href="/tags/Metaspace/" style="font-size: 10px;">Metaspace</a> <a href="/tags/Netflix-Hystrix/" style="font-size: 10px;">Netflix Hystrix</a> <a href="/tags/Network/" style="font-size: 16px;">Network</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Object-Model/" style="font-size: 12px;">Object Model</a> <a href="/tags/Play-Framework/" style="font-size: 11px;">Play Framework</a> <a href="/tags/Quorum/" style="font-size: 10px;">Quorum</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Reflection/" style="font-size: 11px;">Reflection</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/STL/" style="font-size: 11px;">STL</a> <a href="/tags/Scala/" style="font-size: 19px;">Scala</a> <a href="/tags/Slick/" style="font-size: 11px;">Slick</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Struct/" style="font-size: 10px;">Struct</a> <a href="/tags/Summary/" style="font-size: 12px;">Summary</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/Type-Lambda/" style="font-size: 10px;">Type Lambda</a> <a href="/tags/Type-System/" style="font-size: 10px;">Type System</a> <a href="/tags/Type-Theory/" style="font-size: 12px;">Type Theory</a> <a href="/tags/UE4/" style="font-size: 10px;">UE4</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/Vert-x/" style="font-size: 19px;">Vert.x</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Web/" style="font-size: 12px;">Web</a> <a href="/tags/Web开发/" style="font-size: 12px;">Web开发</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/functional/" style="font-size: 10px;">functional</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/事务/" style="font-size: 10px;">事务</a> <a href="/tags/云服务/" style="font-size: 12px;">云服务</a> <a href="/tags/内存区域/" style="font-size: 10px;">内存区域</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/分布式系统/" style="font-size: 12px;">分布式系统</a> <a href="/tags/前端/" style="font-size: 12px;">前端</a> <a href="/tags/基础/" style="font-size: 10px;">基础</a> <a href="/tags/多线程/" style="font-size: 11px;">多线程</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/开发/" style="font-size: 17px;">开发</a> <a href="/tags/异步/" style="font-size: 13px;">异步</a> <a href="/tags/异步编程/" style="font-size: 18px;">异步编程</a> <a href="/tags/微服务/" style="font-size: 13px;">微服务</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 11px;">数据库</a> <a href="/tags/架构/" style="font-size: 11px;">架构</a> <a href="/tags/消息系统/" style="font-size: 10px;">消息系统</a> <a href="/tags/源码分析/" style="font-size: 14px;">源码分析</a> <a href="/tags/生活/" style="font-size: 10px;">生活</a> <a href="/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Fighting</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-vertx-advanced-demystifying-thread-model" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-demystifying-thread-model/" class="article-date">
      <time datetime="2016-09-24T16:00:00.000Z" itemprop="datePublished">2016-09-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-demystifying-thread-model/">Vert.x 技术内幕 | 解道Vert.x线程模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="线程模型概述">线程模型概述</h1><p>Vert.x的线程模型设计的非常巧妙。总的来说，Vert.x中主要有两种线程：<strong>Event Loop线程</strong> 和 <strong>Worker线程</strong>。其中，Event Loop线程结合了Netty的<code>EventLoop</code>，用于处理事件。每一个<code>EventLoop</code>都与唯一的线程相绑定，这个线程就叫Event Loop线程。Event Loop线程不能被阻塞，否则事件将无法被处理。</p>
<p>Worker线程用于执行阻塞任务，这样既可以执行阻塞任务而又不阻塞Event Loop线程。</p>
<p>如果像Node.js一样只有单个Event Loop的话就不能充分利用多核CPU的性能了。为了充分利用多核CPU的性能，Vert.x中提供了一组Event Loop线程。每个Event Loop线程都可以处理事件。为了保证线程安全，防止资源争用，Vert.x保证了某一个<code>Handler</code>总是被同一个Event Loop线程执行，这样不仅可以保证线程安全，而且还可以在底层对锁进行优化提升性能。所以，只要开发者遵循Vert.x的线程模型，开发者就不需要再担心线程安全的问题，这是非常方便的。</p>
<p>本篇文章将底层的角度来解析Vert.x的线程模型。对应的Vert.x版本为<strong>3.3.3</strong>。</p>
<h1 id="Event_Loop线程">Event Loop线程</h1><p>首先回顾一下Event Loop线程，它会不断地轮询获取事件，并将获取到的事件分发到对应的事件处理器中进行处理：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertx-event-loop-xx.png" alt="Vert.x Event Loop"></p>
<p>Vert.x线程模型中最重要的一点就是：<strong>永远不要阻塞Event Loop线程</strong>。因为一旦处理事件的线程被阻塞了，事件就会一直积压着不能被处理，整个应用也就不能正常工作了。</p>
<p>Vert.x中内置一种用于检测Event Loop是否阻塞的线程：<code>vertx-blocked-thread-checker</code>。一旦Event Loop处理某个事件的时间超过一定阈值（默认为2000ms）就会警告，如果阻塞的时间过长就会抛出异常。Block Checker的实现原理比较简单，底层借助了JUC的<code>TimerTask</code>，定时计算每个Event Loop线程的处理事件消耗的时间，如果超时就进行相应的警告。</p>
<h1 id="Vert-x_Thread">Vert.x Thread</h1><p>Vert.x中的Event Loop线程及Worker线程都用<code>VertxThread</code>类表示，并通过<code>VertxThreadFactory</code>线程工厂来创建。<code>VertxThreadFactory</code>创建Vert.x线程的过程非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">  VertxThread t = <span class="keyword">new</span> VertxThread(runnable, prefix + threadCount.getAndIncrement(), worker, maxExecTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (checker != <span class="keyword">null</span>) &#123;</span><br><span class="line">    checker.registerThread(t);</span><br><span class="line">  &#125;</span><br><span class="line">  addToMap(t);</span><br><span class="line"></span><br><span class="line">  t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了创建<code>VertxThread</code>线程之外，<code>VertxThreadFactory</code>还会将此线程注册至Block Checker线程中以监视线程的阻塞情况，并且将此线程添加至内部的<code>weakMap</code>中。这个<code>weakMap</code>作用只有一个，就是在注销对应的Verticle的时候可以将每个<code>VertxThread</code>中的<code>Context</code>实例清除(unset)。为了保证资源不被一直占用，这里使用了<code>WeakHashMap</code>来存储每一个<code>VertxThread</code>。当里面的<code>VertxThread</code>的引用不被其他实例持有的时候，它就会被标记为可清除的对象，等待GC。</p>
<p>至于<code>VertxThread</code>，它其实就是在普通线程的基础上存储了额外的数据（如对应的Vert.x Context，最大执行时长，当前执行时间，是否为Worker线程等），这里就不多讲了。</p>
<h1 id="Vert-x_Context">Vert.x Context</h1><p>Vert.x底层中一个重要的概念就是<code>Context</code>，每个<code>Context</code>都会绑定着一个Event Loop线程（而一个Event Loop线程可以对应多个<code>Context</code>）。我们可以把<code>Context</code>看作是控制一系列的<code>Handler</code>的执行作用域及顺序的上下文对象。</p>
<p>每当Vert.x底层将事件分发至<code>Handler</code>的时候，Vert.x都会给此<code>Handler</code>钦点一个<code>Context</code>用于处理任务：</p>
<ul>
<li>如果当前线程是Vert.x线程(<code>VertxThread</code>)，那么Vert.x就会复用此线程上绑定的<code>Context</code>；如果没有对应的<code>Context</code>就创建新的</li>
<li>如果当前线程是普通线程，就创建新的<code>Context</code></li>
</ul>
<p>Vert.x中存在三种<code>Context</code>，与之前的线程种类相对应：</p>
<ul>
<li><code>EventLoopContext</code></li>
<li><code>WorkerContext</code></li>
<li><code>MultiThreadedWorkerContext</code></li>
</ul>
<h2 id="Event_loop_context">Event loop context</h2><p>每个Event Loop Context都会对应着唯一的一个<code>EventLoop</code>，即一个Event Loop Context只会在同一个Event Loop线程上执行任务。在创建<code>Context</code>的时候，Vert.x会自动根据轮询策略选择对应的<code>EventLoop</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ContextImpl</span><span class="params">(VertxInternal vertx, WorkerPool internalBlockingPool, WorkerPool workerPool, String deploymentID, JsonObject config,</span><br><span class="line">                        ClassLoader tccl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    EventLoopGroup group = vertx.getEventLoopGroup();</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.eventLoop = group.next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.eventLoop = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在Netty中，<code>EventLoopGroup</code>代表一组<code>EventLoop</code>，而从中获取<code>EventLoop</code>的方法则是<code>next</code>方法。<code>EventLoopGroup</code>中<code>EventLoop</code>的数量由CPU内核数目所确定。Vert.x这里使用了Netty NIO对应的<code>NioEventLoop</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(options.getEventLoopPoolSize(), eventLoopThreadFactory);</span><br><span class="line">eventLoopGroup.setIoRatio(NETTY_IO_RATIO);</span><br></pre></td></tr></table></figure>
<p>对应的轮询算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTowEventExecutorChooser(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，正常情况下Netty会用轮询策略选择<code>EventLoop</code>。特别地，如果<code>EventLoop</code>的个数是2的倍数的话，选择的会快一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTowEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在Embedded模式下测试一下Event Loop线程的分配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread());</span><br><span class="line">Vertx vertx = Vertx.vertx();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> index = i;</span><br><span class="line">  vertx.setTimer(<span class="number">1</span>, t -&gt; &#123;</span><br><span class="line">    System.out.println(index + <span class="string">":"</span> + Thread.currentThread());</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果（不同机器运行顺序、Event Loop线程数可能不同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">0</span>:Thread[vert.x-eventloop-thread-<span class="number">0</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">1</span>:Thread[vert.x-eventloop-thread-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">2</span>:Thread[vert.x-eventloop-thread-<span class="number">2</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">3</span>:Thread[vert.x-eventloop-thread-<span class="number">3</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">5</span>:Thread[vert.x-eventloop-thread-<span class="number">5</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">6</span>:Thread[vert.x-eventloop-thread-<span class="number">6</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">8</span>:Thread[vert.x-eventloop-thread-<span class="number">8</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">7</span>:Thread[vert.x-eventloop-thread-<span class="number">7</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">10</span>:Thread[vert.x-eventloop-thread-<span class="number">10</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">9</span>:Thread[vert.x-eventloop-thread-<span class="number">9</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">4</span>:Thread[vert.x-eventloop-thread-<span class="number">4</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">11</span>:Thread[vert.x-eventloop-thread-<span class="number">11</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">12</span>:Thread[vert.x-eventloop-thread-<span class="number">12</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">13</span>:Thread[vert.x-eventloop-thread-<span class="number">13</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">14</span>:Thread[vert.x-eventloop-thread-<span class="number">14</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">16</span>:Thread[vert.x-eventloop-thread-<span class="number">0</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">17</span>:Thread[vert.x-eventloop-thread-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">15</span>:Thread[vert.x-eventloop-thread-<span class="number">15</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">18</span>:Thread[vert.x-eventloop-thread-<span class="number">2</span>,<span class="number">5</span>,main]</span><br><span class="line"><span class="number">19</span>:Thread[vert.x-eventloop-thread-<span class="number">3</span>,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure>
<p>可以看到尽管每个<code>Context</code>对应唯一的Event Loop线程，而每个Event Loop线程却可能对应多个<code>Context</code>。</p>
<p>Event Loop Context会在对应的<code>EventLoop</code>中执行<code>Handler</code>进行事件的处理（IO事件，非阻塞）。Vert.x会保证同一个<code>Handler</code>会一直在同一个Event Loop线程中执行，这样可以简化线程模型，让开发者在写<code>Handler</code>的时候不需要考虑并发的问题，非常方便。</p>
<p>我们来粗略地看一下<code>Handler</code>是如何在<code>EventLoop</code>上执行的。<code>EventLoopContext</code>中实现了<code>executeAsync</code>方法用于包装<code>Handler</code>中事件处理的逻辑并将其提交至对应的<code>EventLoop</code>中进行执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// No metrics, we are on the event loop.</span></span><br><span class="line">  nettyEventLoop().execute(wrapTask(<span class="keyword">null</span>, task, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里Vert.x使用了<code>wrapTask</code>方法将<code>Handler</code>封装成了一个<code>Runnable</code>用于向<code>EventLoop</code>中提交。代码比较直观，大致就是检查当前线程是否为Vert.x线程，然后记录事件处理开始的时间，给当前的Vert.x线程设置<code>Context</code>，并且调用<code>Handler</code>里面的事件处理方法。具体请参考源码，这里就不贴出来了。</p>
<p>那么把封装好的task提交到<code>EventLoop</code>以后，<code>EventLoop</code>是怎么处理的呢？这就需要更多的Netty相关的知识了。根据Netty的模型，Event Loop线程需要处理IO事件，普通事件（即我们的<code>Handler</code>）以及定时事件（比如Vert.x的<code>setTimer</code>）。Vert.x会提供一个<code>NETTY_IO_RATIO</code>给Netty代表<code>EventLoop</code>处理IO事件时间占用的百分比（默认为50，即IO事件时间占用:非IO事件时间占用=1:1）。当<code>EventLoop</code>启动的时候，它会不断轮询IO时间及其它事件并进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// fallthrough</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                processSelectedKeys();</span><br><span class="line">                runAllTasks();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">                processSelectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// process the error</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面Netty会调用<code>processSelectedKeys</code>方法进行IO事件的处理，并且会计算出处理IO时间所用的事件然后计算出给非IO事件处理分配的时间，然后调用<code>runAllTasks</code>方法执行所有的非IO任务（这里面就有我们的各个<code>Handler</code>）。</p>
<p><code>runAllTasks</code>会按顺序从内部的任务队列中取出任务(<code>Runnable</code>)然后进行安全执行。而我们刚才调用的<code>NioEventLoop</code>的<code>execute</code>方法其实就是将包装好的<code>Handler</code>置入<code>NioEventLoop</code>内部的任务队列中等待执行。</p>
<h2 id="Worker_context">Worker context</h2><p>顾名思义，Worker Context用于跑阻塞任务。与Event Loop Context相似，每一个<code>Handler</code>都只会跑在固定的Worker线程下。</p>
<p>Vert.x还提供一种Multi-threaded worker context可以在多个Worker线程下并发执行任务，这样就会出现并发问题，需要开发者自行解决并发问题。因此一般情况下我们用不到Multi-threaded worker context。</p>
<h1 id="Verticle">Verticle</h1><p>我们再来讨论一下<code>Verticle</code>中的<code>Context</code>。在部署<code>Verticle</code>的时候，Vert.x会根据配置来创建<code>Context</code>并绑定到Verticle上，此后此Verticle上所有绑定的<code>Handler</code>都会在此<code>Context</code>上执行。相关实现位于<code>doDeploy</code>方法，这里摘取核心部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Verticle verticle: verticles) &#123;</span><br><span class="line">  WorkerExecutorImpl workerExec = poolName != <span class="keyword">null</span> ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize()) : <span class="keyword">null</span>;</span><br><span class="line">  WorkerPool pool = workerExec != <span class="keyword">null</span> ? workerExec.getPool() : <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 根据配置创建Context</span></span><br><span class="line">  ContextImpl context = options.isWorker() ? vertx.createWorkerContext(options.isMultiThreaded(), deploymentID, pool, conf, tccl) :</span><br><span class="line">    vertx.createEventLoopContext(deploymentID, pool, conf, tccl);</span><br><span class="line">  <span class="keyword">if</span> (workerExec != <span class="keyword">null</span>) &#123;</span><br><span class="line">    context.addCloseHook(workerExec);</span><br><span class="line">  &#125;</span><br><span class="line">  context.setDeployment(deployment);</span><br><span class="line">  deployment.addVerticle(<span class="keyword">new</span> VerticleHolder(verticle, context));</span><br><span class="line">  <span class="comment">// 此Verticle上的Handler都会在创建的context作用域内执行</span></span><br><span class="line">  context.runOnContext(v -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      verticle.init(vertx, context);</span><br><span class="line">      Future&lt;Void&gt; startFuture = Future.future();</span><br><span class="line">      <span class="comment">// 大家熟悉的start方法的执行点</span></span><br><span class="line">      verticle.start(startFuture);</span><br><span class="line">      startFuture.setHandler(ar -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.addChild(deployment);</span><br><span class="line">            deployment.child = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          vertx.metricsSPI().verticleDeployed(verticle);</span><br><span class="line">          deployments.put(deploymentID, deployment);</span><br><span class="line">          <span class="keyword">if</span> (deployCount.incrementAndGet() == verticles.length) &#123;</span><br><span class="line">            reportSuccess(deploymentID, callingContext, completionHandler);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!failureReported.get()) &#123;</span><br><span class="line">          reportFailure(ar.cause(), callingContext, completionHandler);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      reportFailure(t, callingContext, completionHandler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这样一种方式，Vert.x保证了<code>Verticle</code>的线程安全 —— 即某个<code>Verticle</code>上的所有<code>Handler</code>都会在同一个Vert.x线程上执行，这样也保证了<code>Verticle</code>内部成员的安全（没有race condition问题）。比如下面Verticle中处理IO及事件的处理都一直是在同一个Vert.x线程下执行的，每次打印出的线程名称应该是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    vertx.createNetClient().connect(<span class="number">6666</span>, <span class="string">"localhost"</span>, ar -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">        NetSocket socket = ar.result();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        socket.handler(buffer -&gt; &#123;</span><br><span class="line">          i++;</span><br><span class="line">          System.out.println(Thread.currentThread().getName());</span><br><span class="line">          System.out.println(<span class="string">"Net client receiving: "</span> + buffer.toString(<span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        socket.write(<span class="string">"+1s\n"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ar.cause().printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程池">线程池</h1><h2 id="Event_Loop线程池">Event Loop线程池</h2><p>之前我们已经提到过，Event Loop线程池的类型为Netty中的<code>NioEventLoopGroup</code>，里面的线程通过Vert.x自己的线程工厂<code>VertxThreadFactory</code>进行创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eventLoopThreadFactory = <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-eventloop-thread-"</span>, checker, <span class="keyword">false</span>, options.getMaxEventLoopExecuteTime());</span><br><span class="line">eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(options.getEventLoopPoolSize(), eventLoopThreadFactory);</span><br><span class="line">eventLoopGroup.setIoRatio(NETTY_IO_RATIO);</span><br></pre></td></tr></table></figure>
<p>其中Event Loop线程的数目可以在配置中指定。</p>
<h2 id="Worker线程池">Worker线程池</h2><p>在之前讲<code>executeBlocking</code>底层实现的文章中我们已经提到过Worker线程池，它其实就是一种Fixed Thread Pool:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService workerExec = Executors.newFixedThreadPool(options.getWorkerPoolSize(),</span><br><span class="line">    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-worker-thread-"</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime()));</span><br><span class="line">PoolMetrics workerPoolMetrics = isMetricsEnabled() ? metrics.createMetrics(workerExec, <span class="string">"worker"</span>, <span class="string">"vert.x-worker-thread"</span>, options.getWorkerPoolSize()) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</span><br></pre></td></tr></table></figure>
<p>Worker线程同样由<code>VertxThreadFactory</code>构造，类型为<code>VertxThread</code>，用于执行阻塞任务。我们同样可以在配置中指定其数目。</p>
<h2 id="内部阻塞线程池">内部阻塞线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService internalBlockingExec = Executors.newFixedThreadPool(options.getInternalBlockingPoolSize(),</span><br><span class="line">    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-internal-blocking-"</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime()));</span><br><span class="line">PoolMetrics internalBlockingPoolMetrics = isMetricsEnabled() ? metrics.createMetrics(internalBlockingExec, <span class="string">"worker"</span>, <span class="string">"vert.x-internal-blocking"</span>, options.getInternalBlockingPoolSize()) : <span class="keyword">null</span>;</span><br><span class="line">internalBlockingPool = <span class="keyword">new</span> WorkerPool(internalBlockingExec, internalBlockingPoolMetrics);</span><br></pre></td></tr></table></figure>
<p>Internal Blocking Pool可能设计用于内部使用，在<code>executeBlocking(Action&lt;T&gt; action, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</code>这个版本的方法中就使用了它。</p>
<h2 id="Acceptor_Event_Loop线程池">Acceptor Event Loop线程池</h2><p>大家可能会发现<code>VertxImpl</code>类中还有一个<code>acceptorEventLoopGroup</code>。顾名思义，它是Netty中的Acceptor线程池，负责处理客户端的连接请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acceptorEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, acceptorEventLoopThreadFactory);</span><br><span class="line">acceptorEventLoopGroup.setIoRatio(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>由于系统只有一个服务端端口需要监听，因此这里只需要一个线程。</p>
<p>Vert.x中的<code>HttpServer</code>就利用了<code>acceptorEventLoopGroup</code>处理客户端的连接请求，具体的实现后边会另起一篇介绍。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Event-Loop/">Event Loop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-vertx-advanced-execute-blocking-internal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-execute-blocking-internal/" class="article-date">
      <time datetime="2016-09-08T16:00:00.000Z" itemprop="datePublished">2016-09-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-execute-blocking-internal/">Vert.x 技术内幕 | executeBlocking 实现原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="引入">引入</h1><p>大家都知道，Vert.x中的<code>executeBlocking</code>方法用于执行阻塞任务，并且有两种模式：有序执行和无序执行。下面我们来看两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vertx.setPeriodic(<span class="number">1000</span>, t -&gt; &#123;</span><br><span class="line">  vertx.executeBlocking(future -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    future.complete();</span><br><span class="line">  &#125;, r -&gt; &#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">vertx.setPeriodic(<span class="number">1000</span>, t -&gt; &#123;</span><br><span class="line">  vertx.executeBlocking(future -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    future.complete();</span><br><span class="line">  &#125;, r -&gt; &#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们思考一下，每段代码每次执行的时候使用的线程相同么？正常情况下大家都知道<code>executeBlocking</code>底层使用了Worker线程池，因此貌似两种情况没什么区别，都是轮询Worker线程池，每次可能用不同的Worker线程。但是我们测一下：</p>
<p>第一段代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vert<span class="class">.x-worker-thread-0</span></span><br><span class="line">vert<span class="class">.x-worker-thread-1</span></span><br><span class="line">vert<span class="class">.x-worker-thread-2</span></span><br><span class="line">vert<span class="class">.x-worker-thread-3</span></span><br><span class="line">vert.x-worker-thread-<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>第二段代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vert<span class="class">.x-worker-thread-0</span></span><br><span class="line">vert<span class="class">.x-worker-thread-0</span></span><br><span class="line">vert<span class="class">.x-worker-thread-0</span></span><br><span class="line">vert<span class="class">.x-worker-thread-0</span></span><br><span class="line">vert.x-worker-thread-<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>额。。。两段代码每次执行的线程居然有差异？第二次为什么每次都用相同的Worker线程？其实，大家可能忽略了一点：<code>executeBlocking</code>方法默认<strong>顺序执行</strong>提交的阻塞任务。今天我们就来探究一下<code>executeBlocking</code>内部的实现。</p>
<h1 id="Worker线程池">Worker线程池</h1><p>我们来回顾一下Vert.x底层的Worker线程池，它在创建<code>VertxImpl</code>实例的时候进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService workerExec = Executors.newFixedThreadPool(options.getWorkerPoolSize(),</span><br><span class="line">    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-worker-thread-"</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime()));</span><br><span class="line">PoolMetrics workerPoolMetrics = isMetricsEnabled() ? metrics.createMetrics(workerExec, <span class="string">"worker"</span>, <span class="string">"vert.x-worker-thread"</span>, options.getWorkerPoolSize()) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</span><br></pre></td></tr></table></figure>
<p>可以看到底层的Worker线程池本质上是一种<code>FixedThreadPool</code>，里面的线程由<code>VertxThreadFactory</code>控制生成，对应的线程类型为<code>VertxThread</code>。Vert.x内部用<code>WorkerPool</code>类对线程池以及线程池相关的Metrics类进行了封装。</p>
<h1 id="阻塞任务在哪里执行？">阻塞任务在哪里执行？</h1><p>有了Worker线程池的基础，我们来看一下<code>Vertx</code>实例中的<code>executeBlocking</code>方法，它的过程很简单：获取当前的Vert.x Context（没有就创建），然后委托调用<code>Context</code>里的<code>executeBlocking</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, <span class="keyword">boolean</span> ordered,</span><br><span class="line">                                Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler)</span> </span>&#123;</span><br><span class="line">  ContextImpl context = getOrCreateContext();</span><br><span class="line">  context.executeBlocking(blockingCodeHandler, ordered, asyncResultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler,</span><br><span class="line">                                Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler)</span> </span>&#123;</span><br><span class="line">  executeBlocking(blockingCodeHandler, <span class="keyword">true</span>, asyncResultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此方法中可以看到，<code>ordered</code>标志位默认为<code>true</code>，即默认按提交的次序执行阻塞任务。</p>
<p>我们再来看一下<code>ContextImpl</code>类中的<code>executeBlocking</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, <span class="keyword">boolean</span> ordered, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</span> </span>&#123;</span><br><span class="line">  executeBlocking(<span class="keyword">null</span>, blockingCodeHandler, resultHandler, ordered ? workerExec : workerPool.executor(), workerPool.metrics());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Action&lt;T&gt; action, Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler,</span><br><span class="line">    Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler,</span><br><span class="line">    Executor exec, PoolMetrics metrics)</span> </span>&#123;</span><br><span class="line">  Object queueMetric = metrics != <span class="keyword">null</span> ? metrics.submitted() : <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec.execute(() -&gt; &#123;</span><br><span class="line">      Object execMetric = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">        execMetric = metrics.begin(queueMetric);</span><br><span class="line">      &#125;</span><br><span class="line">      Future&lt;T&gt; res = Future.future();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (blockingCodeHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">          ContextImpl.setContext(<span class="keyword">this</span>);</span><br><span class="line">          blockingCodeHandler.handle(res);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          T result = action.perform();</span><br><span class="line">          res.complete(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        res.fail(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">        metrics.end(execMetric, res.succeeded());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (resultHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        runOnContext(v -&gt; res.setHandler(resultHandler));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RejectedExecutionException ignore) &#123;</span><br><span class="line">    <span class="comment">// Pool is already shut down</span></span><br><span class="line">    <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">      metrics.rejected(queueMetric);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用了另一个具体版本的<code>executeBlocking</code>方法，其中第四个参数即为要执行阻塞任务的线程池。如果要有序执行(<code>ordered</code>为true)，底层就使用<code>context</code>实例里的<code>workerExec</code>线程池；如果无序执行，就调用<code>workerPool</code>的<code>executor</code>方法获取另一种线程池。</p>
<p>看到这里，我们大致已经想到了，有序执行和无序执行两种模式使用不同的线程池，因此底层实现肯定有差异。我们来看一下前面提到的两个线程池，它们都是<code>ContextImpl</code>类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> WorkerPool workerPool;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Executor workerExec;</span><br></pre></td></tr></table></figure>
<p>在通过<code>Vertx</code>实例创建<code>Context</code>的时候，这几个变量会被初始化，其来源就是之前我们看过的<code>VertxImpl</code>实例中的Worker线程池。看一下<code>ContextImpl</code>类的构造函数就一目了然了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.workerPool = workerPool;</span><br><span class="line"><span class="keyword">this</span>.workerExec = workerPool.createOrderedExecutor();</span><br></pre></td></tr></table></figure>
<p>嗯。。。有序执行对应的线程池通过<code>workerPool</code>的<code>createOrderedExecutor</code>方法获得，而无序执行对应的线程池通过<code>workerPool</code>的<code>executor</code>方法获得。因此，<code>WorkerPool</code>类是一个关键点，我们稍后就看一下其实现。</p>
<p>注意Vert.x规定,<code>blockingCodeHandler</code>中的逻辑（即阻塞任务）在Worker线程内执行，而<code>resultHandler</code>内的逻辑（结果处理）需要在Vert.x Conext中执行，因此前面需要预先设置当前使用的Worker线程的<code>Context</code>为<code>this</code>以便后面调用<code>runOnContext</code>方法执行结果处理逻辑。</p>
<p>下面就来看一下有序执行和无序执行这两种线程池的具体区别。</p>
<h1 id="无序执行">无序执行</h1><p>我们看一下<code>WorkerPool</code>类的源码中获取无序执行线程池的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ExecutorService <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>executor</code>方法直接返回了内部的<code>pool</code>线程池，而<code>pool</code>线程池其实就是<code>VertxImpl</code>中的<code>workerExec</code>线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</span><br></pre></td></tr></table></figure>
<p>OK！如果大家熟悉并发的话，大家应该对无序执行对应的线程池 —— Worker线程池的行为非常清楚了。它属于一种<code>FixedThreadPool</code>，底层通过阻塞队列<code>LinkedBlockingQueue</code>实现。底层通过轮询算法获取Worker线程执行任务。</p>
<h1 id="有序执行">有序执行</h1><p>下面是时候看有序执行对应的逻辑了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OrderedExecutorFactory orderedFact;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolMetrics metrics;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WorkerPool</span><span class="params">(ExecutorService pool, PoolMetrics metrics)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.orderedFact = <span class="keyword">new</span> OrderedExecutorFactory(pool);</span><br><span class="line">  <span class="keyword">this</span>.pool = pool;</span><br><span class="line">  <span class="keyword">this</span>.metrics = metrics;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Executor <span class="title">createOrderedExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> orderedFact.getExecutor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有序执行对应的线程池是通过<code>OrderedExecutorFactory</code>创建的。其实，<code>OrderedExecutorFactory</code>类会生成真正的有序执行线程池<code>OrderedExecutor</code>，它其实是对Worker线程池<code>pool</code>的一个简单包装，仅仅添加了有序执行相关的逻辑，最后还是委托Worker线程池进行任务处理。</p>
<p>那么<code>OrderedExecutor</code>是如何实现顺序执行的呢？<code>OrderedExecutor</code>内部维护着一个任务队列。每当调用<code>executeBlocking</code>方法执行阻塞过程的时候，Vert.x会将阻塞过程包装成<code>Runnable</code>然后置入<code>OrderedExecutor</code>中的任务队列中；同时如果<code>OrderedExecutor</code>没有开始执行任务，就委托内部的Worker线程池执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">    tasks.add(command);</span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">      running = <span class="keyword">true</span>;</span><br><span class="line">      parent.execute(runner);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，最后委托Worker线程池执行的线程其实是又包装了一层的<code>runner</code>线程。<code>runner</code>的逻辑不难想：不断地从任务队列中取出队首的<code>Runnable</code>然后调用其<code>run</code>方法执行（相当于执行了此任务，只不过在runner对应的线程中）；如果没有任务了就结束本线程。</p>
<p>这里就出现了一种情况：大批量提交阻塞任务的时候，线程池的状态<code>running</code>一直为<code>true</code>，此时所有的任务都积压到任务队列中，而执行所有任务的线程只有一个 —— <code>runner</code>对应的线程。这种情况其实很好想，因为要保证有序执行，就只能让它一个接一个地在同个线程中执行。如果在不同线程中依次执行则不好调度，如果直接并行执行则不能保证有序性。</p>
<p>所以，根据<code>OrderedExecutor</code>线程池的内部实现，只要提交任务的间隔时间小于任务执行的时间，底层其实就仅执行了一次<code>runner</code>，也就是说所有提交的阻塞任务都只在一个线程下跑（running标志位控制）。</p>
<p>这样就可以很好地解释我们一开始提出的问题了。当<code>sleep(200), setPeriodic(1000)</code>的时候，提交任务的间隔时间大于任务执行的时间，这样每次的<code>runner</code>就可以在下一个任务提交之前执行完，因此每次所用的线程会不同（轮询策略）；而<code>sleep(2000), setPeriodic(1000)</code>的时候，提交任务的间隔时间小于任务执行的时间，底层最后都归结到一个<code>runner</code>中执行了，因此所有过程都是在同一个Worker线程执行的（很好想，保证有序就要串行执行）。</p>
<p>当然，如果不想有序执行，可以用<code>void executeBlocking(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, boolean ordered, Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler)</code>这个版本的<code>executeBlocking</code>方法，并将<code>ordered</code>标志位设为<code>false</code>。根据上面的源码，底层会直接使用Worker线程池而不是<code>OrderedExecutor</code>线程池，这样就不会有上面<code>OrderedExecutor</code>的情况了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-vertx-advanced-async-rpc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-async-rpc/" class="article-date">
      <time datetime="2016-09-06T16:00:00.000Z" itemprop="datePublished">2016-09-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-async-rpc/">Vert.x 技术内幕 | 异步RPC实现原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>经常有一些开发者在group中问到，如何利用Vert.x进行RPC通信。其实，Vert.x提供了一个组件 —— <strong>Vert.x Service Proxy</strong>，专门用于进行异步RPC通信（通过Event Bus）。Vert.x Service Proxy会自动生成代理类进行消息的包装与解码、发送与接收以及超时处理，可以为我们省掉不少代码。之前我在Vert.x Blueprint中已经详细讲解了<strong>Vert.x Service Proxy</strong>的使用，大家可以参考 <a href="http://www.sczyh30.com/vertx-blueprint-job-queue/cn/kue-core/index.html#异步rpc">Vert.x Kue 文档</a> 中的相关部分。本篇文章中我们将探索一下通过<strong>Vert.x Service Proxy</strong>生成的代理类进行异步RPC的原理，对应的Vert.x版本为<strong>3.3.2</strong>。</p>
<p>传统的RPC想必大家都不陌生，但是传统的RPC有个缺陷：传统的RPC都是阻塞型的，当调用者远程调用服务时需要阻塞着等待调用结果，这与Vert.x的异步开发模式相违背；而且，传统的RPC未对容错而设计。</p>
<p>因此，Vert.x提供了Service Proxy用于进行异步RPC，其底层依托Clustered Event Bus进行通信。我们只需要按照规范编写我们的服务接口（一般称为Event Bus服务），并加上<code>@ProxyGen</code>注解，Vert.x就会自动为我们生成相应的代理类在底层处理RPC。有了Service Proxy，我们只需给异步方法提供一个回调函数<code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>，在调用结果发送过来的时候会自动调用绑定的回调函数进行相关的处理，这样就与Vert.x的异步开发模式相符了。由于<code>AsyncResult</code>本身就是为容错而设计的（两个状态），因此这里的RPC也具有了容错性。</p>
<h1 id="原理简介">原理简介</h1><p>假设有一个Event Bus服务接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ProxyGen</span></span><br><span class="line"><span class="annotation">@VertxGen</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String SERVICE_ADDRESS = <span class="string">"service.example"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> SomeService <span class="title">createService</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SomeServiceImpl(vertx, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> SomeService <span class="title">createProxy</span><span class="params">(Vertx vertx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ProxyHelper.createProxy(SomeService.class, vertx, SERVICE_ADDRESS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">SomeService <span class="title">process</span><span class="params">(String id, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; resultHandler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个异步方法<code>process</code>，其异步调用返回的结果是<code>AsyncResult&lt;JsonObject&gt;</code>类型的。由于异步RPC底层通过Clustered Event Bus进行通信，我们需要给器指定一个通信地址<code>SERVICE_ADDRESS</code>。<code>@Fluent</code>注解代表此方法返回自身，便于进行组合。我们同时还提供了两个辅助方法：<code>createService</code>方法用于创建服务实例，而<code>createProxy</code>方法则通过<code>ProxyHelper</code>辅助类创建服务代理实例。</p>
<p>假设服务提供端A注册了一个<code>SomeService</code>类型的服务代理，服务调用端B需要通过异步RPC调用服务的<code>process</code>方法，此时调用端B可以利用<code>ProxyHelper</code>获取服务实例并进行服务调用。B中获取的服务其实是一个<strong>服务代理类</strong>，而真正的服务实例在A处。何为服务代理？服务代理可以帮助我们向服务提供端发送调用请求，并且响应调用结果。那么如何发送调用请求呢？相信大家能想到，是调用端B将调用参数和方法名称等必要信息包装成集群消息(<code>ClusteredMessage</code>)，然后通过<code>send</code>方法将请求通过Clustered Event Bus发送至服务提供端A处（需要提供此服务的通信地址）。A在注册服务的时候会创建一个<code>MessageConsumer</code>监听此服务的地址来响应调用请求。当接收到调用请求的时候，A会在本地调用方法，并将结果回复至调用端。所以异步RPC本质上其实是一个基于<strong>代理模式</strong>的 <strong>Request/Response</strong> 消息模式。</p>
<p>用时序图来描述一下上述过程：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertx-async-rpc-sequence.png" alt="Sequence Diagram of Async RPC"></p>
<h1 id="引入">引入</h1><p>以之前的<code>SomeService</code>接口为例，我们可以在集群中的一个节点上注册服务实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SomeService service = SomeService.createService(vertx, config);</span><br><span class="line">ProxyHelper.registerService(SomeService.class, vertx, service, SomeService.SERVICE_ADDRESS);</span><br></pre></td></tr></table></figure>
<p>然后在另一个节点上获取此服务实例的代理，并进行服务调用。调用的时候看起来就像在本地调用(LPC)一样，其实是进行了RPC通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SomeService proxyService = SomeService.createProxy(vertx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke the service</span></span><br><span class="line">proxyService.process(<span class="string">"fuck"</span>, ar -&gt; &#123;</span><br><span class="line">  <span class="comment">// process the result...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实，这里获取到的<code>proxyService</code>实例的真正类型是Vert.x自动生成的服务代理类<code>SomeServiceVertxEBProxy</code>类，里面封装了通过Event Bus进行通信的逻辑。我们首先来讲一下Service Proxy生成代理类的命名规范。</p>
<h1 id="代理类命名规范">代理类命名规范</h1><p>Vert.x Service Proxy在生成代理类时遵循一定的规范。假设有一Event Bus服务接口<code>SomeService</code>，Vert.x会自动为其生成代理类以及代理处理器：</p>
<ul>
<li>代理类的命名规范为 <strong>接口名</strong> + <code>VertxEBProxy</code>。比如<code>SomeService</code>接口对应的代理类名称为<code>SomeServiceVertxEBProxy</code></li>
<li>代理类会继承原始的服务接口并实现所有方法的代理逻辑</li>
<li>代理处理器的命名规范为 <strong>接口名</strong> + <code>VertxProxyHandler</code>。比如<code>SomeService</code>接口对应的代理处理器名称为<code>SomeServiceVertxProxyHandler</code></li>
<li>代理处理器会继承<code>ProxyHandler</code>抽象类</li>
</ul>
<p><code>ProxyHelper</code>辅助类中注册服务以及创建代理都是遵循了这个规范。</p>
<h1 id="在Event_Bus上注册服务">在Event Bus上注册服务</h1><p>我们通过<code>ProxyHelper</code>辅助类中的<code>registerService</code>方法来向Event Bus上注册Event Bus服务，来看其具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MessageConsumer&lt;JsonObject&gt; <span class="title">registerService</span><span class="params">(Class&lt;T&gt; clazz, Vertx vertx, T service, String address,</span><br><span class="line">                                                              <span class="keyword">boolean</span> topLevel,</span><br><span class="line">                                                              <span class="keyword">long</span> timeoutSeconds)</span> </span>&#123;</span><br><span class="line">  String handlerClassName = clazz.getName() + <span class="string">"VertxProxyHandler"</span>;</span><br><span class="line">  Class&lt;?&gt; handlerClass = loadClass(handlerClassName, clazz);</span><br><span class="line">  Constructor constructor = getConstructor(handlerClass, Vertx.class, clazz, <span class="keyword">boolean</span>.class, <span class="keyword">long</span>.class);</span><br><span class="line">  Object instance = createInstance(constructor, vertx, service, topLevel, timeoutSeconds);</span><br><span class="line">  ProxyHandler handler = (ProxyHandler) instance;</span><br><span class="line">  <span class="keyword">return</span> handler.registerHandler(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先根据约定生成对应的代理<code>Handler</code>的名称，然后通过类加载器加载对应的<code>Handler</code>类，再通过反射来创建代理<code>Handler</code>的实例，最后调用<code>handler</code>的<code>registerHandler</code>方法注册服务地址。</p>
<p><code>registerHandler</code>方法的实现在Vert.x生成的各个代理处理器中。以之前的<code>SomeService</code>为例，我们来看一下其对应的代理处理器<code>SomeServiceVertxProxyHandler</code>实现。首先是注册并订阅地址的<code>registerHandler</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageConsumer&lt;JsonObject&gt; <span class="title">registerHandler</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">  MessageConsumer&lt;JsonObject&gt; consumer = vertx.eventBus().&lt;JsonObject&gt;consumer(address).handler(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.setConsumer(consumer);</span><br><span class="line">  <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>registerHandler</code>方法的实现非常简单，就是通过<code>consumer</code>方法在<code>address</code>地址上绑定了<code>SomeServiceVertxProxyHandler</code>自身。那么<code>SomeServiceVertxProxyHandler</code>是如何处理来自服务调用端的服务调用请求，并将调用结果返回到请求端呢？在回答这个问题之前，我们先来看看代理端（调用端）是如何发送服务调用请求的，这就要看对应的服务代理类的实现了。</p>
<h1 id="服务调用">服务调用</h1><p>我们来看一下服务调用端是如何发出服务调用请求的消息的。之前已经介绍过，服务调用端是通过Event Bus的<code>send</code>方法发送调用请求的，并且会提供一个<code>replyHandler</code>来等待方法调用的结果。调用的方法名称会存放在消息中名为<code>action</code>的header中。以之前<code>SomeService</code>的代理类<code>SomeServiceVertxEBProxy</code>中<code>process</code>方法的请求为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SomeService <span class="title">process</span><span class="params">(String id, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; resultHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    resultHandler.handle(Future.failedFuture(<span class="keyword">new</span> IllegalStateException(<span class="string">"Proxy is closed"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  JsonObject _json = <span class="keyword">new</span> JsonObject();</span><br><span class="line">  _json.put(<span class="string">"id"</span>, id);</span><br><span class="line">  DeliveryOptions _deliveryOptions = (_options != <span class="keyword">null</span>) ? <span class="keyword">new</span> DeliveryOptions(_options) : <span class="keyword">new</span> DeliveryOptions();</span><br><span class="line">  _deliveryOptions.addHeader(<span class="string">"action"</span>, <span class="string">"process"</span>);</span><br><span class="line">  _vertx.eventBus().&lt;JsonObject&gt;send(_address, _json, _deliveryOptions, res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.failed()) &#123;</span><br><span class="line">      resultHandler.handle(Future.failedFuture(res.cause()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resultHandler.handle(Future.succeededFuture(res.result().body()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代理类把此方法传入的参数都放到一个<code>JsonObject</code>中了，并将要调用的方法名称存放在消息中名为<code>action</code>的header中。代理方法通过<code>send</code>方法将包装好的消息发送至之前注册的服务地址处，并且绑定<code>replyHandler</code>等待调用结果，然后使用我们传入到<code>process</code>方法中的<code>resultHandler</code>对结果进行处理。是不是很简单呢？</p>
<h1 id="服务提供端的调用逻辑">服务提供端的调用逻辑</h1><p>调用请求发出之后，我们的服务提供端就会收到调用请求消息，然后执行<code>SomeServiceVertxProxyHandler</code>中的处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;JsonObject&gt; msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    JsonObject json = msg.body();</span><br><span class="line">    String action = msg.headers().get(<span class="string">"action"</span>);</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"action not specified"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    accessed();</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"process"</span>: &#123;</span><br><span class="line">        service.process((java.lang.String)json.getValue(<span class="string">"id"</span>), createHandler(msg));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid action: "</span> + action);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    msg.reply(<span class="keyword">new</span> ServiceException(<span class="number">500</span>, t.getMessage()));</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>handle</code>方法首先从消息header中获取方法名称，如果获取不到则调用失败；接着<code>handle</code>方法会调用<code>accessed</code>方法记录最后调用服务的时间戳，这是为了实现超时的逻辑，后面我们会讲。接着<code>handle</code>方法会根据方法名称分派对应的逻辑，在“真正”的服务实例上调用方法。注意异步RPC的过程本质是 <strong>Request/Response</strong> 模式，因此这里的异步结果处理函数<code>resultHandler</code>应该将调用结果发送回调用端。此<code>resultHandler</code>是通过<code>createHandler</code>方法生成的，逻辑很清晰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Handler&lt;AsyncResult&lt;T&gt;&gt; createHandler(Message msg) &#123;</span><br><span class="line">  <span class="keyword">return</span> res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.failed()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.cause() <span class="keyword">instanceof</span> ServiceException) &#123;</span><br><span class="line">        msg.reply(res.cause());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg.reply(<span class="keyword">new</span> ServiceException(-<span class="number">1</span>, res.cause().getMessage()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.result() != <span class="keyword">null</span>  &amp;&amp; res.result().getClass().isEnum()) &#123;</span><br><span class="line">        msg.reply(((Enum) res.result()).name());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg.reply(res.result());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，一旦在服务提供端的调用过程完成时，调用结果就会被发送回调用端。这样调用端就可以调用结果执行真正的处理逻辑了。</p>
<h1 id="超时处理">超时处理</h1><p>Vert.x自动生成的代理处理器内都封装了一个简单的超时处理逻辑，它是通过定时器定时检查最后的调用时间实现的。逻辑比较简单，直接放上相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SomeServiceVertxProxyHandler</span><span class="params">(Vertx vertx, SomeService service, <span class="keyword">boolean</span> topLevel, <span class="keyword">long</span> timeoutSeconds)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 前面代码略。。。</span></span><br><span class="line">  <span class="keyword">if</span> (timeoutSeconds != -<span class="number">1</span> &amp;&amp; !topLevel) &#123;</span><br><span class="line">    <span class="keyword">long</span> period = timeoutSeconds * <span class="number">1000</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (period &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">      period = <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.timerID = vertx.setPeriodic(period, <span class="keyword">this</span>::checkTimedOut);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  accessed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkTimedOut</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">  <span class="keyword">if</span> (now - lastAccessed &gt; timeoutSeconds * <span class="number">1000000000</span>) &#123;</span><br><span class="line">    close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦超时，就自动调用<code>close</code>方法终止定时器，注销响应服务调用请求的consumer并关闭代理。</p>
<h1 id="代码是如何生成的？">代码是如何生成的？</h1><p>大家可能会很好奇，这些服务代理类是怎么生成出来的？其实，这都是Vert.x Codegen的功劳。Vert.x Codegen的本质是一个 <strong>注解处理器</strong>(APT)，它可以扫描源码中是否包含要处理的注解，检查规范后根据响应的模板生成对应的代码，这就是注解处理器的作用(注解处理器于JDK 1.6引入)。为了让Codegen正确地生成代码，我们需要配置编译参数来确保注解处理器能够正常的工作，具体的可以参考 <a href="https://github.com/vert-x3/vertx-codegen/blob/master/README.md" target="_blank" rel="external">Vert.x Codegen的文档</a> （之前里面缺了Gradle相关的实例，我给补上了）。</p>
<p>Vert.x Codegen使用MVEL2作为生成代码的模板，扩展名为<code>*.templ</code>，比如代理类和代理处理器的模板就位于 <a href="https://github.com/vert-x3/vertx-service-proxy/tree/master/src/main/resources/serviceproxy/template" target="_blank" rel="external">vert-x3/vertx-service-proxy</a> 中，配置文件类似于这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">name</span>": <span class="value"><span class="string">"Proxy"</span></span>,</span><br><span class="line">  "<span class="attribute">generators</span>": <span class="value">[</span><br><span class="line">    &#123;</span><br><span class="line">      "<span class="attribute">kind</span>": <span class="value"><span class="string">"proxy"</span></span>,</span><br><span class="line">      "<span class="attribute">fileName</span>": <span class="value"><span class="string">"ifaceFQCN + 'VertxEBProxy.java'"</span></span>,</span><br><span class="line">      "<span class="attribute">templateFileName</span>": <span class="value"><span class="string">"serviceproxy/template/proxygen.templ"</span></span><br><span class="line">    </span>&#125;,&#123;</span><br><span class="line">      "<span class="attribute">kind</span>": <span class="value"><span class="string">"proxy"</span></span>,</span><br><span class="line">      "<span class="attribute">fileName</span>": <span class="value"><span class="string">"ifaceFQCN + 'VertxProxyHandler.java'"</span></span>,</span><br><span class="line">      "<span class="attribute">templateFileName</span>": <span class="value"><span class="string">"serviceproxy/template/handlergen.templ"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line">  ]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>具体的代码生成逻辑还要涉及APT及MVEL2的知识，这里就不展开讲了，有兴趣的朋友可以研究研究Vert.x Codegen的源码。</p>
<h1 id="优点与缺点">优点与缺点</h1><p>Vert.x提供的这种Async RPC有着许多优点：</p>
<ul>
<li>通过Clustered Event Bus传输消息，不需引入其它额外的组件</li>
<li>自动生成代理类及代理处理器，可以帮助我们做消息封装、传输、编码解码以及超时处理等问题，省掉不少冗余代码，让我们可以以LPC的方式进行RPC通信</li>
<li>多语言支持(Polyglot support)。这是Vert.x的一大亮点。只要加上<code>@VertxGen</code>注解并在编译期依赖中加上对应语言的依赖(如<code>vertx-lang-ruby</code>)，Vert.x Codegen就会自动处理注解并生成对应语言的服务代理（通过调用Java版本的服务代理实现）。这样Async RPC可以真正地做到不限language</li>
</ul>
<p>当然Vert.x要求我们的服务接口必须是 <strong>基于回调的</strong>，这样写起来可能会不优雅。还好<code>@VertxGen</code>注解支持生成Rx版本的服务类，因此只要加上<code>vertx-rx-java</code>依赖，Codegen就能生成对应的Rx风格的服务类（异步方法返回<code>Observable</code>），这样我们就能以更reactive的风格来构建应用了，岂不美哉？</p>
<p>当然，为了考虑多语言支持的兼容性，Vert.x在传递消息的时候依然使用了传统的JSON，这样传输效率可能不如Protobuf高，但是不一定成为瓶颈。（看业务情况。真正的瓶颈一般还是在DB上）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-vertx-advanced-clustered-event-bus-internal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-clustered-event-bus-internal/" class="article-date">
      <time datetime="2016-09-04T16:00:00.000Z" itemprop="datePublished">2016-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-clustered-event-bus-internal/">Vert.x 技术内幕 | Event Bus 源码分析 (集群模式)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="http://www.sczyh30.com/posts/Vert-x/vertx-advanced-local-event-bus-internal/">上篇文章</a>中我们探索了Local模式下Event Bus的源码，在这篇文章中我们来探索一下Vert.x中的Clustered Event Bus是如何实现的。对应的Vert.x版本为<strong>3.3.2</strong>。</p>
<h1 id="集群模式介绍">集群模式介绍</h1><p>我们先来简单地介绍一下集群模式下Event Bus的基本原理。</p>
<p>我们可以通过集群模式下的Event Bus在不同的服务器之间进行通信，其本质为TCP通信。Vert.x集群模式需要一个集群管理器（默认为<code>HazelcastClusterManager</code>）来管理集群的状态，存储元数据。当我们在某个节点A给集群模式的Event Bus绑定一个对应地址<code>address</code>的<code>consumer</code>的时候，Event Bus会将此节点的<code>ServerID</code>（包含<code>host</code>和<code>port</code>信息）存储至集群管理器的共享Map中，<code>key</code>为绑定的地址<code>address</code>，value为绑定了此地址<code>address</code>的所有结点的<code>ServerID</code>集合（可以看作是具有负载均衡功能的<code>Set</code>）。集群中的所有节点都可以从集群管理器中获取Map记录。并且绑定consumer的同时节点A会建立一个<code>NetServer</code>接收数据。这样，我们再通过另一个结点B向此地址<code>address</code>发送消息的时候，B就会从集群管理器中取出此地址对应的<code>ServerID</code>集合，并根据是点对点发送还是发布，根据相应的策略创建<code>NetClient</code>执行消息分发逻辑。这样，对应的<code>NetServer</code>收到数据后会对其进行解码然后在本地进行消息的处理。</p>
<p>集群模式下我们还需要注意几个问题：</p>
<ul>
<li>某个节点挂了怎么办？</li>
<li>如何确保结点的高可用性？</li>
</ul>
<p>当某个节点挂掉的时候，其连接将会不可用，集群管理器就会将此节点的信息从集群中移除，并且传播到所有的节点删除对应缓存的信息，这样发消息的时候就不会发送到挂掉的无效节点处。至于高可用性，Vert.x提供了高可用管理器<code>HAManager</code>用于实现高可用性，在发生故障时能够快速failover，详情可见<a href="http://vertx.io/docs/vertx-core/java/#_high_availability_and_fail_over" target="_blank" rel="external">官方文档</a>。</p>
<p>好了，下面我们就来分析一下Clustered Event Bus的源码。集群模式下Event Bus的类型为<code>ClusteredEventBus</code>，它继承了单机模式的<code>EventBusImpl</code>类。其初始化过程与Local模式大同小异，因此这里就直接分析发送和接受消息相关的逻辑了。</p>
<h1 id="绑定MessageConsumer">绑定MessageConsumer</h1><p>我们还是先来看<code>consumer</code>方法的逻辑。前面的调用逻辑都和Local模式下相同，可以参考之前的文章。不同之处在添加记录的地方。Cluster模式下Event Bus需要将当前机器的位置存储至Map中并且传播至集群内的所有节点，因此<code>ClusteredEventBus</code>重写了四个参数版本的<code>addRegistration</code>方法（之前在<code>EventBusImpl</code>类中这个版本的方法用处不大，这里用处就大了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addRegistration</span><span class="params">(<span class="keyword">boolean</span> newAddress, String address,</span><br><span class="line">                                   <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly,</span><br><span class="line">                                   Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (newAddress &amp;&amp; subs != <span class="keyword">null</span> &amp;&amp; !replyHandler &amp;&amp; !localOnly) &#123;</span><br><span class="line">    <span class="comment">// Propagate the information</span></span><br><span class="line">    subs.add(address, serverID, completionHandler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler.handle(Future.succeededFuture());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要绑定<code>MessageConsumer</code>对应的地址在本地中没有注册过，并且不是Event Bus自动生成的reply consumer，并且允许在集群范围内传播的话，Event Bus就会将当前机器的位置添加到集群内的记录<code>subs</code>中。<code>subs</code>的类型为<code>AsyncMultiMap</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AsyncMultiMap&lt;String, ServerID&gt; subs;</span><br></pre></td></tr></table></figure>
<p>ClusteredEventBus启动时会对其进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clusterManager.&lt;String, ServerID&gt;getAsyncMultiMap(SUBS_MAP_NAME, ar2 -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar2.succeeded()) &#123;</span><br><span class="line">    subs = ar2.result();</span><br><span class="line">    <span class="comment">// 其他代码暂略。。。</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 代码略。。。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从名字就可以看出来，<code>AsyncMultiMap</code>允许<strong>一键多值</strong>，并且其变动可以<strong>在集群范围内传播</strong>。由于<code>AsyncMultiMap</code>是<strong>集群范围内</strong>的，因此对其操作都是异步的。在这里我们可以简单地把它看作是一个<code>Map&lt;String, ChoosableIterable&lt;ServerID&gt;&gt;</code>类型的键值对，其中<code>ChoosableIterable</code>与之前见到过的<code>Handlers</code>类似，属于可以通过轮询算法获取某一元素的集合。<code>subs</code>的key为绑定的地址，value为绑定此地址的机器位置的集合。机器的位置用<code>ServerID</code>表示，里面包含了该机器的<code>host</code>和<code>port</code>。这样，每当我们向某个地址绑定一个<code>MessageConsumer</code>的时候，绑定consumer的<code>ServerID</code>就会被记录到集群中并与地址相对应，其它机器在向此地址发送（或发布）消息的时候，Event Bus就可以从集群中获取在此地址上绑定了consumer的所有<code>ServerID</code>，再根据相应的策略选出合适的<code>ServerID</code>建立TCP通信将数据发送至对应机器中，对应机器收到消息后解码并在本地对其进行处理。</p>
<p>这里面还需要注意一点：我们可以在<code>EventBusOptions</code>中指定<code>ServerID</code>的<code>port</code>和<code>host</code>，若不指定则<code>port</code>将随机分配(<code>NetServer</code>的特性)。</p>
<p>剩下的过程也就大同小异了。至于<code>unregister</code>方法，无非就是将底层的<code>removeRegistration</code>方法重写，从<code>subs</code>中删除对应的<code>ServerID</code>并传播至其它节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeRegistration</span><span class="params">(HandlerHolder lastHolder, String address,</span><br><span class="line">                                      Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastHolder != <span class="keyword">null</span> &amp;&amp; subs != <span class="keyword">null</span> &amp;&amp; !lastHolder.isLocalOnly()) &#123;</span><br><span class="line">    removeSub(address, serverID, completionHandler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    callCompletionHandlerAsync(completionHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeSub</span><span class="params">(String subName, ServerID theServerID, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">  subs.remove(subName, theServerID, ar -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ar.succeeded()) &#123;</span><br><span class="line">      log.error(<span class="string">"Failed to remove sub"</span>, ar.cause());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (ar.result()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">          completionHandler.handle(Future.succeededFuture());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">          completionHandler.handle(Future.failedFuture(<span class="string">"sub not found"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="消息的发送/发布">消息的发送/发布</h1><p>集群模式下的消息与本地模式下的消息不同。集群模式下的消息实体类型为<code>ClusteredMessage</code>，它继承了<code>MessageImpl</code>消息实体类，并且根据远程传输的特性实现了一种Wire Protocol用于远程传输消息，并负责消息的编码和解码。具体的实现就不展开说了，如果有兴趣的话可以阅读<code>ClusteredMessage</code>类中相关方法的实现。</p>
<p>我们上篇文章提到过，Event Bus底层通过<code>createMessage</code>方法创建消息。因此<code>ClusteredEventBus</code>里就对此方法进行了重写，当然改动就是把<code>MessageImpl</code>替换成了<code>ClusteredMessage</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MessageImpl <span class="title">createMessage</span><span class="params">(<span class="keyword">boolean</span> send, String address, MultiMap headers, Object body, String codecName)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(address, <span class="string">"no null address accepted"</span>);</span><br><span class="line">  MessageCodec codec = codecManager.lookupCodec(body, codecName);</span><br><span class="line">  <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  ClusteredMessage msg = <span class="keyword">new</span> ClusteredMessage(serverID, address, <span class="keyword">null</span>, headers, body, codec, send, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是消息的发送逻辑了。<code>ClusteredEventBus</code>重写了<code>sendOrPub</code>方法，此方法存在于<code>SendContextImpl</code>类中的<code>next</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">    Handler&lt;SendContext&gt; handler = iter.next();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handler.handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      log.error(<span class="string">"Failure in interceptor"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sendOrPub(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下<code>ClusteredEventBus</code>是如何进行集群内消息的分发的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendOrPub</span><span class="params">(SendContextImpl&lt;T&gt; sendContext)</span> </span>&#123;</span><br><span class="line">  String address = sendContext.message.address();</span><br><span class="line">  Handler&lt;AsyncResult&lt;ChoosableIterable&lt;ServerID&gt;&gt;&gt; resultHandler = asyncResult -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (asyncResult.succeeded()) &#123;</span><br><span class="line">      ChoosableIterable&lt;ServerID&gt; serverIDs = asyncResult.result();</span><br><span class="line">      <span class="keyword">if</span> (serverIDs != <span class="keyword">null</span> &amp;&amp; !serverIDs.isEmpty()) &#123;</span><br><span class="line">        sendToSubs(serverIDs, sendContext);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        metrics.messageSent(address, !sendContext.message.send(), <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        deliverMessageLocally(sendContext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(<span class="string">"Failed to send message"</span>, asyncResult.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (Vertx.currentContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Guarantees the order when there is no current context</span></span><br><span class="line">    sendNoContext.runOnContext(v -&gt; &#123;</span><br><span class="line">      subs.get(address, resultHandler);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    subs.get(address, resultHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先Event Bus需要从传入的<code>sendContext</code>中获取要发送至的地址。接着Event Bus需要从集群管理器中获取在此地址上绑定consumer的所有<code>ServerID</code>，这个过程是异步的，并且需要在Vert.x Context中执行。如果获取记录成功，我们会得到一个可通过轮询算法获取<code>ServerID</code>的集合(类型为<code>ChoosableIterable&lt;ServerID&gt;</code>)。如果集合为空，则代表集群内其它节点没有在此地址绑定consumer（或者由于一致性问题没有同步），Event Bus就将消息通过<code>deliverMessageLocally</code>方法在本地进行相应的分发。<code>deliverMessageLocally</code>方法的逻辑之前我们已经详细讲过了，这里就不再细说了；如果集合不为空，Event Bus就调用<code>sendToSubs</code>方法进行下一步操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendToSubs</span><span class="params">(ChoosableIterable&lt;ServerID&gt; subs, SendContextImpl&lt;T&gt; sendContext)</span> </span>&#123;</span><br><span class="line">  String address = sendContext.message.address();</span><br><span class="line">  <span class="keyword">if</span> (sendContext.message.send()) &#123;</span><br><span class="line">    <span class="comment">// Choose one</span></span><br><span class="line">    ServerID sid = subs.choose();</span><br><span class="line">    <span class="keyword">if</span> (!sid.equals(serverID)) &#123;  <span class="comment">//We don't send to this node</span></span><br><span class="line">      metrics.messageSent(address, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">      sendRemote(sid, sendContext.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      metrics.messageSent(address, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      deliverMessageLocally(sendContext);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Publish</span></span><br><span class="line">    <span class="keyword">boolean</span> local = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> remote = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ServerID sid : subs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!sid.equals(serverID)) &#123;  <span class="comment">//We don't send to this node</span></span><br><span class="line">        remote = <span class="keyword">true</span>;</span><br><span class="line">        sendRemote(sid, sendContext.message);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        local = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    metrics.messageSent(address, <span class="keyword">true</span>, local, remote);</span><br><span class="line">    <span class="keyword">if</span> (local) &#123;</span><br><span class="line">      deliverMessageLocally(sendContext);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就到了分<code>send</code>和<code>publish</code>的时候了。如果发送消息的模式为点对点模式(<code>send</code>)，Event Bus会从给的的集合中通过轮询算法获取一个<code>ServerID</code>。然后Event Bus会检查获取到的<code>ServerID</code>是否与本机<code>ServerID</code>相同，如果相同则代表在一个机子上，直接记录metrics信息并且调用<code>deliverMessageLocally</code>方法往本地发送消息即可；如果不相同，Event Bus就会调用<code>sendRemote</code>方法执行真正的远程消息发送逻辑。发布订阅模式的逻辑与其大同小异，只不过需要遍历一下<code>ChoosableIterable&lt;ServerID&gt;</code>集合，然后依次执行之前讲过的逻辑。注意如果要在本地发布消息只需要发一次。</p>
<p>真正的远程消息发送逻辑在<code>sendRemote</code>方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRemote</span><span class="params">(ServerID theServerID, MessageImpl message)</span> </span>&#123;</span><br><span class="line">  ConnectionHolder holder = connections.get(theServerID);</span><br><span class="line">  <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    holder = <span class="keyword">new</span> ConnectionHolder(<span class="keyword">this</span>, theServerID, options);</span><br><span class="line">    ConnectionHolder prevHolder = connections.putIfAbsent(theServerID, holder);</span><br><span class="line">    <span class="keyword">if</span> (prevHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Another one sneaked in</span></span><br><span class="line">      holder = prevHolder;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      holder.connect();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  holder.writeMessage((ClusteredMessage)message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始我们就提到过，节点之间通过Event Bus进行通信的本质是TCP，因此这里需要创建一个<code>NetClient</code>作为TCP服务端，连接到之前获取的<code>ServerID</code>对应的节点然后将消息通过TCP协议发送至接收端。这里Vert.x用一个封装类<code>ConnectionHolder</code>对<code>NetClient</code>进行了一些封装。</p>
<p><code>ClusteredEventBus</code>中维持着一个<code>connections</code>哈希表对用于保存<code>ServerID</code>对应的连接<code>ConnectionHolder</code>。在<code>sendRemote</code>方法中,Event Bus首先会从<code>connections</code>中获取<code>ServerID</code>对应的连接。如果获取不到就创建连接并将其添加至<code>connections</code>记录中并调用对应<code>ConnectionHolder</code>的<code>connect</code>方法建立连接；最后调用<code>writeMessage</code>方法将消息编码后通过TCP发送至对应的接收端。</p>
<p>那么<code>ConnectionHolder</code>是如何实现的呢？我们来看一下其构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConnectionHolder(ClusteredEventBus eventBus, ServerID serverID, EventBusOptions options) &#123;</span><br><span class="line">  <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">  <span class="keyword">this</span>.serverID = serverID;</span><br><span class="line">  <span class="keyword">this</span>.vertx = eventBus.vertx();</span><br><span class="line">  <span class="keyword">this</span>.metrics = eventBus.getMetrics();</span><br><span class="line">  NetClientOptions clientOptions = <span class="keyword">new</span> NetClientOptions(options.toJson());</span><br><span class="line">  ClusteredEventBus.setCertOptions(clientOptions, options.getKeyCertOptions());</span><br><span class="line">  ClusteredEventBus.setTrustOptions(clientOptions, options.getTrustOptions());</span><br><span class="line">  client = <span class="keyword">new</span> NetClientImpl(eventBus.vertx(), clientOptions, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>ConnectionHolder</code>初始化的时候会创建一个<code>NetClient</code>作为TCP请求端，而请求的对象就是接收端的<code>NetServer</code>(后边会讲)，客户端配置已经在<code>EventBusOptions</code>中事先配置好了。我们来看看<code>connect</code>方法是如何建立连接的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (connected) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already connected"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  client.connect(serverID.port, serverID.host, res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">      connected(res.result());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里很简单地调用了<code>NetClient#connect</code>方法建立TCP连接，如果建立连接成功的话会得到一个<code>NetSocket</code>对象。Event Bus接着将其传至<code>connected</code>方法中进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(NetSocket socket)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.socket = socket;</span><br><span class="line">  connected = <span class="keyword">true</span>;</span><br><span class="line">  socket.exceptionHandler(t -&gt; close());</span><br><span class="line">  socket.closeHandler(v -&gt; close());</span><br><span class="line">  socket.handler(data -&gt; &#123;</span><br><span class="line">    <span class="comment">// Got a pong back</span></span><br><span class="line">    vertx.cancelTimer(timeoutID);</span><br><span class="line">    schedulePing();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Start a pinger</span></span><br><span class="line">  schedulePing();</span><br><span class="line">  <span class="keyword">for</span> (ClusteredMessage message : pending) &#123;</span><br><span class="line">    Buffer data = message.encodeToWire();</span><br><span class="line">    metrics.messageWritten(message.address(), data.length());</span><br><span class="line">    socket.write(data);</span><br><span class="line">  &#125;</span><br><span class="line">  pending.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先Event Bus通过<code>exceptionHandler</code>和<code>closeHandler</code>方法给连接对应的<code>NetSocket</code>绑定异常回调和连接关闭回调，触发的时候都调用<code>close</code>方法关闭连接；为了保证不丢失连接，消息发送方每隔一段时间就需要对消息接收方发送一次心跳包（<code>PING</code>），如果消息接收方在一定时间内没有回复，那么就认为连接丢失，调用<code>close</code>方法关闭连接。心跳检测的逻辑在<code>schedulePing</code>方法中，比较清晰，这里就不详细说了。大家会发现<code>ConnectionHolder</code>里也有个消息队列（缓冲区）<code>pending</code>，并且这里会将队列中的消息依次通过TCP发送至接收端。为什么需要这样呢？其实，这要从创建TCP客户端说起。创建TCP客户端这个过程应该是异步的，需要消耗一定时间，而<code>ConnectionHolder</code>中封装的<code>connect</code>方法却是同步式的。前面我们刚刚看过，通过<code>connect</code>方法建立连接以后会接着调用<code>writeMessage</code>方法发送消息，而这时候客户端连接可能还没建立，因此需要这么个缓冲区先存着，等着连接建立了再一块发送出去（存疑：为什么不将<code>connect</code>方法直接设计成异步的？）。</p>
<p>至于发送消息的<code>writeMessage</code>方法，其逻辑一目了然：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeMessage</span><span class="params">(ClusteredMessage message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (connected) &#123;</span><br><span class="line">    Buffer data = message.encodeToWire();</span><br><span class="line">    metrics.messageWritten(message.address(), data.length());</span><br><span class="line">    socket.write(data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pending == <span class="keyword">null</span>) &#123;</span><br><span class="line">      pending = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    pending.add(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果连接已建立，Event Bus就会调用对应<code>ClusteredMessage</code>的<code>encodeToWire</code>方法将其转化为字节流<code>Buffer</code>，然后记录metrics信息，最后通过<code>socket</code>的<code>write</code>方法将消息写入到Socket中，这样消息就从发送端通过TCP发送到了接收端。如果连接未建立，就如之前讲的那样，先把消息存到消息队列中，等连接建立了再一块发出去。</p>
<p>这样，Clustered Event Bus下消息的发送逻辑就理清楚了。下面我们看一下接收端是如何接收消息并在本地进行消息的处理的。</p>
<h1 id="消息的接收">消息的接收</h1><p>一开始我们提到过，每个节点的Clustered Event Bus在启动时都会创建一个<code>NetServer</code>作为接收消息的TCP服务端。TCP Server的<code>port</code>和<code>host</code>可以在<code>EventBusOptions</code>中指定，如果不指定的话默认随机分配<code>port</code>，然后Event Bus会根据<code>NetServer</code>的配置来生成当前节点的<code>ServerID</code>。</p>
<p>创建TCP Server的逻辑在<code>start</code>方法中，与接受消息有关的逻辑就是这一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.connectHandler(getServerHandler());</span><br></pre></td></tr></table></figure>
<p>我们知道，<code>NetServer</code>的<code>connectHandler</code>方法用于绑定对服务端Socket的处理函数，而这里绑定的处理函数是由<code>getServerHandler</code>方法生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Handler&lt;NetSocket&gt; <span class="title">getServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> socket -&gt; &#123;</span><br><span class="line">    RecordParser parser = RecordParser.newFixed(<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line">    Handler&lt;Buffer&gt; handler = <span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">      <span class="keyword">int</span> size = -<span class="number">1</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == -<span class="number">1</span>) &#123;</span><br><span class="line">          size = buff.getInt(<span class="number">0</span>);</span><br><span class="line">          parser.fixedSizeMode(size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ClusteredMessage received = <span class="keyword">new</span> ClusteredMessage();</span><br><span class="line">          received.readFromWire(buff, codecManager);</span><br><span class="line">          metrics.messageRead(received.address(), buff.length());</span><br><span class="line">          parser.fixedSizeMode(<span class="number">4</span>);</span><br><span class="line">          size = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (received.codec() == CodecManager.PING_MESSAGE_CODEC) &#123;</span><br><span class="line">            <span class="comment">// Just send back pong directly on connection</span></span><br><span class="line">            socket.write(PONG);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deliverMessageLocally(received);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    parser.setOutput(handler);</span><br><span class="line">    socket.handler(parser);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑非常清晰。这里Event Bus使用了<code>RecordParser</code>来获取发送过来的对应长度的<code>Buffer</code>，并将其绑定在<code>NetServer</code>的Socket上。真正的解析<code>Buffer</code>并处理的逻辑在内部的<code>handler</code>中。之前<code>ClusteredMessage</code>中的Wire Protocol规定<code>Buffer</code>的首部第一个<code>int</code>值为要发送<code>Buffer</code>的长度（逻辑见<code>ClusteredMessage#encodeToWire</code>方法），因此这里首先获取长度，然后给<code>parser</code>设定正确的fixed size，这样<code>parser</code>就可以截取正确长度的<code>Buffer</code>流了。下面Event Bus会创建一个空的<code>ClusteredMessage</code>，然后调用其<code>readFromWire</code>方法从<code>Buffer</code>中重建消息。当然这里还要记录消息已经读取的metrics信息。接着检测收到的消息实体类型是否为心跳检测包(<code>PING</code>)，如果是的话就发送回ACK消息(<code>PONG</code>)；如果不是心跳包，则代表是正常的消息，Event Bus就调用我们熟悉的<code>deliverMessageLocally</code>函数在本地进行分发处理，接下来的过程就和Local模式一样了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-vertx-advanced-local-event-bus-internal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Vert-x/vertx-advanced-local-event-bus-internal/" class="article-date">
      <time datetime="2016-09-02T16:00:00.000Z" itemprop="datePublished">2016-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Vert-x/vertx-advanced-local-event-bus-internal/">Vert.x 技术内幕 | Event Bus 源码分析 (Local模式)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Event Bus是Vert.x的“神经系统”，是最为关键的几个部分之一。今天我们就来探索一下Event Bus的实现原理。本篇分析的是Local模式的Event Bus，对应的Vert.x版本为<strong>3.3.2</strong>。</p>
<p>本文假定读者有一定的并发编程基础以及Vert.x使用基础，并且对Vert.x的线程模型以及<a href="http://vertx.io/docs/vertx-core/java/#streams" target="_blank" rel="external">back-pressure</a>有所了解。</p>
<h1 id="Local_Event_Bus的创建">Local Event Bus的创建</h1><p>一般情况下，我们通过<code>Vertx</code>的<code>eventBus</code>方法来创建或获取一个<code>EventBus</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vertx vertx = Vertx.vertx();</span><br><span class="line">EventBus eventBus = vertx.eventBus();</span><br></pre></td></tr></table></figure>
<p><code>eventBus</code>方法定义于<code>Vertx</code>接口中，我们来看一下其位于<code>VertxImpl</code>类中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">eventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (eventBus == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If reading from different thread possibility that it's been set but not visible - so provide</span></span><br><span class="line">    <span class="comment">// memory barrier</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> eventBus;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> eventBus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到此方法返回<code>VertxImpl</code>实例中的<code>eventBus</code>成员，同时需要注意并发可见性问题。那么<code>eventBus</code>成员是何时初始化的呢？答案在<code>VertxImpl</code>类的构造函数中。这里截取相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.isClustered()) &#123;</span><br><span class="line">  <span class="comment">// 集群模式相关逻辑</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.clusterManager = <span class="keyword">null</span>;</span><br><span class="line">  createAndStartEventBus(options, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>VertxImpl</code>内部是通过<code>createAndStartEventBus</code>方法来初始化<code>eventBus</code>的。我们来看一下其逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndStartEventBus</span><span class="params">(VertxOptions options, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options.isClustered()) &#123;</span><br><span class="line">    eventBus = <span class="keyword">new</span> ClusteredEventBus(<span class="keyword">this</span>, options, clusterManager, haManager);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    eventBus = <span class="keyword">new</span> EventBusImpl(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  eventBus.start(ar2 -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ar2.succeeded()) &#123;</span><br><span class="line">      <span class="comment">// If the metric provider wants to use the event bus, it cannot use it in its constructor as the event bus</span></span><br><span class="line">      <span class="comment">// may not be initialized yet. We invokes the eventBusInitialized so it can starts using the event bus.</span></span><br><span class="line">      metrics.eventBusInitialized(eventBus);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (resultHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resultHandler.handle(Future.succeededFuture(<span class="keyword">this</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(<span class="string">"Failed to start event bus"</span>, ar2.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到此方法通过<code>eventBus = new EventBusImpl(this)</code>将<code>eventBus</code>进行了初始化(Local模式为<code>EventBusImpl</code>)，并且调用<code>eventBus</code>的<code>start</code>方法对其进行一些额外的初始化工作。我们来看一下<code>EventBusImpl</code>类的<code>start</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (started) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already started"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  started = <span class="keyword">true</span>;</span><br><span class="line">  completionHandler.handle(Future.succeededFuture());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先初始化过程需要防止race condition，因此方法为<code>synchronized</code>的。该方法仅仅将<code>EventBusImpl</code>类中的一个<code>started</code>标志位设为<code>true</code>来代表Event Bus已启动。注意<code>started</code>标志位为<code>volatile</code>的，这样可以保证其可见性，确保其它线程通过<code>checkStarted</code>方法读到的<code>started</code>结果总是最新的。设置完<code>started</code>标志位后，Vert.x会接着调用传入的<code>completionHandler</code>处理函数，也就是上面我们在<code>createAndStartEventBus</code>方法中看到的 —— 调用<code>metrics</code>成员的<code>eventBusInitialized</code>方法以便Metrics类可以在Event Bus初始化完毕后使用它（不过默认情况下此方法的逻辑为空）。</p>
<p>可以看到初始化过程还是比较简单的，我们接下来先来看看订阅消息 —— <code>consumer</code>方法的逻辑。</p>
<h1 id="consume">consume</h1><p>我们来看一下<code>consumer</code>方法的逻辑，其原型位于<code>EventBus</code>接口中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address, Handler&lt;Message&lt;T&gt;&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其实现位于<code>EventBusImpl</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address, Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(handler, <span class="string">"handler"</span>);</span><br><span class="line">  MessageConsumer&lt;T&gt; consumer = consumer(address);</span><br><span class="line">  consumer.handler(handler);</span><br><span class="line">  <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要确保传入的<code>handler</code>不为空，然后Vert.x会调用只接受一个<code>address</code>参数的<code>consumer</code>方法获取对应的<code>MessageConsumer</code>，最后给获取到的<code>MessageConsumer</code>绑定上传入的<code>handler</code>。我们首先来看一下另一个<code>consumer</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">  checkStarted();</span><br><span class="line">  Objects.requireNonNull(address, <span class="string">"address"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HandlerRegistration&lt;&gt;(vertx, metrics, <span class="keyword">this</span>, address, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先Vert.x会检查Event Bus是否已经启动，并且确保传入的地址不为空。然后Vert.x会传入一大堆参数创建一个新的<code>HandlerRegistration</code>类型的实例，并返回。可以推测<code>HandlerRegistration</code>是<code>MessageConsumer</code>接口的具体实现，它一定非常重要。所以我们来看一看<code>HandlerRegistration</code>类是个啥玩意。首先看一下<code>HandlerRegistration</code>的类体系结构：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertx-handlerregistration-ch.png" alt=""></p>
<p>可以看到<code>HandlerRegistration</code>类同时继承了<code>MessageConsumer&lt;T&gt;</code>以及<code>Handler&lt;Message&lt;T&gt;&gt;</code>接口，从其类名可以看出它相当于一个”Handler注册记录”，是非常重要的一个类。它有一堆的成员变量，构造函数对<code>vertx</code>, <code>metrics</code>, <code>eventBus</code>, <code>address</code>（发送地址）, <code>repliedAddress</code>（回复地址）, <code>localOnly</code>（是否在集群内传播）, <code>asyncResultHandler</code>等几个成员变量进行初始化，并且检查超时时间<code>timeout</code>，如果设定了超时时间那么设定并保存超时计时器（仅用于reply handler中），如果计时器时间到，代表回复超时。因为有一些函数还没介绍，超时的逻辑我们后边再讲。</p>
<blockquote>
<p>Note: 由于<code>MessageConsumer</code>接口继承了<code>ReadStream</code>接口，因此它支持back-pressure，其实现就在<code>HandlerRegistration</code>类中。我们将稍后解析back-pressure的实现。</p>
</blockquote>
<p>现在回到<code>consumer</code>方法中来。创建了<code>MessageConsumer</code>实例后，我们接着调用它的<code>handler</code>方法绑定上对应的消息处理函数。<code>handler</code>方法的实现位于<code>HandlerRegistration</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> MessageConsumer&lt;T&gt; <span class="title">handler</span><span class="params">(Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handler != <span class="keyword">null</span> &amp;&amp; !registered) &#123;</span><br><span class="line">    registered = <span class="keyword">true</span>;</span><br><span class="line">    eventBus.addRegistration(address, <span class="keyword">this</span>, repliedAddress != <span class="keyword">null</span>, localOnly);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.handler == <span class="keyword">null</span> &amp;&amp; registered) &#123;</span><br><span class="line">    <span class="comment">// This will set registered to false</span></span><br><span class="line">    <span class="keyword">this</span>.unregister();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，<code>handler</code>方法将此<code>HandlerRegistration</code>中的<code>handler</code>成员设置为传入的消息处理函数。<code>HandlerRegistration</code>类中有一个<code>registered</code>标志位代表是否已绑定消息处理函数。<code>handler</code>方法会检查传入的<code>handler</code>是否为空且是否已绑定消息处理函数。如果不为空且未绑定，Vert.x就会将<code>registered</code>标志位设为<code>true</code>并且调用<code>eventBus</code>的<code>addRegistration</code>方法将此consumer注册至Event Bus上；如果<code>handler</code>为空且已绑定消息处理函数，我们就调用<code>unregister</code>方法注销当前的consumer。我们稍后会分析<code>unregister</code>方法的实现。</p>
<p>前面提到过注册consumer的逻辑位于Event Bus的<code>addRegistration</code>方法中，因此我们来分析一下它的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; registration,</span><br><span class="line">                                   <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(registration.getHandler(), <span class="string">"handler"</span>);</span><br><span class="line">  <span class="keyword">boolean</span> newAddress = addLocalRegistration(address, registration, replyHandler, localOnly);</span><br><span class="line">  addRegistration(newAddress, address, replyHandler, localOnly, registration::setResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addRegistration</code>方法接受四个参数：发送地址<code>address</code>、传入的consumer <code>registration</code>、代表是否为reply handler的标志位<code>replyHandler</code>以及代表是否在集群范围内传播的标志位<code>localOnly</code>。首先确保传入的<code>HandlerRegistration</code>不为空。然后Vert.x会调用<code>addLocalRegistration</code>方法将此consumer注册至Event Bus上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">addLocalRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; registration,</span><br><span class="line">                                           <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(address, <span class="string">"address"</span>);</span><br><span class="line"></span><br><span class="line">  Context context = Vertx.currentContext();</span><br><span class="line">  <span class="keyword">boolean</span> hasContext = context != <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!hasContext) &#123;</span><br><span class="line">    <span class="comment">// Embedded</span></span><br><span class="line">    context = vertx.getOrCreateContext();</span><br><span class="line">  &#125;</span><br><span class="line">  registration.setHandlerContext(context);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> newAddress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  HandlerHolder holder = <span class="keyword">new</span> HandlerHolder&lt;&gt;(metrics, registration, replyHandler, localOnly, context);</span><br><span class="line"></span><br><span class="line">  Handlers handlers = handlerMap.get(address);</span><br><span class="line">  <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handlers = <span class="keyword">new</span> Handlers();</span><br><span class="line">    Handlers prevHandlers = handlerMap.putIfAbsent(address, handlers);</span><br><span class="line">    <span class="keyword">if</span> (prevHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handlers = prevHandlers;</span><br><span class="line">    &#125;</span><br><span class="line">    newAddress = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  handlers.list.add(holder);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasContext) &#123;</span><br><span class="line">    HandlerEntry entry = <span class="keyword">new</span> HandlerEntry&lt;&gt;(address, registration);</span><br><span class="line">    context.addCloseHook(entry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先该方法要确保地址<code>address</code>不为空，接着它会获取当前线程下对应的Vert.x Context，如果获取不到则表明当前不在<code>Verticle</code>中（即Embedded），需要调用<code>vertx.getOrCreateContext()</code>来获取<code>Context</code>；然后将获取到的<code>Context</code>赋值给<code>registration</code>内部的<code>handlerContext</code>（代表消息处理对应的Vert.x Context）。</p>
<p>下面就要将给定的<code>registration</code>注册至Event Bus上了。这里Vert.x用一个<code>HandlerHolder</code>类来包装<code>registration</code>和<code>context</code>。接着Vert.x会从存储消息处理<code>Handler</code>的哈希表<code>handlerMap</code>中获取给定地址对应的<code>Handlers</code>，哈希表的类型为<code>ConcurrentMap&lt;String, Handlers&gt;</code>，key为地址，value为对应的<code>HandlerHolder</code>集合。注意这里的<code>Handlers</code>类代表一些<code>Handler</code>的集合，它内部维护着一个列表<code>list</code>用于存储每个<code>HandlerHolder</code>。<code>Handlers</code>类中只有一个<code>choose</code>函数，此函数根据轮询算法从<code>HandlerHolder</code>集合中选定一个<code>HandlerHolder</code>，这即是Event Bus发送消息时实现load-balancing的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handlers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger pos = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> List&lt;HandlerHolder&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HandlerHolder <span class="title">choose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> size = list.size();</span><br><span class="line">      <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> p = pos.getAndIncrement();</span><br><span class="line">      <span class="keyword">if</span> (p &gt;= size - <span class="number">1</span>) &#123;</span><br><span class="line">        pos.set(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(p);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="comment">// Can happen</span></span><br><span class="line">        pos.set(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到对应的<code>handlers</code>以后，Vert.x首先需要检查其是否为空，如果为空代表此地址还没有注册消息处理<code>Handler</code>，Vert.x就会创建一个<code>Handlers</code>并且将其置入<code>handlerMap</code>中，将<code>newAddress</code>标志位设为<code>true</code>代表这是一个新注册的地址，然后将其赋值给<code>handlers</code>。接着我们向<code>handlers</code>中的<code>HandlerHolder</code>列表<code>list</code>中添加刚刚创建的<code>HandlerHolder</code>实例，这样就将<code>registration</code>注册至Event Bus中了。</p>
<p>前面判断当前线程是否在Vert.x Context的标志位<code>hasContext</code>还有一个用途：如果当前线程在Vert.x Context下（比如在Verticle中），Vert.x会通过<code>addCloseHook</code>方法给当前的<code>context</code>添加一个钩子函数用于注销当前绑定的<code>registration</code>。当对应的<code>Verticle</code>被undeploy的时候，此Verticle绑定的所有消息处理<code>Handler</code>都会被unregister。Hook的类型为<code>HandlerEntry&lt;T&gt;</code>，它继承了<code>Closeable</code>接口，对应的逻辑在<code>close</code>函数中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerEntry</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String address;</span><br><span class="line">  <span class="keyword">final</span> HandlerRegistration&lt;T&gt; handler;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HandlerEntry</span><span class="params">(String address, HandlerRegistration&lt;T&gt; handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Called by context on undeploy</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">    handler.unregister(completionHandler);</span><br><span class="line">    completionHandler.handle(Future.succeededFuture());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>close</code>函数会将绑定的<code>registration</code>从Event Bus的<code>handlerMap</code>中移除并执行<code>completionHandler</code>中的逻辑，<code>completionHandler</code>可由用户指定。</p>
<p>那么在哪里调用这些绑定的hook呢？答案是在<code>DeploymentManager</code>类中的<code>doUndeploy</code>方法中，通过<code>context</code>的<code>runCloseHooks</code>方法执行绑定的hook函数。相关代码如下（只截取相关逻辑）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doUndeploy</span><span class="params">(ContextImpl undeployingContext, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 前面代码略</span></span><br><span class="line">  context.runCloseHooks(ar2 -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ar2.failed()) &#123;</span><br><span class="line">      <span class="comment">// Log error but we report success anyway</span></span><br><span class="line">      log.error(<span class="string">"Failed to run close hook"</span>, ar2.cause());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ar.succeeded() &amp;&amp; undeployCount.incrementAndGet() == numToUndeploy) &#123;</span><br><span class="line">      reportSuccess(<span class="keyword">null</span>, undeployingContext, completionHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ar.failed() &amp;&amp; !failureReported.get()) &#123;</span><br><span class="line">      failureReported.set(<span class="keyword">true</span>);</span><br><span class="line">      reportFailure(ar.cause(), undeployingContext, completionHandler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 后面代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到<code>addRegistration</code>方法中。刚才<code>addLocalRegistration</code>方法的返回值<code>newAddress</code>代表对应的地址是否为新注册的。接着我们调用另一个版本的<code>addRegistration</code>方法，传入了一大堆参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addRegistration</span><span class="params">(<span class="keyword">boolean</span> newAddress, String address,</span><br><span class="line">                                   <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly,</span><br><span class="line">                                   Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">  completionHandler.handle(Future.succeededFuture());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，传入的前几个参数没用到。。。最后一个参数<code>completionHandler</code>传入的是<code>registration::setResult</code>方法引用，也就是说这个方法调用了对应<code>registration</code>的<code>setResult</code>方法。其实现位于<code>HandlerRegistration</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(AsyncResult&lt;Void&gt; result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.result = result;</span><br><span class="line">  <span class="keyword">if</span> (completionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">      metric = metrics.handlerRegistered(address, repliedAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    Handler&lt;AsyncResult&lt;Void&gt;&gt; callback = completionHandler;</span><br><span class="line">    vertx.runOnContext(v -&gt; callback.handle(result));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.failed()) &#123;</span><br><span class="line">    log.error(<span class="string">"Failed to propagate registration for handler "</span> + handler + <span class="string">" and address "</span> + address);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    metric = metrics.handlerRegistered(address, repliedAddress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先先设置<code>registration</code>内部的<code>result</code>成员（正常情况下为<code>Future.succeededFuture()</code>）。接着Vert.x会判断<code>registration</code>是否绑定了<code>completionHandler</code>（与之前的<code>completionHandler</code>不同，这里的<code>completionHandler</code>是<code>MessageConsumer</code>注册成功时调用的<code>Handler</code>），若绑定则记录Metrics信息(<code>handlerRegistered</code>)并在Vert.x Context内调用<code>completionHandler</code>的逻辑；若未绑定<code>completionHandler</code>则仅记录Metrics信息。</p>
<p>到此为止，<code>consumer</code>方法的逻辑就分析完了。在分析<code>send</code>和<code>publish</code>方法的逻辑之前，我们先来看一下如何注销绑定的<code>MessageConsumer</code>。</p>
<h1 id="unregister">unregister</h1><p>我们通过调用<code>MessageConsumer</code>的<code>unregister</code>方法实现注销操作。Vert.x提供了两个版本的<code>unregister</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中第二个版本的<code>unregister</code>方法会在注销操作完成时调用传入的<code>completionHandler</code>。比如在cluster范围内注销consumer需要消耗一定的时间在集群内传播，因此第二个版本的方法就会派上用场。我们来看一下其实现，它们最后都是调用了<code>HandlerRegistration</code>类的<code>doUnregister</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler, <span class="keyword">boolean</span> callEndHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (timeoutID != -<span class="number">1</span>) &#123;</span><br><span class="line">    vertx.cancelTimer(timeoutID);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (endHandler != <span class="keyword">null</span> &amp;&amp; callEndHandler) &#123;</span><br><span class="line">    Handler&lt;Void&gt; theEndHandler = endHandler;</span><br><span class="line">    Handler&lt;AsyncResult&lt;Void&gt;&gt; handler = completionHandler;</span><br><span class="line">    completionHandler = ar -&gt; &#123;</span><br><span class="line">      theEndHandler.handle(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler.handle(ar);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">    registered = <span class="keyword">false</span>;</span><br><span class="line">    eventBus.removeRegistration(address, <span class="keyword">this</span>, completionHandler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    callCompletionHandlerAsync(completionHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  registered = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果设定了超时定时器(<code>timeoutID</code>合法)，那么Vert.x会首先将定时器关闭。接着Vert.x会判断是否需要调用<code>endHandler</code>。那么<code>endHandler</code>又是什么呢？前面我们提到过<code>MessageConsumer</code>接口继承了<code>ReadStream</code>接口，而<code>ReadStream</code>接口定义了一个<code>endHandler</code>方法用于绑定一个<code>endHandler</code>，当stream中的数据读取完毕时会调用。而在Event Bus中，消息源源不断地从一处发送至另一处，因此只有在某个consumer<br>被unregister的时候，其对应的stream才可以叫“读取完毕”，因此Vert.x选择在<code>doUnregister</code>方法中调用<code>endHandler</code>。</p>
<p>接着Vert.x会判断此consumer是否已注册消息处理函数<code>Handler</code>（通过检查<code>registered</code>标志位），若已注册则将对应的<code>Handler</code>从Event Bus中的<code>handlerMap</code>中移除并将<code>registered</code>设为<code>false</code>；若还未注册<code>Handler</code>且提供了注销结束时的回调<code>completionHandler</code>(注意不是<code>HandlerRegistration</code>类的成员变量<code>completionHandler</code>，而是之前第二个版本的<code>unregister</code>中传入的<code>Handler</code>，用同样的名字很容易混。。。)，则通过<code>callCompletionHandlerAsync</code>方法调用回调函数。</p>
<p>从Event Bus中移除<code>Handler</code>的逻辑位于<code>EventBusImpl</code>类的<code>removeRegistration</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; handler, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">  HandlerHolder holder = removeLocalRegistration(address, handler);</span><br><span class="line">  removeRegistration(holder, address, completionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeRegistration</span><span class="params">(HandlerHolder handlerHolder, String address,</span><br><span class="line">                                      Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">  callCompletionHandlerAsync(completionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">HandlerHolder <span class="title">removeLocalRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; handler)</span> </span>&#123;</span><br><span class="line">  Handlers handlers = handlerMap.get(address);</span><br><span class="line">  HandlerHolder lastHolder = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (handlers) &#123;</span><br><span class="line">      <span class="keyword">int</span> size = handlers.list.size();</span><br><span class="line">      <span class="comment">// Requires a list traversal. This is tricky to optimise since we can't use a set since</span></span><br><span class="line">      <span class="comment">// we need fast ordered traversal for the round robin</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        HandlerHolder holder = handlers.list.get(i);</span><br><span class="line">        <span class="keyword">if</span> (holder.getHandler() == handler) &#123;</span><br><span class="line">          handlers.list.remove(i);</span><br><span class="line">          holder.setRemoved();</span><br><span class="line">          <span class="keyword">if</span> (handlers.list.isEmpty()) &#123;</span><br><span class="line">            handlerMap.remove(address);</span><br><span class="line">            lastHolder = holder;</span><br><span class="line">          &#125;</span><br><span class="line">          holder.getContext().removeCloseHook(<span class="keyword">new</span> HandlerEntry&lt;&gt;(address, holder.getHandler()));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lastHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其真正的<code>unregister</code>逻辑位于<code>removeLocalRegistration</code>方法中。首先需要从<code>handlerMap</code>中获取地址对应的<code>Handlers</code>实例<code>handlers</code>，如果<code>handlers</code>不为空，为了防止并发问题，Vert.x需要对其加锁后再进行操作。Vert.x需要遍历<code>handlers</code>中的列表，遇到与传入的<code>HandlerRegistration</code>相匹配的<code>HandlerHolder</code>就将其从列表中移除，然后调用对应<code>holder</code>的<code>setRemoved</code>方法标记其为已注销并记录Metrics数据（<code>handlerUnregistered</code>）。如果移除此<code>HandlerHolder</code>后<code>handlers</code>没有任何注册的<code>Handler</code>了，就将该地址对应的<code>Handlers</code>实例从<code>handlerMap</code>中移除并保存刚刚移除的<code>HandlerHolder</code>。另外，由于已经将此consumer注销，在undeploy verticle的时候不需要再进行unregister，因此这里还要将之前注册到context的hook移除。</p>
<p>调用完<code>removeLocalRegistration</code>方法以后，Vert.x会调用另一个版本的<code>removeRegistration</code>方法，调用<code>completionHandler</code>（用户在第二个版本的<code>unregister</code>方法中传入的处理函数）对应的逻辑，其它的参数都没什么用。。。</p>
<p>这就是<code>MessageConsumer</code>注销的逻辑实现。下面就到了本文的另一重头戏了 —— 发送消息相关的函数<code>send</code>和<code>publish</code>。</p>
<h1 id="send_&amp;_publish">send &amp; publish</h1><p><code>send</code>和<code>publish</code>的逻辑相近，只不过一个是发送至目标地址的某一消费者，一个是发布至目标地址的所有消费者。Vert.x使用一个标志位<code>send</code>来代表是否为点对点发送模式。</p>
<p>几个版本的<code>send</code>和<code>publish</code>最终都归结于生成消息对象然后调用<code>sendOrPubInternal</code>方法执行逻辑，只不过<code>send</code>标志位不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">EventBus <span class="title">send</span><span class="params">(String address, Object message, DeliveryOptions options, Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</span><br><span class="line">  sendOrPubInternal(createMessage(<span class="keyword">true</span>, address, options.getHeaders(), message, options.getCodecName()), options, replyHandler);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">publish</span><span class="params">(String address, Object message, DeliveryOptions options)</span> </span>&#123;</span><br><span class="line">  sendOrPubInternal(createMessage(<span class="keyword">false</span>, address, options.getHeaders(), message, options.getCodecName()), options, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法中都是通过<code>createMessage</code>方法来生成对应的消息对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MessageImpl <span class="title">createMessage</span><span class="params">(<span class="keyword">boolean</span> send, String address, MultiMap headers, Object body, String codecName)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(address, <span class="string">"no null address accepted"</span>);</span><br><span class="line">  MessageCodec codec = codecManager.lookupCodec(body, codecName);</span><br><span class="line">  <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  MessageImpl msg = <span class="keyword">new</span> MessageImpl(address, <span class="keyword">null</span>, headers, body, codec, send, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createMessage</code>方法接受5个参数：<code>send</code>即上面提到的标志位，<code>address</code>为发送目标地址，<code>headers</code>为设置的header，<code>body</code>代表发送的对象，<code>codecName</code>代表对应的Codec（消息编码解码器）名称。<code>createMessage</code>方法首先会确保地址不为空，然后通过<code>codecManager</code>来获取对应的<code>MessageCodec</code>。如果没有提供Codec(即<code>codecName</code>为空)，那么<code>codecManager</code>会根据发送对象<code>body</code>的类型来提供内置的Codec实现（具体逻辑请见<a href="https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/eventbus/impl/CodecManager.java#L47" target="_blank" rel="external">此处</a>）。准备好<code>MessageCodec</code>后，<code>createMessage</code>方法就会创建一个<code>MessageImpl</code>实例并且返回。</p>
<p>这里我们还需要了解一下<code>MessageImpl</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageImpl</span><span class="params">(String address, String replyAddress, MultiMap headers, U sentBody,</span><br><span class="line">                   MessageCodec&lt;U, V&gt; messageCodec,</span><br><span class="line">                   <span class="keyword">boolean</span> send, EventBusImpl bus)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.messageCodec = messageCodec; <span class="comment">// Codec</span></span><br><span class="line">  <span class="keyword">this</span>.address = address; <span class="comment">// 发送目标地址</span></span><br><span class="line">  <span class="keyword">this</span>.replyAddress = replyAddress; <span class="comment">// 回复地址</span></span><br><span class="line">  <span class="keyword">this</span>.headers = headers; <span class="comment">// header</span></span><br><span class="line">  <span class="keyword">this</span>.sentBody = sentBody; <span class="comment">// 发送的对象</span></span><br><span class="line">  <span class="keyword">this</span>.send = send; <span class="comment">// 是否为点对点模式</span></span><br><span class="line">  <span class="keyword">this</span>.bus = bus; <span class="comment">// 相关的Event Bus实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createMessage</code>方法并没有设置回复地址<code>replyAddress</code>。如果用户指定了<code>replyHandler</code>的话，后边<code>sendOrPubInternal</code>方法会对此消息实体进行加工，设置<code>replyAddress</code>并生成回复逻辑对应的<code>HandlerRegistration</code>。</p>
<p>我们看一下<code>sendOrPubInternal</code>方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendOrPubInternal</span><span class="params">(MessageImpl message, DeliveryOptions options,</span><br><span class="line">                                   Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</span><br><span class="line">  checkStarted();</span><br><span class="line">  HandlerRegistration&lt;T&gt; replyHandlerRegistration = createReplyHandlerRegistration(message, options, replyHandler);</span><br><span class="line">  SendContextImpl&lt;T&gt; sendContext = <span class="keyword">new</span> SendContextImpl&lt;&gt;(message, options, replyHandlerRegistration);</span><br><span class="line">  sendContext.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它接受三个参数：要发送的消息<code>message</code>，发送配置选项<code>options</code>以及回复处理函数<code>replyHandler</code>。首先<code>sendOrPubInternal</code>方法要检查Event Bus是否已启动，接着如果绑定了回复处理函数，Vert.x就会调用<code>createReplyHandlerRegistration</code>方法给消息实体<code>message</code>包装上回复地址，并且生成对应的reply consumer。接着Vert.x创建了一个包装消息的<code>SendContextImpl</code>实例并调用了其<code>next</code>方法。</p>
<p>我们一步一步来解释。首先是<code>createReplyHandlerRegistration</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">HandlerRegistration&lt;T&gt; <span class="title">createReplyHandlerRegistration</span><span class="params">(MessageImpl message, DeliveryOptions options, Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (replyHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> timeout = options.getSendTimeout();</span><br><span class="line">    String replyAddress = generateReplyAddress();</span><br><span class="line">    message.setReplyAddress(replyAddress);</span><br><span class="line">    Handler&lt;Message&lt;T&gt;&gt; simpleReplyHandler = convertHandler(replyHandler);</span><br><span class="line">    HandlerRegistration&lt;T&gt; registration =</span><br><span class="line">      <span class="keyword">new</span> HandlerRegistration&lt;&gt;(vertx, metrics, <span class="keyword">this</span>, replyAddress, message.address, <span class="keyword">true</span>, replyHandler, timeout);</span><br><span class="line">    registration.handler(simpleReplyHandler);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createReplyHandlerRegistration</code>方法首先检查传入的<code>replyHandler</code>是否为空（是否绑定了<code>replyHandler</code>，回复处理函数），如果为空则代表不需要处理回复，直接返回<code>null</code>；若<code>replyHandler</code>不为空，<code>createReplyHandlerRegistration</code>方法就会从配置中获取reply的最大超时时长(默认30s)，然后调用<code>generateReplyAddress</code>方法生成对应的回复地址<code>replyAddress</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong replySequence = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">generateReplyAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Long.toString(replySequence.incrementAndGet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成回复地址的逻辑有点简单。。。。<code>EventBusImpl</code>实例中维护着一个<code>AtomicLong</code>类型的<code>replySequence</code>成员变量代表对应的回复地址。每次生成的时候都会使其自增，然后转化为String。也就是说生成的<code>replyAddress</code>都类似于”1”、”5”这样，而不是我们想象中的直接回复至sender的地址。。。</p>
<p>生成完毕以后，<code>createReplyHandlerRegistration</code>方法会将生成的<code>replyAddress</code>设定到消息对象<code>message</code>中。接着Vert.x会通过<code>convertHandler</code>方法对<code>replyHandler</code>进行包装处理并生成类型简化为<code>Handler&lt;Message&lt;T&gt;&gt;</code>的<code>simpleReplyHandler</code>，它用于绑定至后面创建的reply consumer上。接着Vert.x会创建对应的reply consumer。关于<code>reply</code>操作的实现，我们后边会详细讲述。下面Vert.x就通过<code>handler</code>方法将生成的回复处理函数<code>simpleReplyHandler</code>绑定至创建好的reply consumer中，其底层实现我们之前已经分析过了，这里就不再赘述。最后此方法返回生成的<code>registration</code>，即对应的reply consumer。注意这个reply consumer是<strong>一次性</strong>的，也就是说Vert.x会在其接收到回复或超时的时候自动对其进行注销。</p>
<p>OK，现在回到<code>sendOrPubInternal</code>方法中来。下面Vert.x会创建一个<code>SendContextImpl</code>实例并调用其<code>next</code>方法。<code>SendContextImpl</code>类实现了<code>SendContext</code>接口，它相当于一个消息的封装体，并且可以与Event Bus中的<code>interceptors</code>（拦截器）结合使用。</p>
<p><code>SendContext</code>接口定义了三个方法：</p>
<ul>
<li><code>message</code>: 获取当前<code>SendContext</code>包装的消息实体</li>
<li><code>next</code>: 调用下一个消息拦截器</li>
<li><code>send</code>: 代表消息的发送模式是否为点对点模式</li>
</ul>
<p>在Event Bus中，消息拦截器本质上是一个<code>Handler&lt;SendContext&gt;</code>类型的处理函数。Event Bus内部存储着一个<code>interceptors</code>列表用于存储绑定的消息拦截器。我们可以通过<code>addInterceptor</code>和<code>removeInterceptor</code>方法进行消息拦截器的添加和删除操作。如果要进行链式拦截，则在每个拦截器中都应该调用对应<code>SendContext</code>的<code>next</code>方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eventBus.addInterceptor(sc -&gt; &#123;</span><br><span class="line">  <span class="comment">// 一些处理逻辑</span></span><br><span class="line">  sc.next(); <span class="comment">// 调用下一个拦截器</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们来看一下<code>SendContextImpl</code>类中<code>next</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SendContextImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">SendContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> MessageImpl message;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> DeliveryOptions options;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> HandlerRegistration&lt;T&gt; handlerRegistration;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Handler&lt;SendContext&gt;&gt; iter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SendContextImpl</span><span class="params">(MessageImpl message, DeliveryOptions options, HandlerRegistration&lt;T&gt; handlerRegistration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">    <span class="keyword">this</span>.handlerRegistration = handlerRegistration;</span><br><span class="line">    <span class="keyword">this</span>.iter = interceptors.iterator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Message&lt;T&gt; <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">      Handler&lt;SendContext&gt; handler = iter.next();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        handler.handle(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">"Failure in interceptor"</span>, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendOrPub(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message.send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>SendContextImpl</code>类中维护了一个拦截器列表对应的迭代器。每次调用<code>next</code>方法时，如果迭代器中存在拦截器，就将下个拦截器取出并进行相关调用。如果迭代器为空，则代表拦截器都已经调用完毕，Vert.x就会调用<code>EventBusImpl</code>类下的<code>sendOrPub</code>方法进行消息的发送操作。</p>
<p><code>sendOrPub</code>方法仅仅在metrics模块中记录相关数据(<code>messageSent</code>)，最后调用<code>deliverMessageLocally(SendContextImpl&lt;T&gt;)</code>方法执行消息的发送逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">deliverMessageLocally</span><span class="params">(SendContextImpl&lt;T&gt; sendContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!deliverMessageLocally(sendContext.message)) &#123;</span><br><span class="line">    <span class="comment">// no handlers</span></span><br><span class="line">    metrics.replyFailure(sendContext.message.address, ReplyFailure.NO_HANDLERS);</span><br><span class="line">    <span class="keyword">if</span> (sendContext.handlerRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">      sendContext.handlerRegistration.sendAsyncResultFailure(ReplyFailure.NO_HANDLERS, <span class="string">"No handlers for address "</span></span><br><span class="line">                                                             + sendContext.message.address);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面又套了一层。。。它最后其实是调用了<code>deliverMessageLocally(MessageImpl)</code>方法。此方法返回值代表发送消息的目标地址是否注册有<code>MessageConsumer</code>，如果没有(<code>false</code>)则记录错误并调用<code>sendContext</code>中保存的回复处理函数处理错误（如果绑定了<code>replyHandler</code>的话）。</p>
<p><code>deliverMessageLocally(MessageImpl)</code>方法是真正区分<code>send</code>和<code>publish</code>的地方，我们来看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">deliverMessageLocally</span><span class="params">(MessageImpl msg)</span> </span>&#123;</span><br><span class="line">  msg.setBus(<span class="keyword">this</span>);</span><br><span class="line">  Handlers handlers = handlerMap.get(msg.address());</span><br><span class="line">  <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.send()) &#123;</span><br><span class="line">      <span class="comment">//Choose one</span></span><br><span class="line">      HandlerHolder holder = handlers.choose();</span><br><span class="line">      metrics.messageReceived(msg.address(), !msg.send(), isMessageLocal(msg), holder != <span class="keyword">null</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        deliverToHandler(msg, holder);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Publish</span></span><br><span class="line">      metrics.messageReceived(msg.address(), !msg.send(), isMessageLocal(msg), handlers.list.size());</span><br><span class="line">      <span class="keyword">for</span> (HandlerHolder holder: handlers.list) &#123;</span><br><span class="line">        deliverToHandler(msg, holder);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    metrics.messageReceived(msg.address(), !msg.send(), isMessageLocal(msg), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先Vert.x需要从<code>handlerMap</code>中获取目标地址对应的处理函数集合<code>handlers</code>。接着，如果<code>handlers</code>不为空的话，Vert.x就会判断消息实体的<code>send</code>标志位。如果<code>send</code>标志位为<code>true</code>则代表以点对点模式发送，Vert.x就会通过<code>handlers</code>的<code>choose</code>方法(之前提到过)，按照轮询算法来获取其中的某一个<code>HandlerHolder</code>。获取到<code>HandlerHolder</code>之后，Vert.x会通过<code>deliverToHandler</code>方法将消息分发至<code>HandlerHolder</code>中进行处理；如果<code>send</code>标志位为<code>false</code>则代表向所有消费者发布消息，Vert.x就会对<code>handlers</code>中的每一个<code>HandlerHolder</code>依次调用<code>deliverToHandler</code>方法，以便将消息分发至所有注册到此地址的<code>Handler</code>中进行处理。</p>
<p>消息处理的真正逻辑就在<code>deliverToHandler</code>方法中。我们来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">deliverToHandler</span><span class="params">(MessageImpl msg, HandlerHolder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Each handler gets a fresh copy</span></span><br><span class="line">  <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  Message&lt;T&gt; copied = msg.copyBeforeReceive();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metrics.isEnabled()) &#123;</span><br><span class="line">    metrics.scheduleMessage(holder.getHandler().getMetric(), msg.isLocal());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  holder.getContext().runOnContext((v) -&gt; &#123;</span><br><span class="line">    <span class="comment">// Need to check handler is still there - the handler might have been removed after the message were sent but</span></span><br><span class="line">    <span class="comment">// before it was received</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!holder.isRemoved()) &#123;</span><br><span class="line">        holder.getHandler().handle(copied);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (holder.isReplyHandler()) &#123;</span><br><span class="line">        holder.getHandler().unregister();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>deliverToHandler</code>方法会复制一份要发送的消息，然后<code>deliverToHandler</code>方法会调用<code>metrics</code>的<code>scheduleMessage</code>方法记录对应的Metrics信息（计划对消息进行处理。此函数修复了<a href="https://github.com/eclipse/vert.x/issues/1480" target="_blank" rel="external">Issue 1480</a>）。接着<code>deliverToHandler</code>方法会从传入的<code>HandlerHolder</code>中获取对应的Vert.x Context，然后调用<code>runOnContext</code>方法以便可以让消息处理逻辑在Vert.x Context中执行。为防止对应的handler在处理之前被移除，这里还需要检查一下<code>holder</code>的<code>isRemoved</code>属性。如果没有移除，那么就从<code>holder</code>中获取对应的<code>handler</code>并调用其<code>handle</code>方法执行消息的处理逻辑。注意这里获取的<code>handler</code>实际上是一个<code>HandlerRegistration</code>。前面提到过<code>HandlerRegistration</code>类同时实现了<code>MessageConsumer</code>接口和<code>Handler</code>接口，因此它兼具这两个接口所期望的功能。另外，之前我们提到过Vert.x会自动注销接收过回复的reply consumer，其逻辑就在这个finally块中。Vert.x会检查<code>holder</code>中的<code>handler</code>是否为reply handler（reply consumer)，如果是的话就调用其<code>unregister</code>方法将其注销，来确保reply consumer为一次性的。</p>
<p>之前我们提到过<code>MessageConsumer</code>继承了<code>ReadStream</code>接口，因此<code>HandlerRegistration</code>需要实现flow control(back-pressure)的相关逻辑。那么如何实现呢？我们看到,<code>HandlerRegistration</code>类中有一个<code>paused</code>标志位代表是否还继续处理消息。<code>ReadStream</code>接口中定义了两个函数用于控制stream的通断：当处理速度小于读取速度(发生拥塞)的时候我们可以通过<code>pause</code>方法暂停消息的传递，将积压的消息暂存于内部的消息队列（缓冲区）<code>pending</code>中；当相对速度正常的时候，我们可以通过<code>resume</code>方法恢复消息的传递和处理。</p>
<p>我们看一下<code>HandlerRegistration</code>中<code>handle</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;T&gt; message)</span> </span>&#123;</span><br><span class="line">  Handler&lt;Message&lt;T&gt;&gt; theHandler;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (paused) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pending.size() &lt; maxBufferedMessages) &#123;</span><br><span class="line">        pending.add(message);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (discardHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">          discardHandler.handle(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(<span class="string">"Discarding message as more than "</span> + maxBufferedMessages + <span class="string">" buffered in paused consumer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (pending.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pending.add(message);</span><br><span class="line">        message = pending.poll();</span><br><span class="line">      &#125;</span><br><span class="line">      theHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  deliver(theHandler, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然。。。<code>handle</code>方法在处理消息的基础上实现了拥塞控制的功能。为了防止资源争用，需要对自身进行加锁；首先<code>handle</code>方法会判断当前的<code>consumer</code>是否为<code>paused</code>状态，如果为<code>paused</code>状态，<code>handle</code>方法会检查当前缓冲区大小是否已经超过给定的最大缓冲区大小<code>maxBufferedMessages</code>，如果没超过，就将收到的消息push到缓冲区中；如果大于或等于阈值，Vert.x就需要丢弃超出的那部分消息。如果当前的<code>consumer</code>为正常状态，则如果缓冲区不为空，就将收到的消息push到缓冲区中并从缓冲区中pull队列首端的消息，然后调用<code>deliver</code>方法执行真正的消息处理逻辑。注意这里是在锁之外执行<code>deliver</code>方法的，这是为了保证在multithreaded worker context下可以并发传递消息（见<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=473714" target="_blank" rel="external">Bug 473714
</a>）。由于multithreaded worker context允许在不同线程并发执行逻辑（见<a href="http://vertx.io/docs/vertx-core/java/#_multi_threaded_worker_verticles" target="_blank" rel="external">官方文档</a>），如果将<code>deliver</code>方法置于<code>synchronized</code>块之内，其他线程必须等待当前锁被释放才能进行消息的传递逻辑，因而不能做到“delivery concurrently”。</p>
<p><code>deliver</code>方法是真正执行“消息处理”逻辑的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Handler&lt;Message&lt;T&gt;&gt; theHandler, Message&lt;T&gt; message)</span> </span>&#123;</span><br><span class="line">  checkNextTick();</span><br><span class="line">  <span class="keyword">boolean</span> local = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (message <span class="keyword">instanceof</span> ClusteredMessage) &#123;</span><br><span class="line">    <span class="comment">// A bit hacky</span></span><br><span class="line">    ClusteredMessage cmsg = (ClusteredMessage)message;</span><br><span class="line">    <span class="keyword">if</span> (cmsg.isFromWire()) &#123;</span><br><span class="line">      local = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  String creditsAddress = message.headers().get(MessageProducerImpl.CREDIT_ADDRESS_HEADER_NAME);</span><br><span class="line">  <span class="keyword">if</span> (creditsAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">    eventBus.send(creditsAddress, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    metrics.beginHandleMessage(metric, local);</span><br><span class="line">    theHandler.handle(message);</span><br><span class="line">    metrics.endHandleMessage(metric, <span class="keyword">null</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">"Failed to handleMessage"</span>, e);</span><br><span class="line">    metrics.endHandleMessage(metric, e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先Vert.x会调用<code>checkNextTick</code>方法来检查消息队列（缓冲区）中是否存在更多的消息等待被处理，如果有的话就取出队列首端的消息并调用<code>deliver</code>方法将其传递给<code>handler</code>进行处理。这里仍需要注意并发问题，相关实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!pending.isEmpty()) &#123;</span><br><span class="line">    handlerContext.runOnContext(v -&gt; &#123;</span><br><span class="line">      Message&lt;T&gt; message;</span><br><span class="line">      Handler&lt;Message&lt;T&gt;&gt; theHandler;</span><br><span class="line">      <span class="keyword">synchronized</span> (HandlerRegistration.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (paused || (message = pending.poll()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        theHandler = handler;</span><br><span class="line">      &#125;</span><br><span class="line">      deliver(theHandler, message);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查完消息队列以后，Vert.x会接着根据<code>message</code>判断消息是否仅在本地进行处理并给<code>local</code>标志位赋值，<code>local</code>标志位将在记录Metrics数据时用到。</p>
<p>接下来我们看到Vert.x从消息的<code>headers</code>中获取了一个地址<code>creditsAddress</code>，如果<code>creditsAddress</code>存在就向此地址发送一条消息，body为<code>1</code>。那么这个<code>creditsAddress</code>又是啥呢？其实，它与flow control有关，我们会在下面详细分析。发送完<code>credit</code>消息以后，接下来就到了调用<code>handler</code>处理消息的时刻了。在处理消息之前需要调用<code>metrics</code>的<code>beginHandleMessage</code>方法记录消息开始处理的metrics数据，在处理完消息以后需要调用<code>endHandleMessage</code>方法记录消息处理结束的metrics数据。</p>
<p>嗯。。。到此为止，消息的发送和处理过程就已经一目了然了。下面我们讲一讲之前代码中出现的<code>creditsAddress</code>到底是啥玩意～</p>
<h1 id="MessageProducer">MessageProducer</h1><p>之前我们提到过，Vert.x定义了两个接口作为 <strong>flow control aware object</strong> 的规范：<code>WriteStream</code>以及<code>ReadStream</code>。对于<code>ReadStream</code>我们已经不再陌生了，<code>MessageConsumer</code>就继承了它；那么大家应该可以想象到，有<code>MessageConsumer</code>就必有<code>MessageProducer</code>。不错，Vert.x中的<code>MessageProducer</code>接口对应某个<code>address</code>上的消息生产者，同时它继承了<code>WriteStream</code>接口，因此<code>MessageProducer</code>的实现类<code>MessageProducerImpl</code>同样具有flow control的能力。我们可以把<code>MessageProducer</code>看做是一个具有flow control功能的增强版的<code>EventBus</code>。我们可以通过<code>EventBus</code>接口的<code>publisher</code>方法创建一个<code>MessageProducer</code>。</p>
<p>对<code>MessageProducer</code>有了初步了解之后，我们就可以解释前面<code>deliver</code>方法中的<code>creditsAddress</code>了。<code>MessageProducer</code>接口的实现类 —— <code>MessageProducerImpl</code>类的流量控制功能是基于<code>credit</code>的，其内部会维护一个<code>credit</code>值代表“发送消息的能力”，其默认值等于<code>DEFAULT_WRITE_QUEUE_MAX_SIZE</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize = DEFAULT_WRITE_QUEUE_MAX_SIZE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> credits = DEFAULT_WRITE_QUEUE_MAX_SIZE;</span><br></pre></td></tr></table></figure>
<p>在采用点对点模式发送消息的时候，<code>MessageProducer</code>底层会调用<code>doSend</code>方法进行消息的发送。发送依然利用Event Bus的<code>send</code>方法，只不过<code>doSend</code>方法中添加了flow control的相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> &lt;R&gt; <span class="function"><span class="keyword">void</span> <span class="title">doSend</span><span class="params">(T data, Handler&lt;AsyncResult&lt;Message&lt;R&gt;&gt;&gt; replyHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (credits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    credits--;</span><br><span class="line">    <span class="keyword">if</span> (replyHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      bus.send(address, data, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      bus.send(address, data, options, replyHandler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pending.add(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>MessageConsumer</code>类似，<code>MessageProducer</code>内部同样保存着一个消息队列（缓冲区）用于暂存堆积的消息。当<code>credits</code>大于<strong>0</strong>的时候代表可以发送消息（没有出现拥塞），Vert.x就会调用Event Bus的<code>send</code>方法进行消息的发送，同时<code>credits</code>要减1；如果<code>credits</code>小于等于0，则代表此时消息发送的速度太快，出现了拥塞，需要暂缓发送，因此将要发送的对象暂存于缓冲区中。大家可能会问，<code>credits</code>值不断减小，那么恢复消息发送能力（增大<code>credits</code>）的逻辑在哪呢？这就要提到<code>creditsAddress</code>了。我们看一下<code>MessageProducerImpl</code>类的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageProducerImpl</span><span class="params">(Vertx vertx, String address, <span class="keyword">boolean</span> send, DeliveryOptions options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vertx = vertx;</span><br><span class="line">  <span class="keyword">this</span>.bus = vertx.eventBus();</span><br><span class="line">  <span class="keyword">this</span>.address = address;</span><br><span class="line">  <span class="keyword">this</span>.send = send;</span><br><span class="line">  <span class="keyword">this</span>.options = options;</span><br><span class="line">  <span class="keyword">if</span> (send) &#123;</span><br><span class="line">    String creditAddress = UUID.randomUUID().toString() + <span class="string">"-credit"</span>;</span><br><span class="line">    creditConsumer = bus.consumer(creditAddress, msg -&gt; &#123;</span><br><span class="line">      doReceiveCredit(msg.body());</span><br><span class="line">    &#125;);</span><br><span class="line">    options.addHeader(CREDIT_ADDRESS_HEADER_NAME, creditAddress);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    creditConsumer = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MessageProducerImpl</code>的构造函数中生成了一个<code>creditAddress</code>，然后给该地址绑定了一个<code>Handler</code>，当收到消息时调用<code>doReceiveCredit</code>方法执行解除拥塞，恢复消息发送的逻辑。<code>MessageProducerImpl</code>会将此<code>MessageConsumer</code>保存，以便在关闭消息生产者流的时候将其注销。接着构造函数会往<code>options</code>的<code>headers</code>中添加一条记录，保存对应的<code>creditAddress</code>，这也就是上面我们在<code>deliver</code>函数中获取的<code>creditAddress</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于HandlerRegistration类的deliver函数中</span></span><br><span class="line">String creditsAddress = message.headers().get(MessageProducerImpl.CREDIT_ADDRESS_HEADER_NAME);</span><br><span class="line"><span class="keyword">if</span> (creditsAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">  eventBus.send(creditsAddress, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，发送消息到<code>creditsAddress</code>的逻辑也就好理解了。由于<code>deliver</code>函数的逻辑就是处理消息，因此这里向<code>creditsAddress</code>发送一个 <strong>1</strong> 其实就是将对应的<code>credits</code>值加1。恢复消息发送的逻辑位于<code>MessageProducerImpl</code>类的<code>doReceiveCredit</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doReceiveCredit</span><span class="params">(<span class="keyword">int</span> credit)</span> </span>&#123;</span><br><span class="line">  credits += credit;</span><br><span class="line">  <span class="keyword">while</span> (credits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    T data = pending.poll();</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      credits--;</span><br><span class="line">      bus.send(address, data, options);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Handler&lt;Void&gt; theDrainHandler = drainHandler;</span><br><span class="line">  <span class="keyword">if</span> (theDrainHandler != <span class="keyword">null</span> &amp;&amp; credits &gt;= maxSize / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.drainHandler = <span class="keyword">null</span>;</span><br><span class="line">    vertx.runOnContext(v -&gt; theDrainHandler.handle(<span class="keyword">null</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑一目了然。首先给<code>credits</code>加上发送过来的值（正常情况下为1），然后恢复发送能力，将缓冲区的数据依次取出、发送然后减小<code>credits</code>。同时如果<code>MessageProducer</code>绑定了<code>drainHandler</code>(消息流不拥塞的时候调用的逻辑，详见<a href="http://vertx.io/docs/vertx-core/java/#_writestream" target="_blank" rel="external">官方文档</a>)，并且<code>MessageProducer</code>发送的消息不再拥塞（<code>credits &gt;= maxSize / 2</code>），那么就在Vert.x Context中执行<code>drainHandler</code>中的逻辑。</p>
<p>怎么样，体会到Vert.x中flow control的强大之处了吧！官方文档中<code>MessageProducer</code>的篇幅几乎没有，只在介绍<code>WriteStream</code>的时候提了提，因此这部分也可以作为<code>MessageProducer</code>的参考。</p>
<h1 id="reply">reply</h1><p>最后就是消息的回复逻辑 —— <code>reply</code>方法了。<code>reply</code>方法的实现位于<code>MessageImpl</code>类中，最终调用的是<code>reply(Object, DeliveryOptions, Handler&lt;AsyncResult&lt;Message&lt;R&gt;&gt;&gt;)</code>这个版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function"><span class="keyword">void</span> <span class="title">reply</span><span class="params">(Object message, DeliveryOptions options, Handler&lt;AsyncResult&lt;Message&lt;R&gt;&gt;&gt; replyHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (replyAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sendReply(bus.createMessage(<span class="keyword">true</span>, replyAddress, options.getHeaders(), message, options.getCodecName()), options, replyHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>reply</code>方法同样调用<code>EventBus</code>的<code>createMessage</code>方法创建要回复的消息实体，传入的<code>replyAddress</code>即为之前讲过的生成的非常简单的回复地址。然后再将消息实体、配置以及对应的<code>replyHandler</code>（如果有的话）传入<code>sendReply</code>方法进行消息的回复。最后其实是调用了Event Bus中的四个参数的<code>sendReply</code>方法，它的逻辑与之前讲过的<code>sendOrPubInternal</code>非常相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendReply</span><span class="params">(MessageImpl replyMessage, MessageImpl replierMessage, DeliveryOptions options,</span><br><span class="line">                             Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (replyMessage.address() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"address not specified"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    HandlerRegistration&lt;T&gt; replyHandlerRegistration = createReplyHandlerRegistration(replyMessage, options, replyHandler);</span><br><span class="line">    <span class="keyword">new</span> ReplySendContextImpl&lt;&gt;(replyMessage, options, replyHandlerRegistration, replierMessage).next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数中<code>replyMessage</code>代表回复消息实体，<code>replierMessage</code>则代表回复者自身的消息实体(sender)。</p>
<p>如果地址为空则抛出异常；如果地址不为空，则先调用<code>createReplyHandlerRegistration</code>方法创建对应的<code>replyHandlerRegistration</code>。<code>createReplyHandlerRegistration</code>方法的实现之前已经讲过了。注意这里的<code>createReplyHandlerRegistration</code>其实对应的是此replier的回复，因为Vert.x中的 <strong>Request-Response</strong> 消息模型不限制相互回复（通信）的次数。当然如果没有指定此replier的回复的<code>replyHandler</code>，那么此处的<code>replyHandlerRegistration</code>就为空。最后<code>sendReply</code>方法会创建一个<code>ReplySendContextImpl</code>并调用其<code>next</code>方法。</p>
<p><code>ReplySendContextImpl</code>类同样是<code>SendContext</code>接口的一个实现（继承了<code>SendContextImpl</code>类）。<code>ReplySendContextImpl</code>比起其父类就多保存了一个<code>replierMessage</code>。<code>next</code>方法的逻辑与父类逻辑非常相似，只不过将回复的逻辑替换成了另一个版本的<code>sendReply</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">    Handler&lt;SendContext&gt; handler = iter.next();</span><br><span class="line">    handler.handle(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sendReply(<span class="keyword">this</span>, replierMessage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而。。。<code>sendReply</code>方法并没有用到传入的<code>replierMessage</code>，所以这里最终还是调用了<code>sendOrPub</code>方法（尼玛，封装的<code>ReplySendContextImpl</code>貌似并没有什么卵用，可能为以后的扩展考虑？）。。。之后的逻辑我们都已经分析过了。</p>
<p>这里再强调一点。当我们发送消息同时指定<code>replyHandler</code>的时候，其内部为reply创建的reply consumer(类型为<code>HandlerRegistration</code>)指定了<code>timeout</code>。这个定时器从<code>HandlerRegistration</code>创建的时候就开始计时了。我们回顾一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeout != -<span class="number">1</span>) &#123;</span><br><span class="line">  timeoutID = vertx.setTimer(timeout, tid -&gt; &#123;</span><br><span class="line">    metrics.replyFailure(address, ReplyFailure.TIMEOUT);</span><br><span class="line">    sendAsyncResultFailure(ReplyFailure.TIMEOUT, <span class="string">"Timed out after waiting "</span> + timeout + <span class="string">"(ms) for a reply. address: "</span> + address);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计时器会在超时的时候记录错误并强制注销当前consumer。由于reply consumer是<strong>一次性的</strong>，当收到reply的时候，Vert.x会自动对reply consumer调用<code>unregister</code>方法对其进行注销（实现位于<code>EventBusImpl#deliverToHandler</code>方法中），而在注销逻辑中会关闭定时器（参见前面对<code>doUnregister</code>方法的解析）；如果超时，那么计时器就会触发，Vert.x会调用<code>sendAsyncResultFailure</code>方法注销当前reply consumer并处理错误。</p>
<h1 id="synchronized的性能问题">synchronized的性能问题</h1><p>大家可能看到为了防止race condition，Vert.x底层大量使用了<code>synchronized</code>关键字（重量级锁）。这会不会影响性能呢？其实，如果开发者遵循Vert.x的线程模型和开发规范（使用Verticle）的话，有些地方的<code>synchronized</code>对应的锁会被优化为 <strong>偏向锁</strong> 或 <strong>轻量级锁</strong>（因为通常都是同一个Event Loop线程获取对应的锁），这样性能总体开销不会太大。当然如果使用Multi-threaded worker verticles就要格外关注性能问题了。。。</p>
<h1 id="总结">总结</h1><p>我们来简略地总结一下Event Bus的工作原理。当我们调用<code>consumer</code>绑定一个<code>MessageConsumer</code>时，Vert.x会将它保存至Event Bus实例内部的Map中；当我们通过<code>send</code>或<code>publish</code>向对应的地址发送消息的时候，Vert.x会遍历Event Bus中存储consumer的Map，获取与地址相对应的consumer集合，然后根据相应的策略传递并处理消息(<code>send</code>通过轮询策略获取任意一个consumer并将消息传递至consumer中，<code>publish</code>则会将消息传递至所有注册到对应地址的consumer中)。同时，<code>MessageConsumer</code>和<code>MessageProducer</code>这两个接口的实现都具有flow control功能，因此它们也可以用在<code>Pump</code>中。</p>
<p>Event Bus是Vert.x中最为重要的一部分之一，探索Event Bus的源码可以加深我们对Event Bus工作原理的理解。作为开发者，只会使用框架是不够的，能够理解内部的实现原理和精华，并对其进行改进才是更为重要的。本篇文章分析的是Local模式下的Event Bus，下篇文章我们将来探索一下生产环境中更常用的 <strong>Clustered Event Bus</strong> 的实现原理，敬请期待！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-busy-enough-2016-08" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Life/busy-enough-2016-08/" class="article-date">
      <time datetime="2016-08-29T16:25:00.000Z" itemprop="datePublished">2016-08-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Life/busy-enough-2016-08/">最近真忙～</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近越来越忙了，要忙各种项目，Blog都没空更了。。。等着抽空更新一波之前没发的文章。。。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/CoYX-A0XEAEYpu9.jpg" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Life/">Life</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-vertx-blueprint-3-micro-shop-microservice" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/" class="article-date">
      <time datetime="2016-08-29T10:00:00.000Z" itemprop="datePublished">2016-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务实战</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Vert.x 蓝图项目已经发布至Vert.x官方网站：<a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x Blueprint Tutorials</a></p>
<hr>
<p><strong>Vert.x 蓝图系列</strong> 的第三篇教程出炉咯！这篇教程是微服务实战相关的主题。篇幅较长，team给了模板用于渲染对应的文档，因此这里就直接放链接了：</p>
<ul>
<li><a href="http://sczyh30.github.io/vertx-blueprint-microservice/cn/index.html" target="_blank" rel="external">Vert.x 蓝图 - Micro Shop 微服务实战 (开发篇)</a></li>
<li><a href="http://sczyh30.github.io/vertx-blueprint-microservice/cn/api-gateway.html" target="_blank" rel="external">Vert.x 蓝图 - Micro Shop 微服务实战 (API Gateway)</a></li>
</ul>
<p>对应的GitHub Repository:  <a href="https://github.com/sczyh30/vertx-blueprint-microservice" target="_blank" rel="external">sczyh30/vertx-blueprint-microservice</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-vertx-blueprint-2-vertx-kue-http-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/" class="article-date">
      <time datetime="2016-07-24T07:00:00.000Z" itemprop="datePublished">2016-07-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/">Vert.x Blueprint 系列教程(二) | Vert.x Kue 教程（Web部分）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">上部分蓝图教程</a>中我们一起探索了如何用Vert.x开发一个基于消息的应用。在这部分教程中，我们将粗略地探索一下<code>kue-http</code>模块的实现。</p>
<h1 id="Vert-x_Kue_REST_API">Vert.x Kue REST API</h1><p><code>kue-http</code>模块中只有一个类<code>KueHttpVerticle</code>，作为整个REST API以及UI服务的实现。对REST API部分来说，如果看过我们之前的 <a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x 蓝图 | 待办事项服务开发教程</a> 的话，你应该对这一部分非常熟悉了，因此这里我们就不详细解释了。有关使用Vert.x Web实现REST API的教程可参考 <a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x 蓝图 | 待办事项服务开发教程</a>。</p>
<h1 id="将Kue_UI与Vert-x_Web进行适配">将Kue UI与Vert.x Web进行适配</h1><p>除了REST API之外，我们还给Vert.x Kue提供了一个用户界面。我们复用了Automattic/Kue的用户界面所以我们就不用写前端代码了（部分API有变动的地方我已进行了修改）。我们只需要将前端代码与Vert.x Web适配即可。</p>
<p>首先，前端的代码都属于静态资源，因此我们需要配置路由来允许访问静态资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.route().handler(StaticHandler.create(root));</span><br></pre></td></tr></table></figure>
<p>这样我们就可以直接访问静态资源咯～</p>
<p>注意到Kue UI使用了<strong>Jade</strong>（最近貌似改名叫Pug了）作为模板引擎，因此我们需要一个Jade模板解析器。好在Vert.x Web提供了一个Jade模板解析的实现: <code>io.vertx:vertx-web-templ-jade</code>，所以我们可以利用这个实现来渲染UI。首先在类中定义一个<code>JadeTemplateEngine</code>并在<code>start</code>方法中初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine = JadeTemplateEngine.create();</span><br></pre></td></tr></table></figure>
<p>然后我们就可以写一个处理器方法来根据不同的任务状态来渲染UI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(RoutingContext context, String state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String uiPath = <span class="string">"webroot/views/job/list.jade"</span>; <span class="comment">// (1)</span></span><br><span class="line">  String title = config().getString(<span class="string">"kue.ui.title"</span>, <span class="string">"Vert.x Kue"</span>);</span><br><span class="line">  kue.getAllTypes()</span><br><span class="line">    .setHandler(resultHandler(context, r -&gt; &#123;</span><br><span class="line">      context.put(<span class="string">"state"</span>, state) <span class="comment">// (2)</span></span><br><span class="line">        .put(<span class="string">"types"</span>, r)</span><br><span class="line">        .put(<span class="string">"title"</span>, title);</span><br><span class="line">      engine.render(context, uiPath, res -&gt; &#123; <span class="comment">// (3)</span></span><br><span class="line">        <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">          context.response()</span><br><span class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>) <span class="comment">// (4)</span></span><br><span class="line">            .end(res.result());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          context.fail(res.cause());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们需要给渲染引擎指定我们前端代码的地址 (1)。然后我们从Redis中获取其中所有的任务类型，然后向解析器context中添加任务状态、网页标题、任务类型等信息供渲染器渲染使用 (2)。接着我们就可以调用<code>engine.render(context, path, handler)</code>方法进行渲染 (3)。如果渲染成功，我们将页面写入HTTP Response (4)。</p>
<p>现在我们可以利用<code>render</code>方法去实现其它的路由函数了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUIActive</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  render(context, <span class="string">"active"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们给它绑个路由就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.route(KUE_UI_ACTIVE).handler(<span class="keyword">this</span>::handleUIActive);</span><br></pre></td></tr></table></figure>
<p>是不是非常方便呢？不仅如此，Vert.x Web还提供了其它各种模板引擎的支持，比如 <em>FreeMaker</em>, <em>Pebble</em> 以及 <em>Thymeleaf 3</em>。如果感兴趣的话，你可以查阅<a href="http://vertx.io/docs/vertx-web/java/#_templates" target="_blank" rel="external">官方文档</a>来获取详细的使用指南。</p>
<h1 id="展示时间！">展示时间！</h1><p>是不是等不及要看UI长啥样了？现在我们就来展示一下！首先构建项目：</p>
<pre><code><span class="title">gradle</span> build
</code></pre><p><code>kue-http</code>需要<code>kue-core</code>运行着（因为<code>kue-core</code>里注册了Event Bus服务），因此我们先运行<code>kue-core</code>，再运行<code>kue-http</code>。不要忘记运行Redis:</p>
<pre><code>redis-server
java -jar kue-core/build/libs/vertx-blueprint-kue-core<span class="class">.jar</span> -cluster -ha -conf config/config<span class="class">.json</span>
java -jar kue-http/build/libs/vertx-blueprint-kue-http<span class="class">.jar</span> -cluster -ha -conf config/config.json
</code></pre><p>为了更好地观察任务处理的流程，我们再运行一个示例：</p>
<pre><code>java -jar kue-example<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-example.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>好啦！现在在浏览器中访问<code>http://localhost:8080</code>，我们的Kue UI就呈现在我们眼前啦！</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/vertx_kue_ui_1.png" alt="Vert.x Kue UI"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-vertx-blueprint-2-vertx-kue-core-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/" class="article-date">
      <time datetime="2016-07-24T06:00:00.000Z" itemprop="datePublished">2016-07-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本文章是 <strong>Vert.x 蓝图系列</strong> 的第二篇教程。全系列：</p>
<ul>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</a></li>
<li>Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程</li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践</a></li>
</ul>
<h1 id="前言">前言</h1><p>欢迎回到Vert.x 蓝图系列～在本教程中，我们将利用Vert.x开发一个基于消息的应用 - Vert.x Kue，它是一个使用Vert.x开发的优先级工作队列，数据存储使用的是 <em>Redis</em> 。Vert.x Kue是<a href="https://github.com/Automattic/kue" target="_blank" rel="external">Automattic/kue</a>的Vert.x实现版本。我们可以使用Vert.x Kue来处理各种各样的任务，比如文件转换、订单处理等等。</p>
<p>通过本教程，你将会学习到以下内容：</p>
<ul>
<li>消息、消息系统以及事件驱动的运用</li>
<li>Vert.x <strong>Event Bus</strong> 的几种事件机制（发布/订阅、点对点模式）</li>
<li>设计 <strong>分布式</strong> 的Vert.x应用</li>
<li>工作队列的设计</li>
<li><strong>Vert.x Service Proxy</strong>（服务代理）的运用</li>
<li>更深层次的Redis运用</li>
</ul>
<p>本教程是 <a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x 蓝图系列</a> 的第二篇教程，对应的Vert.x版本为 <strong>3.3.3</strong> 。本教程中的完整代码已托管至<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/tree/master" target="_blank" rel="external">GitHub</a>。</p>
<h1 id="Vert-x的消息系统">Vert.x的消息系统</h1><p>既然我们要用Vert.x开发一个基于消息的应用，那么我们先来瞅一瞅Vert.x的消息系统吧～在Vert.x中，我们可以通过 <strong>Event Bus</strong> 来发送和接收各种各样的消息，这些消息可以来自不同的<code>Vertx</code>实例。怎么样，很酷吧？我们都将消息发送至Event Bus上的某个<strong>地址</strong>上，这个地址可以是任意的字符串。</p>
<p>Event Bus支持三种消息机制：<strong>发布/订阅</strong>(Publish/Subscribe)、<strong>点对点</strong>(Point to point)以及<strong>请求/回应</strong>(Request-Response)模式。下面我们就来看一看这几种机制。</p>
<h2 id="发布/订阅模式">发布/订阅模式</h2><p>在<strong>发布/订阅模式</strong>中，消息被发布到Event Bus的某一个地址上，所有订阅此地址的<code>Handler</code>都会接收到该消息并且调用相应的处理逻辑。我们来看一看示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EventBus eventBus = vertx.eventBus();</span><br><span class="line"></span><br><span class="line">eventBus.consumer(<span class="string">"foo.bar.baz"</span>, r -&gt; &#123; <span class="comment">// subscribe to `foo.bar.baz` address</span></span><br><span class="line">  System.out.println(<span class="string">"1: "</span> + r.body());</span><br><span class="line">&#125;);</span><br><span class="line">eventBus.consumer(<span class="string">"foo.bar.baz"</span>, r -&gt; &#123; <span class="comment">// subscribe to `foo.bar.baz` address</span></span><br><span class="line">  System.out.println(<span class="string">"2: "</span> + r.body());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventBus.publish(<span class="string">"foo.bar.baz"</span>, <span class="string">"+1s"</span>); <span class="comment">// 向此地址发送消息</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过<code>vertx.eventBus()</code>方法获取<code>EventBus</code>的引用，然后我们就可以通过<code>consume</code>方法订阅某个地址的消息并且绑定一个<code>Handler</code>。接着我们通过<code>publish</code>向此地址发送消息。如果运行上面的例子，我们会得到一下结果：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2</span>: <span class="string">+1s</span></span><br><span class="line"><span class="attribute">1</span>: <span class="string">+1s</span></span><br></pre></td></tr></table></figure>
<h2 id="点对点模式">点对点模式</h2><p>如果我们把上面的示例中的<code>publish</code>方法替代成<code>send</code>方法，上面的实例就变成<strong>点对点模式</strong>了。在点对点模式中，消息被发布到Event Bus的某一个地址上。Vert.x会将此消息传递给其中监听此地址的<code>Handler</code>之一。如果有多个<code>Handler</code>绑定到此地址，那么就使用轮询算法随机挑一个<code>Handler</code>传递消息。比如在此示例中，程序只会打印<code>2: +1s</code>或者<code>1: +1s</code>之中的一个。</p>
<h2 id="请求/回应模式">请求/回应模式</h2><p>当我们绑定的<code>Handler</code>接收到消息的时候，我们可不可以给消息的发送者回复呢？当然了！当我们通过<code>send</code>方法发送消息的时候，我们可以同时指定一个回复处理函数(reply handler)。然后当某个消息的订阅者接收到消息的时候，它就可以给发送者回复消息；如果发送者接收到了回复，发送者绑定的回复处理函数就会被调用。这就是<strong>请求/回应模式</strong>。</p>
<p>好啦，现在我们已经粗略了解了Vert.x中的消息系统 - Event Bus的基本使用，下面我们就看看Vert.x Kue的基本设计。有关更多关于Event Bus的信息请参考<a href="http://vertx.io/docs/vertx-core/java/#event_bus" target="_blank" rel="external">Vert.x Core Manual - Event Bus</a>。</p>
<h1 id="Vert-x_Kue_架构设计">Vert.x Kue 架构设计</h1><h2 id="Vert-x_Kue_组件划分">Vert.x Kue 组件划分</h2><p>在我们的项目中，我们将Vert.x Kue划分为两个模块：</p>
<ul>
<li><code>kue-core</code>: 核心组件，提供优先级队列的功能</li>
<li><code>kue-http</code>: Web组件，提供Web UI以及REST API</li>
</ul>
<p>另外我们还提供一个示例模块<code>kue-example</code>用于演示以及阐述如何使用Vert.x Kue。</p>
<p>既然我们的项目有两个模块，那么你一定会好奇：两个模块之间是如何进行通信的？并且如果我们写自己的Kue应用的话，我们该怎样去调用Kue Core中的服务呢？不要着急，谜底将在后边的章节中揭晓:-)</p>
<h2 id="Vert-x_Kue_核心模块">Vert.x Kue 核心模块</h2><p>回顾一下Vert.x Kue的作用 - 优先级工作队列，所以在Vert.x Kue的核心模块中我们设计了以下的类：</p>
<ul>
<li><code>Job</code> - 任务（作业）数据实体</li>
<li><code>JobService</code> - 异步服务接口，提供操作任务以及获取数据的相关逻辑</li>
<li><code>KueWorker</code> - 用于处理任务的Verticle</li>
<li><code>Kue</code> - 工作队列</li>
</ul>
<p>前边我们提到过，我们的两个组件之间需要一种通信机制可以互相通信 - 这里我们使用Vert.x的<strong>集群模式</strong>，即以clustered的模式来部署Verticle。这样的环境下的Event Bus同样也是集群模式的，因此各个组件可以通过集群模式下的Event Bus进行通信。很不错吧？在Vert.x的集群模式下，我们需要指定一个集群管理器<code>ClusterManager</code>。这里我们使用默认的<code>HazelcastClusterManager</code>，使用<strong>Hazelcast</strong>作为集群管理。</p>
<p>在Vert.x Kue中，我们将<code>JobService</code>服务发布至分布式的Event Bus上，这样其它的组件就可以通过Event Bus调用该服务了。我们设计了一个<code>KueVerticle</code>用于注册服务。Vert.x提供了Vert.x Service Proxy（服务代理组件），可以很方便地将服务注册至Event Bus上，然后在其它地方获取此服务的代理并调用。我们将在下面的章节中详细介绍<strong>Vert.x Service Proxy</strong>。</p>
<h2 id="基于Future的异步模式">基于Future的异步模式</h2><p>在我们的Vert.x Kue中，大多数的异步方法都是基于<code>Future</code>的。如果您看过蓝图系列的第一篇文章的话，您一定不会对这种模式很陌生。在Vert.x 3.3.2中，我们的<code>Future</code>支持基本的响应式的操作，比如<code>map</code>和<code>compose</code>。它们用起来非常方便，因为我们可以将多个<code>Future</code>以响应式的方式组合起来而不用担心陷入回调地狱中。</p>
<h2 id="Vert-x_Kue中的事件">Vert.x Kue中的事件</h2><p>正如我们在<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">Vert.x Kue 特性介绍</a>中提到的那样，Vert.x Kue支持两种级别的事件：<strong>任务事件(job events)</strong> 以及 <strong>队列事件(queue events)</strong>。在Vert.x Kue中，我们设计了三种事件地址：</p>
<ul>
<li><code>vertx.kue.handler.job.{handlerType}.{addressId}.{jobType}</code>: 某个特定任务的任务事件地址</li>
<li><code>vertx.kue.handler.workers.{eventType}</code>: （全局）队列事件地址</li>
<li><code>vertx.kue.handler.workers.{eventType}.{addressId}</code>: 某个特定任务的内部事件地址</li>
</ul>
<p>在<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">特性介绍文档</a>中，我们提到了以下几种任务事件：</p>
<ul>
<li><code>start</code> 开始处理一个任务 (<code>onStart</code>)</li>
<li><code>promotion</code> 一个延期的任务时间已到，提升至工作队列中 (<code>onPromotion</code>)</li>
<li><code>progress</code> 任务的进度变化 (<code>onProgress</code>)</li>
<li><code>failed_attempt</code> 任务处理失败，但是还可以重试 (<code>onFailureAttempt</code>)</li>
<li><code>failed</code> 任务处理失败并且不能重试 (<code>onFailure</code>)</li>
<li><code>complete</code> 任务完成 (<code>onComplete</code>)</li>
<li><code>remove</code> 任务从后端存储中移除 (<code>onRemove</code>)</li>
</ul>
<p>队列事件也相似，只不过需要加前缀<code>job_</code>。这些事件都会通过<code>send</code>方法发送至Event Bus上。每一个任务都有对应的任务事件地址，因此它们能够正确地接收到对应的事件并进行相应的处理逻辑。</p>
<p>特别地，我们还有两个内部事件：<code>done</code>和<code>done_fail</code>。<code>done</code>事件对应一个任务在底层的处理已经完成，而<code>done_fail</code>事件对应一个任务在底层的处理失败。这两个事件使用第三种地址进行传递。</p>
<h2 id="任务状态">任务状态</h2><p>在Vert.x Kue中，任务共有五种状态：</p>
<ul>
<li><code>INACTIVE</code>: 任务还未开始处理，在工作队列中等待处理</li>
<li><code>ACTIVE</code>: 任务正在处理中</li>
<li><code>COMPLETE</code>: 任务处理完成</li>
<li><code>FAILED</code>: 任务处理失败</li>
<li><code>DELAYED</code>: 任务延时处理，正在等待计时器时间到并提升至工作队列中</li>
</ul>
<p>我们使用状态图来描述任务状态的变化：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/job_state_machine.png" alt="Job State Machine"></p>
<p>以及任务状态的变化伴随的事件：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/event_emit_state_machine.png" alt="Events with state change"></p>
<h2 id="整体设计">整体设计</h2><p>为了让大家对Vert.x Kue的架构有大致的了解，我用一幅图来简略描述整个Vert.x Kue的设计：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_diagram.png" alt="Diagram - How Vert.x Kue works"></p>
<p>现在我们对Vert.x Kue的设计有了大致的了解了，下面我们就来看一看Vert.x Kue的代码实现了～</p>
<h1 id="项目结构">项目结构</h1><p>我们来开始探索Vert.x Kue的旅程吧！首先我们先从GitHub上clone源代码：</p>
<pre><code>git clone <span class="string">https:</span><span class="comment">//github.com/sczyh30/vertx-blueprint-job-queue.git</span>
</code></pre><p>然后你可以把项目作为Gradle项目导入你的IDE中。（如何导入请参考相关IDE帮助文档）</p>
<p>正如我们之前所提到的，我们的Vert.x Kue中有两个功能模块和一个实例模块，因此我们需要在Gradle工程文件中定义三个子工程。我们来看一下本项目中的<code>build.gradle</code>文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">configure(<span class="keyword">allprojects</span>) &#123; <span class="keyword">project</span> -&gt;</span><br><span class="line"></span><br><span class="line">  ext &#123;</span><br><span class="line">    vertxVersion = <span class="string">"3.3.2"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply plugin: <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-core:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-codegen:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-rx-java:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-hazelcast:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-lang-ruby:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line"></span><br><span class="line">    testCompile(<span class="string">"io.vertx:vertx-unit:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    testCompile <span class="keyword">group</span>: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.12'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">sourceSets</span> &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">      java &#123;</span><br><span class="line">        srcDirs += <span class="string">'src/main/generated'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  compileJava &#123;</span><br><span class="line">    <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></span><br><span class="line">    <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="string">"kue-core"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-redis-client:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-service-proxy:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jar &#123;</span><br><span class="line">    archiveName = <span class="string">'vertx-blueprint-kue-core.jar'</span></span><br><span class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.queue.KueVerticle'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123; <span class="comment">// codegen</span></span><br><span class="line">    <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</span><br><span class="line">    <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span></span><br><span class="line">    <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</span><br><span class="line">    <span class="keyword">options</span>.compilerArgs = [</span><br><span class="line">      <span class="string">"-proc:only"</span>,</span><br><span class="line">      <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</span><br><span class="line">      <span class="string">"-AoutputDirectory=$&#123;project.projectDir&#125;/src/main"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  compileJava &#123;</span><br><span class="line">    <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></span><br><span class="line">    <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">    dependsOn annotationProcessing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="string">"kue-http"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web-templ-jade:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jar &#123;</span><br><span class="line">    archiveName = <span class="string">'vertx-blueprint-kue-http.jar'</span></span><br><span class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.http.KueHttpVerticle'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="string">"kue-example"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jar &#123;</span><br><span class="line">    archiveName = <span class="string">'vertx-blueprint-kue-example.jar'</span></span><br><span class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.example.LearningVertxVerticle'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> wrapper(type: Wrapper) &#123;</span><br><span class="line">  gradleVersion = <span class="string">'2.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(⊙o⊙)…比之前的待办事项服务项目中的长不少诶。。。我们来解释一下：</p>
<ul>
<li>在<code>configure(allprojects)</code>作用域中，我们配置了一些全局信息（对所有子工程都适用）。</li>
<li>我们定义了三个子工程：<code>kue-core</code>、<code>kue-http</code>以及<code>kue-example</code>。这里我们来解释一下里面用到的依赖。在<code>kue-core</code>中，<code>vertx-redis-client</code>用于Redis通信，<code>vertx-service-proxy</code>用于Event Bus上的服务代理。在<code>kue-http</code>中，我们将<code>kue-core</code>子工程作为它的一个依赖。<code>vertx-web</code>和<code>vertx-web-templ-jade</code>用于Kue Web端的开发。</li>
<li>任务<code>annotationProcessing</code>用于注解处理（Vert.x Codegen）。我们已经在上一篇教程中介绍过了，这里就不展开讲了。</li>
</ul>
<p>我们还需要在 <code>settings.gradle</code> 中配置工程：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name = <span class="string">'vertx-blueprint-job-queue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">"kue-core"</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"kue-http"</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"kue-example"</span></span><br></pre></td></tr></table></figure>
<p>看完了配置文件以后，我们再来浏览一下我们的项目目录结构：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── kue-core</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── <span class="keyword">main</span></span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   └── <span class="keyword">resources</span></span><br><span class="line">│       └── test</span><br><span class="line">│           ├── java</span><br><span class="line">│           └── <span class="keyword">resources</span></span><br><span class="line">├── kue-example</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── <span class="keyword">main</span></span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   └── <span class="keyword">resources</span></span><br><span class="line">│       └── test</span><br><span class="line">│           ├── java</span><br><span class="line">│           └── <span class="keyword">resources</span></span><br><span class="line">├── kue-http</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── <span class="keyword">main</span></span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   └── <span class="keyword">resources</span></span><br><span class="line">│       └── test</span><br><span class="line">│           ├── java</span><br><span class="line">│           └── <span class="keyword">resources</span></span><br><span class="line">└── <span class="keyword">settings</span>.gradle</span><br></pre></td></tr></table></figure>
<p>在Gradle中，项目的源码都位于<code>{projectName}/src/main/java</code>目录内。这篇教程是围绕Vert.x Kue Core的，所以我们的代码都在<code>kue-core</code>目录中。</p>
<p>好啦！现在我们已经对Vert.x Kue项目的整体结构有了大致的了解了，下面我们开始源码探索之旅！</p>
<h1 id="任务实体_-_不仅仅是一个数据对象">任务实体 - 不仅仅是一个数据对象</h1><p>Vert.x Kue是用来处理任务的，因此我们先来看一下代表任务实体的<code>Job</code>类。<code>Job</code>类位于<code>io.vertx.blueprint.kue.queue</code>包下。代码可能有点长，不要担心，我们把它分成几部分，分别来解析。</p>
<h2 id="任务成员属性">任务成员属性</h2><p>我们先来看一下<code>Job</code>类中的成员属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@DataObject</span>(generateConverter = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="comment">// job properties</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address_id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String zid;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> JsonObject data;</span><br><span class="line">    <span class="keyword">private</span> Priority priority = Priority.NORMAL;</span><br><span class="line">    <span class="keyword">private</span> JobState state = JobState.INACTIVE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delay = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max_attempts = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> removeOnComplete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ttl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> JsonObject backoff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> attempts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> progress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> JsonObject result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// job metrics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> created_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> promote_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> updated_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> failed_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> started_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> duration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我去。。。好多属性！我们一个一个地解释：</p>
<ul>
<li><code>address_id</code>: 一个UUID序列，作为Event Bus的地址</li>
<li><code>id</code>: 任务的编号(id)</li>
<li><code>type</code>: 任务的类型</li>
<li><code>data</code>: 任务携带的数据，以 <code>JsonObject</code> 类型表示</li>
<li><code>priority</code>: 任务优先级，以 <code>Priority</code> 枚举类型表示。默认优先级为正常(<code>NORMAL</code>)</li>
<li><code>delay</code>: 任务的延迟时间，默认是 <strong>0</strong></li>
<li><code>state</code>: 任务状态，以 <code>JobState</code> 枚举类型表示。默认状态为等待(<code>INACTIVE</code>)</li>
<li><code>attempts</code>: 任务已经尝试执行的次数</li>
<li><code>max_attempts</code>: 任务尝试执行次数的最大阈值</li>
<li><code>removeOnComplete</code>: 代表任务完成时是否自动从后台移除</li>
<li><code>zid</code>: <code>zset</code>操作对应的编号(zid)，保持先进先出顺序</li>
<li><code>ttl</code>: TTL(Time to live)</li>
<li><code>backoff</code>: 任务重试配置，以 <code>JsonObject</code> 类型表示</li>
<li><code>progress</code>: 任务执行的进度</li>
<li><code>result</code>: 任务执行的结果，以 <code>JsonObject</code> 类型表示</li>
</ul>
<p>还有这些统计数据：</p>
<ul>
<li><code>created_at</code>: 代表此任务创建的时间</li>
<li><code>promote_at</code>: 代表此任务从延时状态被提升至等待状态时的时间</li>
<li><code>updated_at</code>: 代表任务更新的时间</li>
<li><code>failed_at</code>: 代表任务失败的时间</li>
<li><code>started_at</code>: 代表任务开始的时间</li>
<li><code>duration</code>: 代表处理任务花费的时间，单位为毫秒(<code>ms</code>)</li>
</ul>
<p>你可能注意到在 <code>Job</code> 类中还存在着几个静态成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Job.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vertx vertx;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisClient client;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setVertx</span><span class="params">(Vertx v, RedisClient redisClient)</span> </span>&#123;</span><br><span class="line">  vertx = v;</span><br><span class="line">  client = redisClient;</span><br><span class="line">  eventBus = vertx.eventBus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>logger</code> 对象，我想大家应该都很熟悉，它代表一个Vert.x Logger实例用于日志记录。但是你一定想问为什么 <code>Job</code> 类中存在着一个<code>Vertx</code>类型的静态成员。<code>Job</code>类不应该是一个数据对象吗？当然咯！<code>Job</code>类代表一个数据对象，但<strong>不仅仅</strong>是一个数据对象。这里我模仿了一些Automattic/kue的风格，把一些任务相关逻辑方法放到了<code>Job</code>类里，它们大多都是基于<code>Future</code>的异步方法，因此可以很方便地去调用以及进行组合变换。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">job.save()</span><br><span class="line">    .compose(Job::updateNow)</span><br><span class="line">    .compose(j -&gt; j.log(<span class="string">"good!"</span>));</span><br></pre></td></tr></table></figure>
<p>由于我们不能在<code>Job</code>类被JVM加载的时候就获取<code>Vertx</code>实例，我们必须手动给<code>Job</code>类中的静态<code>Vertx</code>成员赋值。这里我们是在<code>Kue</code>类中对其进行赋值的。当我们创建一个工作队列的时候，<code>Job</code>类中的静态成员变量会被初始化。同时为了保证程序的正确性，我们需要一个方法来检测静态成员变量是否初始化。当我们在创建一个任务的时候，如果静态成员此时未被初始化，那么日志会给出警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">_checkStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vertx == <span class="keyword">null</span>) &#123;</span><br><span class="line">    logger.warn(<span class="string">"static Vertx instance in Job class is not initialized!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还注意到 <code>Job</code> 类也是由<code>@DataObject</code>注解修饰的。Vert.x Codegen可以处理含有<code>@DataObject</code>注解的类并生成对应的JSON转换器，并且Vert.x Service Proxy也需要数据对象。</p>
<p>在<code>Job</code>类中我们有四个构造函数。其中<code>address_id</code>成员必须在一个任务被创建时就被赋值，默认情况下此地址用一个唯一的UUID字符串表示。每一个构造函数中我们都要调用<code>_checkStatic</code>函数来检测静态成员变量是否被初始化。</p>
<h2 id="任务事件辅助函数">任务事件辅助函数</h2><p>正如我们之前所提到的那样，我们通过一个特定的地址<code>vertx.kue.handler.job.{handlerType}.{addressId}.{jobType}</code>在分布式的Event Bus上发送和接收任务事件(job events)。所以我们提供了两个用于发送和接收事件的辅助函数<code>emit</code>和<code>on</code>(类似于Node.js中的<code>EventEmitter</code>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Job <span class="title">on</span><span class="params">(String event, Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</span><br><span class="line">  logger.debug(<span class="string">"[LOG] On: "</span> + Kue.getCertainJobAddress(event, <span class="keyword">this</span>));</span><br><span class="line">  eventBus.consumer(Kue.getCertainJobAddress(event, <span class="keyword">this</span>), handler);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">emit</span><span class="params">(String event, Object msg)</span> </span>&#123;</span><br><span class="line">  logger.debug(<span class="string">"[LOG] Emit: "</span> + Kue.getCertainJobAddress(event, <span class="keyword">this</span>));</span><br><span class="line">  eventBus.send(Kue.getCertainJobAddress(event, <span class="keyword">this</span>), msg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在后面的代码中，我们将频繁使用这两个辅助函数。</p>
<h2 id="Redis中的存储形式">Redis中的存储形式</h2><p>在我们探索相关的逻辑函数之前，我们先来描述一下Vert.x Kue的数据在Redis中是以什么样的形式存储的：</p>
<ul>
<li>所有的key都在<code>vertx_kue</code>命名空间下(以<code>vertx_kue:</code>作为前缀)</li>
<li><code>vertx:kue:job:{id}</code>: 存储任务实体的map</li>
<li><code>vertx:kue:ids</code>: 计数器，指示当前最大的任务ID</li>
<li><code>vertx:kue:job:types</code>: 存储所有任务类型的列表</li>
<li><code>vertx:kue:{type}:jobs</code>: 指示所有等待状态下的某种类型任务的列表</li>
<li><code>vertx_kue:jobs</code>: 存储所有任务<code>zid</code>的有序集合</li>
<li><code>vertx_kue:job:{state}</code>: 存储所有指定状态的任务<code>zid</code>的有序集合</li>
<li><code>vertx_kue:jobs:{type}:{state}</code>: 存储所有指定状态和类型的任务<code>zid</code>的有序集合</li>
<li><code>vertx:kue:job:{id}:log</code>: 存储指定<code>id</code>的任务对应日志的列表</li>
</ul>
<p>OK，下面我们就来看看<code>Job</code>类中重要的逻辑函数。</p>
<h2 id="改变任务状态">改变任务状态</h2><p>我们之前提到过，Vert.x Kue中的任务一共有五种状态。所有的任务相关的操作都伴随着任务状态的变换，因此我们先来看一下<code>state</code>方法的实现，它用于改变任务的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">state</span><span class="params">(JobState newState)</span> </span>&#123;</span><br><span class="line">  Future&lt;Job&gt; future = Future.future();</span><br><span class="line">  RedisClient client = RedisHelper.client(vertx, <span class="keyword">new</span> JsonObject()); <span class="comment">// use a new client to keep transaction</span></span><br><span class="line">  JobState oldState = <span class="keyword">this</span>.state;</span><br><span class="line">  client.transaction().multi(r0 -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (r0.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldState != <span class="keyword">null</span> &amp;&amp; !oldState.equals(newState)) &#123; <span class="comment">// (2)</span></span><br><span class="line">        client.transaction().zrem(RedisHelper.getStateKey(oldState), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">          .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + oldState.name()), <span class="keyword">this</span>.zid, _failure());</span><br><span class="line">      &#125;</span><br><span class="line">      client.transaction().hset(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), <span class="string">"state"</span>, newState.name(), _failure()) <span class="comment">// (3)</span></span><br><span class="line">        .zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">        .zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + newState.name()), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (newState) &#123; <span class="comment">// dispatch different state</span></span><br><span class="line">        <span class="keyword">case</span> ACTIVE: <span class="comment">// (4)</span></span><br><span class="line">          client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</span><br><span class="line">            <span class="keyword">this</span>.priority.getValue() &lt; <span class="number">0</span> ? <span class="keyword">this</span>.priority.getValue() : -<span class="keyword">this</span>.priority.getValue(),</span><br><span class="line">            <span class="keyword">this</span>.zid, _failure());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DELAYED: <span class="comment">// (5)</span></span><br><span class="line">          client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</span><br><span class="line">            <span class="keyword">this</span>.promote_at, <span class="keyword">this</span>.zid, _failure());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> INACTIVE: <span class="comment">// (6)</span></span><br><span class="line">          client.transaction().lpush(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="string">"1"</span>, _failure());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.state = newState;</span><br><span class="line"></span><br><span class="line">      client.transaction().exec(r -&gt; &#123; <span class="comment">// (7)</span></span><br><span class="line">        <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">          future.complete(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          future.fail(r.cause());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      future.fail(r0.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> future.compose(Job::updateNow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先创建了一个<code>Future</code>对象。然后我们调用了 <code>client.transaction().multi(handler)</code> 函数开始一次Redis事务 (1)。在Vert.x 3.3.2中，所有的Redis事务操作都移至<code>RedisTransaction</code>类中，所以我们需要先调用<code>client.transaction()</code>方法去获取一个事务实例，然后调用<code>multi</code>代表事务块的开始。</p>
<p>在<code>multi</code>函数传入的<code>Handler</code>中，我们先判定当前的任务状态。如果当前任务状态不为空并且不等于新的任务状态，我们就将Redis中存储的旧的状态信息移除 (2)。为了方便起见，我们提供了一个<code>RedisHelper</code>辅助类，里面提供了一些生成特定地址以及编码解码<code>zid</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.JobState;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Vertx;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</span><br><span class="line"><span class="keyword">import</span> io.vertx.redis.RedisOptions;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERTX_KUE_REDIS_PREFIX = <span class="string">"vertx_kue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">RedisHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisClient <span class="title">client</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RedisClient.create(vertx, options(config));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisOptions <span class="title">options</span><span class="params">(JsonObject config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisOptions()</span><br><span class="line">      .setHost(config.getString(<span class="string">"redis.host"</span>, <span class="string">"127.0.0.1"</span>))</span><br><span class="line">      .setPort(config.getInteger(<span class="string">"redis.port"</span>, <span class="number">6379</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> VERTX_KUE_REDIS_PREFIX + <span class="string">":"</span> + key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStateKey</span><span class="params">(JobState state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> VERTX_KUE_REDIS_PREFIX + <span class="string">":jobs:"</span> + state.name();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createFIFO</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    String idLen = <span class="string">""</span> + (<span class="string">""</span> + id).length();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">2</span> - idLen.length();</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>)</span><br><span class="line">      idLen = <span class="string">"0"</span> + idLen;</span><br><span class="line">    <span class="keyword">return</span> idLen + <span class="string">"|"</span> + id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stripFIFO</span><span class="params">(String zid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zid.substring(zid.indexOf(<span class="string">'|'</span>) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">numStripFIFO</span><span class="params">(String zid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Long.parseLong(zid.substring(zid.indexOf(<span class="string">'|'</span>) + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的key都必须在<code>vertx_kue</code>命名空间下，因此我们封装了一个<code>getKey</code>方法。我们还实现了<code>createFIFO</code>和<code>stripFIFO</code>方法用于生成<code>zid</code>以及解码<code>zid</code>。<code>zid</code>的格式使用了Automattic/Kue中的格式。</p>
<p>回到<code>state</code>方法来。我们使用<code>zrem(String key, String member, Handler&lt;AsyncResult&lt;String&gt;&gt; handler)</code>方法将特定的数据从有序集合中移除。两个key分别是<code>vertx_kue:job:{state}</code> 以及 <code>vertx_kue:jobs:{type}:{state}</code>；<code>member</code>对应着任务的<code>zid</code>。</p>
<p>接下来我们使用<code>hset</code>方法来变更新的状态 (3)，然后用<code>zadd</code>方法往<code>vertx_kue:job:{state}</code> 和 <code>vertx_kue:jobs:{type}:{state}</code>两个有序集合中添加此任务的<code>zid</code>，同时传递一个<strong>权重</strong>(score)。这个非常重要，我们就是通过这个实现<strong>优先级</strong>队列的。我们直接使用<code>priority</code>对应的值作为<code>score</code>。这样，当我们需要从Redis中获取任务的时候，我们就可以通过<code>zpop</code>方法获取优先级最高的任务。我们会在后面详细讲述。</p>
<p>不同的新状态需要不同的操作。对于<code>ACTIVE</code>状态，我们通过<code>zadd</code>命令将<code>zid</code>添加至<code>vertx_kue:jobs:ACTIVE</code>有序集合中并赋予优先级权值 (4)。对于<code>DELAYED</code>状态，我们通过<code>zadd</code>命令将<code>zid</code>添加至<code>vertx_kue:jobs:DELAYED</code>有序集合中并赋予提升时间(<code>promote_at</code>)权值 (5)。对于<code>INACTIVE</code>状态，我们向<code>vertx:kue:{type}:jobs</code>列表中添加一个元素 (6)。这些操作都是在Redis事务块内完成的。最后我们通过<code>exec</code>方法一并执行这些事务操作 (7)。如果执行成功，我们给<code>future</code>赋值（当前任务）。最后我们返回<code>future</code>并且与<code>updateNow</code>方法相组合。</p>
<p><code>updateNow</code>方法非常简单，就是把<code>updated_at</code>的值设为当前时间，然后存到Redis中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;Job&gt; <span class="title">updateNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updated_at = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.set(<span class="string">"updated_at"</span>, String.valueOf(updated_at));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="保存任务">保存任务</h2><p>这里我们来看一下整个<code>Job</code>类中最重要的方法之一 - <code>save</code>方法，它的作用是保存任务至Redis中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// check</span></span><br><span class="line">  Objects.requireNonNull(<span class="keyword">this</span>.type, <span class="string">"Job type cannot be null"</span>); <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> update(); <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">  Future&lt;Job&gt; future = Future.future();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成id</span></span><br><span class="line">  client.incr(RedisHelper.getKey(<span class="string">"ids"</span>), res -&gt; &#123; <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.id = res.result();</span><br><span class="line">      <span class="keyword">this</span>.zid = RedisHelper.createFIFO(id); <span class="comment">// (4)</span></span><br><span class="line">      String key = RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = JobState.DELAYED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      client.sadd(RedisHelper.getKey(<span class="string">"job:types"</span>), <span class="keyword">this</span>.type, _failure()); <span class="comment">// (5)</span></span><br><span class="line">       <span class="keyword">this</span>.created_at = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">this</span>.promote_at = <span class="keyword">this</span>.created_at + <span class="keyword">this</span>.delay;</span><br><span class="line">       <span class="comment">// 保存任务</span></span><br><span class="line">       client.hmset(key, <span class="keyword">this</span>.toJson(), _completer(future, <span class="keyword">this</span>)); <span class="comment">// (6)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      future.fail(res.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> future.compose(Job::update); <span class="comment">// (7)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，任务类型不能为空所以我们要检查<code>type</code>是否为空 (1)。接着，如果当前任务的id大于0，则代表此任务已经存储过（因为id是存储时分配），此时只需执行更新操作(<code>update</code>)即可 (2)。然后我们创建一个<code>Future</code>对象，然后使用<code>incr</code>方法从<code>vertx_kue:ids</code>字段获取一个新的<code>id</code> (3)。同时我们使用<code>RedisHelper.createFIFO(id)</code>方法来生成新的<code>zid</code> (4)。接着我们来判断任务延时是否大于0，若大于0则将当前任务状态设置为<code>DELAYED</code>。然后我们通过<code>sadd</code>方法将当前任务类型添加至<code>vertx:kue:job:types</code>列表中 (5) 并且保存任务创建时间(<code>created_at</code>)以及任务提升时间(<code>promote_at</code>)。经过这一系列的操作后，所有的属性都已准备好，所以我们可以利用<code>hmset</code>方法将此任务实体存储至<code>vertx:kue:job:{id}</code>哈希表中 (6)。如果存储操作成功，那么将当前任务实体赋给<code>future</code>，否则记录错误。最后我们返回此<code>future</code>并且将其与<code>update</code>方法进行组合。</p>
<p><code>update</code>方法进行一些更新操作，它的逻辑比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;Job&gt; <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Future&lt;Job&gt; future = Future.future();</span><br><span class="line">  <span class="keyword">this</span>.updated_at = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  client.transaction().multi(_failure())</span><br><span class="line">    .hset(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), <span class="string">"updated_at"</span>, String.valueOf(<span class="keyword">this</span>.updated_at), _failure())</span><br><span class="line">    .zadd(RedisHelper.getKey(<span class="string">"jobs"</span>), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">    .exec(_completer(future, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> future.compose(r -&gt;</span><br><span class="line">    <span class="keyword">this</span>.state(<span class="keyword">this</span>.state));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>update</code>方法只做了三件微小的工作：存储任务更新时间、存储<code>zid</code>以及更改当前任务状态（组合<code>state</code>方法）。</p>
<p>最后总结一下将一个任务存储到Redis中经过的步骤：<code>save -&gt; update -&gt; state</code> :-)</p>
<h2 id="移除任务">移除任务</h2><p>移除任务非常简单，借助<code>zrem</code>和<code>del</code>方法即可。我们来看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Void&gt; <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Future&lt;Void&gt; future = Future.future();</span><br><span class="line">  client.transaction().multi(_failure())</span><br><span class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.stateName()), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + <span class="keyword">this</span>.stateName()), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs"</span>), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">    .del(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id + <span class="string">":log"</span>), _failure())</span><br><span class="line">    .del(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), _failure())</span><br><span class="line">    .exec(r -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">"remove"</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"id"</span>, <span class="keyword">this</span>.id));</span><br><span class="line">        future.complete();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        future.fail(r.cause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到成功移除任务时，我们会向Event Bus上的特定地址发送<code>remove</code>任务事件。此事件包含着被移除任务的<code>id</code>。</p>
<h2 id="监听任务事件">监听任务事件</h2><p>我们可以通过几种 <code>onXXX</code> 方法来监听任务事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onComplete</span><span class="params">(Handler&lt;Job&gt; completeHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"complete"</span>, message -&gt; &#123;</span><br><span class="line">    completeHandler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onFailure</span><span class="params">(Handler&lt;JsonObject&gt; failureHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"failed"</span>, message -&gt; &#123;</span><br><span class="line">    failureHandler.handle((JsonObject) message.body());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onFailureAttempt</span><span class="params">(Handler&lt;JsonObject&gt; failureHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"failed_attempt"</span>, message -&gt; &#123;</span><br><span class="line">    failureHandler.handle((JsonObject) message.body());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onPromotion</span><span class="params">(Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"promotion"</span>, message -&gt; &#123;</span><br><span class="line">    handler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onStart</span><span class="params">(Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"start"</span>, message -&gt; &#123;</span><br><span class="line">    handler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onRemove</span><span class="params">(Handler&lt;JsonObject&gt; removeHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"start"</span>, message -&gt; &#123;</span><br><span class="line">    removeHandler.handle((JsonObject) message.body());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onProgress</span><span class="params">(Handler&lt;Integer&gt; progressHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"progress"</span>, message -&gt; &#123;</span><br><span class="line">    progressHandler.handle((Integer) message.body());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到不同的事件，对应接收的数据类型也有差异。我们来说明一下：</p>
<ul>
<li><code>onComplete</code>、<code>onPromotion</code> 以及 <code>onStart</code>: 发送的数据是对应的<code>Job</code>对象</li>
<li><code>onFailure</code> and <code>onFailureAttempt</code>: 发送的数据是<code>JsonObject</code>类型的，其格式类似于：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">job</span>": <span class="value">&#123;&#125;</span>,</span><br><span class="line">    "<span class="attribute">extra</span>": <span class="value">&#123;</span><br><span class="line">        "<span class="attribute">message</span>": <span class="value"><span class="string">"some_error"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>onProgress</code>: 发送的数据是当前任务进度</li>
<li><code>onRemove</code>: 发送的数据是<code>JsonObject</code>类型的，其中<code>id</code>代表被移除任务的编号</li>
</ul>
<h2 id="更新任务进度">更新任务进度</h2><p>我们可以通过<code>progress</code>方法来更新任务进度。看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">progress</span><span class="params">(<span class="keyword">int</span> complete, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = Math.min(<span class="number">100</span>, complete * <span class="number">100</span> / total); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">"progress"</span>, n); <span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.setProgress(n) <span class="comment">// (3)</span></span><br><span class="line">    .set(<span class="string">"progress"</span>, String.valueOf(n))</span><br><span class="line">    .compose(Job::updateNow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>progress</code>方法接受两个参数：第一个是当前完成的进度值，第二个是完成状态需要的进度值。我们首先计算出当前的进度 (1)，然后向特定地址发送<code>progress</code>事件 (2)。最后我们将进度存储至Redis中并更新时间，返回<code>Future</code> (3)。</p>
<h2 id="任务失败以及重试机制">任务失败以及重试机制</h2><p>当一个任务处理失败时，如果它有剩余的重试次数，Vert.x Kue会自动调用<code>failAttempt</code>方法进行重试。我们来看一下<code>failAttempt</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;Job&gt; <span class="title">failedAttempt</span><span class="params">(Throwable err)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.error(err)</span><br><span class="line">    .compose(Job::failed)</span><br><span class="line">    .compose(Job::attemptInternal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(⊙o⊙)非常简短吧～实际上，<code>failAttempt</code>方法是三个异步方法的组合：<code>error</code>、<code>failed</code>以及<code>attemptInternal</code>。当一个任务需要进行重试的时候，我们首先向Event Bus发布 <code>error</code> 队列事件并且在Redis中记录日志，然后将当前的任务状态置为<code>FAILED</code>，最后重新处理此任务。</p>
<p>我们先来看一下<code>error</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">error</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.emitError(ex)</span><br><span class="line">    .set(<span class="string">"error"</span>, ex.getMessage())</span><br><span class="line">    .compose(j -&gt; j.log(<span class="string">"error | "</span> + ex.getMessage()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的逻辑很简单：首先我们向Event Bus发布 <strong>错误</strong> 事件，然后记录错误日志即可。这里我们封装了一个发布错误的函数<code>emitError</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">emitError</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">  JsonObject errorMessage = <span class="keyword">new</span> JsonObject().put(<span class="string">"id"</span>, <span class="keyword">this</span>.id)</span><br><span class="line">    .put(<span class="string">"message"</span>, ex.getMessage());</span><br><span class="line">  eventBus.publish(Kue.workerAddress(<span class="string">"error"</span>), errorMessage);</span><br><span class="line">  eventBus.send(Kue.getCertainJobAddress(<span class="string">"error"</span>, <span class="keyword">this</span>), errorMessage);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中发送的错误信息格式类似于下面的样子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">id</span>": <span class="value"><span class="number">2052</span></span>,</span><br><span class="line">    "<span class="attribute">message</span>": <span class="value"><span class="string">"some error"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们再来看一下<code>failed</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">failed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.failed_at = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.updateNow()</span><br><span class="line">    .compose(j -&gt; j.set(<span class="string">"failed_at"</span>, String.valueOf(j.failed_at)))</span><br><span class="line">    .compose(j -&gt; j.state(JobState.FAILED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单，首先我们更新任务的更新时间和失败时间，然后通过<code>state</code>方法将当前任务状态置为<code>FAILED</code>即可。</p>
<p>任务重试的核心逻辑在<code>attemptInternal</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;Job&gt; <span class="title">attemptInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> remaining = <span class="keyword">this</span>.max_attempts - <span class="keyword">this</span>.attempts; <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">if</span> (remaining &gt; <span class="number">0</span>) &#123; <span class="comment">// 还有重试次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.attemptAdd() <span class="comment">// (2)</span></span><br><span class="line">      .compose(Job::reattempt) <span class="comment">// (3)</span></span><br><span class="line">      .setHandler(r -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.failed()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.emitError(r.cause()); <span class="comment">// (4)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123; <span class="comment">// (5)</span></span><br><span class="line">    <span class="keyword">return</span> Future.failedFuture(<span class="string">"No more attempts"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// (6)</span></span><br><span class="line">    <span class="keyword">return</span> Future.failedFuture(<span class="keyword">new</span> IllegalStateException(<span class="string">"Attempts Exceeded"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的<code>Job</code>数据对象中，我们存储了最大重试次数<code>max_attempts</code>以及已经重试的次数<code>attempts</code>，所以我们首先根据这两个数据计算剩余的重试次数<code>remaining</code> (1)。如果还有剩余次数的话，我们就先调用<code>attemptAdd</code>方法增加一次已重试次数并 (2)，然后我们调用<code>reattempt</code>方法执行真正的任务重试逻辑 (3)。最后返回这两个异步方法组合的<code>Future</code>。如果其中一个过程出现错误，我们就发布<code>error</code>事件 (4)。如果没有剩余次数了或者超出剩余次数了，我们直接返回错误。</p>
<p>在我们解析<code>reattempt</code>方法之前，我们先来回顾一下Vert.x Kue中的任务失败恢复机制。Vert.x Kue支持延时重试机制(retry backoff)，并且支持不同的策略（如 <strong>fixed</strong> 以及 <strong>exponential</strong>）。之前我们提到<code>Job</code>类中有一个<code>backoff</code>成员变量，它用于配置延时重试的策略。它的格式类似于这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">type</span>": <span class="value"><span class="string">"fixed"</span></span>,</span><br><span class="line">    "<span class="attribute">delay</span>": <span class="value"><span class="number">5000</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>延时重试机制的实现在<code>getBackoffImpl</code>方法中，它返回一个<code>Function&lt;Integer, Long&gt;</code>对象，代表一个接受<code>Integer</code>类型（即<code>attempts</code>），返回<code>Long</code>类型（代表计算出的延时值）的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Function&lt;Integer, Long&gt; getBackoffImpl() &#123;</span><br><span class="line">  String type = <span class="keyword">this</span>.backoff.getString(<span class="string">"type"</span>, <span class="string">"fixed"</span>); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">long</span> _delay = <span class="keyword">this</span>.backoff.getLong(<span class="string">"delay"</span>, <span class="keyword">this</span>.delay); <span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"exponential"</span>: <span class="comment">// (3)</span></span><br><span class="line">      <span class="keyword">return</span> attempts -&gt; Math.round(_delay * <span class="number">0.5</span> * (Math.pow(<span class="number">2</span>, attempts) - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"fixed"</span>:</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// (4)</span></span><br><span class="line">      <span class="keyword">return</span> attempts -&gt; _delay;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们从<code>backoff</code>配置中获取延迟重试策略。目前Vert.x Kue支持两种策略：<code>fixed</code> 和 <code>exponential</code>。前者采用固定延迟时间，而后者采用指数增长型延迟时间。默认情况下Vert.x Kue会采用<code>fixed</code>策略 (1)。接下来我们从<code>backoff</code>配置中获取延迟时间，如果配置中没有指定，那么就使用任务对象中的延迟时间<code>delay</code> (2)。接下来就是根据具体的策略进行计算了。对于指数型延迟，我们计算<code>[delay * 0.5 * 2^attempts]</code>作为延迟时间 (3)；对于固定型延迟策略，我们直接使用获取到的延迟时间 (4)。</p>
<p>好啦，现在回到“真正的重试”方法 —— <code>reattempt</code>方法来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;Job&gt; <span class="title">reattempt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.backoff != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> delay = <span class="keyword">this</span>.getBackoffImpl().apply(attempts); <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.setDelay(delay)</span><br><span class="line">      .setPromote_at(System.currentTimeMillis() + delay)</span><br><span class="line">      .update() <span class="comment">// (2)</span></span><br><span class="line">      .compose(Job::delayed); <span class="comment">// (3)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.inactive(); <span class="comment">// (4)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先检查<code>backoff</code>配置是否存在，若存在则计算出对应的延时时间 (1) 并且设定<code>delay</code>和<code>promote_at</code>属性的值然后保存至Redis中 (2)。接着我们通过<code>delayed</code>方法将任务的状态设为延时(<code>DELAYED</code>) (3)。如果延时重试配置不存在，我们就通过<code>inactive</code>方法直接将此任务置入工作队列中 (4)。</p>
<p>这就是整个任务重试功能的实现，也不是很复杂蛤？观察上面的代码，我们可以发现<code>Future</code>组合无处不在。这种响应式的组合非常方便。想一想如果我们用回调的异步方式来写代码的话，我们很容易陷入回调地狱中(⊙o⊙)。。。几个回调嵌套起来总显得不是那么优美和简洁，而用响应式的、可组合的<code>Future</code>就可以有效地避免这个问题。</p>
<p>不错！到现在为止我们已经探索完<code>Job</code>类的源码了～下面我们来看一下<code>JobService</code>类。</p>
<h1 id="Event_Bus_服务_-_JobService">Event Bus 服务 - JobService</h1><p>在本章节中我们来探索一下<code>JobService</code>接口及其实现 —— 它包含着各种普通的操作和统计<code>Job</code>的逻辑。</p>
<h2 id="异步RPC">异步RPC</h2><p>我们的<code>JobService</code>是一个通用逻辑接口，因此我们希望应用中的每一个组件都能访问此服务，即进行RPC。在Vert.x中，我们可以将服务注册至Event Bus上，然后其它组件就可以通过Event Bus来远程调用注册的服务了。</p>
<p>传统的RPC有一个缺点：消费者需要阻塞等待生产者的回应。你可能想说：这是一种阻塞模型，和Vert.x推崇的异步开发模式不相符。没错！而且，传统的RPC不是真正<strong>面向失败设计</strong>的。</p>
<p>还好，Vert.x提供了一种高效的、响应式的RPC —— 异步RPC。我们不需要等待生产者的回应，而只需要传递一个<code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code>参数给异步方法。这样当收到生产者结果时，对应的<code>Handler</code>就会被调用，非常方便，这与Vert.x的异步开发模式相符。并且，<code>AsyncResult</code>也是面向失败设计的。</p>
<p>所以讲到这里，你可能想问：到底怎么在Event Bus上注册服务呢？我们是不是需要写一大堆的逻辑去包装和发送信息，然后在另一端解码信息并进行调用呢？不，这太麻烦了！有了Vert.x 服务代理，我们不需要这么做！Vert.x提供了一个组件 <strong>Vert.x Service Proxy</strong> 来自动生成服务代理。有了它的帮助，我们就只需要按照规范设计我们的异步服务接口，然后用<code>@ProxyGen</code>注解修饰即可。</p>
<p>[NOTE <code>@ProxyGen</code>注解的限制 | <code>@ProxyGen</code>注解的使用有诸多限制。比如，所有的异步方法都必须是基于回调的，也就是说每个方法都要接受一个<code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code>类型的参数。并且，类型<code>R</code>也是有限制的 —— 只允许基本类型以及数据对象类型。详情请参考<a href="http://vertx.io/docs/vertx-service-proxy/" target="_blank" rel="external">官方文档</a>。 ]</p>
<h2 id="异步服务接口">异步服务接口</h2><p>我们来看一下<code>JobService</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ProxyGen</span></span><br><span class="line"><span class="annotation">@VertxGen</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> JobService <span class="title">create</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JobServiceImpl(vertx, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> JobService <span class="title">createProxy</span><span class="params">(Vertx vertx, String address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ProxyHelper.createProxy(JobService.class, vertx, address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取任务，按照优先级顺序</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> id      job id</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Job&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 删除任务</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> id      job id</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">removeJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Void&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 判断任务是否存在</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> id      job id</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">existsJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Boolean&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取任务日志</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> id      job id</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getJobLog</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;JsonArray&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取某一范围内某个指定状态下的任务列表</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> state   expected job state</span><br><span class="line">   * <span class="doctag">@param</span> from    from</span><br><span class="line">   * <span class="doctag">@param</span> to      to</span><br><span class="line">   * <span class="doctag">@param</span> order   range order</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">jobRangeByState</span><span class="params">(String state, <span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取某一范围内某个指定状态和类型下的任务列表</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type    expected job type</span><br><span class="line">   * <span class="doctag">@param</span> state   expected job state</span><br><span class="line">   * <span class="doctag">@param</span> from    from</span><br><span class="line">   * <span class="doctag">@param</span> to      to</span><br><span class="line">   * <span class="doctag">@param</span> order   range order</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">jobRangeByType</span><span class="params">(String type, String state, <span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取某一范围内的任务列表（按照顺序或倒序）</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> from    from</span><br><span class="line">   * <span class="doctag">@param</span> to      to</span><br><span class="line">   * <span class="doctag">@param</span> order   range order</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">jobRange</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取指定状态和类型下的任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type    job type</span><br><span class="line">   * <span class="doctag">@param</span> state   job state</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">cardByType</span><span class="params">(String type, JobState state, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取某个状态下的任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> state   job state</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">card</span><span class="params">(JobState state, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取COMPLETE状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type    job type; if null, then return global metrics</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">completeCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取FAILED状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">failedCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取INACTIVE状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">inactiveCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取ACTIVE状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">activeCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取DELAYED状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">delayedCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取当前存在的所有任务类型</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getAllTypes</span><span class="params">(Handler&lt;AsyncResult&lt;List&lt;String&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取指定状态下的所有任务的ID</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> state   job state</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getIdsByState</span><span class="params">(JobState state, Handler&lt;AsyncResult&lt;List&lt;Long&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 工作队列运行时间（ms）</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getWorkTime</span><span class="params">(Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们还为<code>JobService</code>接口添加了<code>@VertxGen</code>注解，Vert.x Codegen可以处理此注解生成多种语言版本的服务。</p>
<p>在<code>JobService</code>接口中我们还定义了两个静态方法：<code>create</code>用于创建一个任务服务实例，<code>createProxy</code>用于创建一个服务代理。</p>
<p><code>JobService</code>接口中包含一些任务操作和统计的相关逻辑，每个方法的功能都已经在注释中阐述了，因此我们就直接来看它的实现吧～</p>
<h2 id="任务服务的实现">任务服务的实现</h2><p><code>JobService</code>接口的实现位于<code>JobServiceImpl</code>类中，代码非常长，因此这里就不贴代码了。。。大家可以对照<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/kue-core/src/main/java/io/vertx/blueprint/kue/service/impl/JobServiceImpl.java" target="_blank" rel="external">GitHub中的代码</a>读下面的内容。</p>
<ul>
<li><code>getJob</code>: 获取任务的方法非常简单。直接利用<code>hgetall</code>命令从Redis中取出对应的任务即可。</li>
<li><code>removeJob</code>: 我们可以将此方法看作是<code>getJob</code>和<code>Job#remove</code>两个方法的组合。</li>
<li><code>existsJob</code>: 使用<code>exists</code>命令判断对应<code>id</code>的任务是否存在。</li>
<li><code>getJobLog</code>: 使用<code>lrange</code>命令从<code>vertx_kue:job:{id}:log</code>列表中取出日志。</li>
<li><code>rangeGeneral</code>: 使用<code>zrange</code>命令获取一定范围内的任务，这是一个通用方法。</li>
</ul>
<p>[NOTE <code>zrange</code> 操作 | <code>zrange</code> 返回某一有序集合中某个特定范围内的元素。详情请见<a href="http://redis.io/commands/zrange" target="_blank" rel="external">ZRANGE - Redis</a>。 ]</p>
<p>以下三个方法复用了<code>rangeGeneral</code>方法：</p>
<ul>
<li><code>jobRangeByState</code>: 指定状态，对应的key为<code>vertx_kue:jobs:{state}</code>。</li>
<li><code>jobRangeByType</code>: 指定状态和类型，对应的key为<code>vertx_kue:jobs:{type}:{state}</code>。</li>
<li><code>jobRange</code>: 对应的key为<code>vertx_kue:jobs</code>。</li>
</ul>
<p>这两个通用方法用于任务数量的统计：</p>
<ul>
<li><code>cardByType</code>: 利用<code>zcard</code>命令获取某一指定状态和类型下任务的数量。</li>
<li><code>card</code>: 利用<code>zcard</code>命令获取某一指定状态下任务的数量。</li>
</ul>
<p>下面五个辅助统计方法复用了上面两个通用方法：</p>
<ul>
<li><code>completeCount</code></li>
<li><code>failedCount</code></li>
<li><code>delayedCount</code></li>
<li><code>inactiveCount</code></li>
<li><code>activeCount</code></li>
</ul>
<p>接着看：</p>
<ul>
<li><code>getAllTypes</code>: 利用<code>smembers</code>命令获取<code>vertx_kue:job:types</code>集合中存储的所有的任务类型。</li>
<li><code>getIdsByState</code>: 使用<code>zrange</code>获取某一指定状态下所有任务的ID。</li>
<li><code>getWorkTime</code>: 使用<code>get</code>命令从<code>vertx_kue:stats:work-time</code>中获取Vert.x Kue的工作时间。</li>
</ul>
<h2 id="注册任务服务">注册任务服务</h2><p>既然完成了<code>JobService</code>的实现，接下来我们来看一下如何利用Service Proxy将服务注册至Event Bus上。这里我们还需要一个<code>KueVerticle</code>来创建要注册的服务实例，并且将其注册至Event Bus上。</p>
<p>打开<code>io.vertx.blueprint.kue.queue.KueVerticle</code>类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.service.JobService;</span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.util.RedisHelper;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.logging.Logger;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.logging.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</span><br><span class="line"><span class="keyword">import</span> io.vertx.serviceproxy.ProxyHelper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KueVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Job.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EB_JOB_SERVICE_ADDRESS = <span class="string">"vertx.kue.service.job.internal"</span>; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> JsonObject config;</span><br><span class="line">  <span class="keyword">private</span> JobService jobService;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config();</span><br><span class="line">    <span class="keyword">this</span>.jobService = JobService.create(vertx, config); <span class="comment">// (2)</span></span><br><span class="line">    <span class="comment">// create redis client</span></span><br><span class="line">    RedisClient redisClient = RedisHelper.client(vertx, config);</span><br><span class="line">    redisClient.ping(pr -&gt; &#123; <span class="comment">// (3) test connection</span></span><br><span class="line">      <span class="keyword">if</span> (pr.succeeded()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Kue Verticle is running..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (4) register job service</span></span><br><span class="line">        ProxyHelper.registerService(JobService.class, vertx, jobService, EB_JOB_SERVICE_ADDRESS);</span><br><span class="line"></span><br><span class="line">        future.complete();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"oops!"</span>, pr.cause());</span><br><span class="line">        future.fail(pr.cause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们需要定义一个地址用于服务注册 (1)。在<code>start</code>方法中，我们创建了一个任务服务实例 (2)，然后通过<code>ping</code>命令测试Redis连接 (3)。如果连接正常，那么我们就可以通过<code>ProxyHelper</code>类中的<code>registerService</code>辅助方法来将服务实例注册至Event Bus上 (4)。</p>
<p>这样，一旦我们在集群模式下部署<code>KueVerticle</code>，服务就会被发布至Event Bus上，然后我们就可以在其他组件中去远程调用此服务了。很奇妙吧！</p>
<h1 id="Kue_-_工作队列">Kue - 工作队列</h1><p><code>Kue</code>类代表着工作队列。我们来看一下<code>Kue</code>类的实现。首先先看一下其构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Kue</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vertx = vertx;</span><br><span class="line">  <span class="keyword">this</span>.config = config;</span><br><span class="line">  <span class="keyword">this</span>.jobService = JobService.createProxy(vertx, EB_JOB_SERVICE_ADDRESS);</span><br><span class="line">  <span class="keyword">this</span>.client = RedisHelper.client(vertx, config);</span><br><span class="line">  Job.setVertx(vertx, RedisHelper.client(vertx, config)); <span class="comment">// init static vertx instance inner job</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要注意两点：第一点，我们通过<code>createProxy</code>方法来创建一个<code>JobService</code>的服务代理；第二点，之前提到过，我们需要在这里初始化<code>Job</code>类中的静态成员变量。</p>
<h2 id="基于Future的封装">基于Future的封装</h2><p>我们的<code>JobService</code>是基于回调的，这是服务代理组件所要求的。为了让Vert.x Kue更加响应式，使用起来更加方便，我们在<code>Kue</code>类中以基于Future的异步模式封装了<code>JobService</code>中的所有异步方法。这很简单，比如这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function">JobService <span class="title">getJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Job&gt;&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以这么封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;Optional&lt;Job&gt;&gt; getJob(<span class="keyword">long</span> id) &#123;</span><br><span class="line">  Future&lt;Optional&lt;Job&gt;&gt; future = Future.future();</span><br><span class="line">  jobService.getJob(id, r -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">      future.complete(Optional.ofNullable(r.result()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      future.fail(r.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是加一层<code>Future</code>。其它的封装过程也类似所以我们就不细说了。</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_future_based_methods.png" alt=""></p>
<h2 id="process和processBlocking方法">process和processBlocking方法</h2><p><code>process</code>和<code>processBlocking</code>方法用于处理任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">process</span><span class="params">(String type, <span class="keyword">int</span> n, Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The process times must be positive"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    processInternal(type, handler, <span class="keyword">false</span>);</span><br><span class="line">  &#125;<span class="function">f</span><br><span class="line">  <span class="title">setupTimers</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">process</span><span class="params">(String type, Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  processInternal(type, handler, <span class="keyword">false</span>);</span><br><span class="line">  setupTimers();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">processBlocking</span><span class="params">(String type, <span class="keyword">int</span> n, Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The process times must be positive"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    processInternal(type, handler, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  setupTimers();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个<code>process</code>方法都类似 —— 它们都是使用<strong>Event Loop</strong>线程处理任务的，其中第一个方法还可以指定同时处理任务数量的阈值。我们来回顾一下使用<strong>Event Loop</strong>线程的注意事项 —— 我们不能阻塞Event Loop线程。因此如果我们需要在处理任务时做一些耗时的操作，我们可以使用<code>processBlocking</code>方法。这几个方法的代码看起来都差不多，那么区别在哪呢？之前我们提到过，我们设计了一种Verticle - <code>KueWorker</code>，用于处理任务。因此对于<code>process</code>方法来说，<code>KueWorker</code>就是一种普通的Verticle；而对于<code>processBlocking</code>方法来说，<code>KueWorker</code>是一种<strong>Worker Verticle</strong>。这两种Verticle有什么不同呢？区别在于，Worker Verticle会使用<strong>Worker线程</strong>，因此即使我们执行一些耗时的操作，Event Loop线程也不会被阻塞。</p>
<p>创建及部署<code>KueWorker</code>的逻辑在<code>processInternal</code>方法中，这三个方法都使用了<code>processInternal</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processInternal</span><span class="params">(String type, Handler&lt;Job&gt; handler, <span class="keyword">boolean</span> isWorker)</span> </span>&#123;</span><br><span class="line">  KueWorker worker = <span class="keyword">new</span> KueWorker(type, handler, <span class="keyword">this</span>); <span class="comment">// (1)</span></span><br><span class="line">  vertx.deployVerticle(worker, <span class="keyword">new</span> DeploymentOptions().setWorker(isWorker), r0 -&gt; &#123; <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">if</span> (r0.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.on(<span class="string">"job_complete"</span>, msg -&gt; &#123;</span><br><span class="line">        <span class="keyword">long</span> dur = <span class="keyword">new</span> Job(((JsonObject) msg.body()).getJsonObject(<span class="string">"job"</span>)).getDuration();</span><br><span class="line">        client.incrby(RedisHelper.getKey(<span class="string">"stats:work-time"</span>), dur, r1 -&gt; &#123; <span class="comment">// (3)</span></span><br><span class="line">          <span class="keyword">if</span> (r1.failed())</span><br><span class="line">            r1.cause().printStackTrace();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们创建一个<code>KueWorker</code>实例 (1)。我们将在稍后详细介绍<code>KueWorker</code>的实现。然后我们根据提供的配置来部署此<code>KueWorker</code> (2)。<code>processInternal</code>方法的第三个参数代表此<code>KueWorker</code>是否为worker verticle。如果部署成功，我们就监听<code>complete</code>事件。每当接收到<code>complete</code>事件的时候，我们获取收到的信息（处理任务消耗的时间），然后用<code>incrby</code>增加对应的工作时间 (3)。</p>
<p>再回到前面三个处理方法中。除了部署<code>KueWorker</code>以外，我们还调用了<code>setupTimers</code>方法，用于设定定时器以监测延时任务以及监测活动任务TTL。</p>
<h2 id="监测延时任务">监测延时任务</h2><p>Vert.x Kue支持延时任务，因此我们需要在任务延时时间到达时将任务“提升”至工作队列中等待处理。这个工作是在<code>checkJobPromotion</code>方法中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkJobPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout = config.getInteger(<span class="string">"job.promotion.interval"</span>, <span class="number">1000</span>); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">int</span> limit = config.getInteger(<span class="string">"job.promotion.limit"</span>, <span class="number">1000</span>); <span class="comment">// (2)</span></span><br><span class="line">  vertx.setPeriodic(timeout, l -&gt; &#123; <span class="comment">// (3)</span></span><br><span class="line">    client.zrangebyscore(RedisHelper.getKey(<span class="string">"jobs:DELAYED"</span>), String.valueOf(<span class="number">0</span>), String.valueOf(System.currentTimeMillis()),</span><br><span class="line">      <span class="keyword">new</span> RangeLimitOptions(<span class="keyword">new</span> JsonObject().put(<span class="string">"offset"</span>, <span class="number">0</span>).put(<span class="string">"count"</span>, limit)), r -&gt; &#123;  <span class="comment">// (4)</span></span><br><span class="line">        <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">          r.result().forEach(r1 -&gt; &#123;</span><br><span class="line">            <span class="keyword">long</span> id = Long.parseLong(RedisHelper.stripFIFO((String) r1));</span><br><span class="line">            <span class="keyword">this</span>.getJob(id).compose(jr -&gt; jr.get().inactive())  <span class="comment">// (5)</span></span><br><span class="line">              .setHandler(jr -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (jr.succeeded()) &#123;</span><br><span class="line">                  jr.result().emit(<span class="string">"promotion"</span>, jr.result().getId()); <span class="comment">// (6)</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  jr.cause().printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r.cause().printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们从配置中获取监测延时任务的间隔(<code>job.promotion.interval</code>，默认1000ms)以及提升数量阈值(<code>job.promotion.limit</code>，默认1000)。然后我们使用<code>vertx.setPeriodic</code>方法设一个周期性的定时器 (3)，每隔一段时间就从Redis中获取需要被提升的任务 (4)。这里我们通过<code>zrangebyscore</code>获取每个需要被提升任务的<code>id</code>。我们来看一下<code>zrangebyscore</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisClient <span class="title">zrangebyscore</span><span class="params">(String key, String min, String max, RangeLimitOptions options, Handler&lt;AsyncResult&lt;JsonArray&gt;&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>key</code>: 某个有序集合的key，即<code>vertx_kue:jobs:DELAYED</code></li>
<li><code>min</code> and <code>max</code>: 最小值以及最大值（按照某种模式）。这里<code>min</code>是<strong>0</strong>，而<code>max</code>是当前时间戳</li>
</ul>
<p>我们来回顾一下<code>Job</code>类中的<code>state</code>方法。当我们要把任务状态设为<code>DELAYED</code>的时候，我们将score设为<code>promote_at</code>时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> DELAYED:</span><br><span class="line">  client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</span><br><span class="line">    <span class="keyword">this</span>.promote_at, <span class="keyword">this</span>.zid, _failure());</span><br></pre></td></tr></table></figure>
<p>因此我们将<code>max</code>设为当前时间(<code>System.currentTimeMillis()</code>)，只要当前时间超过需要提升的时间，这就说明此任务可以被提升了。</p>
<ul>
<li><code>options</code>: range和limit配置。这里我们需要指定<code>LIMIT</code>值所以我们用<code>new RangeLimitOptions(new JsonObject().put(&quot;offset&quot;, 0).put(&quot;count&quot;, limit)</code>创建了一个配置</li>
</ul>
<p><code>zrangebyscore</code>的结果是一个<code>JsonArray</code>，里面包含着所有等待提升任务的<code>zid</code>。获得结果后我们就将每个<code>zid</code>转换为<code>id</code>，然后分别获取对应的任务实体，最后对每个任务调用<code>inactive</code>方法来将任务状态设为<code>INACTIVE</code> (5)。如果任务成功提升至工作队列，我们就发送<code>promotion</code>事件 (6)。</p>
<h2 id="CallbackKue_-_提供多语言支持">CallbackKue - 提供多语言支持</h2><p>我们知道，Vert.x支持多种语言(如JS，Ruby)，因此如果能让我们的Vert.x Kue支持多种语言那当然是极好的！这没有问题～Vert.x Codegen可以处理含<code>@VertxGen</code>注解的异步接口，生成多语言版本。<code>@VertxGen</code>注解同样限制异步方法 —— 需要基于回调，因此我们设计了一个<code>CallbackKue</code>接口用于提供多语言支持。<code>CallbackKue</code>的设计非常简单，其实现复用了<code>Kue</code>和<code>jobService</code>的代码。大家可以直接看源码，一目了然，这里就不细说了。</p>
<p>注意要生成多语言版本的代码，需要添加相应的依赖。比如要生成Ruby版本的代码就要向<code>build.gradle</code>中添加<code>compile(&quot;io.vertx:vertx-lang-ruby:${vertxVersion}&quot;)</code>。</p>
<h1 id="KueWorker_-_任务在此处理">KueWorker - 任务在此处理</h1><p>好啦，我们已经对Vert.x Kue Core的几个核心部分有了大致的了解了，现在是时候探索一下任务处理的本源 - <code>KueWorker</code>了～</p>
<p>每一个worker都对应一个特定的任务类型，并且绑定着特定的处理函数(<code>Handler</code>)，所以我们需要在创建的时候指定它们。</p>
<h2 id="prepareAndStart方法">prepareAndStart方法</h2><p>在<code>KueWorker</code>中，我们使用<code>prepareAndStart</code>方法来准备要处理的任务并且开始处理任务的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAndStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.getJobFromBackend().setHandler(jr -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (jr.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (jr.result().isPresent()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.job = jr.result().get(); <span class="comment">// (2)</span></span><br><span class="line">        process(); <span class="comment">// (3)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, <span class="string">"job_not_exist"</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"job not exist"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, jr.cause().getMessage()));</span><br><span class="line">        jr.cause().printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较直观。首先我们通过<code>getJobFromBackend</code>方法从Redis中按照优先级顺序获取任务 (1)。如果成功获取任务，我们就把获取到的任务保存起来 (2) 然后通过<code>process</code>方法处理任务 (3)。如果中间出现错误，我们需要发送<code>error</code>错误事件，其中携带错误信息。</p>
<h2 id="使用zpop按照优先级顺序获取任务">使用zpop按照优先级顺序获取任务</h2><p>我们来看一下我们是如何从Redis中按照优先级顺序获取任务实体的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Future&lt;Optional&lt;Job&gt;&gt; getJobFromBackend() &#123;</span><br><span class="line">  Future&lt;Optional&lt;Job&gt;&gt; future = Future.future();</span><br><span class="line">  client.blpop(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="number">0</span>, r1 -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (r1.failed()) &#123;</span><br><span class="line">      client.lpush(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="string">"1"</span>, r2 -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (r2.failed())</span><br><span class="line">          future.fail(r2.cause());</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.zpop(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":INACTIVE"</span>)) <span class="comment">// (2)</span></span><br><span class="line">        .compose(kue::getJob) <span class="comment">// (3)</span></span><br><span class="line">        .setHandler(r -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">            future.complete(r.result());</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">            future.fail(r.cause());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我们已经了解到，每当我们保存一个任务的时候，我们都会向<code>vertx_kue:{type}:jobs</code>列表中插入一个新元素表示新的任务可供处理。因此这里我们通过<code>blpop</code>命令来等待可用的任务 (1)。一旦有任务可供处理，我们就利用<code>zpop</code>方法取出高优先级的任务的<code>zid</code> (2)。<code>zpop</code>命令是一个原子操作，用于从有序集合中弹出最小score值的元素。注意Redis没有实现<code>zpop</code>命令，因此我们需要自己实现。</p>
<p><a href="http://redis.io/topics/transactions#using-a-hrefcommandswatchwatcha-to-implement-zpop" target="_blank" rel="external">Redis官方文档</a>介绍了一种实现<code>zpop</code>命令的简单方法 - 利用 <code>WATCH</code>。这里我们利用另外一种思路实现<code>zpop</code>命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;Long&gt; <span class="title">zpop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  Future&lt;Long&gt; future = Future.future();</span><br><span class="line">  client.transaction()</span><br><span class="line">    .multi(_failure())</span><br><span class="line">    .zrange(key, <span class="number">0</span>, <span class="number">0</span>, _failure())</span><br><span class="line">    .zremrangebyrank(key, <span class="number">0</span>, <span class="number">0</span>, _failure())</span><br><span class="line">    .exec(r -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">        JsonArray res = r.result();</span><br><span class="line">        <span class="keyword">if</span> (res.getJsonArray(<span class="number">0</span>).size() == <span class="number">0</span>) <span class="comment">// empty set</span></span><br><span class="line">          future.fail(<span class="keyword">new</span> IllegalStateException(<span class="string">"Empty zpop set"</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            future.complete(Long.parseLong(RedisHelper.stripFIFO(</span><br><span class="line">              res.getJsonArray(<span class="number">0</span>).getString(<span class="number">0</span>))));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            future.fail(ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        future.fail(r.cause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的<code>zpop</code>的实现中，我们首先开始了一个事务块，然后依次执行<code>zrange</code>和<code>zremrangebyrank</code>命令。有关这些命令的详情我们就不细说了，可以参考<a href="http://redis.io/commands" target="_blank" rel="external">Redis官方文档</a>。然后我们提交事务，如果提交成功，我们会获得一个<code>JsonArray</code>类型的结果。正常情况下我们都可以通过<code>res.getJsonArray(0).getString(0)</code>获取到对应的<code>zid</code>值。获取到<code>zid</code>值以后我们就可以将其转换为任务的<code>id</code>了，最后我们将<code>id</code>置于<code>Future</code>内（因为<code>zpop</code>也是一个异步方法）。</p>
<p>接着回到<code>getJobFromBackend</code>方法中。获取到对应的<code>id</code>之后，我们就可以通过<code>Kue</code>的<code>getJob</code>函数获取任务实体了 (3)。由于<code>getJobFromBackend</code>也是一个异步方法，因此我们同样将结果置于<code>Future</code>中。</p>
<h2 id="真正的“处理”逻辑">真正的“处理”逻辑</h2><p>前边讲了那么多，都是在为处理任务做准备。。。不要着急，现在终于到了真正的“处理”逻辑咯！我们看一下<code>process</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> curTime = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">this</span>.job.setStarted_at(curTime)</span><br><span class="line">    .set(<span class="string">"started_at"</span>, String.valueOf(curTime)) <span class="comment">// (1) set start time</span></span><br><span class="line">    .compose(Job::active) <span class="comment">// (2) set the job state to ACTIVE</span></span><br><span class="line">    .setHandler(r -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">        Job j = r.result();</span><br><span class="line">        <span class="comment">// emit start event</span></span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"start"</span>, j, <span class="keyword">null</span>);  <span class="comment">// (3) emit job `start` event</span></span><br><span class="line">        <span class="comment">// (4) process logic invocation</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          jobHandler.handle(j);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">          j.done(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (5) consume the job done event</span></span><br><span class="line"></span><br><span class="line">        eventBus.consumer(Kue.workerAddress(<span class="string">"done"</span>, j), msg -&gt; &#123;</span><br><span class="line">          createDoneCallback(j).handle(Future.succeededFuture(</span><br><span class="line">            ((JsonObject) msg.body()).getJsonObject(<span class="string">"result"</span>)));</span><br><span class="line">        &#125;);</span><br><span class="line">        eventBus.consumer(Kue.workerAddress(<span class="string">"done_fail"</span>, j), msg -&gt; &#123;</span><br><span class="line">          createDoneCallback(j).handle(Future.failedFuture(</span><br><span class="line">            (String) msg.body()));</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">this</span>.job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, r.cause().getMessage()));</span><br><span class="line">          r.cause().printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了最核心的函数了！首先我们先给开始时间赋值 (1) 然后将任务状态置为<code>ACTIVE</code> (2)。如果这两个操作成功的话，我们就向Event Bus发送任务开始(<code>start</code>)事件 (3)。接下来我们调用真正的处理逻辑 - 之前绑定的<code>jobHandler</code> (4)。如果处理过程中抛出异常的话，Vert.x Kue就会调用<code>job.done(ex)</code>方法发送<code>done_fail</code>内部事件来通知worker任务处理失败。但是似乎没有看到在哪里接收并处理<code>done</code>和<code>done_fail</code>事件呢？就在这 (5)！一旦Vert.x Kue接收到这两个事件，它就会调用对应的<code>handler</code>去进行任务完成或失败的相应操作。这里的<code>handler</code>是由<code>createDoneCallback</code>方法生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; createDoneCallback(Job job) &#123;</span><br><span class="line">  <span class="keyword">return</span> r0 -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (job == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r0.failed()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fail(r0.cause()); <span class="comment">// (1)</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> dur = System.currentTimeMillis() - job.getStarted_at();</span><br><span class="line">    job.setDuration(dur)</span><br><span class="line">      .set(<span class="string">"duration"</span>, String.valueOf(dur)); <span class="comment">// (2)</span></span><br><span class="line">    JsonObject result = r0.result();</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      job.setResult(result)</span><br><span class="line">        .set(<span class="string">"result"</span>, result.encodePrettily()); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.complete().setHandler(r -&gt; &#123; <span class="comment">// (4)</span></span><br><span class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">        Job j = r.result();</span><br><span class="line">        <span class="keyword">if</span> (j.isRemoveOnComplete()) &#123; <span class="comment">// (5)</span></span><br><span class="line">          j.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"complete"</span>, j, <span class="keyword">null</span>); <span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.prepareAndStart(); <span class="comment">// (7) 准备处理下一个任务</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务处理有两种情况：完成和失败，因此我们先来看任务成功处理的情况。我们首先给任务的用时(<code>duration</code>)赋值 (2)，并且如果任务产生了结果，也给结果(<code>result</code>)赋值 (3)。然后我们调用<code>job.complete</code>方法将状态设置为<code>COMPLETE</code> (4)。如果成功的话，我们就检查<code>removeOnComplete</code>标志位 (5) 并决定是否将任务从Redis中移除。然后我们向Event Bus发送任务完成事件(<code>complete</code>)以及队列事件<code>job_complete</code> (6)。现在这个任务的处理过程已经结束了，worker需要准备处理下一个任务了，因此最后我们调用<code>prepareAndStart</code>方法准备处理下一个<code>Job</code>。</p>
<h2 id="处理失败了怎么办？">处理失败了怎么办？</h2><p>人生不如意事十之八九，任务处理过程中很可能会遇见各种各样的问题而失败。当任务处理失败时，我们调用<code>KueWorker</code>中的<code>fail</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">  job.failedAttempt(ex).setHandler(r -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (r.failed()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.error(r.cause(), job); <span class="comment">// (2)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Job res = r.result();</span><br><span class="line">      <span class="keyword">if</span> (res.hasAttempts()) &#123; <span class="comment">// (3)</span></span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"failed_attempt"</span>, job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, ex.getMessage()));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"failed"</span>, job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, ex.getMessage())); <span class="comment">// (4)</span></span><br><span class="line">      &#125;</span><br><span class="line">      prepareAndStart(); <span class="comment">// (5)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面对失败时，我们首先通过<code>failedAttempt</code>方法尝试从错误中恢复 (1)。如果恢复失败（比如没有重试次数了）就向Event Bus发送<code>error</code>队列事件 (2)。如果恢复成功，我们就根据是否还有剩余重试次数来发送对应的事件(<code>failed</code>或者<code>failed_attempt</code>)。搞定错误以后，worker同样需要准备处理下一个任务了，因此最后我们调用<code>prepareAndStart</code>方法准备处理下一个<code>Job</code> (5)。</p>
<p>这就是<code>KueWorker</code>的全部实现，是不是很有趣呢？看了这么久的代码也有些累了，下面是时候来写个Kue应用跑一下咯～</p>
<h1 id="展示时间！">展示时间！</h1><p>在<code>io.vertx.blueprint.kue.example</code>包下(<code>kue-example</code>子工程)创建一个<code>LearningVertxVerticle</code>类，然后编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.Kue;</span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.Job;</span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.Priority;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearningVertxVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建工作队列</span></span><br><span class="line">    Kue kue = Kue.createQueue(vertx, config());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听全局错误事件</span></span><br><span class="line">    kue.on(<span class="string">"error"</span>, message -&gt;</span><br><span class="line">      System.out.println(<span class="string">"[Global Error] "</span> + message.body()));</span><br><span class="line"></span><br><span class="line">    JsonObject data = <span class="keyword">new</span> JsonObject()</span><br><span class="line">      .put(<span class="string">"title"</span>, <span class="string">"Learning Vert.x"</span>)</span><br><span class="line">      .put(<span class="string">"content"</span>, <span class="string">"core"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备学习Vert.x，爽！</span></span><br><span class="line">    Job j = kue.createJob(<span class="string">"learn vertx"</span>, data)</span><br><span class="line">      .priority(Priority.HIGH)</span><br><span class="line">      .onComplete(r -&gt; &#123; <span class="comment">// 完成任务事件监听</span></span><br><span class="line">        System.out.println(<span class="string">"Feeling: "</span> + r.getResult().getString(<span class="string">"feeling"</span>, <span class="string">"none"</span>));</span><br><span class="line">    &#125;).onFailure(r -&gt; &#123; <span class="comment">// 任务失败事件监听</span></span><br><span class="line">        System.out.println(<span class="string">"eee...so difficult..."</span>);</span><br><span class="line">    &#125;).onProgress(r -&gt; &#123; <span class="comment">// 任务进度变更事件监听</span></span><br><span class="line">        System.out.println(<span class="string">"I love this! My progress =&gt; "</span> + r);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存任务</span></span><br><span class="line">    j.save().setHandler(r0 -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r0.succeeded()) &#123;</span><br><span class="line">        <span class="comment">// 开始学习！</span></span><br><span class="line">        kue.processBlocking(<span class="string">"learn vertx"</span>, <span class="number">1</span>, job -&gt; &#123;</span><br><span class="line">          job.progress(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">          <span class="comment">// 3秒速成</span></span><br><span class="line">          vertx.setTimer(<span class="number">3000</span>, r1 -&gt; &#123;</span><br><span class="line">            job.setResult(<span class="keyword">new</span> JsonObject().put(<span class="string">"feeling"</span>, <span class="string">"amazing and wonderful!"</span>)) <span class="comment">// 结果</span></span><br><span class="line">              .done(); <span class="comment">// 完成啦！</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">"Wow, something happened: "</span> + r0.cause().getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，一个Vert.x Kue应用可以分为几部分：创建工作队列、创建任务、保存任务以及处理任务。我们推荐开发者把应用写成<code>Verticle</code>的形式。</p>
<p>在这个例子中，我们要模拟一个学习Vert.x的任务！首先我们通过<code>Kue.createQueue</code>方法创建一个工作队列并且通过<code>on(error, handler)</code>方法监听全局错误(<code>error</code>)事件。接着我们通过<code>kue.createJob</code>方法创建学习任务，将优先级设定为<code>HIGH</code>，并且监听<code>complete</code>、<code>failed</code>以及<code>progress</code>事件。然后我们需要保存任务，保存完毕以后我们就可以通过<code>processBlocking</code>方法来执行耗时任务了。在处理逻辑中，我们首先通过<code>job.progress</code>方法将进度设为<code>10</code>，然后使用<code>vertx.setTimer</code>方法设一个3秒的定时器，定时器时间到以后赋予结果并完成任务。</p>
<p>像往常一样，我们还需要在<code>build.gradle</code>中配置一下。我们需要将<code>kue-example</code>子工程中的<code>Main-Verticle</code>属性设为刚才写的<code>io.vertx.blueprint.kue.example.LearningVertxVerticle</code>：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(<span class="string">"kue-example"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jar &#123;</span><br><span class="line">    archiveName = <span class="string">'vertx-blueprint-kue-example.jar'</span></span><br><span class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.example.LearningVertxVerticle'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，到了展示时间了！打开终端，构建项目：</p>
<pre><code><span class="title">gradle</span> build
</code></pre><p>当然不要忘记运行Redis：</p>
<pre><code>redis-<span class="keyword">server</span>
</code></pre><p>然后我们先运行Vert.x Kue Core部分：</p>
<pre><code>java -jar kue-core<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-core.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>然后再运行我们的实例：</p>
<pre><code>java -jar kue-example<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-example.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>这时终端应该会依次显示输出：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">INFO:</span> Kue Verticle is running...</span><br><span class="line">I love this! My progress =&gt; <span class="number">10</span></span><br><span class="line"><span class="label">Feeling:</span> amazing <span class="keyword">and</span> wonderful!</span><br></pre></td></tr></table></figure>
<p>当然你也可以在Vert.x Kue的Web端查看任务情况。</p>
<h1 id="完成我们的探索之旅！">完成我们的探索之旅！</h1><p>棒极了！我们终于结束了我们的Vert.x Kue核心部分探索之旅～～！从这篇超长的教程中，你学到了如何利用Vert.x去开发一个基于消息的应用！太酷了！</p>
<p>如果想了解<code>kue-http</code>的实现，请移步<a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/">Vert.x 蓝图 | Vert.x Kue 教程（Web部分）</a>。如果想了解更多的关于Vert.x Kue的特性，请移步<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">Vert.x Kue 特性介绍</a>。</p>
<p>Vert.x能做的不仅仅是这些。想要了解更多的关于Vert.x的知识，请参考<a href="http://vertx.io/docs/" target="_blank" rel="external">Vert.x 官方文档</a> —— 这永远是资料最齐全的地方。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/消息系统/">消息系统</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-vertx-blueprint-1-todo-backend-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/" class="article-date">
      <time datetime="2016-06-15T16:00:00.000Z" itemprop="datePublished">2016-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本文章是 <a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x 蓝图系列</a> 的第一篇教程。全系列：</p>
<ul>
<li>Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程</a></li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践</a></li>
</ul>
<h1 id="前言">前言</h1><p>在本教程中，我们会使用Vert.x来一步一步地开发一个REST风格的Web服务 - Todo Backend，你可以把它看作是一个简单的待办事项服务，我们可以自由添加或者取消各种待办事项。</p>
<p>通过本教程，你将会学习到以下的内容：</p>
<ul>
<li><strong>Vert.x</strong> 是什么，以及其基本设计思想</li>
<li><code>Verticle</code>是什么，以及如何使用<code>Verticle</code></li>
<li>如何用 <strong>Vert.x Web</strong> 来开发REST风格的Web服务</li>
<li><strong>异步编程风格</strong> 的应用</li>
<li>如何通过 Vert.x 的各种组件来进行数据的存储操作（如 <em>Redis</em> 和 <em>MySQL</em>）</li>
</ul>
<p>本教程是 <strong>Vert.x 蓝图系列</strong> 的第一篇教程，对应的Vert.x版本为<strong>3.3.3</strong>。本教程中的完整代码已托管至<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/tree/master" target="_blank" rel="external">GitHub</a>。</p>
<h1 id="踏入Vert-x之门">踏入Vert.x之门</h1><p>朋友，欢迎来到Vert.x的世界！初次听说Vert.x，你一定会非常好奇：这是啥？让我们来看一下Vert.x的官方解释：</p>
<blockquote>
<p>Vert.x is a tool-kit for building reactive applications on the JVM.</p>
</blockquote>
<p>(⊙o⊙)哦哦。。。翻译一下，Vert.x是一个在JVM上构建 <strong>响应式</strong> 应用的 <strong>工具集</strong> 。这个定义比较模糊，我们来简单解释一下：<strong>工具集</strong> 意味着Vert.x非常轻量，可以嵌入到你当前的应用中而不需要改变现有的结构；另一个重要的描述是 <strong>响应式</strong> —— Vert.x就是为构建响应式应用（系统）而设计的。响应式系统这个概念在 <a href="http://reactivemanifesto.org/" target="_blank" rel="external">Reactive Manifesto</a> 中有详细的定义。我们在这里总结4个要点：</p>
<ul>
<li>响应式的(Responsive)：一个响应式系统需要在 <em>合理</em> 的时间内处理请求。</li>
<li>弹性的(Resilient)：一个响应式系统必须在遇到 <em>异常</em> （崩溃，超时， <code>500</code> 错误等等）的时候保持响应的能力，所以它必须要为 <em>异常处理</em> 而设计。</li>
<li>可伸缩的(Elastic)：一个响应式系统必须在不同的负载情况下都要保持响应能力，所以它必须能伸能缩，并且可以利用最少的资源来处理负载。</li>
<li>消息驱动：一个响应式系统的各个组件之间通过 <strong>异步消息传递</strong> 来进行交互。</li>
</ul>
<p>Vert.x是 <strong>事件驱动的</strong>，同时也是非阻塞的。首先，我们来介绍 <strong>Event Loop</strong> 的概念。Event Loop是一组负责分发和处理事件的线程。注意，我们绝对不能去阻塞Event Loop线程，否则事件的处理过程会被阻塞，我们的应用就失去了响应能力。因此当我们在写Vert.x应用的时候，我们要时刻谨记 <strong>异步非阻塞开发模式</strong> 而不是传统的阻塞开发模式。我们将会在下面详细讲解异步非阻塞开发模式。</p>
<h1 id="我们的应用_-_待办事项服务">我们的应用 - 待办事项服务</h1><p>我们的应用是一个REST风格的待办事项服务，它非常简单，整个API其实就围绕着 <em>增删改查</em> 四种操作。所以我们可以设计以下的路由：</p>
<ul>
<li>添加待办事项: <code>POST /todos</code></li>
<li>获取某一待办事项: <code>GET /todos/:todoId</code></li>
<li>获取所有待办事项: <code>GET /todos</code></li>
<li>更新待办事项: <code>PATCH /todos/:todoId</code></li>
<li>删除某一待办事项: <code>DELETE /todos/:todoId</code></li>
<li>删除所有待办事项: <code>DELETE /todos</code></li>
</ul>
<p>注意我们这里不讨论REST风格API的设计规范（仁者见仁,智者见智），因此你也可以用你喜欢的方式去定义路由。</p>
<p>下面我们开始开发我们的项目！High起来～～～</p>
<h1 id="说干就干！">说干就干！</h1><p>Vert.x Core提供了一些较为底层的处理HTTP请求的功能，这对于Web开发来说不是很方便，因为我们通常不需要这么底层的功能，因此<a href="http://vertx.io/docs/vertx-web/java" target="_blank" rel="external">Vert.x Web</a>应运而生。Vert.x Web基于Vert.x Core，并且提供一组更易于创建Web应用的上层功能（如路由）。</p>
<h2 id="Gradle配置文件">Gradle配置文件</h2><p>首先我们先来创建我们的项目。在本教程中我们使用<strong>Gradle</strong>作为构建工具，当然你也可以使用其它诸如Maven之类的构建工具。我们的项目目录里需要有：</p>
<ol>
<li><code>src/main/java</code> 文件夹（源码目录）</li>
<li><code>src/test/java</code> 文件夹（测试目录）</li>
<li><code>build.gradle</code> 文件（Gradle配置文件）</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build<span class="class">.gradle</span></span><br><span class="line">├── settings<span class="class">.gradle</span></span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   └── java</span><br><span class="line">│   └── test</span><br><span class="line">│       └── java</span><br></pre></td></tr></table></figure>
<p>我们首先来创建 <code>build.gradle</code> 文件，这是Gradle对应的配置文件：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">targetCompatibility = <span class="number">1.8</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">  jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">  compile <span class="string">"io.vertx:vertx-core:3.3.3"</span></span><br><span class="line">  compile <span class="string">'io.vertx:vertx-web:3.3.3'</span></span><br><span class="line"></span><br><span class="line">  testCompile <span class="string">'io.vertx:vertx-unit:3.3.3'</span></span><br><span class="line">  testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能不是很熟悉Gradle，这不要紧。我们来解释一下：</p>
<ul>
<li>我们将 <code>targetCompatibility</code> 和 <code>sourceCompatibility</code> 这两个值都设为<strong>1.8</strong>，代表目标Java版本是Java 8。这非常重要，因为Vert.x就是基于Java 8构建的。</li>
<li>在<code>dependencies</code>中，我们声明了我们需要的依赖。<code>vertx-core</code> 和 <code>vert-web</code> 用于开发REST API。</li>
</ul>
<p>搞定<code>build.gradle</code>以后，我们开始写代码！</p>
<h2 id="待办事项对象">待办事项对象</h2><p>首先我们需要创建我们的数据实体对象 - <code>Todo</code> 实体。在<code>io.vertx.blueprint.todolist.entity</code>包下创建<code>Todo</code>类，并且编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.codegen.annotations.DataObject;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@DataObject</span>(generateConverter = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger acc = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">// counter</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> Boolean completed;</span><br><span class="line">  <span class="keyword">private</span> Integer order;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(Todo other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = other.id;</span><br><span class="line">    <span class="keyword">this</span>.title = other.title;</span><br><span class="line">    <span class="keyword">this</span>.completed = other.completed;</span><br><span class="line">    <span class="keyword">this</span>.order = other.order;</span><br><span class="line">    <span class="keyword">this</span>.url = other.url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(JsonObject obj)</span> </span>&#123;</span><br><span class="line">    TodoConverter.fromJson(obj, <span class="keyword">this</span>); <span class="comment">// 还未生成Converter的时候需要先注释掉，生成过后再取消注释</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(String jsonStr)</span> </span>&#123;</span><br><span class="line">    TodoConverter.fromJson(<span class="keyword">new</span> JsonObject(jsonStr), <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(<span class="keyword">int</span> id, String title, Boolean completed, Integer order, String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.completed = completed;</span><br><span class="line">    <span class="keyword">this</span>.order = order;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonObject <span class="title">toJson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JsonObject json = <span class="keyword">new</span> JsonObject();</span><br><span class="line">    TodoConverter.toJson(<span class="keyword">this</span>, json);</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIncId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = acc.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIncId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> acc.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setIncIdWith</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    acc.set(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">isCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getOrElse(completed, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompleted</span><span class="params">(Boolean completed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.completed = completed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getOrElse(order, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(Integer order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.order = order;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Todo todo = (Todo) o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id != todo.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!title.equals(todo.title)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (completed != <span class="keyword">null</span> ? !completed.equals(todo.completed) : todo.completed != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> order != <span class="keyword">null</span> ? order.equals(todo.order) : todo.order == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = id;</span><br><span class="line">    result = <span class="number">31</span> * result + title.hashCode();</span><br><span class="line">    result = <span class="number">31</span> * result + (completed != <span class="keyword">null</span> ? completed.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (order != <span class="keyword">null</span> ? order.hashCode() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Todo -&gt; &#123;"</span> +</span><br><span class="line">      <span class="string">"id="</span> + id +</span><br><span class="line">      <span class="string">", title='"</span> + title + <span class="string">'\''</span> +</span><br><span class="line">      <span class="string">", completed="</span> + completed +</span><br><span class="line">      <span class="string">", order="</span> + order +</span><br><span class="line">      <span class="string">", url='"</span> + url + <span class="string">'\''</span> +</span><br><span class="line">      <span class="string">'&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getOrElse</span><span class="params">(T value, T defaultValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? defaultValue : value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Todo <span class="title">merge</span><span class="params">(Todo todo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Todo(id,</span><br><span class="line">      getOrElse(todo.title, title),</span><br><span class="line">      getOrElse(todo.completed, completed),</span><br><span class="line">      getOrElse(todo.order, order),</span><br><span class="line">      url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的 <code>Todo</code> 实体对象由序号<code>id</code>、标题<code>title</code>、次序<code>order</code>、地址<code>url</code>以及代表待办事项是否完成的一个标识<code>complete</code>组成。我们可以把它看作是一个简单的Java Bean。它可以被编码成JSON格式的数据，我们在后边会大量使用JSON（事实上，在Vert.x中JSON非常普遍）。同时注意到我们给<code>Todo</code>类加上了一个注解：<code>@DataObject</code>，这是用于生成JSON转换类的注解。</p>
<blockquote>
<p><code>@DataObject</code> 注解</p>
<p>被 <code>@DataObject</code> 注解的实体类需要满足以下条件：拥有一个拷贝构造函数以及一个接受一个 <code>JsonObject</code> 对象的构造函数。</p>
</blockquote>
<p>我们利用Vert.x Codegen来自动生成JSON转换类。我们需要在<code>build.gradle</code>中添加依赖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compileOnly <span class="string">'io.vertx:vertx-codegen:3.3.3'</span></span><br></pre></td></tr></table></figure>
<p>由于Vert.x Codegen仅在编译期生成代码，因此我们这里使用了<code>compileOnly</code>(相当于Maven中的<code>provided</code>。需要Gradle 2.12及以上版本)。同时，我们需要在<code>io.vertx.blueprint.todolist.entity</code>包中添加<code>package-info.java</code>文件来指引Vert.x Codegen生成代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Indicates that this module contains classes that need to be generated / processed.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@ModuleGen</span>(name = <span class="string">"vertx-blueprint-todo-entity"</span>, groupPackage = <span class="string">"io.vertx.blueprint.todolist.entity"</span>)</span><br><span class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.codegen.annotations.ModuleGen;</span><br></pre></td></tr></table></figure>
<p>Vert.x Codegen本质上是一个注解处理器(annotation processing tool)，因此我们还需要在<code>build.gradle</code>中配置apt。往里面添加以下代码：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</span><br><span class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</span><br><span class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</span><br><span class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</span><br><span class="line">  <span class="keyword">options</span>.compilerArgs = [</span><br><span class="line">    <span class="string">"-proc:only"</span>,</span><br><span class="line">    <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</span><br><span class="line">    <span class="string">"-AoutputDirectory=$&#123;destinationDir.absolutePath&#125;"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sourceSets</span> &#123;</span><br><span class="line">  main &#123;</span><br><span class="line">    java &#123;</span><br><span class="line">      srcDirs += <span class="string">'src/main/generated'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileJava &#123;</span><br><span class="line">  <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></span><br><span class="line">  <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">  dependsOn annotationProcessing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，每次我们在编译项目的时候，Vert.x Codegen都会自动检测含有 <code>@DataObject</code> 注解的类并且根据配置生成JSON转换类。在本例中，我们应该会得到一个 <code>TodoConverter</code> 类，然后我们可以在<code>Todo</code>类中使用它。</p>
<h2 id="Verticle">Verticle</h2><p>下面我们来写我们的应用组件。在<code>io.vertx.blueprint.todolist.verticles</code>包中创建<code>SingleApplicationVerticle</code>类，并编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.verticles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</span><br><span class="line"><span class="keyword">import</span> io.vertx.redis.RedisOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleApplicationVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_HOST = <span class="string">"0.0.0.0"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_PORT = <span class="number">8082</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REDIS_PORT = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RedisClient redis;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span> with start...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的<code>SingleApplicationVerticle</code>类继承了<code>AbstractVerticle</code>抽象类。那么什么是 <code>Verticle</code> 呢？在Vert.x中，一个<code>Verticle</code>代表应用的某一组件。我们可以通过部署<code>Verticle</code>来运行这些组件。如果你了解 <strong>Actor</strong> 模型的话，你会发现它和Actor非常类似。</p>
<p>当<code>Verticle</code>被部署的时候，其<code>start</code>方法会被调用。我们注意到这里的<code>start</code>方法接受一个类型为<code>Future&lt;Void&gt;</code>的参数，这代表了这是一个异步的初始化方法。这里的<code>Future</code>代表着<code>Verticle</code>的初始化过程是否完成。你可以通过调用Future的<code>complete</code>方法来代表初始化过程完成，或者<code>fail</code>方法代表初始化过程失败。</p>
<p>现在我们<code>Verticle</code>的轮廓已经搞好了，那么下一步也就很明了了 - 创建HTTP Client并且配置路由，处理HTTP请求。</p>
<h1 id="Vert-x_Web与REST_API">Vert.x Web与REST API</h1><h2 id="创建HTTP服务端并配置路由">创建HTTP服务端并配置路由</h2><p>我们来给<code>start</code>方法加点东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  initData();</span><br><span class="line">  Router router = Router.router(vertx); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">  <span class="comment">// CORS support</span></span><br><span class="line">  Set&lt;String&gt; allowHeaders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  allowHeaders.add(<span class="string">"x-requested-with"</span>);</span><br><span class="line">  allowHeaders.add(<span class="string">"Access-Control-Allow-Origin"</span>);</span><br><span class="line">  allowHeaders.add(<span class="string">"origin"</span>);</span><br><span class="line">  allowHeaders.add(<span class="string">"Content-Type"</span>);</span><br><span class="line">  allowHeaders.add(<span class="string">"accept"</span>);</span><br><span class="line">  Set&lt;HttpMethod&gt; allowMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  allowMethods.add(HttpMethod.GET);</span><br><span class="line">  allowMethods.add(HttpMethod.POST);</span><br><span class="line">  allowMethods.add(HttpMethod.DELETE);</span><br><span class="line">  allowMethods.add(HttpMethod.PATCH);</span><br><span class="line"></span><br><span class="line">  router.route().handler(CorsHandler.create(<span class="string">"*"</span>) <span class="comment">// &lt;2&gt;</span></span><br><span class="line">    .allowedHeaders(allowHeaders)</span><br><span class="line">    .allowedMethods(allowMethods));</span><br><span class="line">  router.route().handler(BodyHandler.create()); <span class="comment">// &lt;3&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span>:routes</span></span><br><span class="line"></span><br><span class="line">  vertx.createHttpServer() <span class="comment">// &lt;4&gt;</span></span><br><span class="line">    .requestHandler(router::accept)</span><br><span class="line">    .listen(PORT, HOST, result -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.succeeded())</span><br><span class="line">          future.complete();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          future.fail(result.cause());</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(⊙o⊙)…一长串代码诶。。是不是看着很晕呢？我们来详细解释一下。</p>
<p>首先我们创建了一个 <code>Router</code> 实例 （1）。这里的<code>Router</code>代表路由器，相信做过Web开发的开发者们一定不会陌生。路由器负责将对应的HTTP请求分发至对应的处理逻辑（Handler）中。每个<code>Handler</code>负责处理请求并且写入回应结果。当HTTP请求到达时，对应的<code>Handler</code>会被调用。</p>
<p>然后我们创建了两个<code>Set</code>：<code>allowHeaders</code>和<code>allowMethods</code>，并且我们向里面添加了一些HTTP Header以及HTTP Method，然后我们给路由器绑定了一个<code>CorsHandler</code> （2）。<code>route()</code>方法（无参数）代表此路由匹配所有请求。这两个<code>Set</code>的作用是支持 <em>CORS</em>，因为我们的API需要开启CORS以便配合前端正常工作。有关CORS的详细内容我们就不在这里细说了，详情可以参考<a href="http://enable-cors.org/server.html" target="_blank" rel="external">这里</a>。我们这里只需要知道如何开启CORS支持即可。</p>
<p>接下来我们给路由器绑定了一个全局的<code>BodyHandler</code> （3），它的作用是处理HTTP请求正文并获取其中的数据。比如，在实现添加待办事项逻辑的时候，我们需要读取请求正文中的JSON数据，这时候我们就可以用<code>BodyHandler</code>。</p>
<p>最后，我们通过<code>vertx.createHttpServer()</code>方法来创建一个HTTP服务端 （4）。注意这个功能是Vert.x Core提供的底层功能之一。然后我们将我们的路由处理器绑定到服务端上，这也是Vert.x Web的核心。你可能不熟悉<code>router::accept</code>这样的表示，这是Java 8中的 <em>方法引用</em>，它相当于一个分发路由的<code>Handler</code>。当有请求到达时，Vert.x会调用<code>accept</code>方法。然后我们通过<code>listen</code>方法监听8082端口。因为创建服务端的过程可能失败，因此我们还需要给<code>listen</code>方法传递一个<code>Handler</code>来检查服务端是否创建成功。正如我们前面所提到的，我们可以使用<code>future.complete</code>来表示过程成功，或者用<code>future.fail</code>来表示过程失败。</p>
<p>到现在为止，我们已经创建好HTTP服务端了，但我们还没有见到任何的路由呢！不要着急，是时候去声明路由了！</p>
<h2 id="配置路由">配置路由</h2><p>下面我们来声明路由。正如我们之前提到的，我们的路由可以设计成这样：</p>
<ul>
<li>添加待办事项: <code>POST /todos</code></li>
<li>获取某一待办事项: <code>GET /todos/:todoId</code></li>
<li>获取所有待办事项: <code>GET /todos</code></li>
<li>更新待办事项: <code>PATCH /todos/:todoId</code></li>
<li>删除某一待办事项: <code>DELETE /todos/:todoId</code></li>
<li>删除所有待办事项: <code>DELETE /todos</code></li>
</ul>
<blockquote>
<p>路径参数</p>
<p>在URL中，我们可以通过<code>:name</code>的形式定义路径参数。当处理请求的时候，Vert.x会自动获取这些路径参数并允许我们访问它们。拿我们的路由举个例子，<code>/todos/19</code> 将 <code>todoId</code> 映射为 <code>19</code>。</p>
</blockquote>
<p>首先我们先在 <code>io.vertx.blueprint.todolist</code> 包下创建一个<code>Constants</code>类用于存储各种全局常量（当然也可以放到其对应的类中）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Constants</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** API Route */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_GET = <span class="string">"/todos/:todoId"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_LIST_ALL = <span class="string">"/todos"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_CREATE = <span class="string">"/todos"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_UPDATE = <span class="string">"/todos/:todoId"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_DELETE = <span class="string">"/todos/:todoId"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_DELETE_ALL = <span class="string">"/todos"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将<code>start</code>方法中的<code>TODO</code>标识处替换为以下的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes</span></span><br><span class="line">router.get(Constants.API_GET).handler(<span class="keyword">this</span>::handleGetTodo);</span><br><span class="line">router.get(Constants.API_LIST_ALL).handler(<span class="keyword">this</span>::handleGetAll);</span><br><span class="line">router.post(Constants.API_CREATE).handler(<span class="keyword">this</span>::handleCreateTodo);</span><br><span class="line">router.patch(Constants.API_UPDATE).handler(<span class="keyword">this</span>::handleUpdateTodo);</span><br><span class="line">router.delete(Constants.API_DELETE).handler(<span class="keyword">this</span>::handleDeleteOne);</span><br><span class="line">router.delete(Constants.API_DELETE_ALL).handler(<span class="keyword">this</span>::handleDeleteAll);</span><br></pre></td></tr></table></figure>
<p>代码很直观、明了。我们用对应的方法（如<code>get</code>,<code>post</code>,<code>patch</code>等等）将路由路径与路由器绑定，并且我们调用<code>handler</code>方法给每个路由绑定上对应的<code>Handler</code>，接受的<code>Handler</code>类型为<code>Handler&lt;RoutingContext&gt;</code>。这里我们分别绑定了六个方法引用，它们的形式都类似于这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将在稍后实现这六个方法，这也是我们待办事项服务逻辑的核心。</p>
<h2 id="异步方法模式">异步方法模式</h2><p>我们之前提到过，Vert.x是 <strong>异步、非阻塞的</strong> 。每一个异步的方法总会接受一个 <code>Handler</code> 参数作为回调函数，当对应的操作完成时会调用接受的<code>Handler</code>，这是异步方法的一种实现。还有一种等价的实现是返回<code>Future</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAsync</span><span class="params">(A a, B b, Handler&lt;R&gt; handler)</span></span>;</span><br><span class="line"><span class="comment">// 这两种实现等价</span></span><br><span class="line"><span class="function">Future&lt;R&gt; <span class="title">doAsync</span><span class="params">(A a, B b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>Future</code> 对象代表着一个操作的结果，这个操作可能还没有进行，可能正在进行，可能成功也可能失败。当操作完成时，<code>Future</code>对象会得到对应的结果。我们也可以通过<code>setHandler</code>方法给<code>Future</code>绑定一个<code>Handler</code>，当<code>Future</code>被赋予结果的时候，此<code>Handler</code>会被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;R&gt; future = doAsync(A a, B b);</span><br><span class="line">future.setHandler(r -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.failed()) &#123;</span><br><span class="line">        <span class="comment">// 处理失败</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 操作结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Vert.x中大多数异步方法都是基于Handler的。而在本教程中，这两种异步模式我们都会接触到。</p>
<h2 id="待办事项逻辑实现">待办事项逻辑实现</h2><p>现在是时候来实现我们的待办事项业务逻辑了！这里我们使用 Redis 作为数据持久化存储。有关Redis的详细介绍请参照<a href="http://redis.io/" target="_blank" rel="external">Redis 官方网站</a>。Vert.x给我们提供了一个组件—— Vert.x-redis，允许我们以异步的形式操作Redis数据。</p>
<blockquote>
<p>如何安装Redis？</p>
<p>请参照Redis官方网站上详细的<a href="http://redis.io/download#installation" target="_blank" rel="external">安装指南</a>。</p>
</blockquote>
<h3 id="Vert-x_Redis">Vert.x Redis</h3><p>Vert.x Redis允许我们以异步的形式操作Redis数据。我们首先需要在<code>build.gradle</code>中添加以下依赖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'io.vertx:vertx-redis-client:3.3.3'</span></span><br></pre></td></tr></table></figure>
<p>我们通过<code>RedisClient</code>对象来操作Redis中的数据，因此我们定义了一个类成员<code>redis</code>。在使用<code>RedisClient</code>之前，我们首先需要与Redis建立连接，并且需要配置（以<code>RedisOptions</code>的形式），后边我们再讲需要配置哪些东西。</p>
<p>我们来实现 <code>initData</code> 方法用于初始化 <code>RedisClient</code> 并且测试连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  RedisOptions config = <span class="keyword">new</span> RedisOptions()</span><br><span class="line">      .setHost(config().getString(<span class="string">"redis.host"</span>, REDIS_HOST)) <span class="comment">// redis host</span></span><br><span class="line">      .setPort(config().getInteger(<span class="string">"redis.port"</span>, REDIS_PORT)); <span class="comment">// redis port</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.redis = RedisClient.create(vertx, config); <span class="comment">// create redis client</span></span><br><span class="line"></span><br><span class="line">  redis.hset(Constants.REDIS_TODO_KEY, <span class="string">"24"</span>, Json.encodePrettily( <span class="comment">// test connection</span></span><br><span class="line">    <span class="keyword">new</span> Todo(<span class="number">24</span>, <span class="string">"Something to do..."</span>, <span class="keyword">false</span>, <span class="number">1</span>, <span class="string">"todo/ex"</span>)), res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.failed()) &#123;</span><br><span class="line">      LOGGER.error(<span class="string">"Redis service is not running!"</span>);</span><br><span class="line">      res.cause().printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在加载Verticle的时候，我们会首先调用<code>initData</code>方法，这样可以保证<code>RedisClient</code>可以被正常创建。</p>
<h3 id="存储格式">存储格式</h3><p>我们知道，Redis支持各种格式的数据，并且支持多种方式存储（如<code>list</code>、<code>hash map</code>等）。这里我们将我们的待办事项存储在 <em>哈希表(map)</em> 中。我们使用待办事项的<code>id</code>作为key，JSON格式的待办事项数据作为value。同时，我们的哈希表本身也要有个key，我们把它命名为 <em>VERT_TODO</em>，并且存储到<code>Constants</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_TODO_KEY = <span class="string">"VERT_TODO"</span>;</span><br></pre></td></tr></table></figure>
<p>正如我们之前提到的，我们利用了生成的JSON数据转换类来实现<code>Todo</code>实体与JSON数据之间的转换（通过几个构造函数），在后面实现待办事项服务的时候可以广泛利用。</p>
<h3 id="获取/获取所有待办事项">获取/获取所有待办事项</h3><p>我们首先来实现获取待办事项的逻辑。正如我们之前所提到的，我们的处理逻辑方法需要接受一个<code>RoutingContext</code>类型的参数。我们看一下获取某一待办事项的逻辑方法(<code>handleGetTodo</code>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">if</span> (todoID == <span class="keyword">null</span>)</span><br><span class="line">    sendError(<span class="number">400</span>, context.response()); <span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    redis.hget(Constants.REDIS_TODO_KEY, todoID, x -&gt; &#123; <span class="comment">// (3)</span></span><br><span class="line">      <span class="keyword">if</span> (x.succeeded()) &#123;</span><br><span class="line">        String result = x.result();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">          sendError(<span class="number">404</span>, context.response());</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          context.response()</span><br><span class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">            .end(result); <span class="comment">// (4)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        sendError(<span class="number">503</span>, context.response());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先通过<code>getParam</code>方法获取路径参数<code>todoId</code> (1)。我们需要检测路径参数获取是否成功，如果不成功就返回 <code>400 Bad Request</code> 错误 (2)。这里我们写一个函数封装返回错误response的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> statusCode, HttpServerResponse response)</span> </span>&#123;</span><br><span class="line">  response.setStatusCode(statusCode).end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面，<code>end</code>方法是非常重要的。只有我们调用<code>end</code>方法时，对应的HTTP Response才能被发送回客户端。</p>
<p>再回到<code>handleGetTodo</code>方法中。如果我们成功获取到了<code>todoId</code>，我们可以通过<code>hget</code>操作从Redis中获取对应的待办事项 (3)。<code>hget</code>代表通过key从对应的哈希表中获取对应的value，我们来看一下<code>hget</code>函数的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisClient <span class="title">hget</span><span class="params">(String key, String field, Handler&lt;AsyncResult&lt;String&gt;&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数<code>key</code>对应哈希表的key，第二个参数<code>field</code>代表待办事项的key，第三个参数代表当获取操作成功时对应的回调。在<code>Handler</code>中，我们首先检查操作是否成功，如果不成功就返回<code>503</code>错误。如果成功了，我们就可以获取操作的结果了。结果是<code>null</code>的话，说明Redis中没有对应的待办事项，因此我们返回<code>404 Not Found</code>代表不存在。如果结果存在，那么我们就可以通过<code>end</code>方法将其写入response中 (4)。注意到我们所有的RESTful API都返回JSON格式的数据，所以我们将<code>content-type</code>头设为<code>JSON</code>。</p>
<p>获取所有待办事项的逻辑<code>handleGetAll</code>与<code>handleGetTodo</code>大体上类似，但实现上有些许不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  redis.hvals(Constants.REDIS_TODO_KEY, res -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">      String encoded = Json.encodePrettily(res.result().stream() <span class="comment">// (2)</span></span><br><span class="line">        .map(x -&gt; <span class="keyword">new</span> Todo((String) x))</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line">      context.response()</span><br><span class="line">        .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        .end(encoded); <span class="comment">// (3)</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      sendError(<span class="number">503</span>, context.response());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们通过<code>hvals</code>操作 (1) 来获取某个哈希表中的所有数据（以JSON数组的形式返回，即<code>JsonArray</code>对象）。在Handler中我们还是像之前那样先检查操作是否成功。如果成功的话我们就可以将结果写入response了。注意这里我们不能直接将返回的<code>JsonArray</code>写入response。想象一下返回的<code>JsonArray</code>包括着待办事项的key以及对应的JSON数据（字符串形式），因此此时每个待办事项对应的JSON数据都被转义了，所以我们需要先把这些转义过的JSON数据转换成实体对象，再重新编码。</p>
<p>我们这里采用了一种响应式编程思想的方法。首先我们了解到<code>JsonArray</code>类继承了<code>Iterable&lt;Object&gt;</code>接口（是不是感觉它很像<code>List</code>呢？），因此我们可以通过<code>stream</code>方法将其转化为<code>Stream</code>对象。注意这里的<code>Stream</code>可不是传统意义上讲的输入输出流(I/O stream)，而是数据流(data flow)。我们需要对数据流进行一系列的变换处理操作，这就是响应式编程的思想（也有点函数式编程的思想）。我们将数据流中的每个字符串数据转换为<code>Todo</code>实体对象，这个过程是通过<code>map</code>算子实现的。我们这里就不深入讨论<code>map</code>算子了，但它在函数式编程中非常重要。在<code>map</code>过后，我们通过<code>collect</code>方法将数据流“归约”成<code>List&lt;Todo&gt;</code>。现在我们就可以通过<code>Json.encodePrettily</code>方法对得到的list进行编码了，转换成JSON格式的数据。最后我们将转换后的结果写入到response中 (3)。</p>
<h3 id="创建待办事项">创建待办事项</h3><p>经过了上面两个业务逻辑实现的过程，你应该开始熟悉Vert.x了～现在我们来实现创建待办事项的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Todo todo = wrapObject(<span class="keyword">new</span> Todo(context.getBodyAsString()), context);</span><br><span class="line">    <span class="keyword">final</span> String encoded = Json.encodePrettily(todo);</span><br><span class="line">    redis.hset(Constants.REDIS_TODO_KEY, String.valueOf(todo.getId()),</span><br><span class="line">      encoded, res -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.succeeded())</span><br><span class="line">          context.response()</span><br><span class="line">            .setStatusCode(<span class="number">201</span>)</span><br><span class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">            .end(encoded);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          sendError(<span class="number">503</span>, context.response());</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</span><br><span class="line">    sendError(<span class="number">400</span>, context.response());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们通过<code>context.getBodyAsString()</code>方法来从请求正文中获取JSON数据并转换成<code>Todo</code>实体对象 (1)。这里我们包装了一个处理<code>Todo</code>实例的方法，用于给其添加必要的信息（如URL）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Todo <span class="title">wrapObject</span><span class="params">(Todo todo, RoutingContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = todo.getId();</span><br><span class="line">  <span class="keyword">if</span> (id &gt; Todo.getIncId()) &#123;</span><br><span class="line">    Todo.setIncIdWith(id);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    todo.setIncId();</span><br><span class="line">  todo.setUrl(context.request().absoluteURI() + <span class="string">"/"</span> + todo.getId());</span><br><span class="line">  <span class="keyword">return</span> todo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于没有ID（或者为默认ID）的待办事项，我们会给它分配一个ID。这里我们采用了自增ID的策略，通过<code>AtomicInteger</code>来实现。</p>
<p>然后我们通过<code>Json.encodePrettily</code>方法将我们的<code>Todo</code>实例再次编码成JSON格式的数据 (2)。接下来我们利用<code>hset</code>函数将待办事项实例插入到对应的哈希表中 (3)。如果插入成功，返回 <code>201</code> 状态码 (4)。</p>
<p>[NOTE 201 状态码? | 正如你所看到的那样，我们将状态码设为<code>201</code>，这代表<code>CREATED</code>（已创建）。另外，如果不指定状态码的话，Vert.x Web默认将状态码设为 <code>200 OK</code>。]</p>
<p>同时，我们接收到的HTTP请求首部可能格式不正确，因此我们需要在方法中捕获<code>DecodeException</code>异常。这样一旦捕获到<code>DecodeException</code>异常，我们就返回<code>400 Bad Request</code>状态码。</p>
<h3 id="更新待办事项">更新待办事项</h3><p>如果你想改变你的计划，你就需要更新你的待办事项。我们来实现更新待办事项的逻辑，它有点小复杂（或者说是，繁琐？）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PATCH /todos/:todoId</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUpdateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String todoID = context.request().getParam(<span class="string">"todoId"</span>); <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">final</span> Todo newTodo = <span class="keyword">new</span> Todo(context.getBodyAsString()); <span class="comment">// (2)</span></span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">    <span class="keyword">if</span> (todoID == <span class="keyword">null</span> || newTodo == <span class="keyword">null</span>) &#123;</span><br><span class="line">      sendError(<span class="number">400</span>, context.response());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redis.hget(Constants.REDIS_TODO_KEY, todoID, x -&gt; &#123; <span class="comment">// (3)</span></span><br><span class="line">      <span class="keyword">if</span> (x.succeeded()) &#123;</span><br><span class="line">        String result = x.result();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">          sendError(<span class="number">404</span>, context.response()); <span class="comment">// (4)</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          Todo oldTodo = <span class="keyword">new</span> Todo(result);</span><br><span class="line">          String response = Json.encodePrettily(oldTodo.merge(newTodo)); <span class="comment">// (5)</span></span><br><span class="line">          redis.hset(Constants.REDIS_TODO_KEY, todoID, response, res -&gt; &#123; <span class="comment">// (6)</span></span><br><span class="line">            <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">              context.response()</span><br><span class="line">                .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">                .end(response); <span class="comment">// (7)</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        sendError(<span class="number">503</span>, context.response());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</span><br><span class="line">    sendError(<span class="number">400</span>, context.response());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唔。。。一大长串代码诶。。。我们来看一下。首先我们从 <code>RoutingContext</code> 中获取路径参数 <code>todoId</code> (1)，这是我们想要更改待办事项对应的id。然后我们从请求正文中获取新的待办事项数据 (2)。这一步也有可能抛出 <code>DecodeException</code> 异常因此我们也需要去捕获它。要更新待办事项，我们需要先通过<code>hget</code>函数获取之前的待办事项 (3)，检查其是否存在。获取旧的待办事项之后，我们调用之前在<code>Todo</code>类中实现的<code>merge</code>方法将旧待办事项与新待办事项整合到一起 (5)，然后编码成JSON格式的数据。然后我们通过<code>hset</code>函数更新对应的待办事项 (6)（<code>hset</code>表示如果不存在就插入，存在就更新）。操作成功的话，返回 <code>200 OK</code> 状态。</p>
<p>这就是更新待办事项的逻辑～要有耐心哟，我们马上就要见到胜利的曙光了～下面我们来实现删除待办事项的逻辑。</p>
<h3 id="删除/删除全部待办事项">删除/删除全部待办事项</h3><p>删除待办事项的逻辑非常简单。我们利用<code>hdel</code>函数来删除某一待办事项，用<code>del</code>函数删掉所有待办事项（实际上是直接把那个哈希表给删了）。如果删除操作成功，返回<code>204 No Content</code> 状态。</p>
<p>这里直接给出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteOne</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>);</span><br><span class="line">  redis.hdel(Constants.REDIS_TODO_KEY, todoID, res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.succeeded())</span><br><span class="line">      context.response().setStatusCode(<span class="number">204</span>).end();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      sendError(<span class="number">503</span>, context.response());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  redis.del(Constants.REDIS_TODO_KEY, res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.succeeded())</span><br><span class="line">      context.response().setStatusCode(<span class="number">204</span>).end();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      sendError(<span class="number">503</span>, context.response());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>啊哈！我们实现待办事项服务的Verticle已经完成咯～一颗赛艇！但是我们该如何去运行我们的<code>Verticle</code>呢？答案是，我们需要 <em>部署并运行</em> 我们的Verticle。还好Vert.x提供了一个运行Verticle的辅助工具：Vert.x Launcher，让我们来看看如何利用它。</p>
<h2 id="将应用与Vert-x_Launcher一起打包">将应用与Vert.x Launcher一起打包</h2><p>要通过Vert.x Launcher来运行Verticle，我们需要在<code>build.gradle</code>中配置一下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">  <span class="comment">// by default fat jar</span></span><br><span class="line">  archiveName = <span class="string">'vertx-blueprint-todo-backend-fat.jar'</span></span><br><span class="line">  <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">  manifest &#123;</span><br><span class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.todolist.verticles.SingleApplicationVerticle'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>jar</code>区块中，我们配置Gradle使其生成 <strong>fat-jar</strong>，并指定启动类。<em>fat-jar</em> 是一个给Vert.x应用打包的简便方法，它直接将我们的应用连同所有的依赖都给打包到jar包中去了，这样我们可以直接通过jar包运行我们的应用而不必再指定依赖的 <code>CLASSPATH</code></li>
<li>我们将<code>Main-Class</code>属性设为<code>io.vertx.core.Launcher</code>，这样就可以通过Vert.x Launcher来启动对应的Verticle了。另外我们需要将<code>Main-Verticle</code>属性设为我们想要部署的Verticle的类名（全名）。</li>
</ul>
<p>配置好了以后，我们就可以打包了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle build</span><br></pre></td></tr></table></figure>
<h2 id="运行我们的服务">运行我们的服务</h2><p>万事俱备，只欠东风。是时候运行我们的待办事项服务了！首先我们先启动Redis服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<p>然后运行服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar build/libs/vertx-blueprint-todo-backend-fat.jar</span><br></pre></td></tr></table></figure>
<p>如果没问题的话，你将会在终端中看到 <code>Succeeded in deploying verticle</code> 的字样。下面我们可以自由测试我们的API了，其中最简便的方法是借助 <a href="https://github.com/TodoBackend/todo-backend-js-spec" target="_blank" rel="external">todo-backend-js-spec</a> 来测试。</p>
<p>键入 <code>http://127.0.0.1:8082/todos</code>：</p>
<p><img src="https://github.com/sczyh30/vertx-blueprint-todo-backend/raw/master/docs/img/todo-test-input.png" alt=""></p>
<p>测试结果：</p>
<p><img src="https://github.com/sczyh30/vertx-blueprint-todo-backend/raw/master/docs/img/todo-test-result.png" alt=""></p>
<p>当然，我们也可以用其它工具，比如 <code>curl</code> ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sczyh30@sczyh30-workshop:~$ curl http://127.0.0.1:8082/todos</span><br><span class="line">[ &#123;</span><br><span class="line">  "id" : 20578623,</span><br><span class="line">  "title" : "blah",</span><br><span class="line">  "completed" : false,</span><br><span class="line">  "order" : 95,</span><br><span class="line">  "url" : "http://127.0.0.1:8082/todos/20578623"</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  "id" : 1744802607,</span><br><span class="line">  "title" : "blah",</span><br><span class="line">  "completed" : false,</span><br><span class="line">  "order" : 523,</span><br><span class="line">  "url" : "http://127.0.0.1:8082/todos/1744802607"</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  "id" : 981337975,</span><br><span class="line">  "title" : "blah",</span><br><span class="line">  "completed" : false,</span><br><span class="line">  "order" : 95,</span><br><span class="line">  "url" : "http://127.0.0.1:8082/todos/981337975"</span><br><span class="line">&#125; ]</span><br></pre></td></tr></table></figure>
<h1 id="将服务与控制器分离">将服务与控制器分离</h1><p>啊哈～我们的待办事项服务已经可以正常运行了，但是回头再来看看 <code>SingleApplicationVerticle</code> 类的代码，你会发现它非常混乱，待办事项业务逻辑与控制器混杂在一起，让这个类非常的庞大，并且这也不利于我们服务的扩展。根据面向对象解耦的思想，我们需要将控制器部分与业务逻辑部分分离。</p>
<h2 id="用Future实现异步服务">用Future实现异步服务</h2><p>下面我们来设计我们的业务逻辑层。就像我们之前提到的那样，我们的服务需要是异步的，因此这些服务的方法要么需要接受一个<code>Handler</code>参数作为回调，要么需要返回一个<code>Future</code>对象。但是想象一下很多个<code>Handler</code>混杂在一起嵌套的情况，你会陷入 <em>回调地狱</em>，这是非常糟糕的。因此，这里我们用<code>Future</code>实现我们的待办事项服务。</p>
<p>在 <code>io.vertx.blueprint.todolist.service</code> 包下创建 <code>TodoService</code> 接口并且编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.entity.Todo;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TodoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">initData</span><span class="params">()</span></span>; <span class="comment">// 初始化数据（或数据库）</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">insert</span><span class="params">(Todo todo)</span></span>;</span><br><span class="line"></span><br><span class="line">  Future&lt;List&lt;Todo&gt;&gt; getAll();</span><br><span class="line"></span><br><span class="line">  Future&lt;Optional&lt;Todo&gt;&gt; getCertain(String todoID);</span><br><span class="line"></span><br><span class="line">  <span class="function">Future&lt;Todo&gt; <span class="title">update</span><span class="params">(String todoId, Todo newTodo)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">delete</span><span class="params">(String todoId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">deleteAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>getCertain</code>方法返回一个<code>Future&lt;Optional&lt;Todo&gt;&gt;</code>对象。那么<code>Optional</code>是啥呢？它封装了一个可能为空的对象。因为数据库里面可能没有与我们给定的<code>todoId</code>相对应的待办事项，查询的结果可能为空，因此我们给它包装上 <code>Optional</code>。<code>Optional</code> 可以避免万恶的 <code>NullPointerException</code>，并且它在函数式编程中用途特别广泛（在Haskell中对应 <strong>Maybe Monad</strong>）。</p>
<p>既然我们已经设计好我们的异步服务接口了，让我们来重构原先的Verticle吧！</p>
<h2 id="开始重构！">开始重构！</h2><p>我们创建一个新的Verticle。在 <code>io.vertx.blueprint.todolist.verticles</code> 包中创建 <code>TodoVerticle</code> 类，并编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.verticles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.Constants;</span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.entity.Todo;</span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.service.TodoService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AsyncResult;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Handler;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.http.HttpMethod;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.http.HttpServerResponse;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.DecodeException;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.Json;</span><br><span class="line"><span class="keyword">import</span> io.vertx.ext.web.Router;</span><br><span class="line"><span class="keyword">import</span> io.vertx.ext.web.RoutingContext;</span><br><span class="line"><span class="keyword">import</span> io.vertx.ext.web.handler.BodyHandler;</span><br><span class="line"><span class="keyword">import</span> io.vertx.ext.web.handler.CorsHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"0.0.0.0"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8082</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TodoService service;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Router router = Router.router(vertx);</span><br><span class="line">    <span class="comment">// CORS support</span></span><br><span class="line">    Set&lt;String&gt; allowHeaders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    allowHeaders.add(<span class="string">"x-requested-with"</span>);</span><br><span class="line">    allowHeaders.add(<span class="string">"Access-Control-Allow-Origin"</span>);</span><br><span class="line">    allowHeaders.add(<span class="string">"origin"</span>);</span><br><span class="line">    allowHeaders.add(<span class="string">"Content-Type"</span>);</span><br><span class="line">    allowHeaders.add(<span class="string">"accept"</span>);</span><br><span class="line">    Set&lt;HttpMethod&gt; allowMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    allowMethods.add(HttpMethod.GET);</span><br><span class="line">    allowMethods.add(HttpMethod.POST);</span><br><span class="line">    allowMethods.add(HttpMethod.DELETE);</span><br><span class="line">    allowMethods.add(HttpMethod.PATCH);</span><br><span class="line"></span><br><span class="line">    router.route().handler(BodyHandler.create());</span><br><span class="line">    router.route().handler(CorsHandler.create(<span class="string">"*"</span>)</span><br><span class="line">      .allowedHeaders(allowHeaders)</span><br><span class="line">      .allowedMethods(allowMethods));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// routes</span></span><br><span class="line">    router.get(Constants.API_GET).handler(<span class="keyword">this</span>::handleGetTodo);</span><br><span class="line">    router.get(Constants.API_LIST_ALL).handler(<span class="keyword">this</span>::handleGetAll);</span><br><span class="line">    router.post(Constants.API_CREATE).handler(<span class="keyword">this</span>::handleCreateTodo);</span><br><span class="line">    router.patch(Constants.API_UPDATE).handler(<span class="keyword">this</span>::handleUpdateTodo);</span><br><span class="line">    router.delete(Constants.API_DELETE).handler(<span class="keyword">this</span>::handleDeleteOne);</span><br><span class="line">    router.delete(Constants.API_DELETE_ALL).handler(<span class="keyword">this</span>::handleDeleteAll);</span><br><span class="line"></span><br><span class="line">    vertx.createHttpServer()</span><br><span class="line">      .requestHandler(router::accept)</span><br><span class="line">      .listen(PORT, HOST, result -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.succeeded())</span><br><span class="line">            future.complete();</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            future.fail(result.cause());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    initData();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUpdateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteOne</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> statusCode, HttpServerResponse response)</span> </span>&#123;</span><br><span class="line">    response.setStatusCode(statusCode).end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">badRequest</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    context.response().setStatusCode(<span class="number">400</span>).end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notFound</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    context.response().setStatusCode(<span class="number">404</span>).end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceUnavailable</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    context.response().setStatusCode(<span class="number">503</span>).end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Todo <span class="title">wrapObject</span><span class="params">(Todo todo, RoutingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = todo.getId();</span><br><span class="line">    <span class="keyword">if</span> (id &gt; Todo.getIncId()) &#123;</span><br><span class="line">      Todo.setIncIdWith(id);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">      todo.setIncId();</span><br><span class="line">    todo.setUrl(context.request().absoluteURI() + <span class="string">"/"</span> + todo.getId());</span><br><span class="line">    <span class="keyword">return</span> todo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很熟悉吧？这个<code>Verticle</code>的结构与我们之前的Verticle相类似，这里就不多说了。下面我们来利用我们之前编写的服务接口实现每一个控制器方法。</p>
<p>首先先实现 <code>initData</code> 方法，此方法用于初始化存储结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String serviceType = config().getString(<span class="string">"service.type"</span>, <span class="string">"redis"</span>);</span><br><span class="line">  LOGGER.info(<span class="string">"Service Type: "</span> + serviceType);</span><br><span class="line">  <span class="keyword">switch</span> (serviceType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"jdbc"</span>:</span><br><span class="line">      service = <span class="keyword">new</span> JdbcTodoService(vertx, config());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"redis"</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      RedisOptions config = <span class="keyword">new</span> RedisOptions()</span><br><span class="line">        .setHost(config().getString(<span class="string">"redis.host"</span>, <span class="string">"127.0.0.1"</span>))</span><br><span class="line">        .setPort(config().getInteger(<span class="string">"redis.port"</span>, <span class="number">6379</span>));</span><br><span class="line">      service = <span class="keyword">new</span> RedisTodoService(vertx, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  service.initData().setHandler(res -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.failed()) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Persistence service is not running!"</span>);</span><br><span class="line">        res.cause().printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们从配置中获取服务的类型，这里我们有两种类型的服务：<code>redis</code>和<code>jdbc</code>，默认是<code>redis</code>。接着我们会根据服务的类型以及对应的配置来创建服务。在这里，我们的配置都是从JSON格式的配置文件中读取，并通过Vert.x Launcher的<code>-conf</code>项加载。后面我们再讲要配置哪些东西。</p>
<p>接着我们给<code>service.initData()</code>方法返回的<code>Future</code>对象绑定了一个<code>Handler</code>，这个<code>Handler</code>将会在<code>Future</code>得到结果的时候被调用。一旦初始化过程失败，错误信息将会显示到终端上。</p>
<p>其它的方法实现也类似，这里就不详细解释了，直接放上代码，非常简洁明了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Wrap the result handler with failure handler (503 Service Unavailable)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler(RoutingContext context, Consumer&lt;T&gt; consumer) &#123;</span><br><span class="line">  <span class="keyword">return</span> res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">      consumer.accept(res.result());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      serviceUnavailable(context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Todo todo = wrapObject(<span class="keyword">new</span> Todo(context.getBodyAsString()), context);</span><br><span class="line">    <span class="keyword">final</span> String encoded = Json.encodePrettily(todo);</span><br><span class="line"></span><br><span class="line">    service.insert(todo).setHandler(resultHandler(context, res -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        context.response()</span><br><span class="line">          .setStatusCode(<span class="number">201</span>)</span><br><span class="line">          .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">          .end(encoded);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serviceUnavailable(context);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</span><br><span class="line">    sendError(<span class="number">400</span>, context.response());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>);</span><br><span class="line">  <span class="keyword">if</span> (todoID == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sendError(<span class="number">400</span>, context.response());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  service.getCertain(todoID).setHandler(resultHandler(context, res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.isPresent())</span><br><span class="line">      notFound(context);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> String encoded = Json.encodePrettily(res.get());</span><br><span class="line">      context.response()</span><br><span class="line">        .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        .end(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  service.getAll().setHandler(resultHandler(context, res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">      serviceUnavailable(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> String encoded = Json.encodePrettily(res);</span><br><span class="line">      context.response()</span><br><span class="line">        .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        .end(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUpdateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String todoID = context.request().getParam(<span class="string">"todoId"</span>);</span><br><span class="line">    <span class="keyword">final</span> Todo newTodo = <span class="keyword">new</span> Todo(context.getBodyAsString());</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">    <span class="keyword">if</span> (todoID == <span class="keyword">null</span>) &#123;</span><br><span class="line">      sendError(<span class="number">400</span>, context.response());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    service.update(todoID, newTodo)</span><br><span class="line">      .setHandler(resultHandler(context, res -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>)</span><br><span class="line">          notFound(context);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> String encoded = Json.encodePrettily(res);</span><br><span class="line">          context.response()</span><br><span class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">            .end(encoded);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</span><br><span class="line">    badRequest(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;Boolean&gt;&gt; deleteResultHandler(RoutingContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.result()) &#123;</span><br><span class="line">        context.response().setStatusCode(<span class="number">204</span>).end();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serviceUnavailable(context);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      serviceUnavailable(context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteOne</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>);</span><br><span class="line">  service.delete(todoID)</span><br><span class="line">    .setHandler(deleteResultHandler(context));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">  service.deleteAll()</span><br><span class="line">    .setHandler(deleteResultHandler(context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是和之前的Verticle很相似呢？这里我们还封装了两个<code>Handler</code>生成器：<code>resultHandler</code> 和 <code>deleteResultHandler</code>。这两个生成器封装了一些重复的代码，可以减少代码量。</p>
<p>嗯。。。我们的新Verticle写好了，那么是时候去实现具体的业务逻辑了。这里我们会实现两个版本的业务逻辑，分别对应两种存储：<strong>Redis</strong> 和 <strong>MySQL</strong>。</p>
<h2 id="Vert-x-Redis版本的待办事项服务">Vert.x-Redis版本的待办事项服务</h2><p>之前我们已经实现过一遍Redis版本的服务了，因此你应该对其非常熟悉了。这里我们仅仅解释一个 <code>update</code> 方法，其它的实现都非常类似，代码可以在<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/blob/master/src/main/java/io/vertx/blueprint/todolist/service/RedisTodoService.java" target="_blank" rel="external">GitHub</a>上浏览。</p>
<h3 id="Monadic_Future">Monadic Future</h3><p>回想一下我们之前写的更新待办事项的逻辑，我们会发现它其实是由两个独立的操作组成 - <code>get</code> 和 <code>insert</code>（对于Redis来说）。所以呢，我们可不可以复用 <code>getCertain</code> 和 <code>insert</code> 这两个方法？当然了！因为<code>Future</code>是可组合的，因此我们可以将这两个方法返回的<code>Future</code>组合到一起。是不是非常方便呢？我们来编写此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Todo&gt; <span class="title">update</span><span class="params">(String todoId, Todo newTodo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.getCertain(todoId).compose(old -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (old.isPresent()) &#123;</span><br><span class="line">      Todo fnTodo = old.get().merge(newTodo);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.insert(fnTodo)</span><br><span class="line">        .map(r -&gt; r ? fnTodo : <span class="keyword">null</span>); <span class="comment">// (2)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Future.succeededFuture(); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们调用了<code>getCertain</code>方法，此方法返回一个<code>Future&lt;Optional&lt;Todo&gt;&gt;</code>对象。同时我们使用<code>compose</code>函数将此方法返回的<code>Future</code>与另一个<code>Future</code>进行组合（1），其中<code>compose</code>函数接受一个<code>T =&gt; Future&lt;U&gt;</code>类型的lambda。然后我们接着检查旧的待办事项是否存在，如果存在的话，我们将新的待办事项与旧的待办事项相融合，然后更新待办事项。注意到<code>insert</code>方法返回<code>Future&lt;Boolean&gt;</code>类型的<code>Future</code>，因此我们还需要对此Future的结果做变换，这个变换的过程是通过<code>map</code>函数实现的（2）。<code>map</code>函数接受一个<code>T =&gt; U</code>类型的lambda。如果旧的待办事项不存在，我们返回一个包含null的<code>Future</code>（3）。最后我们返回组合后的<code>Future</code>对象。</p>
<blockquote>
<p><code>Future</code> 的本质</p>
<p>在函数式编程中，<code>Future</code> 实际上是一种 <code>Monad</code>。有关<code>Monad</code>的理论较为复杂，这里就不进行阐述了。你可以简单地把它看作是一个可以进行变换(<code>map</code>)和组合(<code>compose</code>)的包装对象。我们把这种特性叫做 <strong>monadic</strong>。</p>
</blockquote>
<p>下面来实现MySQL版本的待办事项服务。</p>
<h2 id="Vert-x-JDBC版本的待办事项服务">Vert.x-JDBC版本的待办事项服务</h2><h3 id="JDBC_++_异步">JDBC ++ 异步</h3><p>我们使用Vert.x-JDBC和MySQL来实现JDBC版本的待办事项服务。我们知道，数据库操作都是阻塞操作，很可能会占用不少时间。而Vert.x-JDBC提供了一种异步操作数据库的模式，很神奇吧？所以，在传统JDBC代码下我们要执行SQL语句需要这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String SQL = <span class="string">"SELECT * FROM todo"</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">ResultSet rs = pstmt.executeQuery(SQL);</span><br></pre></td></tr></table></figure>
<p>而在Vert.x JDBC中，我们可以利用回调获取数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.query(SQL, result -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something with result...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种异步操作可以有效避免对数据的等待。当数据获取成功时会自动调用回调函数来执行处理数据的逻辑。</p>
<h3 id="添加依赖">添加依赖</h3><p>首先我们需要向<code>build.gradle</code>文件中添加依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'io.vertx:vertx-jdbc-client:3.3.3'</span></span><br><span class="line">compile <span class="string">'mysql:mysql-connector-java:6.0.2'</span></span><br></pre></td></tr></table></figure>
<p>其中第二个依赖是MySQL的驱动，如果你想使用其他的数据库，你需要自行替换掉这个依赖。</p>
<h3 id="初始化JDBCClient">初始化JDBCClient</h3><p>在Vert.x JDBC中，我们需要从一个<code>JDBCClient</code>对象中获取数据库连接，因此我们来看一下如何创建<code>JDBCClient</code>实例。在<code>io.vertx.blueprint.todolist.service</code>包下创建<code>JdbcTodoService</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.entity.Todo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Vertx;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonArray;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"><span class="keyword">import</span> io.vertx.ext.jdbc.JDBCClient;</span><br><span class="line"><span class="keyword">import</span> io.vertx.ext.sql.SQLConnection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTodoService</span> <span class="keyword">implements</span> <span class="title">TodoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vertx vertx;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> JsonObject config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> JDBCClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JdbcTodoService</span><span class="params">(JsonObject config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Vertx.vertx(), config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JdbcTodoService</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vertx = vertx;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">this</span>.client = JDBCClient.createShared(vertx, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用<code>JDBCClient.createShared(vertx, config)</code>方法来创建一个<code>JDBCClient</code>实例，其中我们传入一个<code>JsonObject</code>对象作为配置。一般来说，我们需要配置以下的内容：</p>
<ul>
<li><em>url</em> - JDBC URL，比如 <code>jdbc:mysql://localhost/vertx_blueprint</code></li>
<li><em>driver_class</em> - JDBC驱动名称，比如 <code>com.mysql.cj.jdbc.Driver</code></li>
<li><em>user</em> - 数据库用户</li>
<li><em>password</em> - 数据库密码</li>
</ul>
<p>我们将会通过Vert.x Launcher从配置文件中读取此<code>JsonObject</code>。</p>
<p>现在我们已经创建了<code>JDBCClient</code>实例了，下面我们需要在MySQL中建这样一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`todo`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`completed`</span> TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`order`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`url`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
<p>我们把要用到的数据库语句都存到服务类中（这里我们就不讨论如何设计表以及写SQL了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_CREATE = <span class="string">"CREATE TABLE IF NOT EXISTS `todo` (\n"</span> +</span><br><span class="line">  <span class="string">"  `id` int(11) NOT NULL AUTO_INCREMENT,\n"</span> +</span><br><span class="line">  <span class="string">"  `title` varchar(255) DEFAULT NULL,\n"</span> +</span><br><span class="line">  <span class="string">"  `completed` tinyint(1) DEFAULT NULL,\n"</span> +</span><br><span class="line">  <span class="string">"  `order` int(11) DEFAULT NULL,\n"</span> +</span><br><span class="line">  <span class="string">"  `url` varchar(255) DEFAULT NULL,\n"</span> +</span><br><span class="line">  <span class="string">"  PRIMARY KEY (`id`) )"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_INSERT = <span class="string">"INSERT INTO `todo` "</span> +</span><br><span class="line">  <span class="string">"(`id`, `title`, `completed`, `order`, `url`) VALUES (?, ?, ?, ?, ?)"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_QUERY = <span class="string">"SELECT * FROM todo WHERE id = ?"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_QUERY_ALL = <span class="string">"SELECT * FROM todo"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_UPDATE = <span class="string">"UPDATE `todo`\n"</span> +</span><br><span class="line">  <span class="string">"SET `id` = ?,\n"</span> +</span><br><span class="line">  <span class="string">"`title` = ?,\n"</span> +</span><br><span class="line">  <span class="string">"`completed` = ?,\n"</span> +</span><br><span class="line">  <span class="string">"`order` = ?,\n"</span> +</span><br><span class="line">  <span class="string">"`url` = ?\n"</span> +</span><br><span class="line">  <span class="string">"WHERE `id` = ?;"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_DELETE = <span class="string">"DELETE FROM `todo` WHERE `id` = ?"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_DELETE_ALL = <span class="string">"DELETE FROM `todo`"</span>;</span><br></pre></td></tr></table></figure>
<p>OK！一切工作准备就绪，下面我们来实现我们的JDBC版本的服务～</p>
<h3 id="实现JDBC版本的服务">实现JDBC版本的服务</h3><p>所有的获取连接、获取执行数据的操作都要在<code>Handler</code>中完成。比如我们可以这样获取数据库连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">client.getConnection(conn -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (conn.succeeded()) &#123;</span><br><span class="line">        <span class="keyword">final</span> SQLConnection connection = conn.result();</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// handle failure</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>由于每一个数据库操作都需要获取数据库连接，因此我们来包装一个返回<code>Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt;</code>的方法，在此回调中可以直接使用数据库连接，可以减少一些代码量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt; connHandler(Future future, Handler&lt;SQLConnection&gt; handler) &#123;</span><br><span class="line">  <span class="keyword">return</span> conn -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (conn.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">final</span> SQLConnection connection = conn.result();</span><br><span class="line">      handler.handle(connection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      future.fail(conn.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取数据库连接以后，我们就可以对数据库进行各种操作了：</p>
<ul>
<li><code>query</code> : 执行查询（raw SQL）</li>
<li><code>queryWithParams</code> : 执行预编译查询（prepared statement）</li>
<li><code>updateWithParams</code> : 执行预编译DDL语句（prepared statement）</li>
<li><code>execute</code>: 执行任意SQL语句</li>
</ul>
<p>所有的方法都是异步的所以每个方法最后都接受一个<code>Handler</code>参数，我们可以在此<code>Handler</code>中获取结果并执行相应逻辑。</p>
<p>现在我们来编写初始化数据库表的<code>initData</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Future&lt;Boolean&gt; result = Future.future();</span><br><span class="line">  client.getConnection(connHandler(result, connection -&gt;</span><br><span class="line">    connection.execute(SQL_CREATE, create -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (create.succeeded()) &#123;</span><br><span class="line">        result.complete(<span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.fail(create.cause());</span><br><span class="line">      &#125;</span><br><span class="line">      connection.close();</span><br><span class="line">    &#125;)));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法仅会在Verticle初始化时被调用，如果<code>todo</code>表不存在的话就创建一下。注意，<strong>最后一定要关闭数据库连接</strong>。</p>
<p>下面我们来实现插入逻辑方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title">insert</span><span class="params">(Todo todo)</span> </span>&#123;</span><br><span class="line">  Future&lt;Boolean&gt; result = Future.future();</span><br><span class="line">  client.getConnection(connHandler(result, connection -&gt; &#123;</span><br><span class="line">    connection.updateWithParams(SQL_INSERT, <span class="keyword">new</span> JsonArray().add(todo.getId())</span><br><span class="line">      .add(todo.getTitle())</span><br><span class="line">      .add(todo.isCompleted())</span><br><span class="line">      .add(todo.getOrder())</span><br><span class="line">      .add(todo.getUrl()), r -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r.failed()) &#123;</span><br><span class="line">        result.fail(r.cause());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.complete(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      connection.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用<code>updateWithParams</code>方法执行插入逻辑，并且传递了一个<code>JsonArray</code>变量作为预编译参数。这一点很重要，使用预编译语句可以有效防止SQL注入。</p>
<p>我们再来实现<code>getCertain</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;Optional&lt;Todo&gt;&gt; getCertain(String todoID) &#123;</span><br><span class="line">  Future&lt;Optional&lt;Todo&gt;&gt; result = Future.future();</span><br><span class="line">  client.getConnection(connHandler(result, connection -&gt; &#123;</span><br><span class="line">    connection.queryWithParams(SQL_QUERY, <span class="keyword">new</span> JsonArray().add(todoID), r -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r.failed()) &#123;</span><br><span class="line">        result.fail(r.cause());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        List&lt;JsonObject&gt; list = r.result().getRows();</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span> || list.isEmpty()) &#123;</span><br><span class="line">          result.complete(Optional.empty());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result.complete(Optional.of(<span class="keyword">new</span> Todo(list.get(<span class="number">0</span>))));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      connection.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里，当我们的查询语句执行以后，我们获得到了<code>ResultSet</code>实例作为查询的结果集。我们可以通过<code>getColumnNames</code>方法获取字段名称，通过<code>getResults</code>方法获取结果。这里我们通过<code>getRows</code>方法来获取结果集，结果集的类型为<code>List&lt;JsonObject&gt;</code>。</p>
<p>其余的几个方法：<code>getAll</code>, <code>update</code>, <code>delete</code> 以及 <code>deleteAll</code>都遵循上面的模式，这里就不多说了。你可以在<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/blob/master/src/main/java/io/vertx/blueprint/todolist/service/JdbcTodoService.java" target="_blank" rel="external">GitHub</a>上浏览完整的源代码。</p>
<p>重构完毕，我们来写待办事项服务对应的配置，然后再来运行！</p>
<h2 id="再来运行！">再来运行！</h2><p>首先我们在项目的根目录下创建一个 <code>config</code> 文件夹作为配置文件夹。我们在其中创建一个<code>config_jdbc.json</code>文件作为 <code>jdbc</code> 类型服务的配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">service.type</span>": <span class="value"><span class="string">"jdbc"</span></span>,</span><br><span class="line">  "<span class="attribute">url</span>": <span class="value"><span class="string">"jdbc:mysql://localhost/vertx_blueprint?characterEncoding=UTF-8&amp;useSSL=false"</span></span>,</span><br><span class="line">  "<span class="attribute">driver_class</span>": <span class="value"><span class="string">"com.mysql.cj.jdbc.Driver"</span></span>,</span><br><span class="line">  "<span class="attribute">user</span>": <span class="value"><span class="string">"vbpdb1"</span></span>,</span><br><span class="line">  "<span class="attribute">password</span>": <span class="value"><span class="string">"666666*"</span></span>,</span><br><span class="line">  "<span class="attribute">max_pool_size</span>": <span class="value"><span class="number">30</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>你需要根据自己的情况替换掉上述配置文件中相应的内容(如 <em>JDBC URL</em>，<em>JDBC 驱动</em> 等)。</p>
<p>再建一个<code>config.json</code>文件作为<code>redis</code>类型服务的配置（其它的项就用默认配置好啦）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">service.type</span>": <span class="value"><span class="string">"redis"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>我们的构建文件也需要更新咯～这里直接给出最终的<code>build.gradle</code>文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">version <span class="string">'1.0'</span></span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">  vertxVersion = <span class="string">"3.3.3"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">  <span class="comment">// by default fat jar</span></span><br><span class="line">  archiveName = <span class="string">'vertx-blueprint-todo-backend-fat.jar'</span></span><br><span class="line">  <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">  manifest &#123;</span><br><span class="line">    attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">    attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.todolist.verticles.TodoVerticle'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">  jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compileOnly requires Gradle 2.12+</span></span><br><span class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</span><br><span class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</span><br><span class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</span><br><span class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</span><br><span class="line">  <span class="keyword">options</span>.compilerArgs = [</span><br><span class="line">    <span class="string">"-proc:only"</span>,</span><br><span class="line">    <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</span><br><span class="line">    <span class="string">"-AoutputDirectory=$&#123;destinationDir.absolutePath&#125;"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sourceSets</span> &#123;</span><br><span class="line">  main &#123;</span><br><span class="line">    java &#123;</span><br><span class="line">      srcDirs += <span class="string">'src/main/generated'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileJava &#123;</span><br><span class="line">  <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></span><br><span class="line">  <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">  dependsOn annotationProcessing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-core:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-jdbc-client:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-redis-client:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  compileOnly(<span class="string">"io.vertx:vertx-codegen:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  <span class="keyword">compile</span> <span class="string">'mysql:mysql-connector-java:6.0.2'</span></span><br><span class="line"></span><br><span class="line">  testCompile(<span class="string">"io.vertx:vertx-unit:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  testCompile <span class="keyword">group</span>: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> wrapper(type: Wrapper) &#123;</span><br><span class="line">  gradleVersion = <span class="string">'3.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好啦好啦，迫不及待了吧？～打开终端，构建我们的应用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle build</span><br></pre></td></tr></table></figure>
<p>然后我们可以运行Redis版本的待办事项服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar build/libs/vertx-blueprint-todo-backend-fat.jar -conf config/config.json</span><br></pre></td></tr></table></figure>
<p>我们也可以运行JDBC版本的待办事项服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar build/libs/vertx-blueprint-todo-backend-fat.jar -conf config/config_jdbc.json</span><br></pre></td></tr></table></figure>
<p>同样地，我们也可以使用<a href="https://github.com/TodoBackend/todo-backend-js-spec" target="_blank" rel="external">todo-backend-js-spec</a>来测试我们的API。由于我们的API设计没有改变，因此测试结果应该不会有变化。</p>
<p>我们也提供了待办事项服务对应的Docker Compose镜像构建文件，可以直接通过Docker来运行我们的待办事项服务。你可以在仓库的根目录下看到<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/blob/master/docker-compose.yml" target="_blank" rel="external">相应的配置文件</a>，并通过 <code>docker-compose up -- build</code> 命令来构建并运行。</p>
<p><img src="https://github.com/sczyh30/vertx-blueprint-todo-backend/raw/master/docs/img/vbptds-docker-compose-running.png" alt="Docker Compose"></p>
<h1 id="哈哈，成功了！">哈哈，成功了！</h1><p>哈哈，恭喜你完成了整个待办事项服务，是不是很开心？～在整个教程中，你应该学到了很多关于 <code>Vert.x Web</code>、 <code>Vert.x Redis</code> 和 <code>Vert.x JDBC</code> 的开发知识。当然，最重要的是，你会对Vert.x的 <strong>异步开发模式</strong> 有了更深的理解和领悟。</p>
<p>另外，Vert.x 蓝图系列已经发布至Vert.x官网：<a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x Blueprint Tutorials</a>。其中<a href="http://sczyh30.github.io/vertx-blueprint-job-queue/cn/kue-core/index.html" target="_blank" rel="external">第二个Blueprint</a>是关于消息应用的，<a href="http://sczyh30.github.io/vertx-blueprint-microservice/cn/index.html" target="_blank" rel="external">第三个Blueprint</a>是关于微服务的，有兴趣的朋友可以参考后面几篇蓝图教程。</p>
<p>更多关于Vert.x的文章，请参考<a href="http://vertx.io/blog/archives/" target="_blank" rel="external">Blog on Vert.x Website</a>。官网的资料是最全面的 :-)</p>
<h1 id="来自其它框架？">来自其它框架？</h1><p>之前你可能用过其它的框架，比如Spring Boot。这一小节，我将会用类比的方式来介绍Vert.x Web的使用。</p>
<h2 id="来自Spring_Boot/Spring_MVC">来自Spring Boot/Spring MVC</h2><p>在Spring Boot中，我们通常在控制器(Controller)中来配置路由以及处理请求，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RestController</span></span><br><span class="line"><span class="annotation">@ComponentScan</span></span><br><span class="line"><span class="annotation">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TodoService service;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@RequestMapping</span>(method = RequestMethod.GET, value = <span class="string">"/todos/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Todo <span class="title">getCertain</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> service.fetch(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Spring Boot中，我们使用 <code>@RequestMapping</code> 注解来配置路由，而在Vert.x Web中，我们是通过 <code>Router</code> 对象来配置路由的。并且因为Vert.x Web是异步的，我们会给每个路由绑定一个处理器（<code>Handler</code>）来处理对应的请求。</p>
<p>另外，在Vert.x Web中，我们使用 <code>end</code> 方法来向客户端发送HTTP response。相对地，在Spring Boot中我们直接在每个方法中返回结果作为response。</p>
<h2 id="来自Play_Framework_2">来自Play Framework 2</h2><p>如果之前用过Play Framework 2的话，你一定会非常熟悉异步开发模式。在Play Framework 2中，我们在 <code>routes</code> 文件中定义路由，类似于这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GET</span>     /todos/:todoId      controllers.<span class="type">TodoController</span>.handleGetCertain(todoId: <span class="type">Int</span>)</span><br></pre></td></tr></table></figure>
<p>而在Vert.x Web中，我们通过<code>Router</code>对象来配置路由：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/todos/:todoId"</span>).handler(<span class="keyword">this</span>::handleGetCertain);</span><br></pre></td></tr></table></figure>
<p><code>this::handleGetCertain</code>是处理对应请求的方法引用（在Scala里可以把它看作是一个函数）。</p>
<p>Play Framework 2中的异步开发模式是基于<code>Future</code>的。每一个路由处理函数都返回一个<code>Action</code>对象（实质上是一个类型为<code>Request[A] =&gt; Result</code>的函数），我们在<code>Action.apply</code>(或<code>Action.async</code>)闭包中编写我们的处理逻辑，类似于这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleGetCertain</span>(</span>todoId: <span class="type">Int</span>): <span class="type">Action</span>[<span class="type">AnyContent</span>] = <span class="type">Action</span>.async &#123;</span><br><span class="line">    service.getCertain(todoId) map &#123; <span class="comment">// 服务返回的类型是 `Future[Option[Todo]]`</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(res) =&gt;</span><br><span class="line">            <span class="type">Ok</span>(<span class="type">Json</span>.toJson(res))</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">            <span class="type">NotFound</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在Vert.x Web中，异步开发模式基本上都是基于回调的（当然也可以用Vert.x RxJava）。我们可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</span><br><span class="line">    String todoId = context.request().getParam(<span class="string">"todoId"</span>); <span class="comment">// 获取Path Variable</span></span><br><span class="line">    service.getCertain(todoId).setHandler(r -&gt; &#123; <span class="comment">// 服务返回的类型是 `Future&lt;Optional&lt;Todo&gt;&gt;`</span></span><br><span class="line">        <span class="keyword">if</span> (r.succeeded) &#123;</span><br><span class="line">            Optional&lt;Todo&gt; res = r.result;</span><br><span class="line">            <span class="keyword">if</span> (res.isPresent()) &#123;</span><br><span class="line">                context.response()</span><br><span class="line">                    .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">                    .end(Json.encodePrettily(res));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendError(<span class="number">404</span>, context.response()); <span class="comment">// NotFound(404)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendError(<span class="number">503</span>, context.response());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="想要使用其它持久化存储框架？">想要使用其它持久化存储框架？</h2><p>你可能想在Vert.x中使用其它的持久化存储框架或库，比如MyBatis ORM或者Jedis，这当然可以啦！Vert.x允许开发者整合任何其它的框架和库，但是像MyBatis ORM这种框架都是阻塞型的，可能会阻塞Event Loop线程，因此我们需要利用<code>blockingHandler</code>方法去执行阻塞的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/todos/:todoId"</span>).blockingHandler(routingContext -&gt; &#123;</span><br><span class="line">            String todoID = routingContext.request().getParam(<span class="string">"todoId"</span>);</span><br><span class="line">            Todo res = service.fetchBlocking(todoID); <span class="comment">// 阻塞型</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 做一些微小的工作</span></span><br><span class="line"></span><br><span class="line">            routingContext.next();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>Vert.x会使用Worker线程去执行<code>blockingHandler</code>方法(或者Worker Verticles)中的操作，因此不会阻塞Event Loop线程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2016 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30.
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>