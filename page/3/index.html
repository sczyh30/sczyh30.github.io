<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>「千载弦歌，芳华如梦」 - sczyh30&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--<meta name="keywords" content="sczyh30, blog"/>-->
  <meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/page/3/index.html">
<meta property="og:site_name" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">
  
    <link rel="alternative" href="/atom.xml" title="「千载弦歌，芳华如梦」 - sczyh30&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/AIO/" style="font-size: 10px;">AIO</a> <a href="/tags/AMQP/" style="font-size: 10px;">AMQP</a> <a href="/tags/APT/" style="font-size: 10px;">APT</a> <a href="/tags/Akka-Actor/" style="font-size: 10px;">Akka Actor</a> <a href="/tags/Algorithm/" style="font-size: 13px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 16px;">C++</a> <a href="/tags/C-11/" style="font-size: 10px;">C++ 11</a> <a href="/tags/CE3/" style="font-size: 10px;">CE3</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Category-Theory/" style="font-size: 10px;">Category Theory</a> <a href="/tags/Chemistry/" style="font-size: 11px;">Chemistry</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Docker/" style="font-size: 11px;">Docker</a> <a href="/tags/Engine/" style="font-size: 10px;">Engine</a> <a href="/tags/Euterpea/" style="font-size: 10px;">Euterpea</a> <a href="/tags/FRP/" style="font-size: 10px;">FRP</a> <a href="/tags/Functional-Programming/" style="font-size: 18px;">Functional Programming</a> <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/GC/" style="font-size: 13px;">GC</a> <a href="/tags/GDB/" style="font-size: 10px;">GDB</a> <a href="/tags/Game/" style="font-size: 11px;">Game</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/Haskell/" style="font-size: 14px;">Haskell</a> <a href="/tags/HotSpot/" style="font-size: 12px;">HotSpot</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 19px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Klass-oop/" style="font-size: 10px;">Klass-oop</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/MIDI/" style="font-size: 10px;">MIDI</a> <a href="/tags/Mathematical-Logic/" style="font-size: 10px;">Mathematical Logic</a> <a href="/tags/Metaspace/" style="font-size: 10px;">Metaspace</a> <a href="/tags/Netflix-Hystrix/" style="font-size: 10px;">Netflix Hystrix</a> <a href="/tags/Network/" style="font-size: 16px;">Network</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Object-Model/" style="font-size: 12px;">Object Model</a> <a href="/tags/Play-Framework/" style="font-size: 11px;">Play Framework</a> <a href="/tags/Quorum/" style="font-size: 10px;">Quorum</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Reflection/" style="font-size: 11px;">Reflection</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/STL/" style="font-size: 11px;">STL</a> <a href="/tags/Scala/" style="font-size: 19px;">Scala</a> <a href="/tags/Slick/" style="font-size: 11px;">Slick</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Struct/" style="font-size: 10px;">Struct</a> <a href="/tags/Summary/" style="font-size: 12px;">Summary</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/Type-Lambda/" style="font-size: 10px;">Type Lambda</a> <a href="/tags/Type-System/" style="font-size: 10px;">Type System</a> <a href="/tags/Type-Theory/" style="font-size: 12px;">Type Theory</a> <a href="/tags/UE4/" style="font-size: 10px;">UE4</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/Vert-x/" style="font-size: 17px;">Vert.x</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Web/" style="font-size: 12px;">Web</a> <a href="/tags/Web开发/" style="font-size: 12px;">Web开发</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/functional/" style="font-size: 10px;">functional</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/事务/" style="font-size: 10px;">事务</a> <a href="/tags/云服务/" style="font-size: 12px;">云服务</a> <a href="/tags/内存区域/" style="font-size: 10px;">内存区域</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/分布式系统/" style="font-size: 12px;">分布式系统</a> <a href="/tags/前端/" style="font-size: 12px;">前端</a> <a href="/tags/基础/" style="font-size: 10px;">基础</a> <a href="/tags/多线程/" style="font-size: 11px;">多线程</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/并发/" style="font-size: 13px;">并发</a> <a href="/tags/开发/" style="font-size: 17px;">开发</a> <a href="/tags/异步/" style="font-size: 13px;">异步</a> <a href="/tags/异步编程/" style="font-size: 16px;">异步编程</a> <a href="/tags/微服务/" style="font-size: 13px;">微服务</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 11px;">数据库</a> <a href="/tags/架构/" style="font-size: 11px;">架构</a> <a href="/tags/消息系统/" style="font-size: 10px;">消息系统</a> <a href="/tags/源码分析/" style="font-size: 12px;">源码分析</a> <a href="/tags/生活/" style="font-size: 10px;">生活</a> <a href="/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Fighting</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-play-music-on-linux" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Miscellaneous/play-music-on-linux/" class="article-date">
      <time datetime="2016-04-07T16:00:00.000Z" itemprop="datePublished">2016-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Miscellaneous/play-music-on-linux/">在Linux环境下玩转MIDI</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>今天在Ubuntu下搭了各种MIDI环境，为后边玩 <em>Haskell School of Music</em> 中讲的Euterpea音乐库做准备。</p>
<h1 id="ASLA">ASLA</h1><p>首先介绍一下ASLA(Advanced Linux Sound Architecture)，它为Linux提供了MIDI和音频功能，相当于Linux下音频的基础。Ubuntu应该自带ALSA。</p>
<p><img src="http://tedfelix.com/linux/linux-midi.png" alt=""></p>
<p>查看一下当前系统的内核：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sczyh3<span class="number">0</span><span class="variable">@sczyh30</span>-<span class="symbol">workshop:</span>~<span class="variable">$ </span> uname -a</span><br><span class="line"><span class="constant">Linux </span>sczyh3<span class="number">0</span>-workshop <span class="number">3.19</span>.<span class="number">0</span>-<span class="number">49</span>-generic <span class="comment">#55-Ubuntu SMP Fri Jan 22 02:10:24 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure></p>
<p>由于玩MIDI对时间要求严格，不能卡顿，因此推荐用低延时的内核(Low Latency Kernel)，可以通过<code>sudo apt-get install linux-lowlatency</code>安装然后调整<code>CONFIG_HZ</code>参数。</p>
<p>然后我们来查看一下ALSA设备：<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sczyh30@sczyh30-workshop:~$  cat /<span class="keyword">proc</span>/asound/cards</span><br><span class="line"> 0 [HDMI           ]:<span class="symbol"> HDA-Intel</span> -<span class="symbol"> HDA</span> Intel<span class="symbol"> HDMI</span></span><br><span class="line"><span class="symbol">                      HDA</span> Intel<span class="symbol"> HDMI</span> at 0xf7b14000<span class="symbol"> irq</span> 34</span><br><span class="line"> 1 [PCH            ]:<span class="symbol"> HDA-Intel</span> -<span class="symbol"> HDA</span> Intel<span class="symbol"> PCH</span></span><br><span class="line"><span class="symbol">                      HDA</span> Intel<span class="symbol"> PCH</span> at 0xf7b10000<span class="symbol"> irq</span> 33</span><br></pre></td></tr></table></figure></p>
<p>从出现的列表看不出哪个是声卡设备，因此再用<code>aplay</code>命令看一下详细信息：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sczyh30<span class="comment">@sczyh30-workshop:~$  aplay -l</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> PLAYBACK 硬體裝置清單 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">card 0: HDMI [HDA Intel HDMI], device 3: HDMI 0 [HDMI 0]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br><span class="line">card 0: HDMI [HDA Intel HDMI], device 7: HDMI 1 [HDMI 1]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br><span class="line">card 0: HDMI [HDA Intel HDMI], device 8: HDMI 2 [HDMI 2]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br><span class="line">card 1: PCH [HDA Intel PCH], device 0: ALC892 Analog [ALC892 Analog]</span><br><span class="line">  子设备: 0/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br><span class="line">card 1: PCH [HDA Intel PCH], device 1: ALC892 Digital [ALC892 Digital]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br></pre></td></tr></table></figure>
<p>可以看到card 1位置为声卡，在ALSA设备里表示为<code>hw:1</code>，当然card 1处有两个子设备，可以分别用<code>hw:1,0</code>和<code>hw:1,1</code>表示。在下边调用ALSA设备的时候都会用到<code>hw:1</code>。</p>
<p>下面来测试一下ALSA音频功能。首先通过<code>sox</code>命令生成一段音频，然后用<code>aplay</code>播放：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sox -b <span class="number">16</span> -n test.wav rate <span class="number">44100</span> channels <span class="number">2</span> synth <span class="number">1</span> sine <span class="number">440</span></span><br><span class="line">aplay -D hw:<span class="number">1</span> test.wav</span><br></pre></td></tr></table></figure></p>
<p>正常情况下会听到”滴”的一声，代表设备正常，否则就是设备设置的不对。如果提示设备忙，那么可能是其它程序（比如pulseaudio）占用了。</p>
<h1 id="FluidSynth">FluidSynth</h1><p>下面来玩一下 <strong>FluidSynth</strong> ，它是一个音频合成器。它可以将MIDI数据通过<code>soundfont</code>转化为音频。先安装：<code>sudo apt-get install fluidsynth</code>。</p>
<p>fluidsynth可以用来播放MIDI文件，命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fluidsynth --audio-driver=alsa -o audio.alsa.device=hw:<span class="number">1</span> /usr/share/sounds/sf2/FluidR3_GM.sf2 song.mid</span><br></pre></td></tr></table></figure></p>
<p>当然fluidsynth也可以接受其它程序传输的MIDI数据并转化为音频。这时候fluidsynth将作为一个“音频服务器”。它会等待其它程序与它建立连接，并发送MIDI数据。命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fluidsynth --server --audio-driver=alsa -o audio.alsa.device=hw:<span class="number">1</span> /usr/share/sounds/sf2/FluidR3_GM.sf2</span><br></pre></td></tr></table></figure>
<p>此时fluidsynth已开始运行，用<code>aplaymidi -l</code>命令可以看到fluidsynth正在监听的端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sczyh30@sczyh30-workshop:~$ aplaymidi <span class="operator">-l</span></span><br><span class="line"> Port    Client name                      Port name</span><br><span class="line"> <span class="number">14</span>:<span class="number">0</span>    Midi Through                     Midi Through Port-<span class="number">0</span></span><br><span class="line"><span class="number">128</span>:<span class="number">0</span>    FLUID Synth (<span class="number">26298</span>)              Synth input port (<span class="number">26298</span>:<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后就可以往这个端口传输MIDI数据，比如MIDI文件：<code>aplaymidi -p 128:0 song.mid</code>。</p>
<p>再来玩一下VMPK(Virtual MIDI Pinao Keyboard)，它是个MIDI Piano，产生MIDI数据。首先先安装：<code>sudo apt-get install vmpk</code>，然后启动。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/linux-piano-1.png" alt=""></p>
<p>这时候由于没有与音频设备建立连接，按琴键的时候不会有声音。我们需要通过<code>aconnect</code>命令与fluidsynth建立连接。首先查看一下当前的Audio IO：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/linux-vmpk-config-bash.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sczyh30@sczyh30-workshop:~$ aconnect -i</span><br><span class="line">client <span class="number">0</span>: <span class="string">'System'</span> [<span class="built_in">type</span>=内核]</span><br><span class="line">    <span class="number">0</span> <span class="string">'Timer           '</span></span><br><span class="line">    <span class="number">1</span> <span class="string">'Announce        '</span></span><br><span class="line">client <span class="number">14</span>: <span class="string">'Midi Through'</span> [<span class="built_in">type</span>=内核]</span><br><span class="line">    <span class="number">0</span> <span class="string">'Midi Through Port-0'</span></span><br><span class="line">client <span class="number">129</span>: <span class="string">'VMPK Output'</span> [<span class="built_in">type</span>=用户]</span><br><span class="line">    <span class="number">0</span> <span class="string">'VMPK Output     '</span></span><br><span class="line">sczyh30@sczyh30-workshop:~$ aconnect -o</span><br><span class="line">client <span class="number">14</span>: <span class="string">'Midi Through'</span> [<span class="built_in">type</span>=内核]</span><br><span class="line">    <span class="number">0</span> <span class="string">'Midi Through Port-0'</span></span><br><span class="line">client <span class="number">128</span>: <span class="string">'FLUID Synth (26298)'</span> [<span class="built_in">type</span>=用户]</span><br><span class="line">    <span class="number">0</span> <span class="string">'Synth input port (26298:0)'</span></span><br><span class="line">client <span class="number">130</span>: <span class="string">'VMPK Input'</span> [<span class="built_in">type</span>=用户]</span><br><span class="line">    <span class="number">0</span> <span class="string">'VMPK Input      '</span></span><br></pre></td></tr></table></figure>
<p>我们需要将MIDI转化为Audio，即从<code>VMPK</code>到<code>FLUID Synth</code>。建立连接：<code>aconnect 129:0 128:0</code>，然后再测试一下VMPK，有声音输出了。</p>
<p>FluidSynth也有GUI版本<code>Qsynth</code>，可以很方便地合成声音。</p>
<h1 id="Euterpea依赖">Euterpea依赖</h1><p>Euterpea需要asound：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libasound2-dev jackd2</span><br></pre></td></tr></table></figure></p>
<p>然而现在配置好Euterpea后，无论如何play它都不发声音。。。官网说这玩意只在某些特定的Haskell版本上正常运行，也是醉了。。待调试好后再来补充。。</p>
<p>【补充】Windows下不用配置就可以很愉快的玩Euterpea了。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Miscellaneous/">Miscellaneous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Euterpea/">Euterpea</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MIDI/">MIDI</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-slick-3-type-system-query-prolouge" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/slick-3-type-system-query-prolouge/" class="article-date">
      <time datetime="2016-04-06T16:00:00.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/slick-3-type-system-query-prolouge/">探索万恶的Slick 3 类型系统 | Prologue</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这两天在给Samsara Aquarius的各个Service写分页的时候，设计了一个抽象层，想把一些公共的分页逻辑放在这个trait中，但是被Slick的类型系统折磨了一点时间。。今天粗略看了一下相关的源码，结合这几天遇到的问题，总结一下。因此就把这篇文章作为Prologue吧。。。（Slick的版本为3.1.1）</p>
<h1 id="蛋疼的类型参数">蛋疼的类型参数</h1><p>在Slick里面，分页可以通过<code>drop</code>和<code>take</code>函数实现。<code>query.drop(offset).take(n)</code>对应的SQL为<code>LIMIT n, offset</code>。因此在一开始，我设计了一个trait作为分页逻辑的抽象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PageDao</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">page</span>(</span>): <span class="type">Future</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>(</span>offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[_]]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>page</code>函数用于获取总页数，<code>fetchWithPage</code>函数实现分页查询逻辑。</p>
<p>在Slick里，db操作通过<code>db.run(DBIOAction)</code>进行，而每个<code>Query</code>可以通过<code>result</code>函数隐式转换成<code>DBIOAction</code>，因此我们需要给参数中加上Query，以便我们的Service层可以传递不同的Query：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PageDao</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">page</span>(</span>query: slick.lifted.<span class="type">Query</span>[_, _, <span class="type">Seq</span>]): <span class="type">Future</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>(</span>query: slick.lifted.<span class="type">Query</span>[_, _, <span class="type">Seq</span>], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[_]]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Query[+E, U, C[_]]</code>是一个接受3个类型参数的type constructor，这为后边的蛋疼埋下伏笔。。</p>
<p>好了，接下来，由于我们需要在抽象层进行db操作，因此必须获取db对象，这里我选择继承<code>HasDatabaseConfigProvider[JdbcProfile]</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">WithPageProvider</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HasDatabaseConfigProvider</span>[</span><span class="type">JdbcProfile</span>] <span class="keyword">with</span> <span class="type">PageDao</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> driver.api._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">withQueryByPage</span> =</span></span><br><span class="line">    (query: slick.lifted.<span class="type">Query</span>[_, _, _], offset: <span class="type">Int</span>) =&gt;</span><br><span class="line">      query.drop(offset).take(<span class="type">LIMIT_PAGE</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">page</span>(</span>query: slick.lifted.<span class="type">Query</span>[_, _, _]): <span class="type">Future</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    db.run(query.length.result) map &#123; all =&gt;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">p</span> =</span> all % <span class="type">LIMIT_PAGE</span> == <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (p) all / <span class="type">LIMIT_PAGE</span></span><br><span class="line">      <span class="keyword">else</span> (all / <span class="type">LIMIT_PAGE</span>) + <span class="number">1</span></span><br><span class="line">    &#125; recover &#123;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">Exception</span> =&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>(</span>query: slick.lifted.<span class="type">Query</span>[_, _, _], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[_]] = &#123;</span><br><span class="line">    db.run(withQueryByPage(query, offset).result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯。。逻辑很快写好了，一切似乎都是OK的，下面在业务层中调用一下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>(</span>offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[(<span class="type">Category</span>, <span class="type">Int</span>)]] =</span><br><span class="line">    <span class="keyword">super</span>.fetchWithPage(categoriesCompiled, offset)</span><br></pre></td></tr></table></figure>
<p>很快，远方就传来了IDE提示GG的声音。。。提示：<code>Expression of type Future[Seq[_]] doesn&#39;t conform to expected type Future[Seq[(Category, Int)]]</code>。</p>
<p>嗯。。。看来是必须具化Seq的type parameter了。。那么就给trait里的<code>fetchWithPage</code>加个type parameter吧。。下面就陷入了苦逼的Slick类型系统初探过程——Slick在<code>run</code>、<code>result</code>的过程中，如何从一个原始的<code>Query[+E, U, C[_]]</code>转化为最终的<code>Future[Seq[R]]</code>？也就是说Query的这几个type parameters该取什么类型？想解决这个问题，只能看Slick的源码了。。首先从<code>run</code>函数出发，看看Future是怎么产生的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Run an Action asynchronously and return the result as a Future. */</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>[</span><span class="type">R</span>](a: <span class="type">DBIOAction</span>[<span class="type">R</span>, <span class="type">NoStream</span>, <span class="type">Nothing</span>]): <span class="type">Future</span>[<span class="type">R</span>] = runInternal(a, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，最后返回Future的类型参数是<code>DBIOAction[R, NoStream, Nothing]</code>的第一个类型参数R。接着我们看一下<code>DBIOAction</code>的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">DBIOAction</span>[</span>+<span class="type">R</span>, +<span class="type">S</span> &lt;: <span class="type">NoStream</span>, -<span class="type">E</span> &lt;: <span class="type">Effect</span>] <span class="keyword">extends</span> <span class="type">Dumpable</span></span><br></pre></td></tr></table></figure>
<p>嗯，看到这里，似乎明白了什么。。然后再看一下<code>Query</code>的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">QueryBase</span>[</span><span class="type">T</span>] <span class="keyword">extends</span> <span class="type">Rep</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>[</span>+<span class="type">E</span>, <span class="type">U</span>, <span class="type">C</span>[_]] <span class="keyword">extends</span> <span class="type">QueryBase</span>[<span class="type">C</span>[<span class="type">U</span>]]</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Query[+E, U, C[_]]</code>继承了<code>QueryBase[C[U]]</code>，然而注释里完全没有这三个type parameters的含义，所以就瞎猜。。注释里提到计算结果代表一个集合类型，如<code>Rep[Seq[T]]</code>，而<code>QueryBase[T]</code>又继承了<code>Rep[T]</code>，所以很容易想到<code>Query</code>第三个类型参数为<code>Seq</code>。然而一开始没有看到后边的<code>[C[U]]</code>，又因为DBIOAction中返回类型为第一个类型参数R，因此就错误地把这里的返回类型想成了第一个类型参数E（还是协变的，很迷惑人）。于是把<code>fetchWithPage</code>改成了这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>[</span><span class="type">R</span>](query: slick.lifted.<span class="type">Query</span>[<span class="type">R</span>, _, <span class="type">Seq</span>], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">R</span>]]</span><br></pre></td></tr></table></figure>
<p>仍然在报错，这次成了<code>Expression of type Future[Seq[Any]] doesn&#39;t conform to expected type Future[Seq[R]]</code>。</p>
<p>这时候提示就比较明显了，既然第一个类型参数已经限定为<code>R</code>，而返回值还为<code>Future[Seq[Any]]</code>，那么很容易就会联想到当前为<code>_</code>的类型参数有猫腻，即<code>Query[+E, U, C[_]]</code>中的<code>U</code>。这时候再看到后边继承的<code>QueryBase[C[U]]</code>，一切都一目了然了。这里的<code>QueryBase[C[U]]</code>是一个higher-kinded type，既然我们将<code>C</code>设为<code>Seq</code>，那么很容易想到<code>C[U]</code>其实就是对应着<code>Seq[Result]</code>，那么我们的R参数应该放在<code>Query</code>的第二个类型参数U上。改一下发现，一切都正常了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>[</span><span class="type">R</span>](query: slick.lifted.<span class="type">Query</span>[_, <span class="type">R</span>, <span class="type">Seq</span>], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">R</span>]] = &#123;</span><br><span class="line">    db.run(withQueryByPage(query, offset).result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="寻根溯源">寻根溯源</h1><p>问题解决了，但<code>Query[+E, U, C[_]]</code>里那个<code>+E</code>实在是很迷惑人，于是就继续探究了探究它到底是什么玩意。注释里没写，那就从<code>Query</code>的实现中找吧。。在<code>TableQuery</code>的定义中有：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableQuery</span>[</span><span class="type">E</span> &lt;: <span class="type">AbstractTable</span>[_]](cons: <span class="type">Tag</span> =&gt; <span class="type">E</span>) <span class="keyword">extends</span> <span class="type">Query</span>[<span class="type">E</span>, <span class="type">E</span>#<span class="type">TableElementType</span>, <span class="type">Seq</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The driver-independent superclass of all table row objects.*/</span></span><br><span class="line"><span class="comment">// @tparam T Row type for this table.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTable</span>[</span><span class="type">T</span>](<span class="function"><span class="keyword">val</span> <span class="title">tableTag</span>:</span> <span class="type">Tag</span>, <span class="function"><span class="keyword">val</span> <span class="title">schemaName</span>:</span> <span class="type">Option</span>[<span class="type">String</span>], <span class="function"><span class="keyword">val</span> <span class="title">tableName</span>:</span> <span class="type">String</span>) <span class="keyword">extends</span> <span class="type">Rep</span>[<span class="type">T</span>] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">TableElementType</span></span><br><span class="line"></span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>E需要是<code>AbstractTable[_]</code>的子类，而我们在定义表的映射的时候都是继承了<code>Table[_]</code>类，因此可以确定E就是查询的类型所对应的Table类（比如ArticleTable）。</p>
<p>另外一个值的探究的地方就是那个<code>result</code>函数是如何将一个<code>Query</code>转化为<code>DBIOAction</code>的。蛋疼的地方在于这个转换是隐式的（相当于实现了Typeclass Pattern），因此追踪如何转换的比较困难。好在写代码的时候发现，如果不导入<code>driver.api._</code>的话，就会找不到<code>result</code>函数，因此可以从这里入手。跳转到<code>api</code>的源码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">api</span>:</span> <span class="type">API</span> = <span class="keyword">new</span> <span class="type">API</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>那么秘密应该就藏在<code>JdbcProfile#API</code>类里了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">API</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">LowPriorityAPI</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">super</span>.<span class="title">API</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ImplicitColumnTypes</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">FastPath</span>[</span><span class="type">T</span>] = <span class="type">JdbcFastPath</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">SimpleDBIO</span>[</span>+<span class="type">R</span>] = <span class="type">SimpleJdbcAction</span>[<span class="type">R</span>]</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">SimpleDBIO</span> =</span> <span class="type">SimpleJdbcAction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">jdbcFastPathExtensionMethods</span>[</span><span class="type">T</span>, <span class="type">P</span>](mp: <span class="type">MappedProjection</span>[<span class="type">T</span>, <span class="type">P</span>]) = <span class="keyword">new</span> <span class="type">JdbcFastPathExtensionMethods</span>[<span class="type">T</span>, <span class="type">P</span>](mp)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">queryDeleteActionExtensionMethods</span>[</span><span class="type">C</span>[_]](q: <span class="type">Query</span>[_ &lt;: <span class="type">RelationalProfile</span>#<span class="type">Table</span>[_], _, <span class="type">C</span>]): <span class="type">DeleteActionExtensionMethods</span> =</span><br><span class="line">    createDeleteActionExtensionMethods(deleteCompiler.run(q.toNode).tree, ())</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">runnableCompiledDeleteActionExtensionMethods</span>[</span><span class="type">RU</span>, <span class="type">C</span>[_]](c: <span class="type">RunnableCompiled</span>[_ &lt;: <span class="type">Query</span>[_, _, <span class="type">C</span>], <span class="type">C</span>[<span class="type">RU</span>]]): <span class="type">DeleteActionExtensionMethods</span> =</span><br><span class="line">    createDeleteActionExtensionMethods(c.compiledDelete, c.param)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">runnableCompiledUpdateActionExtensionMethods</span>[</span><span class="type">RU</span>, <span class="type">C</span>[_]](c: <span class="type">RunnableCompiled</span>[_ &lt;: <span class="type">Query</span>[_, _, <span class="type">C</span>], <span class="type">C</span>[<span class="type">RU</span>]]): <span class="type">UpdateActionExtensionMethods</span>[<span class="type">RU</span>] =</span><br><span class="line">    createUpdateActionExtensionMethods(c.compiledUpdate, c.param)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">jdbcActionExtensionMethods</span>[</span><span class="type">E</span> &lt;: <span class="type">Effect</span>, <span class="type">R</span>, <span class="type">S</span> &lt;: <span class="type">NoStream</span>](a: <span class="type">DBIOAction</span>[<span class="type">R</span>, <span class="type">S</span>, <span class="type">E</span>]): <span class="type">JdbcActionExtensionMethods</span>[<span class="type">E</span>, <span class="type">R</span>, <span class="type">S</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">JdbcActionExtensionMethods</span>[<span class="type">E</span>, <span class="type">R</span>, <span class="type">S</span>](a)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">actionBasedSQLInterpolation</span>(</span>s: <span class="type">StringContext</span>) = <span class="keyword">new</span> <span class="type">ActionBasedSQLInterpolation</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面存在这样的继承关系（简化过后的）：<code>JdbcProfile#API &lt;:&lt; RelationalProfile#API &lt;:&lt; BasicProfile#API</code>。</p>
<p>再看RelationalProfile中的API类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">API</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">super</span>.<span class="title">API</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ImplicitColumnTypes</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Table</span>[</span><span class="type">T</span>] = driver.<span class="type">Table</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Sequence</span>[</span><span class="type">T</span>] = driver.<span class="type">Sequence</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">Sequence</span> =</span> driver.<span class="type">Sequence</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">ColumnType</span>[</span><span class="type">T</span>] = driver.<span class="type">ColumnType</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">BaseColumnType</span>[</span><span class="type">T</span>] = driver.<span class="type">BaseColumnType</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">MappedColumnType</span> =</span> driver.<span class="type">MappedColumnType</span></span><br><span class="line"></span><br><span class="line">  <span class="annotation">@deprecated</span>(<span class="string">"Use an explicit conversion to an Option column with `.?`"</span>, <span class="string">"3.0"</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">columnToOptionColumn</span>[</span><span class="type">T</span> : <span class="type">BaseTypedType</span>](c: <span class="type">Rep</span>[<span class="type">T</span>]): <span class="type">Rep</span>[<span class="type">Option</span>[<span class="type">T</span>]] = c.?</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">valueToConstColumn</span>[</span><span class="type">T</span> : <span class="type">TypedType</span>](v: <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">LiteralColumn</span>[<span class="type">T</span>](v)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">columnToOrdered</span>[</span><span class="type">T</span> : <span class="type">TypedType</span>](c: <span class="type">Rep</span>[<span class="type">T</span>]): <span class="type">ColumnOrdered</span>[<span class="type">T</span>] = <span class="type">ColumnOrdered</span>[<span class="type">T</span>](c, <span class="type">Ordering</span>())</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">tableQueryToTableQueryExtensionMethods</span>[</span><span class="type">T</span> &lt;: <span class="type">RelationalProfile</span>#<span class="type">Table</span>[_], <span class="type">U</span>](q: <span class="type">Query</span>[<span class="type">T</span>, <span class="type">U</span>, <span class="type">Seq</span>] <span class="keyword">with</span> <span class="type">TableQuery</span>[<span class="type">T</span>]) =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">TableQueryExtensionMethods</span>[<span class="type">T</span>, <span class="type">U</span>](q)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableCompiledInsertActionExtensionMethods</span>[</span><span class="type">EU</span>](c: <span class="type">StreamableCompiled</span>[_, _, <span class="type">EU</span>]): <span class="type">InsertActionExtensionMethods</span>[<span class="type">EU</span>] = createInsertActionExtensionMethods[<span class="type">EU</span>](c.compiledInsert.asInstanceOf[<span class="type">CompiledInsert</span>])</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">queryInsertActionExtensionMethods</span>[</span><span class="type">U</span>, <span class="type">C</span>[_]](q: <span class="type">Query</span>[_, <span class="type">U</span>, <span class="type">C</span>]) = createInsertActionExtensionMethods[<span class="type">U</span>](compileInsert(q.toNode))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">schemaActionExtensionMethods</span>(</span>sd: <span class="type">SchemaDescription</span>): <span class="type">SchemaActionExtensionMethods</span> = createSchemaActionExtensionMethods(sd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看BasicProfile中的API类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">API</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Aliases</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ExtensionMethodConversions</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Database</span> =</span> <span class="type">Backend</span>#<span class="type">Database</span></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">Database</span> =</span> backend.<span class="type">Database</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Session</span> =</span> <span class="type">Backend</span>#<span class="type">Session</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">SlickException</span> =</span> slick.<span class="type">SlickException</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">val</span> <span class="title">slickDriver</span>:</span> driver.<span class="keyword">type</span> = driver</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Work-around for SI-3346</span></span><br><span class="line">  <span class="annotation">@inline</span> <span class="keyword">implicit</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">anyToToShapedValue</span>[</span><span class="type">T</span>](value: <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">ToShapedValue</span>[<span class="type">T</span>](value)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">repQueryActionExtensionMethods</span>[</span><span class="type">U</span>](rep: <span class="type">Rep</span>[<span class="type">U</span>]): <span class="type">QueryActionExtensionMethods</span>[<span class="type">U</span>, <span class="type">NoStream</span>] =</span><br><span class="line">    createQueryActionExtensionMethods[<span class="type">U</span>, <span class="type">NoStream</span>](queryCompiler.run(rep.toNode).tree, ())</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableQueryActionExtensionMethods</span>[</span><span class="type">U</span>, <span class="type">C</span>[_]](q: <span class="type">Query</span>[_,<span class="type">U</span>, <span class="type">C</span>]): <span class="type">StreamingQueryActionExtensionMethods</span>[<span class="type">C</span>[<span class="type">U</span>], <span class="type">U</span>] =</span><br><span class="line">    createStreamingQueryActionExtensionMethods[<span class="type">C</span>[<span class="type">U</span>], <span class="type">U</span>](queryCompiler.run(q.toNode).tree, ())</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">runnableCompiledQueryActionExtensionMethods</span>[</span><span class="type">RU</span>](c: <span class="type">RunnableCompiled</span>[_, <span class="type">RU</span>]): <span class="type">QueryActionExtensionMethods</span>[<span class="type">RU</span>, <span class="type">NoStream</span>] =</span><br><span class="line">    createQueryActionExtensionMethods[<span class="type">RU</span>, <span class="type">NoStream</span>](c.compiledQuery, c.param)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableCompiledQueryActionExtensionMethods</span>[</span><span class="type">RU</span>, <span class="type">EU</span>](c: <span class="type">StreamableCompiled</span>[_, <span class="type">RU</span>, <span class="type">EU</span>]): <span class="type">StreamingQueryActionExtensionMethods</span>[<span class="type">RU</span>, <span class="type">EU</span>] =</span><br><span class="line">    createStreamingQueryActionExtensionMethods[<span class="type">RU</span>, <span class="type">EU</span>](c.compiledQuery, c.param)</span><br><span class="line">  <span class="comment">// Applying a CompiledFunction always results in only a RunnableCompiled, not a StreamableCompiled, so we need this:</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableAppliedCompiledFunctionActionExtensionMethods</span>[</span><span class="type">R</span>, <span class="type">RU</span>, <span class="type">EU</span>, <span class="type">C</span>[_]](c: <span class="type">AppliedCompiledFunction</span>[_, <span class="type">Query</span>[<span class="type">R</span>, <span class="type">EU</span>, <span class="type">C</span>], <span class="type">RU</span>]): <span class="type">StreamingQueryActionExtensionMethods</span>[<span class="type">RU</span>, <span class="type">EU</span>] =</span><br><span class="line">    createStreamingQueryActionExtensionMethods[<span class="type">RU</span>, <span class="type">EU</span>](c.compiledQuery, c.param)</span><br><span class="line">  <span class="comment">// This only works on Scala 2.11 due to SI-3346:</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">recordQueryActionExtensionMethods</span>[</span><span class="type">M</span>, <span class="type">R</span>](q: <span class="type">M</span>)(<span class="keyword">implicit</span> shape: <span class="type">Shape</span>[_ &lt;: <span class="type">FlatShapeLevel</span>, <span class="type">M</span>, <span class="type">R</span>, _]): <span class="type">QueryActionExtensionMethods</span>[<span class="type">R</span>, <span class="type">NoStream</span>] =</span><br><span class="line">    createQueryActionExtensionMethods[<span class="type">R</span>, <span class="type">NoStream</span>](queryCompiler.run(shape.toNode(q)).tree, ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此多的implicit转换，可以将Query和CompiledQuery转换成各种QueryActionExtensionMethods。那么我们再来看<code>result</code>的源码，看看它是不是在某个QueryActionExtensionMethods类里：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamingQueryActionExtensionMethodsImpl</span>[</span><span class="type">R</span>, <span class="type">T</span>](tree: <span class="type">Node</span>, param: <span class="type">Any</span>) <span class="keyword">extends</span> <span class="type">QueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">Streaming</span>[<span class="type">T</span>]](tree, param) <span class="keyword">with</span> <span class="keyword">super</span>.<span class="type">StreamingQueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">result</span>:</span> <span class="type">StreamingDriverAction</span>[<span class="type">R</span>, <span class="type">T</span>, <span class="type">Effect</span>.<span class="type">Read</span>] = <span class="keyword">super</span>.result.asInstanceOf[<span class="type">StreamingDriverAction</span>[<span class="type">R</span>, <span class="type">T</span>, <span class="type">Effect</span>.<span class="type">Read</span>]]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然！<code>result</code>方法存在于这个QueryActionExtensionMethods类里，而且Query可以通过上述API隐式转换为QueryActionExtensionMethods。这个类好混乱，继承了两个trait，还没注释（这一点最蛋疼了，直接看源码估计无解）。再往它的父类找：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">QueryActionExtensionMethodsImpl</span>[</span><span class="type">R</span>, <span class="type">S</span> &lt;: <span class="type">NoStream</span>] &#123;</span><br><span class="line">    <span class="comment">/** An Action that runs this query. */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span>:</span> <span class="type">DriverAction</span>[<span class="type">R</span>, <span class="type">S</span>, <span class="type">Effect</span>.<span class="type">Read</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">StreamingQueryActionExtensionMethodsImpl</span>[</span><span class="type">R</span>, <span class="type">T</span>] <span class="keyword">extends</span> <span class="type">QueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">Streaming</span>[<span class="type">T</span>]] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span>:</span> <span class="type">StreamingDriverAction</span>[<span class="type">R</span>, <span class="type">T</span>, <span class="type">Effect</span>.<span class="type">Read</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>它们是最基本的<code>QueryActionExtensionMethods</code>，即查询操作。</p>
<p>到此为止，我们终于搞明白了一个数据库查询过程中从<code>Query</code>经过implicit的<code>result</code>转换成<code>DBIOAction</code>，再进行<code>db.run</code>得到Future异步结果的类型转换的过程。我做了一张图来总结这个过程：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/slick-db-type-convert-query-sczyh30-fixed.png" alt="Slick Query Type Process"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Slick/">Slick</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-slick-3-summary-functional-relational-mapping" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/slick-3-summary-functional-relational-mapping/" class="article-date">
      <time datetime="2016-04-01T16:00:00.000Z" itemprop="datePublished">2016-04-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/slick-3-summary-functional-relational-mapping/">Slick 3总结 | Functional Relational Mapping</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>不同于平常的ORM框架，Slick提供了一种函数响应式操作数据库的方式：Functional Relational Mapping。这种函数响应式的操作方式允许我们将数据库的每一个表都看作是一个 <strong>集合</strong>，对数据库的CRUD操作可以转化为对这些“集合”的操作，因此我们可以充分利用各种Monadic的算子而不需要自己编写SQL（当然，需要保证Slick解析的SQL性能好）。并且，Slick是以 <strong>异步</strong> 的方式操作数据库，返回Future，这有助于我们编写异步响应式的程序，比MyBatis等等的同步阻塞ORM框架之流好很多。这里我们就来总结一下Slick中Functional Relational Mapping的使用以及与SQL语句的对应关系（MySQL语法）。后面有时间的话，我还会总结一下Slick中FRM的实现原理。</p>
<h1 id="Functional_Relational_Mapping_⇔_SQL">Functional Relational Mapping ⇔ SQL</h1><p>首先我们需要自己定义对应的映射Table，当然也可以用Generator生成。假设有以下两个表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`article`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">85</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`author`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`cid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`update_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_title`</span> (<span class="string">`title`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_cid`</span> (<span class="string">`cid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`category`</span> (</span><br><span class="line">  <span class="string">`cid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`abbr`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="string">`cid`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`name_UNIQUE`</span> (<span class="string">`name`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`abbr_UNIQUE`</span> (<span class="string">`abbr`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span></span><br></pre></td></tr></table></figure></p>
<p>它们对应的Table可以简化成下面的两个类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ArticleTable</span>(</span>tag: <span class="type">Tag</span>) <span class="keyword">extends</span> <span class="type">Table</span>[<span class="type">Article</span>](tag, <span class="string">"article"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">*</span> =</span> (id, title, author, url, cid, updateDate) &lt;&gt; (entity.<span class="type">Article</span>.tupled, entity.<span class="type">Article</span>.unapply) <span class="comment">// 投影关系</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">id</span>:</span> <span class="type">Rep</span>[<span class="type">Int</span>] = column[<span class="type">Int</span>](<span class="string">"id"</span>, <span class="type">O</span>.<span class="type">AutoInc</span>, <span class="type">O</span>.<span class="type">PrimaryKey</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">title</span>:</span> <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"title"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">85</span>, varying = <span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">author</span>:</span> <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"author"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">45</span>, varying = <span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">url</span>:</span> <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"url"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">150</span>, varying = <span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">cid</span>:</span> <span class="type">Rep</span>[<span class="type">Int</span>] = column[<span class="type">Int</span>](<span class="string">"cid"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">updateDate</span>:</span> <span class="type">Rep</span>[java.sql.<span class="type">Date</span>] = column[java.sql.<span class="type">Date</span>](<span class="string">"update_date"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">index1</span> =</span> index(<span class="string">"index_cid"</span>, cid)</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">index2</span> =</span> index(<span class="string">"index_title"</span>, title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CategoryTable</span>(</span>tag: <span class="type">Tag</span>) <span class="keyword">extends</span> <span class="type">Table</span>[<span class="type">Category</span>](tag, <span class="string">"category"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">*</span> =</span> (cid, name, abbr) &lt;&gt; (entity.<span class="type">Category</span>.tupled, entity.<span class="type">Category</span>.unapply)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">cid</span>:</span> <span class="type">Rep</span>[<span class="type">Int</span>] = column[<span class="type">Int</span>](<span class="string">"cid"</span>, <span class="type">O</span>.<span class="type">AutoInc</span>, <span class="type">O</span>.<span class="type">PrimaryKey</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">name</span>:</span> <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"name"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">45</span>, varying = <span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">abbr</span>:</span> <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"abbr"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">45</span>, varying = <span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">index1</span> =</span> index(<span class="string">"abbr_UNIQUE"</span>, abbr, unique=<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">index2</span> =</span> index(<span class="string">"name_UNIQUE"</span>, name, unique=<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们就可以定义这两个表对应的Slick TableQuery集合：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">articles</span> =</span> <span class="type">TableQuery</span>[<span class="type">ArticleTable</span>]</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">categories</span> =</span> <span class="type">TableQuery</span>[<span class="type">CategoryTable</span>]</span><br></pre></td></tr></table></figure>
<p>下面我们就可以对这两个“集合”进行操作了～</p>
<h2 id="SELECT">SELECT</h2><p>普通的SELECT语句非常简单，比如<code>SELECT * FROM article</code>对应<code>articles.result</code>，即article表中所有的数据。</p>
<p>如果要选择的话可以用<code>map</code>算子映射出对应的投影。</p>
<h2 id="WHERE">WHERE</h2><p>含WHERE的SQL：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> title, url <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> id = <span class="number">10</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>WHERE</code>通过<code>filter</code>算子实现，对应FRM：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">articles.map(x =&gt; (x.title, x.url))</span><br><span class="line">        .filter(_.id === <span class="number">10</span>)</span><br><span class="line">        .result</span><br></pre></td></tr></table></figure></p>
<h2 id="ORDER_BY">ORDER BY</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> article <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span></span></span><br></pre></td></tr></table></figure>
<p><code>ORDER BY</code>通过<code>sortBy</code>算子实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">articles.sortBy(_.id.desc).result</span><br></pre></td></tr></table></figure></p>
<h2 id="LIMIT(分页)">LIMIT(分页)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> article <span class="keyword">LIMIT</span> <span class="number">10000</span>, <span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p><code>LIMIT</code>通过<code>take</code>算子和<code>drop</code>算子实现。<code>drop(offset)</code>表示忽略前offset条记录，<code>take(n)</code>代表取n条记录。对应FRM：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">articles.drop(<span class="number">10000</span>).take(<span class="number">10</span>).result</span><br></pre></td></tr></table></figure></p>
<h2 id="聚合函数">聚合函数</h2><p>使用各种聚合函数也非常方便：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">articles.map(_.id).max.result</span><br><span class="line">articles.map(_.id).min.result</span><br><span class="line">articles.map(_.id).avg.result</span><br></pre></td></tr></table></figure></p>
<h2 id="JOIN">JOIN</h2><p>Slick中的连接操作分为Applicative Join和Monadic Join两种。Monadic Join，顾名思义就是用Monad的思想去进行<code>JOIN</code>操作(通过<code>flatMap</code>算子)。</p>
<h3 id="Applicative_Join">Applicative Join</h3><p>Applicative Join通过<code>join</code>和<code>on</code>来进行<code>JOIN</code>操作。</p>
<p>内连接的例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> a.*, c.name</span><br><span class="line"><span class="keyword">FROM</span> article <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> category <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">ON</span> a.cid = c.cid</span></span><br></pre></td></tr></table></figure></p>
<p>对应Applicative Join：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">innerJoin</span> =</span> <span class="keyword">for</span> &#123;</span><br><span class="line">    (a, c) &lt;- articles join categories on (_.cid === _.cid)</span><br><span class="line">&#125; <span class="keyword">yield</span> (a, c.name)</span><br></pre></td></tr></table></figure></p>
<p>左外连接和右外连接也差不多，只不过外连接可能带来NULL项，因此对应的可能出现NULL的位置被包装为<code>Option</code>，例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">leftOuterJoin</span> =</span> <span class="keyword">for</span> &#123;</span><br><span class="line">    (a, c) &lt;- articles joinLeft categories on (_.cid === _.cid)</span><br><span class="line">&#125; <span class="keyword">yield</span> (a, c.map(_.name))</span><br></pre></td></tr></table></figure></p>
<h3 id="Monadic_Join">Monadic Join</h3><p>Monadic Join通过<code>flatMap</code>来进行<code>JOIN</code>操作，这里只举一个内连接的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">monadicInnerJoin</span> =</span> <span class="keyword">for</span> &#123;</span><br><span class="line">    a &lt;- articles</span><br><span class="line">    c &lt;- categories <span class="keyword">if</span> c.cid === a.cid</span><br><span class="line">&#125; <span class="keyword">yield</span> (a, c.name)</span><br></pre></td></tr></table></figure></p>
<p>注意它会被转化成implicit join(<code>SELECT ... FROM a, b WHERE ...</code>)的形式（貌似是Slick的<a href="http://slick.typesafe.com/doc/3.1.1/queries.html#monadic-joins" target="_blank" rel="external">规则</a>）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> a.*, c.name</span><br><span class="line"><span class="keyword">FROM</span> article <span class="keyword">AS</span> a, category <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">WHERE</span> a.cid = c.cid</span></span><br></pre></td></tr></table></figure></p>
<h2 id="UNION">UNION</h2><p><code>UNION</code>操作比较简单，直接<code>q1 union q2</code>即可。</p>
<h2 id="COUNT">COUNT</h2><p>若需要计算<code>COUNT</code>值，直接使用<code>length</code>算子：<code>articles.filter(_.id &gt; 100).length.result</code></p>
<h1 id="FRM的实现原理">FRM的实现原理</h1><p>Slick实现Functional Relational Mapping的方式比较强悍。粗略地看了下代码，Slick底层应该是将每个Action逐层解析后转化为AST，然后转化为对应的SQL并执行的。后边有时间详细了解一下。。(<strong>待填坑！</strong>)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Slick/">Slick</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步/">异步</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-play-framework-2-5-dependency-injection-di" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/play-framework-2-5-dependency-injection-di/" class="article-date">
      <time datetime="2016-03-28T16:00:00.000Z" itemprop="datePublished">2016-03-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/play-framework-2-5-dependency-injection-di/">Play Framework 2.5 | Dependency Injection总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近在将Samsara Aquarius从Play 2.4.6迁移至Play 2.5.0的时候发现，Play 2.5将一些全局对象deprcated了，并强烈建议全面使用依赖注入来代替全局对象，所以就把Aquarius的代码用DI重构了一下。其实从Play 2.4.0开始就引入了依赖注入了(基于<a href="https://jcp.org/en/jsr/detail?id=330" target="_blank" rel="external">JSR 330</a>标准)，只不过还没有很好地推广。这里就来总结一下Play Framework中DI的使用。（本来开发的时候想保持FP风格的，无奈DI更多的是偏OO的风格。。FP与OO杂糅不好把握呀。。）</p>
<h1 id="为何需要引入依赖注入">为何需要引入依赖注入</h1><p>依赖注入(Dependency Injection)在OOP中早已是一个耳熟能详的原则了，其中Spring里用DI都用烂了。简单来说，依赖注入使得我们不需要自己创建对象，而是由容器来帮我们创建。每个组件之间不再是直接相互依赖，而是通过容器进行注入，这降低了组件之间的耦合度。这个容器就像是一个全局的大工厂，专门“生产”对象，而我们只需要进行配置（常见的通过XML文件或通过注解）。</p>
<p>在Play API中有一个Global对象，保存着一些全局的可变状态。另外还有一个Application对象相当于当前正在运行的Play实例。这两个伴生对象经常会在测试和部署的时候引发问题，并且也会影响Play实例的生命周期以及插件系统的工作。因此从Play 2.4开始，开发者对底层的结构做了很大的调整，底层所有的组件（包括Application、Route、Controller）都通过依赖注入进行管理，而不再使用Global和Application对象。后面版本中这两个对象只是从DI中获取实例的引用。从Play 2.5开始，这些全局对象被Deprecated。</p>
<p>Play内部的DI组件都用的是 <strong>Google Guice</strong>。只要是符合JSR-330标准的DI组件都可用于Play Framework中。</p>
<h1 id="DI_in_Play_Framework">DI in Play Framework</h1><h2 id="如何使用">如何使用</h2><p>比如我们的B组件需要A组件的实例作为依赖，那么我们可以这么定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.<span class="type">Inject</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">@Inject</span>(</span>) (a: <span class="type">A</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>@Inject()</code>需要插入在类名之后，构造参数列表之前，后边跟上需要注入的对象列表。</p>
<p>依赖注入有<a href="https://github.com/google/guice/wiki/Injections" target="_blank" rel="external">好几种方式</a>：<strong>构造注入</strong>、<strong>方法注入</strong> 等等。这里采用最常用的构造注入。</p>
<h2 id="生命周期及范围">生命周期及范围</h2><p>依赖注入系统管理着各个注入组件的生命周期和范围。有以下规则：</p>
<ul>
<li>每次从Injector里取出的都是新的对象，即每次需要此组件的时候都会创建新的实例，用Spring IoC的话来说就是Bean的范围是 <strong>Prototype</strong> 。这一点和Spring不同(Spring默认是Singleton)。当然可以通过给待注入的类加上<code>@Singleton</code>注解来实现 <strong>Singleton</strong> 。</li>
<li>遵循懒加载原则，即不用的时候就不创建。如果需要提前创建实例的话可以使用 <strong>Eager Binding</strong> 。</li>
</ul>
<h2 id="ApplicationLifecycle">ApplicationLifecycle</h2><p>有些组件需要在Play结束运行的时候进行一些清理工作，如关闭连接、关闭句柄。Play提供了<code>ApplicationLifecycle</code>类，可以通过<code>addStopHook</code>函数给组件注册回调，在Play结束运行的时候进行清理工作。<code>addStopHook</code>函数有两个版本，常用的是第一个：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStopHook</span>(</span>hook: () =&gt; <span class="type">Future</span>[_]): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStopHook</span>(</span>hook: <span class="type">Callable</span>[_ &lt;: <span class="type">CompletionStage</span>[_]]): <span class="type">Unit</span></span><br></pre></td></tr></table></figure></p>
<p>底层实现嘛比较直观，默认的实现是<code>DefaultApplicationLifecycle</code>类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Default implementation of the application lifecycle.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultApplicationLifecycle</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ApplicationLifecycle</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">mutex</span> =</span> <span class="keyword">new</span> <span class="type">Object</span>()</span><br><span class="line">  <span class="annotation">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> hooks = <span class="type">List</span>.empty[() =&gt; <span class="type">Future</span>[_]]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addStopHook</span>(</span>hook: () =&gt; <span class="type">Future</span>[_]) = mutex.synchronized &#123;</span><br><span class="line">    hooks = hook :: hooks</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(</span>): <span class="type">Future</span>[_] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do we care if one hook executes on another hooks redeeming thread? Hopefully not.</span></span><br><span class="line">    <span class="keyword">import</span> play.api.libs.iteratee.<span class="type">Execution</span>.<span class="type">Implicits</span>.trampoline</span><br><span class="line"></span><br><span class="line">    hooks.foldLeft(<span class="type">Future</span>.successful[<span class="type">Any</span>](())) &#123; (future, hook) =&gt;</span><br><span class="line">      future.flatMap &#123; _ =&gt;</span><br><span class="line">        hook().recover &#123;</span><br><span class="line">          <span class="keyword">case</span> e =&gt; <span class="type">Logger</span>.error(<span class="string">"Error executing stop hook"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>DefaultApplicationLifecycle</code>类里维护了一个钩子列表hook用于存储所有注册的回调函数，类型为<code>List[() =&gt; Future[_]]</code>。由于<code>DefaultApplicationLifecycle</code>组件为单例，因此为避免资源争用，将hook变量声明为<code>@volatile</code>，并且注册回调函数时需要加锁。注意回调函数是按注册的顺序进行存储的。在应用结束时，会调用<code>stop</code>函数，通过<code>foldl</code>依次调用各个回调函数。</p>
<h2 id="重构例子">重构例子</h2><p>之前我把部分的Service设计成了Object（脑残了），并且在获取Slick的<code>DatabaseConfig</code>的时候使用了全局变量<code>play.api.Play.current</code>。这里我们来重构一下。</p>
<p>首先把Service重构为单例的类，并且通过DI的方式获取<code>db</code>。可以继承<code>HasDatabaseConfigProvider[JdbcProfile]</code>接口并注入<code>DatabaseConfigProvider</code>，这样Service就可以直接使用<code>HasDatabaseConfigProvider</code>的<code>db</code>对象了。当然如果不想继承<code>HasDatabaseConfigProvider</code>接口的话也可以仅注入<code>DatabaseConfigProvider</code>并自己在类中获取<code>dbConfig</code>和<code>db</code>(其它方式见Play-Slcik的文档)。</p>
<p>代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="title">@Inject</span>(</span>)(<span class="keyword">protected</span> <span class="function"><span class="keyword">val</span> <span class="title">dbConfigProvider</span>:</span> <span class="type">DatabaseConfigProvider</span>) <span class="keyword">extends</span> <span class="type">HasDatabaseConfigProvider</span>[<span class="type">JdbcProfile</span>] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> driver.api._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">users</span> =</span> <span class="type">TableQuery</span>[<span class="type">UserTable</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span>(</span>user: <span class="type">User</span>): <span class="type">Future</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    db.run(users += user) recover &#123;</span><br><span class="line">      <span class="keyword">case</span> duplicate: com.mysql.jdbc.exceptions.<span class="type">MySQLIntegrityConstraintViolationException</span> =&gt; <span class="type">DB_ADD_DUPLICATE</span></span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">Exception</span> =&gt; -<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码略......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来就是在Controller里配置DI将Service注入至Controller中。以UserController为例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="title">@Inject</span>(</span>) (service: <span class="type">UserService</span>) <span class="keyword">extends</span> <span class="type">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loginIndex</span> =</span> <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request =&gt;</span><br><span class="line">    request.session.get(<span class="string">"aq_token"</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(user) =&gt; <span class="type">Redirect</span>(routes.<span class="type">Application</span>.index())</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">Ok</span>(views.html.login(<span class="type">LoginForm</span>.form))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// 其他代码略......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DI底层调用过程">DI底层调用过程</h2><p>Play API中所有的DI都用的 <strong>Google Guice</strong>。它们最后都是调用了<code>GuiceInjector</code>类的<code>instanceOf</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Play Injector backed by a Guice Injector.</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuiceInjector</span> <span class="title">@Inject</span>(</span>) (injector: com.google.inject.<span class="type">Injector</span>) <span class="keyword">extends</span> <span class="type">PlayInjector</span> &#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Get an instance of the given class from the injector.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instanceOf</span>[</span><span class="type">T</span>](<span class="keyword">implicit</span> ct: <span class="type">ClassTag</span>[<span class="type">T</span>]) = instanceOf(ct.runtimeClass.asInstanceOf[<span class="type">Class</span>[<span class="type">T</span>]])</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Get an instance of the given class from the injector.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instanceOf</span>[</span><span class="type">T</span>](clazz: <span class="type">Class</span>[<span class="type">T</span>]) = injector.getInstance(clazz)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Get an instance bound to the given binding key.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instanceOf</span>[</span><span class="type">T</span>](key: <span class="type">BindingKey</span>[<span class="type">T</span>]) = injector.getInstance(<span class="type">GuiceKey</span>(key))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再往底层调用<code>com.google.inject.internal#getProvider</code>方法获取Provider，最终都会调用到某个种类的Injector的<code>inject</code>、<code>provision</code>、<code>construct</code>方法。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/play-scala-injector-dbg-01.png" alt="Call Stack"></p>
<h1 id="题外话-函数式编程中的DI">题外话-函数式编程中的DI</h1><p>以前用DI的时候一直在想，这玩意在OOP中用途这么广泛，那么在FP里会是什么光景呢？其实在FP里，<strong>Currying</strong> 就可以当做是OOP中的DI。这里先挖个坑，待填坑:)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DI/">DI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Play-Framework/">Play Framework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-functional-programming-type-and-kind" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Functional-Programming/functional-programming-type-and-kind/" class="article-date">
      <time datetime="2016-03-15T16:00:00.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Functional-Programming/functional-programming-type-and-kind/">FP :: Type Theory | Type, Type Constructor 与 Kind</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>以前忘了总结了。。正好在这里总结一下 <strong>Type</strong>, <strong>Type Constructor</strong> 与 <strong>Kind</strong> 这几个概念，结合Haskell和Scala。</p>
<h1 id="Type,_Type_Constructor_与_Kind_(Haskell)">Type, Type Constructor 与 Kind (Haskell)</h1><p><em>Types and Programming Languages</em> 里的一张图非常直观地表现了Kind与Type的意义：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/tapl-type-kind.png" alt=""></p>
<p>其中，上图的Term就是值(Value)的意思，比如<code>1</code>、<code>&quot;haha&quot;</code>之类的，都是Term。</p>
<p>而Type，则是 <strong>Value的类型</strong>，比如<code>1</code>的Type是<code>Num</code>(Haskell)，<code>&quot;haha&quot;</code>的Type是<code>String</code>。然后我们引入Type Constructor的概念，它接受一个或多个类型参数(type parameter)并构造出一个新Type，比如<code>Maybe</code>是一个Unary Type Constructor，它接受一个类型参数，可以构造出<code>Maybe Int</code>和<code>Maybe String</code>等等的不同的Type。再比如<code>Either</code>的定义为<code>data Either a b = Left a | Right b</code>，它接受两个类型参数，可以构造出像<code>Either Bool</code>和<code>Either Int Bool</code>这样的Type Constructor。其实，我们也可以把这些Primitive Type看作是一种特殊的Type Constructor，即接受零个类型参数(Nullary Type Constructor)。</p>
<p>有了Type和Type Constructor的概念以后，我们就可以定义Kind了。Kind表示 <strong>Type Constructor的类型</strong> ，在Haskell中有以下定义：</p>
<ul>
<li>Nullary Type Constructor（即普通的Type）的kind为<code>*</code></li>
<li>如果k1和k2是kind，那么<code>k1 -&gt; k2</code>代表一个Type constructor的kind，这个Constructor接受kind为k1的类型参数，返回kind为k2的类型参数。<br>比如<code>Either String</code>的kind为<code>* -&gt; *</code></li>
</ul>
<p>这样，从Value到Type、Type Constructor，再到Kind，每上一个层次都是一个抽象。Type Constructor是Value的类型，Kind又是Type Constructor的类型。</p>
<h1 id="Kind_Polymorphism_(Haskell)">Kind Polymorphism (Haskell)</h1><p>默认情况下，Haskell不允许kind具有多态性(Kind polymorphism)。比如我们的Either的定义如下:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">Either</span> a b = <span class="type">Left</span> a | <span class="type">Right</span> b 	<span class="comment">-- Defined in ‘Data.Either’</span></span></span><br></pre></td></tr></table></figure></p>
<p>a和b的kind是任意的，可以是<code>*</code>，也可以是<code>* -&gt; *</code>。Haskell默认将它们的kind都推导为<code>*</code>，因此下面的定义是不允许的：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="typedef"><span class="keyword">data</span> <span class="type">T1</span> = <span class="type">Either</span> []</span></span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:<span class="number">123</span>:<span class="number">18</span>:</span><br><span class="line">    <span class="type">Expecting</span> one more argument to ‘[]’</span><br><span class="line">    <span class="type">Expected</span> a <span class="typedef"><span class="keyword">type</span>, but ‘[]’ has kind ‘* -&gt; *’</span></span><br><span class="line">    <span class="type">In</span> the <span class="typedef"><span class="keyword">type</span> ‘[]’</span></span><br><span class="line">    <span class="type">In</span> the definition <span class="keyword">of</span> <span class="typedef"><span class="keyword">data</span> constructor ‘<span class="type">Either</span>’</span></span><br><span class="line">    <span class="type">In</span> the <span class="typedef"><span class="keyword">data</span> declaration for ‘<span class="type">T1</span>’</span></span><br></pre></td></tr></table></figure></p>
<p>当然有些时候Haskell也是可以推导出来某些Higher-order kind的，比如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">A</span> t k p = <span class="type">A</span> <span class="container">&#123; <span class="title">s1</span> :: <span class="title">p</span>, <span class="title">s2</span> :: <span class="title">t</span> <span class="title">k</span> &#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>由于<code>s2 :: t k</code>，而k默认被推导为<code>*</code>，因此t的kind就会被推导为<code>* -&gt; *</code>，那么A的kind最终被推导为<code>(* -&gt; *) -&gt; * -&gt; * -&gt; *</code>。</p>
<p>如果要使Haskell支持 <strong>polymorphic kinds</strong> ，可以利用GHC的扩展<code>-XPolyKinds</code>，就不再展开总结了，详情可以参考<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/kind-polymorphism.html" target="_blank" rel="external">这里</a>。</p>
<h1 id="Data_Kinds/Datatype_promotion_(Haskell)">Data Kinds/Datatype promotion (Haskell)</h1><p>Datatype promotion是GHC的一个扩展(<code>-XDataKinds</code>)，可以将部分的Datatype给自动promote成kind。比如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :k <span class="type">Left</span></span><br><span class="line"><span class="type">Left</span> :: k -&gt; <span class="type">Either</span> k k1</span><br><span class="line"><span class="type">Prelude</span>&gt; :k <span class="number">3</span></span><br><span class="line"><span class="number">3</span> :: <span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">Nat</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :k <span class="string">""</span></span><br><span class="line"><span class="string">""</span> :: <span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">Symbol</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :k <span class="type">Just</span></span><br><span class="line"><span class="type">Just</span> :: k -&gt; <span class="type">Maybe</span> k</span><br></pre></td></tr></table></figure></p>
<p>具体的应用还没实践过，等实践过再来总结。。</p>
<h1 id="Scala中的Type和Kind">Scala中的Type和Kind</h1><p>Scala中的Type和Kind用一张图总结：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/scala-type-kind-higher.png" alt=""></p>
<p>我觉得Scala中的Kind比较混乱，至少每次试的时候出的结果总与想象的不对应，或许还没有理解吧。。。举几个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Functor</span>[</span><span class="type">M</span>[_]]</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span><br><span class="line"></span></span><br><span class="line">scala&gt; :k -v <span class="type">Functor</span></span><br><span class="line">&lt;console&gt;:<span class="number">11</span>: error: not found: value <span class="type">Functor</span></span><br><span class="line">       <span class="type">Functor</span></span><br><span class="line">       ^</span><br><span class="line"></span><br><span class="line">scala&gt; :k -v <span class="keyword">new</span> <span class="type">Functor</span></span><br><span class="line"><span class="type">Functor</span><span class="symbol">'s</span> kind is <span class="type">X</span>[<span class="type">F</span>[<span class="type">A</span>]]</span><br><span class="line">(* -&gt; *) -&gt; *</span><br><span class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span> <span class="title">that</span> <span class="title">takes</span> <span class="title">type</span> <span class="title">constructor</span>(</span>s): a higher-kinded <span class="class"><span class="keyword">type</span>.</span><br><span class="line"></span></span><br><span class="line">scala&gt; :k -v <span class="type">List</span></span><br><span class="line">scala.collection.immutable.<span class="type">List</span><span class="symbol">'s</span> kind is <span class="type">F</span>[+<span class="type">A</span>]</span><br><span class="line">* -(+)-&gt; *</span><br><span class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span>:</span> a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span><br><span class="line"></span></span><br><span class="line">scala&gt; :k -v <span class="type">List</span>[<span class="type">Int</span>]</span><br><span class="line">scala.collection.immutable.<span class="type">List</span><span class="symbol">'s</span> kind is <span class="type">F</span>[+<span class="type">A</span>]</span><br><span class="line">* -(+)-&gt; *</span><br><span class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span>:</span> a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span><br><span class="line"></span></span><br><span class="line">scala&gt; :k -v <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">scala.collection.immutable.<span class="type">List</span><span class="symbol">'s</span> kind is <span class="type">A</span></span><br><span class="line">*</span><br><span class="line"><span class="type">This</span> is a proper <span class="class"><span class="keyword">type</span>.</span><br><span class="line"></span></span><br><span class="line">scala&gt; :k -v <span class="type">Either</span></span><br><span class="line">scala.util.<span class="type">Either</span><span class="symbol">'s</span> kind is <span class="type">F</span>[+<span class="type">A1</span>,+<span class="type">A2</span>]</span><br><span class="line">* -(+)-&gt; * -(+)-&gt; *</span><br><span class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span>:</span> a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span><br><span class="line"></span></span><br><span class="line">scala&gt; :k -v (<span class="type">Int</span>, <span class="type">String</span>) =&gt; <span class="type">Option</span>[_]</span><br><span class="line">scala.<span class="type">Function2</span><span class="symbol">'s</span> kind is <span class="type">F</span>[-<span class="type">A1</span>,-<span class="type">A2</span>,+<span class="type">A3</span>]</span><br><span class="line">* -(-)-&gt; * -(-)-&gt; * -(+)-&gt; *</span><br><span class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span>:</span> a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span></span><br></pre></td></tr></table></figure>
<p>感觉Scala REPL中的<code>:kind</code>是针对value的而不是type的，非常蛋疼，估计是让JVM的泛型类型擦除搞得Parametric Polymorphism都不爽了。。另外Scala中也分 <strong>1st-order-kinded type</strong> 和 <strong>higher-kinded type</strong> 。所谓higher-kinded type就是类似于<code>A[B[_]]</code>这样的type constructor，比如下面的这个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">T3</span>[</span><span class="type">Q</span>[<span class="type">A</span>], <span class="type">P</span>[<span class="type">B</span>]]</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">T3</span></span><br><span class="line"></span></span><br><span class="line">scala&gt; :k -v <span class="keyword">new</span> <span class="type">T3</span></span><br><span class="line"><span class="type">T3</span><span class="symbol">'s</span> kind is <span class="type">X</span>[<span class="type">F1</span>[<span class="type">A1</span>],<span class="type">F2</span>[<span class="type">A2</span>]]</span><br><span class="line">(* -&gt; *) -&gt; (* -&gt; *) -&gt; *</span><br><span class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span> <span class="title">that</span> <span class="title">takes</span> <span class="title">type</span> <span class="title">constructor</span>(</span>s): a higher-kinded <span class="class"><span class="keyword">type</span>.</span><br><span class="line"></span></span><br><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">T4</span>[</span><span class="type">Tuple2</span>[<span class="type">A</span>, <span class="type">B</span>], <span class="type">P</span>[<span class="type">Option</span>[<span class="type">C</span>]], <span class="type">D</span>, <span class="type">E</span>]</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">T4</span></span><br><span class="line"></span></span><br><span class="line">scala&gt; :k -v <span class="keyword">new</span> <span class="type">T4</span></span><br><span class="line"><span class="type">T4</span><span class="symbol">'s</span> kind is <span class="type">Y</span>[<span class="type">F1</span>[<span class="type">A1</span>,<span class="type">A2</span>],<span class="type">X</span>[<span class="type">F2</span>[<span class="type">A3</span>]],<span class="type">A4</span>,<span class="type">A5</span>]</span><br><span class="line">(* -&gt; * -&gt; *) -&gt; ((* -&gt; *) -&gt; *) -&gt; * -&gt; * -&gt; *</span><br><span class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span> <span class="title">that</span> <span class="title">takes</span> <span class="title">type</span> <span class="title">constructor</span>(</span>s): a higher-kinded <span class="class"><span class="keyword">type</span>.</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1><ul>
<li><em>Types and Programming Languages</em></li>
<li><em>Generics of a Higher Kind</em>, Martin Odersky</li>
<li><a href="https://wiki.haskell.org/Kind" target="_blank" rel="external">Kind - HaskellWiki</a></li>
<li><a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala" target="_blank" rel="external">What is a higher kinded type in Scala?</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Functional-Programming/">Functional Programming</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Type-Theory/">Type Theory</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-java-concurrent-threadlocal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-concurrent-threadlocal/" class="article-date">
      <time datetime="2016-03-04T16:00:00.000Z" itemprop="datePublished">2016-03-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-concurrent-threadlocal/">并发编程 | ThreadLocal源码深入分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>以前只知道ThreadLocal的大致思路，没有去深入研究。今天读了读源码，果然博大精深～</p>
<p>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为<code>private static</code>类型。</p>
<p>假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用<code>HashMap</code>来实现，Thread作为<code>key</code>，变量作为<code>value</code>。事实上，JDK中确实使用了类似<code>Map</code>的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中<code>ThreadLocal</code>的实现。</p>
<h1 id="初探ThreadLocal">初探ThreadLocal</h1><p>我们从ThreadLocal的几个成员变量入手：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * The next hash code to be given out. Updated atomically. Starts at</span><br><span class="line"> * zero.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * The difference between successively generated hash codes - turns</span><br><span class="line"> * implicit sequential thread-local IDs into near-optimally spread</span><br><span class="line"> * multiplicative hash values for power-of-two-sized tables.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the next hash code.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadLocal通过<code>threadLocalHashCode</code>来标识每一个ThreadLocal的唯一性。<code>threadLocalHashCode</code>通过<code>CAS操作</code>进行更新，每次hash操作的增量为<strong>0x61c88647</strong>(这个数的原理没有探究)。<br>再看<code>set</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sets the current thread's copy of this thread-local variable</span><br><span class="line"> * to the specified value.  Most subclasses will have no need to</span><br><span class="line"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span><br><span class="line"> * method to set the values of thread-locals.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span><br><span class="line"> *        this thread-local.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到通过<code>Thread.currentThread()</code>方法获取了当前的线程引用，并传给了<code>getMap(Thread)</code>方法获取一个<code>ThreadLocalMap</code>的实例。我们继续跟进<code>getMap(Thread)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>getMap(Thread)</code>方法直接返回Thread实例的成员变量<code>threadLocals</code>。它的定义在Thread内部，访问级别为package级别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>到了这里，我们可以看出，每个<code>Thread</code>里面都有一个<code>ThreadLocal.ThreadLocalMap</code>成员变量，也就是说每个线程通过<code>ThreadLocal.ThreadLocalMap</code>与ThreadLocal相绑定，这样可以确保每个线程访问到的thread-local variable都是本线程的。</p>
<p>我们往下继续分析。获取了<code>ThreadLocalMap</code>实例以后，如果它不为空则调用<code>ThreadLocalMap.ThreadLocalMap#set</code>方法设值；若为空则调用<code>ThreadLocal#createMap</code>方法new一个<code>ThreadLocalMap</code>实例并赋给<code>Thread.threadLocals</code>。</p>
<p><code>ThreadLocal#createMap</code>方法的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们探究一下<code>ThreadLocalMap</code>的实现。</p>
<h1 id="ThreadLocalMap">ThreadLocalMap</h1><p>ThreadLocalMap是ThreadLocal的静态内部类，它的结构如下：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/threadlocal-map-structure.png" alt="ThreadLocalMap"></p>
<p>可以看到ThreadLocalMap有一个常量和三个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * The initial capacity -- MUST be a power of two.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * The table, resized as necessary.</span><br><span class="line"> * table.length MUST always be a power of two.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * The number of entries in the table.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * The next size value at which to resize.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>INITIAL_CAPACITY</code>代表这个Map的初始容量；1是一个Entry类型的数组，用于存储数据；<code>size</code>代表表中的存储数目；<code>threshold</code>代表需要扩容时对应size的阈值。</p>
<p><code>Entry</code>类是<code>ThreadLocalMap</code>的静态内部类，用于存储数据。它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * The entries in this hash map extend WeakReference, using</span><br><span class="line"> * its main ref field as the key (which is always a</span><br><span class="line"> * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="line"> * == null) mean that the key is no longer referenced, so the</span><br><span class="line"> * entry can be expunged from table.  Such entries are referred to</span><br><span class="line"> * as "stale entries" in the code that follows.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Entry</code>类继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。</p>
<p><code>ThreadLocalMap</code>类有两个构造函数，其中常用的是<code>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Construct a new map initially containing (firstKey, firstValue).</span><br><span class="line"> * ThreadLocalMaps are constructed lazily, so we only create</span><br><span class="line"> * one when we have at least one entry to put in it.</span><br><span class="line"> */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数的第一个参数就是本ThreadLocal实例(<code>this</code>)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。</p>
<p>注意一个细节，计算hash的时候里面采用了<code>hashCode &amp; (size - 1)</code>的算法，这相当于取模运算<code>hashCode % size</code>的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是<strong>2的指数</strong>，因为这可以使得hash发生冲突的次数减小。</p>
<p>接下来我们来看<code>ThreadLocalMap#set</code>方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Set the value associated with key.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key the thread local object</span><br><span class="line"> * <span class="doctag">@param</span> value the value to be set</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果冲突了，就会通过<code>nextIndex</code>方法再次计算哈希值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Increment i modulo len.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们看到<code>ThreadLocalMap</code>解决冲突的方法是<strong>线性探测法</strong>（不断加1），而不是HashMap的<strong>链地址法</strong>，这一点也能从Entry的结构上推断出来。</p>
<p>如果entry里对应的key为<code>null</code>的话，表明此entry为<code>staled entry</code>，就将其替换为当前的key和value：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Replace a stale entry encountered during a set operation</span><br><span class="line"> * with an entry for the specified key.  The value passed in</span><br><span class="line"> * the value parameter is stored in the entry, whether or not</span><br><span class="line"> * an entry already exists for the specified key.</span><br><span class="line"> *</span><br><span class="line"> * As a side effect, this method expunges all stale entries in the</span><br><span class="line"> * "run" containing the stale entry.  (A run is a sequence of entries</span><br><span class="line"> * between two null slots.)</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span>  key the key</span><br><span class="line"> * <span class="doctag">@param</span>  value the value to be associated with key</span><br><span class="line"> * <span class="doctag">@param</span>  staleSlot index of the first stale entry encountered while</span><br><span class="line"> *         searching for key.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。</p>
<p>若是经历了上面步骤没有命中hash，也没有发现无用的Entry，<code>set</code>方法就会创建一个新的Entry，并会进行<strong>启发式的垃圾清理</strong>，用于清理无用的Entry。主要通过<code>cleanSomeSlots</code>方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Heuristically scan some cells looking for stale entries.</span><br><span class="line"> * This is invoked when either a new element is added, or</span><br><span class="line"> * another stale one has been expunged. It performs a</span><br><span class="line"> * logarithmic number of scans, as a balance between no</span><br><span class="line"> * scanning (fast but retains garbage) and a number of scans</span><br><span class="line"> * proportional to number of elements, that would find all</span><br><span class="line"> * garbage but would cause some insertions to take O(n) time.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> i a position known NOT to hold a stale entry. The</span><br><span class="line"> * scan starts at the element after i.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> n scan control: &#123;<span class="doctag">@code</span> log2(n)&#125; cells are scanned,</span><br><span class="line"> * unless a stale entry is found, in which case</span><br><span class="line"> * &#123;<span class="doctag">@code</span> log2(table.length)-1&#125; additional cells are scanned.</span><br><span class="line"> * When called from insertions, this parameter is the number</span><br><span class="line"> * of elements, but when from replaceStaleEntry, it is the</span><br><span class="line"> * table length. (Note: all this could be changed to be either</span><br><span class="line"> * more or less aggressive by weighting n instead of just</span><br><span class="line"> * using straight log n. But this version is simple, fast, and</span><br><span class="line"> * seems to work well.)</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> true if any stale entries have been removed.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    do &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦发现一个位置对应的Entry所持有的ThreadLocal弱引用为null，就会把此位置当做staleSlot并调用<code>expungeStaleEntry</code>方法进行整理(rehashing)的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Expunge a stale entry by rehashing any possibly colliding entries</span><br><span class="line"> * lying between staleSlot and the next null slot.  This also expunges</span><br><span class="line"> * any other stale entries encountered before the trailing null.  See</span><br><span class="line"> * Knuth, Section 6.4</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span><br><span class="line"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span><br><span class="line"> * (all between staleSlot and this slot will have been checked</span><br><span class="line"> * for expunging).</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要没有清理任何的<strong>stale entries</strong>并且size达到阈值的时候（即table已满，所有元素都可用），都会触发<code>rehashing</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Re-pack and/or re-size the table. First scan the entire</span><br><span class="line"> * table removing stale entries. If this doesn't sufficiently</span><br><span class="line"> * shrink the size of the table, double the table size.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Expunge all stale entries in the table.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>rehash操作会执行一次全表的扫描清理工作，并在size大于等于threshold的四分之三时进行resize，即扩容一倍。因此<code>ThreadLocalMap</code>的加载因子一样为<strong>0.75</strong>。</p>
<p>我们继续看<code>getEntry</code>的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Get the entry associated with key.  This method</span><br><span class="line"> * itself handles only the fast path: a direct hit of existing</span><br><span class="line"> * key. It otherwise relays to getEntryAfterMiss.  This is</span><br><span class="line"> * designed to maximize performance for direct hits, in part</span><br><span class="line"> * by making this method readily inlinable.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span>  key the thread local object</span><br><span class="line"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Version of getEntry method for use when key is not found in</span><br><span class="line"> * its direct hash slot.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span>  key the thread local object</span><br><span class="line"> * <span class="doctag">@param</span>  i the table index for key's hash code</span><br><span class="line"> * <span class="doctag">@param</span>  e the entry at table[i]</span><br><span class="line"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用<code>getEntryAfterMiss</code>方法，根据线性探测法继续查找，直到找到或对应entry为<code>null</code>，并返回。</p>
<p>ThreadLocal的get方法就是调用了<code>ThreadLocalMap</code>的getEntry方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>remove</code>方法的思想类似，直接放源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Remove the entry for key.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>remove的时候同样也会调用<code>expungeStaleEntry</code>方法执行清理工作。</p>
<h1 id="总结">总结</h1><p>每个Thread里都含有一个ThreadLocalMap的成员变量，这种机制将ThreadLocal和线程巧妙地绑定在了一起，即可以保证无用的ThreadLocal被及时回收，不会造成内存泄露，又可以提升性能。假如我们把ThreadLocalMap做成一个<code>Map&lt;t extends Thread, ?&gt;</code>类型的Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而JDK里的这种利用ThreadLocal作为key，再将ThreadLocalMap与线程相绑定的实现，完美地解决了这个问题。</p>
<p>总结一下什么时候无用的Entry会被清理：</p>
<ul>
<li>Thread结束的时候</li>
<li>插入元素时，发现<strong>staled entry</strong>，则会进行替换并清理</li>
<li>插入元素时，<code>ThreadLocalMap</code>的<code>size</code>达到<code>threshold</code>，并且没有任何<strong>staled entries</strong>的时候，会调用<code>rehash</code>方法清理并扩容</li>
<li>调用<code>ThreadLocalMap</code>的<code>remove</code>方法或<code>set(null)</code>时</li>
</ul>
<p>尽管不会造成内存泄露，但是可以看到无用的Entry只会在以上四种情况下才会被清理，这就可能导致一些Entry虽然无用但还占内存的情况。因此，我们在使用完ThreadLocal后一定要<code>remove</code>一下，保证及时回收掉无用的Entry。</p>
<p>【场景】当应用线程池的时候，由于线程池的线程一般会复用，Thread不结束，这时候用完更需要<code>remove</code>了。</p>
<p>总的来说，对于多线程资源共享的问题，同步机制采用了“<strong>以时间换空间</strong>”的方式，而ThreadLocal采用了“<strong>以空间换时间</strong>”的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<h1 id="应用">应用</h1><p>应用太多了。。。各大框架都有应用，比如Spring。Spring对一些Bean中的成员变量采用ThreadLocal进行处理，让它们可以成为线程安全的。举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestContextHolder</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsfPresent =</span><br><span class="line">			ClassUtils.isPresent(<span class="string">"javax.faces.context.FacesContext"</span>, RequestContextHolder.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder =</span><br><span class="line">			<span class="keyword">new</span> NamedThreadLocal&lt;RequestAttributes&gt;(<span class="string">"Request attributes"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder =</span><br><span class="line">			<span class="keyword">new</span> NamedInheritableThreadLocal&lt;RequestAttributes&gt;(<span class="string">"Request context"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//......下面省略</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>再比如Spring MVC中的Controller默认是<strong>singleton</strong>的，因此如果Controller或其对应的Service里存在非静态成员变量的话，并发访问就会出现race condition问题，这也可以通过<strong>ThreadLocal</strong>解决。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程安全/">线程安全</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-java-8-completable-future" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-8-completable-future/" class="article-date">
      <time datetime="2016-02-29T16:00:00.000Z" itemprop="datePublished">2016-03-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-8-completable-future/">并发编程 | JDK 1.8中的CompletableFuture | FRP风格</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><code>Future</code>对象代表一个尚未完成异步操作的结果。从JDK 1.5以来，JUC包一直提供着最基本的<code>Future</code>，不过它太鸡肋了，除了<code>get</code>、<code>cancel</code>、<code>isDone</code>和<code>isCancelled</code>方法之外就没有其他的操作了，这样很不方便。好在JDK 1.8中引入了具有FRP风格的<code>CompletableFuture</code>，它类似于Scala中的<code>Future</code>。<code>CompletableFuture</code>属于Monad， 因此支持一系列的函数式的组合、运算操作，非常方便，可以写出很FRP风格的代码而摆脱callback hell。</p>
<p>下面我们来结合FRP的思想，总结一下这些操作（<em>有的时候为了方便表示，我会用Haskell或Scala的语法来表示类型，毕竟Java的类型系统太渣</em>）：</p>
<h1 id="构造CompletableFuture对象">构造CompletableFuture对象</h1><p>CompletableFuture类通过工厂模式创建<code>CompletableFuture</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,</span><br><span class="line">                                                   Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable,</span><br><span class="line">                                               Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们的异步操作不需要返回值，那么可以通过<code>runAsync</code>方法提供一个Runnable创建一个<code>CompletableFuture&lt;Void&gt;</code>对象。如果我们的异步操作需要返回值，那么可以通过<code>supplyAsync</code>方法提供一个<code>Supplier&lt;U&gt;</code>对象来创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; longTask(param));</span><br></pre></td></tr></table></figure>
<p>如果不提供<code>Executor</code>的话，默认使用<code>ForkJoinPool.commonPool()</code>作为线程池。</p>
<p>后缀为<code>Async</code>的方法代表异步执行。</p>
<h1 id="变换(fmap)">变换(fmap)</h1><p>假如我们要通过CompletableFuture来异步获取一组数据，并对数据进行一些处理（变换），我们可以使用<code>thenApply</code>和<code>thenApplyAsync</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(<span class="keyword">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它其实就是<code>fmap</code>函数，用Haskell表示原型为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对比一下fmap</span></span><br><span class="line"><span class="title">fmap</span> :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"></span><br><span class="line"><span class="title">thenApply</span> :: (a -&gt; b) -&gt; <span class="type">CompletableFuture</span> a -&gt; <span class="type">CompletableFuture</span> b</span><br></pre></td></tr></table></figure>
<p>它们不仅可以变换数据的值，也可以变换数据的类型，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Double&gt; f = CompletableFuture.supplyAsync(() -&gt; <span class="string">"4"</span>)</span><br><span class="line">                .thenApply(Integer::parseInt)</span><br><span class="line">                .thenApply(r -&gt; r * r * Math.PI);</span><br></pre></td></tr></table></figure>
<p>fmap以后，数据流的类型进行了以下变换：<code>String -&gt; Integer -&gt; Double</code>。</p>
<h1 id="组合(bind)">组合(bind)</h1><p>有的时候，我们需要在异步操作完成的时候对异步操作的结果进行一些操作，并且操作仍然返回<code>CompletableFuture</code>类型。我们可以利用<code>thenCompose</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(<span class="keyword">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</span><br><span class="line">    Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出它其实对应了Monad里的<code>bind</code>操作(Java和Scala中为<code>flatMap</code>)，用Haskell表示原型为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;=) :: <span class="type">Monad</span> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"></span><br><span class="line"><span class="title">thenCompose</span> :: <span class="type">CompletableFuture</span> a -&gt; (a -&gt; <span class="type">CompletableFuture</span> b) -&gt; <span class="type">CompletableFuture</span> b</span><br></pre></td></tr></table></figure>
<p><code>thenCompose</code>是一个非常重要的操作，它对于构建异步的pipeline非常有用。举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskWorkI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;List&lt;Integer&gt;&gt; longTask(Integer i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pc = <span class="number">0</span>; pc &lt; i; pc++)</span><br><span class="line">                list.add(pc);</span><br><span class="line">            <span class="keyword">return</span> Optional.of(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Long&gt; <span class="title">getResultFuture</span><span class="params">(Optional&lt;List&lt;Integer&gt;&gt; op)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (op.isPresent())</span><br><span class="line">                <span class="keyword">return</span> op.get().stream()</span><br><span class="line">                        .map(Integer::toUnsignedLong)</span><br><span class="line">                        .reduce(<span class="number">0L</span>, (x, y) -&gt; x + y);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Long&gt; f = CompletableFuture.supplyAsync(() -&gt; longTask(<span class="number">1000000</span>))</span><br><span class="line">                .thenComposeAsync(TaskWorkI::getResultFuture);</span><br><span class="line">        Long result = f.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="超级变换(liftM2)">超级变换(liftM2)</h1><p><code>CompletableFuture</code>类里面还有个<code>thenCombine</code>操作，它的原型看起来非常晕：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(</span><br><span class="line">    CompletionStage&lt;? extends U&gt; other,</span><br><span class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(<span class="keyword">null</span>, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(</span><br><span class="line">    CompletionStage&lt;? extends U&gt; other,</span><br><span class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(asyncPool, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(</span><br><span class="line">    CompletionStage&lt;? extends U&gt; other,</span><br><span class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java类型系统过于坑爹，我们用Haskell表示其原型就一目了然了：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thenCombine</span> :: <span class="type">CompletableFuture</span> a -&gt; <span class="type">CompletableFuture</span> b -&gt; (a -&gt; b -&gt; c) -&gt; <span class="type">CompletableFuture</span> c</span><br></pre></td></tr></table></figure>
<p>把参数调调位置，可以发现<code>thenCombine</code>其实类似于Haskell中的<code>liftM2</code>操作：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">liftM2</span> :: <span class="type">Monad</span> m =&gt; (a1 -&gt; a2 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m r</span><br><span class="line"></span><br><span class="line"><span class="title">thenCombine</span> :: <span class="type">CompletableFuture</span> m =&gt; (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c</span><br></pre></td></tr></table></figure>
<h1 id="简单示例">简单示例</h1><p>下面我们用一个简单的例子来说明<code>CompletableFuture</code>的使用。假设我们需要获取一篇文章(Article)的信息、对应分类(Category)信息以及对应的评论数，而且从数据库中query的操作是异步的（每个DB操作都返回一个<code>CompletableFuture</code>），我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleWithCategory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Article article;</span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArticleWithCategory</span><span class="params">(Article article, Category category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.article = article;</span><br><span class="line">        <span class="keyword">this</span>.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwcWithCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArticleWithCategory awc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwcWithCount</span><span class="params">(ArticleWithCategory awc, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.awc = awc;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;ArticleWithCategory&gt; <span class="title">fetchAWC</span><span class="params">(<span class="keyword">int</span> aid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从数据库中异步获取文章信息与分类信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Integer&gt; <span class="title">getCount</span><span class="params">(<span class="keyword">int</span> aid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从数据库中异步获取评论数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;AwcWithCount&gt; <span class="title">fetchWithAWCC</span><span class="params">(<span class="keyword">int</span> aid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetchAWC(aid).thenCompose(x -&gt; <span class="comment">// flatMap</span></span><br><span class="line">            getCount(aid).thenApply(y -&gt; <span class="comment">// map</span></span><br><span class="line">                <span class="keyword">new</span> AwcWithCount(x, y)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其实和Scala中的Slick的各种组合特别相似：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithAWCC</span>(</span>aid: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Option</span>[(<span class="type">Article</span>, <span class="type">Category</span>, <span class="type">Int</span>)]] = &#123;</span><br><span class="line">    db.run((<span class="keyword">for</span> &#123;</span><br><span class="line">        a &lt;- articles <span class="keyword">if</span> _.aid === aid</span><br><span class="line">        c &lt;- categories <span class="keyword">if</span> _.cid === a.cid</span><br><span class="line">    &#125; <span class="keyword">yield</span>(a, c)).result.headOption) flatMap &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(a, c) =&gt;</span><br><span class="line">            db.run(comments.filter(_.aid === aid).length) map &#123; <span class="keyword">case</span> res =&gt;</span><br><span class="line">                <span class="type">Some</span>(a, c, res)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">            <span class="type">Future</span>(<span class="type">None</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rx中同样也提供了类似的组合操作，而且更为丰富。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FRP/">FRP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JUC/">JUC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步/">异步</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-scala-fp-union-curry-howard-isomorphism" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/scala-fp-union-curry-howard-isomorphism/" class="article-date">
      <time datetime="2016-02-25T16:00:00.000Z" itemprop="datePublished">2016-02-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/scala-fp-union-curry-howard-isomorphism/">Scala | 利用Curry-Howard Isomorphism实现union type</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>所谓的联合类型(union type)，在逻辑上是“或”的意思，如<code>A or B or C</code>。</p>
<p>假设我们想实现这样一个函数size，它可以计算一个联合类型对象（Int与String）的长度。我们期望size函数只接受Int类型或String类型（以及它们的子类型，如Null和Nothing）的对象，而不接受任何其他类型的对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>(</span>x: <span class="type">Int</span> ∨ <span class="type">String</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i</span><br><span class="line">  <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size(<span class="number">24</span>) == <span class="number">24</span>   <span class="comment">// OK</span></span><br><span class="line">size(<span class="string">"fuck"</span>) == <span class="number">4</span> <span class="comment">// OK</span></span><br><span class="line">size(<span class="number">1.0</span>)        <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></p>
<p>Scala中的<code>Either</code>类型可以提供一种不支持子类型的联合类型。举个例子，用<code>Either</code>实现size函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>(</span>x: <span class="type">Either</span>[<span class="type">Int</span>, <span class="type">String</span>]) = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Left</span>(i) =&gt; i</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Right</span>(s) =&gt; s.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size(<span class="type">Left</span>(<span class="number">24</span>)) == <span class="number">24</span>    <span class="comment">// OK</span></span><br><span class="line">size(<span class="type">Right</span>(<span class="string">"fuck"</span>)) == <span class="number">4</span> <span class="comment">// OK</span></span><br><span class="line">size(<span class="type">Left</span>(<span class="string">"lv"</span>)) <span class="comment">// error: type mismatch</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以观察出一个问题，那就是要使用Either类型就不可避免要把对象包装成Either类型（<code>Left</code>或<code>Right</code>），这是不方便的。我们需要一些奇技淫巧来实现一个原生类型版本(unboxed)的size函数，这就是下面要介绍的<strong>Curry-Howard Isomorphism</strong>（柯里-霍华德同构）。</p>
<h1 id="Curry-Howard_同构">Curry-Howard 同构</h1><p><a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" target="_blank" rel="external">Curry-Howard 同构</a>通过命题表示了计算机程序与数理逻辑之间的直接联系(逻辑上的等价关系)，即我们可以利用数理逻辑中的某些东西来去表示程序中的特定逻辑。比如在Curry-Howard 同构中，有以下的等价关系：</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>类型系统(Scala)</th>
<th>命题逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>联合类型（并，析取）</td>
<td>A ∨ B（∨为自定义的析取类型）</td>
<td>A ∨ B</td>
</tr>
<tr>
<td>交集类型（交，合取）</td>
<td>A with B</td>
<td>A ∧ B</td>
</tr>
<tr>
<td>子类型（蕴含）</td>
<td>A &lt;: B</td>
<td>A ⇒ B</td>
</tr>
</tbody>
</table>
<p>因此联合类型可以表示为析取式，如<code>P ∨ Q ∨ R</code>。</p>
<p>那么如何根据Curry-Howard 同构实现一个析取类型呢？我们可以先利用<strong>德摩根定律</strong>(De Morgan’s laws)做一个转化。已知德摩根定律：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="literal">A</span> ∨ B) ⇔ ¬(¬<span class="literal">A</span> ∧ ¬B)</span><br></pre></td></tr></table></figure></p>
<p>用Scala代码就可以表示为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">A</span> ∨ <span class="type">B</span>) =:= ¬[¬[<span class="type">A</span>] <span class="keyword">with</span> ¬[<span class="type">B</span>]]</span><br></pre></td></tr></table></figure></p>
<p>这样，问题就转化成了如何实现一个否定类型(¬)。我们从另一个角度去利用Curry-Howard 同构。在类型系统理论中，存在以下等价关系：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>例</th>
<th>对应命题逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum Type</td>
<td>A ∨ B（∨为自定义的析取类型）</td>
<td>析取(A ∨ B)</td>
</tr>
<tr>
<td>Product Type</td>
<td>(A, B)</td>
<td>合取(A ∧ B)</td>
</tr>
<tr>
<td>Function Type</td>
<td>Function1[A, B]</td>
<td>蕴含(A ⇒ B)</td>
</tr>
</tbody>
</table>
<p>再根据以下的等价关系：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="literal">A</span> ⇒ <span class="literal">False</span>) ⇔ ¬<span class="literal">A</span></span><br></pre></td></tr></table></figure></p>
<p>我们就可以写出Scala中对应的类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> =&gt; <span class="type">Nothing</span></span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以定义两个类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬</span>[</span><span class="type">A</span>] = <span class="type">A</span> =&gt; <span class="type">Nothing</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">∨</span>[</span><span class="type">T</span>, <span class="type">U</span>] = ¬[¬[<span class="type">T</span>] <span class="keyword">with</span> ¬[<span class="type">U</span>]]</span><br></pre></td></tr></table></figure></p>
<p>在REPL里测试一下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">¬</span>[</span><span class="type">A</span>] = <span class="type">A</span> =&gt; <span class="type">Nothing</span></span><br><span class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">$u00AC</span></span><br><span class="line"></span></span><br><span class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">∨</span>[</span><span class="type">T</span>, <span class="type">U</span>] = ¬[¬[<span class="type">T</span>] <span class="keyword">with</span> ¬[<span class="type">U</span>]]</span><br><span class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">$u2228</span></span><br><span class="line"></span></span><br><span class="line">scala&gt; implicitly[<span class="type">Int</span> &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</span><br><span class="line">&lt;console&gt;:<span class="number">13</span>: error: <span class="type">Cannot</span> prove that <span class="type">Int</span> &lt;:&lt; ∨[<span class="type">Int</span>,<span class="type">String</span>].</span><br><span class="line">       implicitly[<span class="type">Int</span> &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</span><br></pre></td></tr></table></figure></p>
<p>嗯？哪里出问题了？我们来分析一下<code>(Int ∨ String)</code>这个类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :k ∨[<span class="type">Int</span>, <span class="type">String</span>]</span><br><span class="line">scala.<span class="type">Function1</span><span class="symbol">'s</span> kind is <span class="type">F</span>[-<span class="type">A1</span>,+<span class="type">A2</span>]</span><br></pre></td></tr></table></figure></p>
<p>原来(Int ∨ String)的类型是函数类型，也就是说我们创造的Union Type是函数类型，那Int类型自然不是(Int ∨ String)的子类型了，因为它连函数类型都不是。我们需要将<code>&lt;:&lt;</code>操作符左边的类型转化成函数类型，比如双重否定类型（逻辑上相当于原类型，但其类型为函数类型）：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬¬</span>[</span><span class="type">A</span>] = ¬[¬[<span class="type">A</span>]]</span><br></pre></td></tr></table></figure></p>
<p>再测试一下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">¬¬</span>[</span><span class="type">A</span>] = ¬[¬[<span class="type">A</span>]]</span><br><span class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">$u00AC$u00AC</span></span><br><span class="line"></span></span><br><span class="line">scala&gt; implicitly[¬¬[<span class="type">Int</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</span><br><span class="line">res2: &lt;:&lt;[¬¬[<span class="type">Int</span>],∨[<span class="type">Int</span>,<span class="type">String</span>]] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; implicitly[¬¬[<span class="type">String</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</span><br><span class="line">res3: &lt;:&lt;[¬¬[<span class="type">String</span>],∨[<span class="type">Int</span>,<span class="type">String</span>]] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; implicitly[¬¬[<span class="type">Double</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</span><br><span class="line">&lt;console&gt;:<span class="number">14</span>: error: <span class="type">Cannot</span> prove that ¬¬[<span class="type">Double</span>] &lt;:&lt; ∨[<span class="type">Int</span>,<span class="type">String</span>].</span><br><span class="line">       implicitly[¬¬[<span class="type">Double</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</span><br></pre></td></tr></table></figure></p>
<p>成功了！<code>¬¬[Int]</code>和<code>¬¬[String]</code>都是<code>∨[Int,String]</code>的子类型。把Int换成Double，无法通过编译。下面我们就可以利用隐式转换实现我们的size函数了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>[</span><span class="type">T</span>](t: <span class="type">T</span>)(<span class="keyword">implicit</span> ev: (¬¬[<span class="type">T</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>))) = t <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i</span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试一下，结果very good～<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; size(<span class="number">24</span>)</span><br><span class="line">res5: <span class="type">Int</span> = <span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; size(<span class="string">"Scala"</span>)</span><br><span class="line">res6: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">scala&gt; size(<span class="number">6.666</span>)</span><br><span class="line">&lt;console&gt;:<span class="number">15</span>: error: <span class="type">Cannot</span> prove that ¬¬[<span class="type">Double</span>] &lt;:&lt; ∨[<span class="type">Int</span>,<span class="type">String</span>].</span><br><span class="line">       size(<span class="number">6.666</span>)</span><br><span class="line">           ^</span><br></pre></td></tr></table></figure></p>
<p>最后还可以用type lambda来简化函数的参数，省掉implicit：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">|∨|</span>[</span><span class="type">T</span>, <span class="type">U</span>] = &#123; <span class="class"><span class="keyword">type</span> <span class="title">λ</span>[</span><span class="type">X</span>] = ¬¬[<span class="type">X</span>] &lt;:&lt; (<span class="type">T</span> ∨ <span class="type">U</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>[</span><span class="type">T</span>: (<span class="type">Int</span> |∨| <span class="type">String</span>)#λ](t: <span class="type">T</span>) =</span><br><span class="line">  t <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i</span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.length</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们union type及size函数的最终实现为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬</span>[</span><span class="type">A</span>] = <span class="type">A</span> ⇒ <span class="type">Nothing</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">∨</span>[</span><span class="type">T</span>, <span class="type">U</span>] = ¬[¬[<span class="type">T</span>] <span class="keyword">with</span> ¬[<span class="type">U</span>]]</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬¬</span>[</span><span class="type">A</span>] = ¬[¬[<span class="type">A</span>]]</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">|∨|</span>[</span><span class="type">T</span>, <span class="type">U</span>] = &#123; <span class="class"><span class="keyword">type</span> <span class="title">λ</span>[</span><span class="type">X</span>] = ¬¬[<span class="type">X</span>] &lt;:&lt; (<span class="type">T</span> ∨ <span class="type">U</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>[</span><span class="type">T</span> : (<span class="type">Int</span> |∨| <span class="type">String</span>)#λ](t : <span class="type">T</span>) = t <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i : <span class="type">Int</span> ⇒ i</span><br><span class="line">    <span class="keyword">case</span> s : <span class="type">String</span> ⇒ s.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下，整个过程的本质都是在进行类型推导和证明，因此我们可以将Curry-Howard 同构理解为<strong>类型证明即程序</strong>。</p>
<p>其实类型系统还有很多好玩的东西，比如<strong>dependent type</strong>。。后边可以用Scala玩玩。</p>
<p>最后吐槽一下Scala。。。不明白Scala标准为什么不支持原生的union type。。本来应该由Scala编译器做的事都要交给我们做了(%&gt;_&lt;%)</p>
<hr>
<h1 id="Reference">Reference</h1><p><a href="http://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/" target="_blank" rel="external">Unboxed union types in Scala via the Curry-Howard isomorphism, Miles Sabin</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mathematical-Logic/">Mathematical Logic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-scala-fp-for-expression-detail" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Functional-Programming/scala-fp-for-expression-detail/" class="article-date">
      <time datetime="2016-02-24T16:00:00.000Z" itemprop="datePublished">2016-02-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Functional-Programming/scala-fp-for-expression-detail/">Scala | for表达式的底层转换</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Scala中的for表达式为一种方便的语法糖，它实际上是几种操作<code>map</code>、<code>flatMap</code>和<code>filter</code>的组合。for表达式可以这样表述：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ([pattern &lt;- generator; definition*]+; filter* )</span><br><span class="line">      [<span class="keyword">yield</span>] expression</span><br></pre></td></tr></table></figure></p>
<p>Scala中的for表达式与Haskell中的do-notation类似，都是对操作组合过程的简化，操作的对象都是Monad。这里就类比Haskell中的do-notation来总结Scala中的for-expression。</p>
<h1 id="最简单的for表达式">最简单的for表达式</h1><p>让我们来看看最简单的，只有一个generator的for表达式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x &lt;- e1)</span><br><span class="line">    <span class="keyword">yield</span> e2</span><br></pre></td></tr></table></figure></p>
<p>它会被转化为<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e1 map &#123;x =&gt; e2&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过Quasiquotes获取AST来验证：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">e1</span> =</span> <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">e1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(</span>x: <span class="type">Int</span>) = x * <span class="number">2</span></span><br><span class="line">f1: (x: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; q<span class="string">" for (x &lt;- e1) yield f1 _ "</span></span><br><span class="line">res2: reflect.runtime.universe.<span class="type">Tree</span> = e1.map(((x) =&gt; (f1: (() =&gt; &lt;empty&gt;))))</span><br></pre></td></tr></table></figure></p>
<p>在Haskell中原表达式等价于：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span></span><br><span class="line">    x &lt;- e1</span><br><span class="line">    return e2</span><br></pre></td></tr></table></figure></p>
<p>转换为非do-notation：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">e1</span> &gt;&gt;=</span><br><span class="line">     \x -&gt; return e2</span><br></pre></td></tr></table></figure></p>
<p>根据Monad Laws - Right Unit转化：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> (\x -&gt; e2) e1</span><br></pre></td></tr></table></figure></p>
<h1 id="多个generator的for表达式">多个generator的for表达式</h1><p>多个generator其实就是<code>map</code>和<code>flatMap</code>(<code>fmap</code>和<code>&gt;&gt;=</code>)的组合，比如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x &lt;- e1; y &lt;- e2)</span><br><span class="line">    <span class="keyword">yield</span> e3</span><br></pre></td></tr></table></figure></p>
<p>会转化为<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e1.flatMap(x =&gt; <span class="keyword">for</span> (y &lt;- e2) <span class="keyword">yield</span> e3)</span><br></pre></td></tr></table></figure></p>
<p>即<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e1 flatMap &#123; x =&gt;</span><br><span class="line">    e2 map &#123; y =&gt; e3 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>REPL里验证：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; q<span class="string">"for(x &lt;- e1; y &lt;- e2) yield x + y"</span></span><br><span class="line">res3: reflect.runtime.universe.<span class="type">Tree</span> = e1.flatMap(((x) =&gt; e2.map(((y) =&gt; x.$plus(y)))))</span><br></pre></td></tr></table></figure></p>
<p>举例(Scala):<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">e1</span> =</span> <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">e2</span> =</span> <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">f1</span> =</span> <span class="keyword">for</span>(x &lt;- e1; y &lt;- e2)</span><br><span class="line">  <span class="keyword">yield</span> x + y <span class="comment">// List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">f2</span> =</span> e1 flatMap &#123; x =&gt;</span><br><span class="line">  e2 map &#123; y =&gt; x + y &#125;</span><br><span class="line">&#125; <span class="comment">// List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span></span><br></pre></td></tr></table></figure></p>
<p>在Haskell中原表达式等价于：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span></span><br><span class="line">    x &lt;- e1</span><br><span class="line">    y &lt;- e2</span><br><span class="line">    return e3</span><br></pre></td></tr></table></figure></p>
<p>转换为非do-notation：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">e1</span> &gt;&gt;=</span><br><span class="line">     \x -&gt; e2 &gt;&gt;=</span><br><span class="line">         \y -&gt; return e3</span><br></pre></td></tr></table></figure></p>
<p>根据Monad Laws - Right Unit转化：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">e1</span> &gt;&gt;=</span><br><span class="line">    \x -&gt; fmap (\y -&gt; e3) e2</span><br></pre></td></tr></table></figure></p>
<p>举例(Haskell)：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- result: [5,6,7,6,7,8,7,8,9]</span></span><br><span class="line"><span class="title">f2</span> :: (<span class="type">Num</span> a) =&gt; [a]</span><br><span class="line"><span class="title">f2</span> = <span class="keyword">do</span></span><br><span class="line">    x &lt;- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    y &lt;- [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    return (x + y)</span><br><span class="line"></span><br><span class="line"><span class="title">f3</span> :: (<span class="type">Num</span> a) =&gt; [a]</span><br><span class="line"><span class="title">f3</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &gt;&gt;=</span><br><span class="line">     \x -&gt; [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] &gt;&gt;=</span><br><span class="line">          \y -&gt; return (x + y)</span><br><span class="line"></span><br><span class="line"><span class="title">f4</span> :: (<span class="type">Num</span> a) =&gt; [a]</span><br><span class="line"><span class="title">f4</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &gt;&gt;=</span><br><span class="line">     \x -&gt; fmap (\y -&gt; x + y) [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="含副作用的for表达式">含副作用的for表达式</h1><p>Scala中，for表达式也有支持side effects的版本，比如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x &lt;- e1; y &lt;- e2)</span><br><span class="line">    println(x * y)</span><br></pre></td></tr></table></figure></p>
<p>它的转化和含yield的差不多，只不过它用含副作用的foreach操作替代了map和flatMap算子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e1 foreach &#123;</span><br><span class="line">    x =&gt; e2 foreach &#123;</span><br><span class="line">        y =&gt; println(x * y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="含条件的for表达式">含条件的for表达式</h1><p>Scala支持含有<code>if guard</code>的for表达式，其中<code>if guard</code>对应filter算子。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x &lt;- e1 <span class="keyword">if</span> f)</span><br><span class="line">    <span class="keyword">yield</span> e2</span><br></pre></td></tr></table></figure></p>
<p>会转化为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x &lt;- e1 withFilter &#123;x =&gt; f&#125;)</span><br><span class="line">    <span class="keyword">yield</span> e2</span><br></pre></td></tr></table></figure></p>
<p>即：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e1 withFilter &#123;x =&gt; f&#125; map &#123;x =&gt; e2&#125;</span><br></pre></td></tr></table></figure></p>
<p>REPL里验证：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; reify( <span class="keyword">for</span>(x &lt;- e1 <span class="keyword">if</span> x &gt; <span class="number">2</span>) <span class="keyword">yield</span> f1 _ )</span><br><span class="line">res20: reflect.runtime.universe.<span class="type">Expr</span>[<span class="type">List</span>[<span class="type">Int</span> =&gt; <span class="type">Int</span>]] =</span><br><span class="line"><span class="type">Expr</span>[<span class="type">List</span>[<span class="type">Int</span> =&gt; <span class="type">Int</span>]]($read.e1.withFilter(((x) =&gt; x.$greater(<span class="number">2</span>))).map(((x) =&gt; &#123;</span><br><span class="line">  ((x) =&gt; $read.f1(x))</span><br><span class="line">&#125;))(<span class="type">List</span>.canBuildFrom))</span><br><span class="line"></span><br><span class="line">scala&gt; q<span class="string">" for(x &lt;- e1 if x &gt; 2) yield f1 _ "</span></span><br><span class="line">res21: reflect.runtime.universe.<span class="type">Tree</span> = e1.withFilter(((x) =&gt; x.$greater(<span class="number">2</span>))).map(((x) =&gt; (f1: (() =&gt; &lt;empty&gt;))))</span><br></pre></td></tr></table></figure></p>
<p><strong>注</strong>：definition会影响for表达式的展开（多一次map），后边有时间再总结。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Functional-Programming/">Functional Programming</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-algorithm-quicksort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Algorithm/algorithm-quicksort/" class="article-date">
      <time datetime="2016-02-22T16:00:00.000Z" itemprop="datePublished">2016-02-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Algorithm/algorithm-quicksort/">快速排序实现及优化 | DualPivotQuicksort</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="快速排序的基本实现">快速排序的基本实现</h1><p>快速排序算法是一种基于交换的高效的排序算法，它采用了<strong>分治法</strong>的思想：</p>
<ol>
<li>从数列中取出一个数作为基准数（枢轴，pivot）。</li>
<li>将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。</li>
<li>再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。</li>
</ol>
<p>快排最重要的一步就是划分了。划分的过程用通俗的语言讲就是“挖坑”和“填坑”。</p>
<p>举个例子，首先给一组数组：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>36</td>
<td>9</td>
<td>-7</td>
<td>45</td>
<td>23</td>
<td>61</td>
<td>15</td>
</tr>
</tbody>
</table>
<p>为了方便起见，我们选择第一个元素36作为基准数，这样就腾出了第一个位置（挖坑），下面首先自右向左寻找比基准数小的元素填至第一个位置（填坑）：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>9</td>
<td>-7</td>
<td>45</td>
<td>23</td>
<td>61</td>
<td></td>
<td>36</td>
</tr>
</tbody>
</table>
<p>第七个位置被腾出，然后再自左向右寻找比基准元素大的元素填在空位处：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>9</td>
<td>-7</td>
<td></td>
<td>23</td>
<td>61</td>
<td>45</td>
<td>36</td>
</tr>
</tbody>
</table>
<p>再重复上面的动作，直到第一趟划分完毕。此时[a0,a3]都是小于基准值a4的，[a5,a6]都是大于基准值a4的：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>9</td>
<td>-7</td>
<td>23</td>
<td>36</td>
<td>61</td>
<td>45</td>
<td>36</td>
</tr>
</tbody>
</table>
<p>然后再对两个子序列递归地进行上述的过程，最终可得到有序序列。</p>
<p>总结一下这个划分的过程：</p>
<ol>
<li>设两个指示i=left，j=right；设arr[left]为基准数</li>
<li>从后向前寻找比基准元素大的元素，填至空位处</li>
<li>从前向后寻找比基准元素小的元素，填至空位处</li>
<li>重复执行2、3步，直到两指示相等，将基准元素填至指示的位置，本次划分结束</li>
</ol>
<p>用代码表示为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[left];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt; tmp)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; tmp)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[i] = tmp;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = partition(arr, left, right);</span><br><span class="line">    quick_sort(arr, left, j - <span class="number">1</span>);</span><br><span class="line">    quick_sort(arr, j + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然用Haskell写是最简单的了:)</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">qs</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">qs</span> [] = []</span><br><span class="line"><span class="title">qs</span> (x:xs) =</span><br><span class="line">    <span class="keyword">let</span> s = qs $ filter (&lt;= x) xs</span><br><span class="line">        l = qs $ filter (&gt; x)  xs</span><br><span class="line">    <span class="keyword">in</span> s ++ [x] ++ l</span><br></pre></td></tr></table></figure>
<p>另一种实现划分的思路是先从左到右扫描一个比基准数大的元素，再从右到左扫描一个比基准数小的元素（左右两个指针i、j滑动），然后交换这两个元素，重复操作直到两指针相遇，然后将基准元素arr[left]与左子序列最后的元素arr[j]进行交换即可，用代码描述为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[left];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++i] &lt; temp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[--j] &gt; temp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == left)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序算法的平均时间复杂度为<code>O(NlogN)</code>。快排的最差情况为序列完全有序，此时快排退化为冒泡排序，时间复杂度为<code>O(n^2)</code>。</p>
<h1 id="快速排序的改进和优化(2016-2-23更新)">快速排序的改进和优化(2016.2.23更新)</h1><p>快速排序也有不足之处，比如<strong>对于元素较少或接近有序的数组来说，快速排序比插入排序慢</strong>。针对这种情况，我们可以加个判断，<strong>对小数组使用插入排序</strong>（Java标准库自带的排序就是这么干的，INSERTION_SORT_THRESHOLD = 47）。</p>
<p>另外一个改进快速排序性能的方法就是使用<strong>双枢轴</strong>，即将数组三切分(大于枢轴，等于枢轴，小于枢轴），可以证明这样是熵最优的并且更高效。以Java标准库为例，JDK1.7中的DualPivotQuicksort实现了一种<strong>快速三向切分</strong>的快速排序，它通过将相等元素聚集起来的方式使熵最优（原理：<strong>将相等元素聚集起来</strong>，不必再切分这些元素）。</p>
<p>还有一个优化的杀手锏就是改进划分的策略，这里DualPivotQuicksort使用了一种称为<strong>五取样划分</strong>的策略对数组进行划分。</p>
<p>总结一下，快排的改进主要有三种方法：小数组使用插入排序、双枢轴快速三向切分、五取样划分。具体实现可以看<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/e2117e30fb39/src/share/classes/java/util/DualPivotQuicksort.java" target="_blank" rel="external">DualPivotQuicksort的源码</a>，实现的很复杂，非常奇妙。</p>
<p><img src="http://img.blog.csdn.net/20160220202246946" alt="快速三向切分"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sort/">Sort</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2016 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30.
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>