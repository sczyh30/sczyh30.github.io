<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>「千载弦歌，芳华如梦」 - sczyh30&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--<meta name="keywords" content="sczyh30, blog"/>-->
  <meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/page/8/index.html">
<meta property="og:site_name" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">
  
    <link rel="alternative" href="/atom.xml" title="「千载弦歌，芳华如梦」 - sczyh30&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/AIO/" style="font-size: 10px;">AIO</a> <a href="/tags/AMQP/" style="font-size: 10px;">AMQP</a> <a href="/tags/APT/" style="font-size: 10px;">APT</a> <a href="/tags/Akka-Actor/" style="font-size: 10px;">Akka Actor</a> <a href="/tags/Algorithm/" style="font-size: 13px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 16px;">C++</a> <a href="/tags/C-11/" style="font-size: 10px;">C++ 11</a> <a href="/tags/CE3/" style="font-size: 10px;">CE3</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Category-Theory/" style="font-size: 10px;">Category Theory</a> <a href="/tags/Chemistry/" style="font-size: 11px;">Chemistry</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Docker/" style="font-size: 11px;">Docker</a> <a href="/tags/Engine/" style="font-size: 10px;">Engine</a> <a href="/tags/Euterpea/" style="font-size: 10px;">Euterpea</a> <a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/FRP/" style="font-size: 10px;">FRP</a> <a href="/tags/Functional-Programming/" style="font-size: 18px;">Functional Programming</a> <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/GC/" style="font-size: 13px;">GC</a> <a href="/tags/GDB/" style="font-size: 10px;">GDB</a> <a href="/tags/Game/" style="font-size: 11px;">Game</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/Haskell/" style="font-size: 14px;">Haskell</a> <a href="/tags/HotSpot/" style="font-size: 12px;">HotSpot</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 19px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Klass-oop/" style="font-size: 10px;">Klass-oop</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/MIDI/" style="font-size: 10px;">MIDI</a> <a href="/tags/Mathematical-Logic/" style="font-size: 10px;">Mathematical Logic</a> <a href="/tags/Metaspace/" style="font-size: 10px;">Metaspace</a> <a href="/tags/Netflix-Hystrix/" style="font-size: 10px;">Netflix Hystrix</a> <a href="/tags/Network/" style="font-size: 16px;">Network</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Object-Model/" style="font-size: 12px;">Object Model</a> <a href="/tags/Play-Framework/" style="font-size: 11px;">Play Framework</a> <a href="/tags/Quorum/" style="font-size: 10px;">Quorum</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Reflection/" style="font-size: 11px;">Reflection</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/STL/" style="font-size: 11px;">STL</a> <a href="/tags/Scala/" style="font-size: 19px;">Scala</a> <a href="/tags/Slick/" style="font-size: 11px;">Slick</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Struct/" style="font-size: 10px;">Struct</a> <a href="/tags/Summary/" style="font-size: 12px;">Summary</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/Type-Lambda/" style="font-size: 10px;">Type Lambda</a> <a href="/tags/Type-System/" style="font-size: 10px;">Type System</a> <a href="/tags/Type-Theory/" style="font-size: 12px;">Type Theory</a> <a href="/tags/UE4/" style="font-size: 10px;">UE4</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/Vert-x/" style="font-size: 19px;">Vert.x</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Web/" style="font-size: 12px;">Web</a> <a href="/tags/Web开发/" style="font-size: 12px;">Web开发</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/functional/" style="font-size: 10px;">functional</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/事务/" style="font-size: 10px;">事务</a> <a href="/tags/云服务/" style="font-size: 12px;">云服务</a> <a href="/tags/内存区域/" style="font-size: 10px;">内存区域</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/分布式系统/" style="font-size: 12px;">分布式系统</a> <a href="/tags/前端/" style="font-size: 12px;">前端</a> <a href="/tags/基础/" style="font-size: 10px;">基础</a> <a href="/tags/多线程/" style="font-size: 11px;">多线程</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/开发/" style="font-size: 17px;">开发</a> <a href="/tags/异步/" style="font-size: 13px;">异步</a> <a href="/tags/异步编程/" style="font-size: 18px;">异步编程</a> <a href="/tags/微服务/" style="font-size: 13px;">微服务</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 11px;">数据库</a> <a href="/tags/架构/" style="font-size: 11px;">架构</a> <a href="/tags/消息系统/" style="font-size: 10px;">消息系统</a> <a href="/tags/源码分析/" style="font-size: 14px;">源码分析</a> <a href="/tags/生活/" style="font-size: 10px;">生活</a> <a href="/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Fighting</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-jvm-gc-safepoint-condition" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-gc-safepoint-condition/" class="article-date">
      <time datetime="2015-06-30T16:00:00.000Z" itemprop="datePublished">2015-07-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-gc-safepoint-condition/">深入探究JVM | Safepoint及GC的触发条件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近看JVM看得火热。。在这里我们来总结一下HotSpot JVM里GC Safepoint以及触发GC的条件相关的一些知识。</p>
<h1 id="GC_Safepoint">GC Safepoint</h1><p>如果要触发一次GC，那么JVM中所有Java线程都必须到达GC Safepoint。</p>
<p>JVM只会在特定位置放置safepoint，比如：</p>
<ul>
<li>内存分配的地方（allocation，即new一个新对象的时候）</li>
<li>长时间执行区块结束的时刻（如方法调用，循环跳转等）</li>
</ul>
<p>之所以只在特定的位置放置safepoint，是因为OopMap要占用空间，如果设太多safepoint那么占用空间会太大；再者，safepoint会影响优化，如果某个无用的值处设置了safepoint，那么JIT就无法优化掉这些无用变量，这会影响性能。</p>
<p>HotSpot JVM在通过JIT编译时，会在所有方法返回之前以及循环跳转、异常跳转之前放置Safepoint，并且在每个Safepoint都生成一些信息存储哪些地方是引用（<strong>OopMap</strong>），以便JVM能找到需要的引用。</p>
<p>那么如何确保GC时所有线程都到达GC Safepoint呢？有两种方法：<strong>抢占式中断</strong>(Preemptive Suspension)和<strong>主动式中断</strong>(Voluntary Suspension)。</p>
<p>抢占式中断不需要线程的执行代码去主动配合，当触发GC时，JVM会中断所有线程，然后依次检查每个线程中断的位置是否为Safepoint，如果不是则恢复线程，让它执行至Safepoint再进行终端。</p>
<p>大部分JVM实现（如HotSpot JVM）都是采用<strong>主动式中断</strong>，即GC需要中断线程的时候，它仅仅简单地设个标志，执行线程会主动轮询这个标志位，如果标志位就绪的话就自行中断。Polling Point与Safepoint是重合的。主动式中断的思想是一种hand-shacking protocol的思想。</p>
<p>通过对Safepoint的研究，我们了解到了GC触发的时刻主要是在<strong>new一个新的对象</strong>或者在<strong>循环跳转或方法返回之前</strong>。</p>
<p>【扩展】Safepoint有好几种，比如还有<strong>deoptimization safepoint</strong>之类的，作用不同。</p>
<h1 id="Safe-Region">Safe-Region</h1><p>只有GC Safepoint是不足的，因为我们发现，有一种情况，线程无法响应JVM的中断请求，也无法去轮询标志位：</p>
<ul>
<li>线程处于阻塞或等待状态</li>
</ul>
<p>对于这种情况，引入了safe-region的概念。</p>
<p>Safe-Region是指在代码片段中，引用关系不会发生变化，因此GC可以随心所欲地在任何地方执行。在线程执行到Safe Region里面的代码时，首先标识自己已经进入了Safe Region，那样当这段时间里JVM要发起GC，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<p>另外，当一个线程在执行native方法时，由于此时该线程在执行JVM管理之外的代码，不能对JVM的执行状态做任何修改，因而JVM要进入safepoint不需要关心它。所以也可以把正在执行native函数的线程看作“已经进入了safepoint”，或者把这种情况叫做“在safe-region里”。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://www.infoq.com/cn/articles/jvm-memory-collection" target="_blank" rel="external">JVM内存回收理论与实现, 周志明</a></li>
<li><a href="http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html" target="_blank" rel="external">GC safe-point (or safepoint) and safe-region, Xiao-Feng Li</a></li>
<li><a href="https://www.zhihu.com/question/29268019" target="_blank" rel="external">现代JVM中的Safe Region和Safe Point到底是如何定义和划分的? - RednaxelaFX的回答</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-java-reference-type" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-reference-type/" class="article-date">
      <time datetime="2015-06-28T16:00:00.000Z" itemprop="datePublished">2015-06-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-reference-type/">Java中的几种引用 | 弱引用、软引用、虚引用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Java中存在四种引用：强引用、软引用、弱引用、虚引用，这里来分别分析一下。</p>
<h1 id="StrongReference">StrongReference</h1><p><strong>StrongReference</strong>（强引用）是最普通的引用类型，只要强引用存在，GC就不会进行垃圾回收。</p>
<h1 id="SoftReference">SoftReference</h1><p><strong>SoftReference</strong>（软引用）用来描述一些有用但是非必需的对象。如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM就会把这个软引用加入到与之关联的引用队列中。软引用可用来实现内存敏感的高速缓存。</p>
<h1 id="WeakReference">WeakReference</h1><p><strong>WeakReference</strong>（弱引用）是一种生命周期比软引用更短的引用。当GC扫描启动时，只要扫描到只具有弱引用的对象，<strong>无论内存是否够用都会执行GC</strong>，但由于GC线程优先级很低，因此并不一定能迅速发现这些弱引用对象。弱引用也可以和一个引用队列联合使用。<br>WeakReference在Android中用的挺多。</p>
<h1 id="PhantomReference">PhantomReference</h1><p><strong>PhantomReference</strong>（虚引用）不同于其余三种引用，虚引用不会影响对象的生命周期，也无法通过虚引用获得对象的一个实例；如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动，它必须和引用队列联合使用。</p>
<p>【2015-7-16补充】逛InfoQ的时候又发现了一种FinalReference。。用的不多就不总结了，文章：<a href="http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference" target="_blank" rel="external">JVM源码分析之FinalReference完全解读</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-jvm-gc-intro-count-vs-reachability" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-gc-intro-count-vs-reachability/" class="article-date">
      <time datetime="2015-06-28T16:00:00.000Z" itemprop="datePublished">2015-06-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-gc-intro-count-vs-reachability/">深入探究JVM | 初探GC - 引用计数 VS 可达分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>主流的垃圾回收主要分两大类：引用计数和可达性分析。</p>
<h1 id="引用计数法">引用计数法</h1><p>引用计数的实现很简单，它的思想就是给一个对象增加一个引用计数器，每当一个新的对象引用它时就给计数器加1，不引用了就减1，当计数器为0时即可认为对象无用了，可进行回收。</p>
<p>这个思想很简单，而且很多语言的底层（如Swift，Python）都是基于引用计数法进行回收的。但是引用计数法有一个很大的缺陷：它无法解决循环引用的问题，比如A引用B，B引用A，这样两对象的引用计数器永远不为0，两对象不能被回收，从而造成内存不能被及时清理。</p>
<p>JVM没有使用引用计数法，而是使用了可达性分析来进行GC。</p>
<p>题外话：C++ 11的智能指针就是基于引用计数的，它提供了<code>weak_ptr</code>来解决循环引用的问题。（类似于Java中的<code>WeakReference</code>，作用类似）</p>
<h1 id="可达性分析">可达性分析</h1><p>可达性分析是基于图论的分析方法，它会找一组对象作为GC Root（根结点），并从根结点进行遍历，遍历结束后如果发现某个对象是不可达的（即从GC Root到此对象没有路径），那么它就会被标记为不可达对象，等待GC。比如，假设下图中obj1位GC Root，那么obj5和obj6就是不可达的：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/graph-gc-reachable.png" alt=""></p>
<h1 id="哪些对象可以作为GC_Root">哪些对象可以作为GC Root</h1><p>能作为GC Root的对象必定为可以存活的对象，比如全局性的引用（<strong>静态变量和常量</strong>）以及某些方法的<strong>局部变量</strong>（栈帧中的本地变量表）。</p>
<p>以下对象通常可以作为GC Root：</p>
<ul>
<li>存活的线程</li>
<li><strong>虚拟机栈(栈桢中的本地变量表)中的引用的对象</strong></li>
<li><strong>方法区中的类静态属性以及常量引用的对象</strong></li>
<li><strong>本地方法栈中JNI引用的局部变量以及全局变量</strong></li>
</ul>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="https://www.yourkit.com/docs/java/help/gc_roots.jsp" target="_blank" rel="external">GC roots</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-compiler-a01" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Summary/compiler-a01/" class="article-date">
      <time datetime="2015-06-26T16:00:00.000Z" itemprop="datePublished">2015-06-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Summary/compiler-a01/">编译原理相关 | C++编译器总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="gcc下new_int[]内存的额外信息的存储区域">gcc下new int[]内存的额外信息的存储区域</h2><p>“额外信息”不是在<code>operator new (size_t sz)</code>里记录的，而是编译器在外面看情况额外生成了代码。<br>原因是：全局的operator new (size_t sz)和operator new[] (size_t sz)并不知道要给什么类型的对象分配空间，所以自然也不知道它们所需要记录的额外元数据要些什么。<br>而这些信息从调用者的一侧是知道的，所以就由编译器在调用者的一侧生成代码来做这些事情。<br>关于operator new[] (size_t sz)的实现，参考某个版本的GCC对应的libstdc++ / libsupc++吧。</p>
<p>全局的operator new[] (size_t sz)在这里（这个是throw版；nothrow版在对应的new_opvnt.cc里）：<br><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/new#L128" target="_blank" rel="external">gcc/new_opv.cc at master · gcc-mirror/gcc · GitHub</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_GLIBCXX_WEAK_DEFINITION <span class="keyword">void</span>*</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> sz) _GLIBCXX_THROW (<span class="built_in">std</span>::bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(sz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接传交给operator new(size<em>t sz)了。多狡猾 &gt;</em>&lt;</p>
<p>然后是全局的operator new (size_t sz)<br><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/new#L128" target="_blank" rel="external">gcc/new_op.cc at master · gcc-mirror/gcc · GitHub</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_GLIBCXX_WEAK_DEFINITION <span class="keyword">void</span> *</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="built_in">std</span>::size_t sz)</span> _<span class="title">GLIBCXX_THROW</span> <span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* malloc (0) is unpredictable; avoid it.  */</span></span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">    sz = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__builtin_expect ((p = <span class="built_in">malloc</span> (sz)) == <span class="number">0</span>, <span class="keyword">false</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      new_handler handler = <span class="built_in">std</span>::get_new_handler ();</span><br><span class="line">      <span class="keyword">if</span> (! handler)</span><br><span class="line">	_GLIBCXX_THROW_OR_ABORT(bad_alloc());</span><br><span class="line">      handler ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正常路径上本质上就是调用了libc的malloc(size_t sz)而已，额外信息也不是在这里写入的。<br>所以记录这个”额外信息“的具体实现在malloc函数里。（转自R大）</p>
<p>===================================================================<br>未完待续。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Summary/">Summary</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Compiler/">Compiler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译原理/">编译原理</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-jvm-metaspace" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-metaspace/" class="article-date">
      <time datetime="2015-06-25T16:00:00.000Z" itemprop="datePublished">2015-06-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-metaspace/">深入探究JVM | 探秘Metaspace</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Java 8彻底将永久代移除出了HotSpot JVM，将其原有的数据迁移至Java Heap或Metaspace。这一篇文章我们来总结一下Metaspace（元空间）的特性。如有错误，敬请指出，谢谢~</p>
<hr>
<h1 id="引言：永久代为什么被移出HotSpot_JVM了？">引言：永久代为什么被移出HotSpot JVM了？</h1><p>在HotSpot JVM中，永久代中用于存放类和方法的元数据以及常量池，在Java中对应能通过反射获取到的数据，比如<code>Class</code>和<code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p>
<p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <em>java.lang.OutOfMemoryError: PermGen</em> 。为此我们不得不对虚拟机做调优<br>那么，Java 8中永久代为什么被移出HotSpot JVM了？<br>详见：<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a><br>原因主要有两个：</p>
<ul>
<li>1、由于Permanent Generation内存经常不够用或发生内存泄露，引发恼人的<em>java.lang.OutOfMemoryError: PermGen</em> （在Java Web开发中非常常见）。</li>
<li>2、移除Permanent Generation可以促进HotSpot JVM与JRockit VM的融合，因为JRockit没有永久代。</li>
</ul>
<p>根据上面的各种原因，永久代最终被移除，<strong>方法区移至Metaspace，字符串常量移至Java Heap</strong>。</p>
<h1 id="探秘元空间">探秘元空间</h1><p>由于Metaspace的资料比较少，这里主要是依据Oracle官方的Java虚拟机规范及Oracle Blog里的几篇文章来总结的。</p>
<p>首先，Metaspace（元空间）是哪一块区域？官方的解释是：</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p>
</blockquote>
<p>也就是说，JDK 8开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。</p>
<h2 id="1、优点">1、优点</h2><p>使用本地内存有什么好处呢？最直接的表现就是OOM问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让Metaspace变得无限大显然是不现实的，因此我们也要限制Metaspace的大小：使用<strong>-XX:MaxMetaspaceSize</strong>参数来指定Metaspace区域的大小。JVM默认在运行时根据需要动态地设置<strong>MaxMetaspaceSize</strong>的大小。</p>
<p>除此之外，它还有以下优点：</p>
<ul>
<li>Take advantage of Java Language Specification property : Classes and associated metadata lifetimes match class loader’s</li>
<li>Linear allocation only</li>
<li>No individual reclamation (except for RedefineClasses and class loading failure)</li>
<li>No GC scan or compaction</li>
<li>No relocation for metaspace objects</li>
</ul>
<h2 id="2、垃圾回收">2、垃圾回收</h2><p>如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）。</p>
<p>为了减少垃圾回收的频率及时间，控制吞吐量，对Metaspace进行适当的监控和调优是非常有必要的。如果在Metaspace区发生了频繁的Full GC，那么可能表示存在内存泄露或Metaspace区的空间太小了。</p>
<h2 id="3、新增参数">3、新增参数</h2><ul>
<li><strong>-XX:MetaspaceSize</strong>是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，<em>the initial high-water-mark</em> )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li>
<li><strong>-XX:MaxMetaspaceSize</strong>是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</li>
<li><strong>-XX:MinMetaspaceFreeRatio</strong>表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</li>
<li><strong>-XX:MaxMetaspaceFreeRatio</strong>表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</li>
</ul>
<h2 id="4、监控与调优（待补充）">4、监控与调优（待补充）</h2><p><code>VisualVM</code>, <code>jstat</code>, <code>jstack</code>可以监测元空间的动态，后续将更新这里。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><em>The Java Virtual Machine Specification, Java SE 8 Edition, Oracle</em></li>
<li><a href="http://java-latte.blogspot.sg/2014/03/metaspace-in-java-8.html" target="_blank" rel="external">Metaspace in Java 8</a></li>
<li><a href="http://stackoverflow.com/questions/24074164/what-is-the-use-of-metaspace-in-java-8" target="_blank" rel="external">What is the use of Metaspace in Java 8? - StackOverflow</a></li>
<li><a href="https://blogs.oracle.com/poonam/entry/about_g1_garbage_collector_permanent" target="_blank" rel="external">About G1 Garbage Collector, Permanent Generation and Metaspace</a></li>
<li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a></li>
<li><a href="http://stackoverflow.com/questions/18339707/permgen-elimination-in-jdk-8/22509753#22509753" target="_blank" rel="external">PermGen elimination in JDK 8 - StackOverflow</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Metaspace/">Metaspace</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-java-reflection-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-reflection-2/" class="article-date">
      <time datetime="2015-06-24T16:00:00.000Z" itemprop="datePublished">2015-06-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-reflection-2/">深入解析Java反射（2） - invoke方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>上篇文章中回顾了一下Java反射相关的基础内容。这一节我们来深入研究Method类中的invoke方法，探寻它的奥秘。<br>注:本篇文章的所有源码都基于OpenJDK 1.8。</p>
<hr>
<h1 id="引入">引入</h1><p>即使没有学过反射，大家也一定会见过invoke方法。因为很多方法调用都是靠invoke方法，所以很多异常的抛出都会定位到invoke方法，比如下面的情形大家会很熟悉:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">  at ......</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br></pre></td></tr></table></figure></p>
<p>大家在看到异常抛出时，除了想要排除Bug，是不是同时也对这个神秘的invoke乃至invoke0方法有一些好奇呢？我们下面就来揭开它神秘的面纱，探寻底层的机制。</p>
<h1 id="浅析invoke过程">浅析invoke过程</h1><p>上一篇文章我们讲过，invoke方法用来在运行时动态地调用某个实例的方法。它的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="line">       InvocationTargetException</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们根据invoke方法的实现，将其分为以下几步：</p>
<h2 id="1、权限检查">1、权限检查</h2><p>invoke方法会首先检查AccessibleObject的override属性的值。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。<br>override的值默认是false,表示需要权限调用规则，调用方法时需要检查权限;我们也可以用setAccessible方法设置为true,若override的值为true，表示忽略权限规则，调用方法时无需检查权限（也就是说可以调用任意的private方法，违反了封装）。<br>如果override属性为默认值false，则进行进一步的权限检查：<br>（1）首先用Reflection.quickCheckMemberAccess(clazz, modifiers)方法检查方法是否为public，如果是的话跳出本步；如果不是public方法，那么用Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getCallerClass();</span><br></pre></td></tr></table></figure></p>
<p>在OpenJDK的源码中找到此方法的JNI入口(Reflection.c):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jclass JNICALL <span class="title">Java_sun_reflect_Reflection_getCallerClass__</span></span><br><span class="line"><span class="params">(JNIEnv *env, jclass unused)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_GetCallerClass(env, JVM_CALLER_DEPTH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中JVM_GetCallerClass的源码如下，有兴趣的可以研究一下(位于jvm.cpp):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env, <span class="keyword">int</span> depth))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_GetCallerClass"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pre-JDK 8 and early builds of JDK 8 don't have a CallerSensitive annotation; or</span></span><br><span class="line">  <span class="comment">// sun.reflect.Reflection.getCallerClass with a depth parameter is provided</span></span><br><span class="line">  <span class="comment">// temporarily for existing code to use until a replacement API is defined.</span></span><br><span class="line">  <span class="keyword">if</span> (SystemDictionary::reflect_CallerSensitive_klass() == NULL || depth != JVM_CALLER_DEPTH) &#123;</span><br><span class="line">    Klass* k = thread-&gt;security_get_caller_class(depth);</span><br><span class="line">    <span class="keyword">return</span> (k == NULL) ? NULL : (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Getting the class of the caller frame.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The call stack at this point looks something like this:</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]</span></span><br><span class="line">  <span class="comment">// [1] [ @CallerSensitive API.method                                   ]</span></span><br><span class="line">  <span class="comment">// [.] [ (skipped intermediate frames)                                 ]</span></span><br><span class="line">  <span class="comment">// [n] [ caller                                                        ]</span></span><br><span class="line">  <span class="function">vframeStream <span class="title">vfst</span><span class="params">(thread)</span></span>;</span><br><span class="line">  <span class="comment">// Cf. LibraryCallKit::inline_native_Reflection_getCallerClass</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; !vfst.at_end(); vfst.security_next(), n++) &#123;</span><br><span class="line">    Method* m = vfst.method();</span><br><span class="line">    assert(m != NULL, <span class="string">"sanity"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">// This must only be called from Reflection.getCallerClass</span></span><br><span class="line">      <span class="keyword">if</span> (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) &#123;</span><br><span class="line">        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), <span class="string">"JVM_GetCallerClass must only be called from Reflection.getCallerClass"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// fall-through</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="comment">// Frame 0 and 1 must be caller sensitive.</span></span><br><span class="line">      <span class="keyword">if</span> (!m-&gt;caller_sensitive()) &#123;</span><br><span class="line">        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(<span class="string">"CallerSensitive annotation expected at frame %d"</span>, n));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (!m-&gt;is_ignored_by_security_stack_walk()) &#123;</span><br><span class="line">        <span class="comment">// We have reached the desired frame; return the holder class.</span></span><br><span class="line">        <span class="keyword">return</span> (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></p>
<p>获取了这个Class对象caller后用checkAccess方法做一次快速的权限校验，其实现为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> Object securityCheckCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkAccess</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; clazz, Object obj, <span class="keyword">int</span> modifiers)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (caller == clazz) &#123;  <span class="comment">// 快速校验</span></span><br><span class="line">            <span class="keyword">return</span>;             <span class="comment">// 权限通过校验</span></span><br><span class="line">        &#125;</span><br><span class="line">        Object cache = securityCheckCache;  <span class="comment">// read volatile</span></span><br><span class="line">        Class&lt;?&gt; targetClass = clazz;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; Modifier.isProtected(modifiers)</span><br><span class="line">            &amp;&amp; ((targetClass = obj.getClass()) != clazz)) &#123;</span><br><span class="line">            <span class="comment">// Must match a 2-list of &#123; caller, targetClass &#125;.</span></span><br><span class="line">            <span class="keyword">if</span> (cache <span class="keyword">instanceof</span> Class[]) &#123;</span><br><span class="line">                Class&lt;?&gt;[] cache2 = (Class&lt;?&gt;[]) cache;</span><br><span class="line">                <span class="keyword">if</span> (cache2[<span class="number">1</span>] == targetClass &amp;&amp;</span><br><span class="line">                    cache2[<span class="number">0</span>] == caller) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;     <span class="comment">// ACCESS IS OK</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// (Test cache[1] first since range check for [1]</span></span><br><span class="line">                <span class="comment">// subsumes range check for [0].)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache == caller) &#123;</span><br><span class="line">            <span class="comment">// Non-protected case (or obj.class == this.clazz).</span></span><br><span class="line">            <span class="keyword">return</span>;             <span class="comment">// ACCESS IS OK</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If no return, fall through to the slow path.</span></span><br><span class="line">        slowCheckMemberAccess(caller, clazz, obj, modifiers, targetClass);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先先执行一次快速校验，一旦调用方法的Class正确则权限检查通过。<br>若未通过，则创建一个缓存，中间再进行一堆检查（比如检验是否为protected属性）。<br>如果上面的所有权限检查都未通过，那么将执行更详细的检查，其实现为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keep all this slow stuff out of line:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slowCheckMemberAccess</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; clazz, Object obj, <span class="keyword">int</span> modifiers,</span><br><span class="line">                           Class&lt;?&gt; targetClass)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalAccessException</span><br><span class="line"></span>&#123;</span><br><span class="line">    Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Success: Update the cache.</span></span><br><span class="line">    Object cache = ((targetClass == clazz)</span><br><span class="line">                    ? caller</span><br><span class="line">                    : <span class="keyword">new</span> Class&lt;?&gt;[] &#123; caller, targetClass &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note:  The two cache elements are not volatile,</span></span><br><span class="line">    <span class="comment">// but they are effectively final.  The Java memory model</span></span><br><span class="line">    <span class="comment">// guarantees that the initializing stores for the cache</span></span><br><span class="line">    <span class="comment">// elements will occur before the volatile write.</span></span><br><span class="line">    securityCheckCache = cache;         <span class="comment">// write volatile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大体意思就是，用Reflection.ensureMemberAccess方法继续检查权限，若检查通过就更新缓存，这样下一次同一个类调用同一个方法时就不用执行权限检查了，这是一种简单的缓存机制。由于JMM的happens-before规则能够保证缓存初始化能够在写缓存之前发生，因此两个cache不需要声明为volatile。<br>到这里，前期的权限检查工作就结束了。如果没有通过检查则会抛出异常，如果通过了检查则会到下一步。</p>
<h2 id="2、调用MethodAccessor的invoke方法">2、调用MethodAccessor的invoke方法</h2><p>Method.invoke()实际上并不是自己实现的反射调用逻辑，而是委托给sun.reflect.MethodAccessor来处理。<br>首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。root对象其声明及注释为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> MethodAccessor methodAccessor;</span><br><span class="line"><span class="comment">// For sharing of MethodAccessors. This branching structure is</span></span><br><span class="line"><span class="comment">// currently only two levels deep (i.e., one root Method and</span></span><br><span class="line"><span class="comment">// potentially many Method objects pointing to it.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If this branching structure would ever contain cycles, deadlocks can</span></span><br><span class="line"><span class="comment">// occur in annotation code.</span></span><br><span class="line"><span class="keyword">private</span> Method  root;</span><br></pre></td></tr></table></figure></p>
<p>那么MethodAccessor到底是个啥玩意呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This interface provides the declaration for</span><br><span class="line">    java.lang.reflect.Method.invoke(). Each Method object is</span><br><span class="line">    configured with a (possibly dynamically-generated) class which</span><br><span class="line">    implements this interface.</span><br><span class="line">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Method&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到MethodAccessor是一个接口，定义了invoke方法。分析其Usage可得它的具体实现类有:</p>
<ul>
<li>sun.reflect.DelegatingMethodAccessorImpl</li>
<li>sun.reflect.MethodAccessorImpl</li>
<li>sun.reflect.NativeMethodAccessorImpl</li>
</ul>
<p>第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建；等第一次调用时才新创建MethodAccessor并更新给root，然后调用MethodAccessor.invoke()完成反射调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag"><span class="keyword">NOTE</span></span> that there is no synchronization used here. It is correct</span></span><br><span class="line"><span class="comment">// (though not efficient) to generate more than one MethodAccessor</span></span><br><span class="line"><span class="comment">// for a given Method. However, avoiding synchronization will</span></span><br><span class="line"><span class="comment">// probably make the implementation more scalable.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    MethodAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        methodAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</span><br><span class="line">        setMethodAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到methodAccessor实例由reflectionFactory对象操控生成，它在AccessibleObject下的声明如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reflection factory used by subclasses for creating field,</span></span><br><span class="line"><span class="comment">// method, and constructor accessors. Note that this is called</span></span><br><span class="line"><span class="comment">// very early in the bootstrapping process.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ReflectionFactory reflectionFactory =</span><br><span class="line">    AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> sun.reflect.ReflectionFactory.GetReflectionFactoryAction());</span><br></pre></td></tr></table></figure>
<p>再研究一下sun.reflect.ReflectionFactory类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Permission reflectionFactoryAccessPerm</span><br><span class="line">        = <span class="keyword">new</span> RuntimePermission(<span class="string">"reflectionFactoryAccess"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReflectionFactory soleInstance = <span class="keyword">new</span> ReflectionFactory();</span><br><span class="line">    <span class="comment">// Provides access to package-private mechanisms in java.lang.reflect</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LangReflectAccess langReflectAccess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里设计得非常巧妙</span></span><br><span class="line">    <span class="comment">// "Inflation" mechanism. Loading bytecodes to implement</span></span><br><span class="line">    <span class="comment">// Method.invoke() and Constructor.newInstance() currently costs</span></span><br><span class="line">    <span class="comment">// 3-4x more than an invocation via native code for the first</span></span><br><span class="line">    <span class="comment">// invocation (though subsequent invocations have been benchmarked</span></span><br><span class="line">    <span class="comment">// to be over 20x faster). Unfortunately this cost increases</span></span><br><span class="line">    <span class="comment">// startup time for certain applications that use reflection</span></span><br><span class="line">    <span class="comment">// intensively (but only once per class) to bootstrap themselves.</span></span><br><span class="line">    <span class="comment">// To avoid this penalty we reuse the existing JVM entry points</span></span><br><span class="line">    <span class="comment">// for the first few invocations of Methods and Constructors and</span></span><br><span class="line">    <span class="comment">// then switch to the bytecode-based implementations.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Package-private to be accessible to NativeMethodAccessorImpl</span></span><br><span class="line">    <span class="comment">// and NativeConstructorAccessorImpl</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> noInflation        = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>     inflationThreshold = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这是生成MethodAccessor的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        checkInitted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                generateMethod(method.getDeclaringClass(),</span><br><span class="line">                               method.getName(),</span><br><span class="line">                               method.getParameterTypes(),</span><br><span class="line">                               method.getReturnType(),</span><br><span class="line">                               method.getExceptionTypes(),</span><br><span class="line">                               method.getModifiers());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NativeMethodAccessorImpl acc =</span><br><span class="line">                <span class="keyword">new</span> NativeMethodAccessorImpl(method);</span><br><span class="line">            DelegatingMethodAccessorImpl res =</span><br><span class="line">                <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</span><br><span class="line">            acc.setParent(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** We have to defer full initialization of this class until after</span><br><span class="line">    the static initializer is run since java.lang.reflect.Method's</span><br><span class="line">    static initializer (more properly, that for</span><br><span class="line">    java.lang.reflect.AccessibleObject) causes this class's to be</span><br><span class="line">    run, before the system properties are set up. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkInitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initted) <span class="keyword">return</span>;</span><br><span class="line">        AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// Tests to ensure the system properties table is fully</span></span><br><span class="line">                    <span class="comment">// initialized. This is needed because reflection code is</span></span><br><span class="line">                    <span class="comment">// called very early in the initialization process (before</span></span><br><span class="line">                    <span class="comment">// command-line arguments have been parsed and therefore</span></span><br><span class="line">                    <span class="comment">// these user-settable properties installed.) We assume that</span></span><br><span class="line">                    <span class="comment">// if System.out is non-null then the System class has been</span></span><br><span class="line">                    <span class="comment">// fully initialized and that the bulk of the startup code</span></span><br><span class="line">                    <span class="comment">// has been run.</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (System.out == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// java.lang.System not yet fully initialized</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String val = System.getProperty(<span class="string">"sun.reflect.noInflation"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span> &amp;&amp; val.equals(<span class="string">"true"</span>)) &#123;</span><br><span class="line">                        noInflation = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    val = System.getProperty(<span class="string">"sun.reflect.inflationThreshold"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            inflationThreshold = Integer.parseInt(val);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to parse property sun.reflect.inflationThreshold"</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    initted = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>观察前面的声明部分的注释，我们可以发现一些有趣的东西。就像注释里说的，实际的MethodAccessor实现有两个版本，一个是Java版本，一个是native版本，两者各有特点。初次启动时Method.invoke()和Constructor.newInstance()方法采用native方法要比Java方法快3-4倍，而启动后native方法又要消耗额外的性能而慢于Java方法。也就是说，Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。这是HotSpot的优化方式带来的性能特性，同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。</p>
<p>为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。</p>
<p>研究ReflectionFactory.newMethodAccessor()生产MethodAccessor对象的逻辑，一开始(native版)会生产NativeMethodAccessorImpl和DelegatingMethodAccessorImpl两个对象。<br>DelegatingMethodAccessorImpl的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Delegates its invocation to another MethodAccessorImpl and can</span><br><span class="line">    change its delegate at run time. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;</span><br><span class="line">        setDelegate(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它其实是一个中间层，方便在native版与Java版的MethodAccessor之间进行切换。<br>然后下面就是native版MethodAccessor的Java方面的声明：<br>sun.reflect.NativeMethodAccessorImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Used only for the first few invocations of a Method; afterward,</span><br><span class="line">    switches to bytecode-based implementation */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can't be referred to by name, hence can't be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次NativeMethodAccessorImpl.invoke()方法被调用时，程序调用计数器都会增加1，看看是否超过阈值；一旦超过，则调用MethodAccessorGenerator.generateMethod()来生成Java版的MethodAccessor的实现类，并且改变DelegatingMethodAccessorImpl所引用的MethodAccessor为Java版。后续经由DelegatingMethodAccessorImpl.invoke()调用到的就是Java版的实现了。<br>到这里，我们已经追寻到native版的invoke方法在Java一侧声明的最底层 - invoke0了，下面我们将深入到HotSpot JVM中去研究其具体实现。</p>
<h1 id="寻根溯源_-_在JVM层面探究invoke0方法">寻根溯源 - 在JVM层面探究invoke0方法</h1><p>invoke0方法是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jobject JNICALL <span class="title">Java_sun_reflect_NativeMethodAccessorImpl_invoke0</span></span><br><span class="line"><span class="params">(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_InvokeMethod(env, m, obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>openjdk/hotspot/src/share/vm/prims/jvm.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_InvokeMethod"</span>);</span><br><span class="line">  Handle method_handle;</span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) &#123;</span><br><span class="line">    method_handle = Handle(THREAD, JNIHandles::resolve(method));</span><br><span class="line">    <span class="function">Handle <span class="title">receiver</span><span class="params">(THREAD, JNIHandles::resolve(obj)</span>)</span>;</span><br><span class="line">    <span class="function">objArrayHandle <span class="title">args</span><span class="params">(THREAD, objArrayOop(JNIHandles::resolve(args0)</span>))</span>;</span><br><span class="line">    oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);</span><br><span class="line">    jobject res = JNIHandles::make_local(env, result);</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::should_post_vm_object_alloc()) &#123;</span><br><span class="line">      oop <span class="keyword">ret_t</span>ype = java_lang_reflect_Method::<span class="keyword">return_t</span>ype(method_handle());</span><br><span class="line">      assert(<span class="keyword">ret_t</span>ype != NULL, <span class="string">"sanity check: ret_type oop must not be NULL!"</span>);</span><br><span class="line">      <span class="keyword">if</span> (java_lang_Class::is_primitive(<span class="keyword">ret_t</span>ype)) &#123;</span><br><span class="line">        <span class="comment">// Only for primitive type vm allocates memory for java object.</span></span><br><span class="line">        <span class="comment">// See box() method.</span></span><br><span class="line">        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_StackOverflowError());</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></p>
<p>其关键部分为Reflection::invoke_method:<br>openjdk/hotspot/src/share/vm/runtime/reflection.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) &#123;</span><br><span class="line">  oop mirror             = java_lang_reflect_Method::clazz(method_mirror);</span><br><span class="line">  <span class="keyword">int</span> slot               = java_lang_reflect_Method::slot(method_mirror);</span><br><span class="line">  <span class="keyword">bool</span> override          = java_lang_reflect_Method::override(method_mirror) != <span class="number">0</span>;</span><br><span class="line">  <span class="function">objArrayHandle <span class="title">ptypes</span><span class="params">(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)</span>))</span>;</span><br><span class="line"></span><br><span class="line">  oop <span class="keyword">return_t</span>ype_mirror = java_lang_reflect_Method::<span class="keyword">return_t</span>ype(method_mirror);</span><br><span class="line">  BasicType rtype;</span><br><span class="line">  <span class="keyword">if</span> (java_lang_Class::is_primitive(<span class="keyword">return_t</span>ype_mirror)) &#123;</span><br><span class="line">    rtype = <span class="keyword">basic_type_mirror_to_basic_t</span>ype(<span class="keyword">return_t</span>ype_mirror, CHECK_NULL);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rtype = T_OBJECT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">instanceKlassHandle <span class="title">klass</span><span class="params">(THREAD, java_lang_Class::as_Klass(mirror)</span>)</span>;</span><br><span class="line">  Method* m = klass-&gt;method_with_idnum(slot);</span><br><span class="line">  <span class="keyword">if</span> (m == NULL) &#123;</span><br><span class="line">    THROW_MSG_0(vmSymbols::java_lang_InternalError(), <span class="string">"invoke"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">methodHandle <span class="title">method</span><span class="params">(THREAD, m)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> invoke(klass, method, receiver, override, ptypes, rtype, args, <span class="keyword">true</span>, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面又会涉及到Java的对象模型(klass和oop)，以后继续补充。(<strong>留坑</strong>)</p>
<h1 id="寻根溯源_-_Java版的实现">寻根溯源 - Java版的实现</h1><p>Java版MethodAccessor的生成使用MethodAccessorGenerator实现，由于代码太长，这里就不贴代码了，只贴一下开头的注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Generator for sun.reflect.MethodAccessor and</span><br><span class="line">    sun.reflect.ConstructorAccessor objects using bytecodes to</span><br><span class="line">    implement reflection. A java.lang.reflect.Method or</span><br><span class="line">    java.lang.reflect.Constructor object can delegate its invoke or</span><br><span class="line">    newInstance method to an accessor using native code or to one</span><br><span class="line">    generated by this class. (Methods and Constructors were merged</span><br><span class="line">    together in this class to ensure maximum code sharing.) */</span></span><br></pre></td></tr></table></figure></p>
<p>这里运用了asm动态生成字节码技术（sun.reflect.ClassFileAssembler)，原理比较复杂，后面讲到AOP要用到asm技术的时候再深入了解一下吧。</p>
<h1 id="本篇总结">本篇总结</h1><p>简单地画了个图表示invoke方法的过程，日后再更时序图：</p>
<p><img src="http://img.blog.csdn.net/20150626130739796" alt="invoke方法的过程"></p>
<h1 id="番外篇">番外篇</h1><ol>
<li>MagicAccessorImpl是什么鬼？</li>
</ol>
<p>原本Java的安全机制使得不同类之间不是任意信息都可见，但JDK里面专门设了个MagicAccessorImpl标记类开了个后门来允许不同类之间信息可以互相访问（由JVM管理）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** &lt;P&gt; MagicAccessorImpl (named for parity with FieldAccessorImpl and</span><br><span class="line">    others, not because it actually implements an interface) is a</span><br><span class="line">    marker class in the hierarchy. All subclasses of this class are</span><br><span class="line">    "magically" granted access by the VM to otherwise inaccessible</span><br><span class="line">    fields and methods of other classes. It is used to hold the code</span><br><span class="line">    for dynamically-generated FieldAccessorImpl and MethodAccessorImpl</span><br><span class="line">    subclasses. (Use of the word "unsafe" was avoided in this class's</span><br><span class="line">    name to avoid confusion with &#123;<span class="doctag">@link</span> sun.misc.Unsafe&#125;.) &lt;/P&gt;</span><br><span class="line"></span><br><span class="line">    &lt;P&gt; The bug fix for 4486457 also necessitated disabling</span><br><span class="line">    verification for this class and all subclasses, as opposed to just</span><br><span class="line">    SerializationConstructorAccessorImpl and subclasses, to avoid</span><br><span class="line">    having to indicate to the VM which of these dynamically-generated</span><br><span class="line">    stub classes were known to be able to pass the verifier. &lt;/P&gt;</span><br><span class="line"></span><br><span class="line">    &lt;P&gt; Do not change the name of this class without also changing the</span><br><span class="line">    VM's code. &lt;/P&gt; */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicAccessorImpl</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>@CallerSensitive注解又是什么鬼？</li>
</ol>
<p>详见：<a href="http://openjdk.java.net/jeps/176" target="_blank" rel="external">JEP 176: Mechanical Checking of Caller-Sensitive Methods</a></p>
<blockquote>
<p>Summary: Improve the security of the JDK’s method-handle implementation by replacing the existing hand-maintained list of caller-sensitive methods with a mechanism that accurately identifies such methods and allows their callers to be discovered reliably.</p>
</blockquote>
<p>JDK 1.8才引进了这个注解，因此在老版本的反射实现里并没有这个玩意。这是它的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A method annotated <span class="doctag">@CallerSensitive</span> is sensitive to its calling class,</span><br><span class="line"> * via &#123;<span class="doctag">@link</span> sun.reflect.Reflection#getCallerClass Reflection.getCallerClass&#125;,</span><br><span class="line"> * or via some equivalent.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> John R. Rose</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>(&#123;METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> CallerSensitive &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简而言之，用<code>@CallerSensitive</code>注解修饰的方法从一开始就知道具体调用它的对象，这样就不用再经过一系列的检查才能确定具体调用它的对象了。它实际上是调用<code>sun.reflect.Reflection.getCallerClass</code>方法。</p>
<p>Reflection类位于调用栈中的0帧位置，<code>sun.reflect.Reflection.getCallerClass()</code>方法返回调用栈中从0帧开始的第x帧中的类实例。该方法提供的机制可用于确定调用者类，从而实现“感知调用者（Caller Sensitive）”的行为，即允许应用程序根据调用类或调用栈中的其它类来改变其自身的行为。</p>
<hr>
<h1 id="Reference">Reference</h1><ul>
<li><a href="http://openjdk.java.net/jeps/176" target="_blank" rel="external">JEP 176: Mechanical Checking of Caller-Sensitive Methods</a></li>
<li><a href="http://stackoverflow.com/questions/22626808/what-does-the-sun-reflect-callersensitive-annotation-mean" target="_blank" rel="external">StackOverflow上关于@CallerSensitive的回答</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/548536" target="_blank" rel="external">关于反射调用方法的一个log (R大的一篇文章)</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reflection/">Reflection</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-java-reflection-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-reflection-1/" class="article-date">
      <time datetime="2015-06-23T16:00:00.000Z" itemprop="datePublished">2015-06-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-reflection-1/">深入解析Java反射（1） - 基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>因为本人最近正筹备<a href="http://www.sczyh30.com/samsara">Samsara</a>框架的开发，而其中的IOC部分非常依靠反射，因此趁这个机会来总结一下关于Java反射的一些知识。本篇为基本篇，基于JDK 1.8。</p>
<hr>
<h2 id="一、回顾：什么是反射？">一、回顾：什么是反射？</h2><p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>Oracle官方对反射的解释是</p>
<blockquote>
<p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p>
</blockquote>
<p>&emsp;简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。<br>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br>&emsp;反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java反射框架主要提供以下功能：</p>
<ul>
<li>1.在运行时判断任意一个对象所属的类；</li>
<li>2.在运行时构造任意一个类的对象；</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>4.在运行时调用任意一个对象的方法<h5 id="重点：是运行时而不是编译时">重点：<strong>是运行时而不是编译时</strong></h5></li>
</ul>
<h2 id="二、反射的主要用途">二、反射的主要用途</h2><p>&emsp;很多人都认为反射在实际的Java开发应用中并不广泛，其实不然。<br>&emsp;当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。<br>&emsp;<strong>反射最重要的用途就是开发各种通用框架。</strong><br>&emsp;很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。<br>&emsp;举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"login"</span></span><br><span class="line">               <span class="attribute">class</span>=<span class="value">"org.ScZyhSoft.test.action.SimpleLoginAction"</span></span><br><span class="line">               <span class="attribute">method</span>=<span class="value">"execute"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">result</span>&gt;</span>/shop/shop-index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"error"</span>&gt;</span>login.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">action</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。<br>——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。<br>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
<h2 id="三、反射的基本运用">三、反射的基本运用</h2><p>上面我们提到了反射可以用于判断任意对象所属的类，获得Class对象，构造任意一个对象以及调用一个对象。这里我们介绍一下基本反射功能的实现(反射相关的类一般都在java.lang.relfect包里)。</p>
<h4 id="1、获得Class对象">1、获得Class对象</h4><p>方法有三种<br>(1)使用Class类的forName静态方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">``` </span><br><span class="line">在JDBC开发中常用此方法加载数据库驱动:</span><br><span class="line">```java</span><br><span class="line"> Class.forName(driver);</span><br></pre></td></tr></table></figure></p>
<p>(2)直接获取某一个对象的class，比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure></p>
<p>(3)调用某个对象的getClass()方法,比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure></p>
<h4 id="2、判断是否为某个类的实例">2、判断是否为某个类的实例</h4><p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、创建实例">3、创建实例</h4><p>通过反射来生成对象主要有两种方式。<br>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure></p>
<p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></p>
<h4 id="4、获取方法">4、获取方法</h4><p>获取某个Class对象的方法集合，主要有以下几个方法：<br>getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p>
<p>getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p>
<p>getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure></p>
<p>只是这样描述的话可能难以理解，我们用例子来理解这三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ScZyhSoft.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">	        Class&lt;?&gt; c = methodClass.class;</span><br><span class="line">	        Object object = c.newInstance();</span><br><span class="line">	        Method[] methods = c.getMethods();</span><br><span class="line">	        Method[] declaredMethods = c.getDeclaredMethods();</span><br><span class="line">	        <span class="comment">//获取methodClass类的add方法</span></span><br><span class="line">	        Method method = c.getMethod(<span class="string">"add"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">	        <span class="comment">//getMethods()方法获取的所有方法</span></span><br><span class="line">	        System.out.println(<span class="string">"getMethods获取的方法："</span>);</span><br><span class="line">	        <span class="keyword">for</span>(Method m:methods)</span><br><span class="line">	            System.out.println(m);</span><br><span class="line">	        <span class="comment">//getDeclaredMethods()方法获取的所有方法</span></span><br><span class="line">	        System.out.println(<span class="string">"getDeclaredMethods获取的方法："</span>);</span><br><span class="line">	        <span class="keyword">for</span>(Method m:declaredMethods)</span><br><span class="line">	            System.out.println(m);</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序运行的结果如下:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getMethods获取的方法：</span><br><span class="line">public int org<span class="class">.ScZyhSoft</span><span class="class">.common</span><span class="class">.methodClass</span><span class="class">.add</span>(int,int)</span><br><span class="line">public int org<span class="class">.ScZyhSoft</span><span class="class">.common</span><span class="class">.methodClass</span><span class="class">.sub</span>(int,int)</span><br><span class="line">public final void java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.wait</span>() throws java<span class="class">.lang</span><span class="class">.InterruptedException</span></span><br><span class="line">public final void java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.wait</span>(long,int) throws java<span class="class">.lang</span><span class="class">.InterruptedException</span></span><br><span class="line">public final native void java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.wait</span>(long) throws java<span class="class">.lang</span><span class="class">.InterruptedException</span></span><br><span class="line">public boolean java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.equals</span>(java<span class="class">.lang</span><span class="class">.Object</span>)</span><br><span class="line">public java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.toString</span>()</span><br><span class="line">public native int java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.hashCode</span>()</span><br><span class="line">public final native java<span class="class">.lang</span><span class="class">.Class</span> java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.getClass</span>()</span><br><span class="line">public final native void java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.notify</span>()</span><br><span class="line">public final native void java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.notifyAll</span>()</span><br><span class="line">getDeclaredMethods获取的方法：</span><br><span class="line">public int org<span class="class">.ScZyhSoft</span><span class="class">.common</span><span class="class">.methodClass</span><span class="class">.add</span>(int,int)</span><br><span class="line">public int org<span class="class">.ScZyhSoft</span><span class="class">.common</span><span class="class">.methodClass</span><span class="class">.sub</span>(int,int)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，通过getMethods()获取的方法可以获取到父类的方法,比如java.lang.Object下定义的各个方法。</p>
<h4 id="5、获取构造器信息">5、获取构造器信息</h4><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br></pre></td></tr></table></figure></p>
<p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例~</p>
<h4 id="6、获取类的成员变量（字段）信息">6、获取类的成员变量（字段）信息</h4><p>主要是这几个方法，在此不再赘述：<br><em>getFiled</em>: 访问公有的成员变量<br><em>getDeclaredField</em>：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）</p>
<h4 id="7、调用方法">7、调用方法</h4><p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span></span><br></pre></td></tr></table></figure></p>
<p>下面是一个实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; klass = methodClass.class;</span><br><span class="line">        <span class="comment">//创建methodClass的实例</span></span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        <span class="comment">//获取methodClass类的add方法</span></span><br><span class="line">        Method method = klass.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></span><br><span class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于invoke()方法的详解，后面我会专门写一篇文章来深入解析invoke的过程。</p>
<h4 id="8、利用反射创建数组">8、利用反射创建数组</h4><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        Object array = Array.newInstance(cls,<span class="number">25</span>);</span><br><span class="line">        <span class="comment">//往数组里添加内容</span></span><br><span class="line">        Array.set(array,<span class="number">0</span>,<span class="string">"hello"</span>);</span><br><span class="line">        Array.set(array,<span class="number">1</span>,<span class="string">"Java"</span>);</span><br><span class="line">        Array.set(array,<span class="number">2</span>,<span class="string">"fuck"</span>);</span><br><span class="line">        Array.set(array,<span class="number">3</span>,<span class="string">"Scala"</span>);</span><br><span class="line">        Array.set(array,<span class="number">4</span>,<span class="string">"Clojure"</span>);</span><br><span class="line">        <span class="comment">//获取某一项的内容</span></span><br><span class="line">        System.out.println(Array.get(array,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span><br><span class="line">        <span class="keyword">throws</span> NegativeArraySizeException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>而newArray()方法是一个Native方法，它在Hotspot JVM里的具体实现我们后边再研究，这里先把源码贴出来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newArray</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span><br><span class="line">        <span class="keyword">throws</span> NegativeArraySizeException</span>;</span><br></pre></td></tr></table></figure></p>
<p>源码目录:openjdk\hotspot\src\share\vm\runtime\reflection.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) &#123;</span><br><span class="line">  <span class="keyword">if</span> (element_mirror == NULL) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_NullPointerException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_NegativeArraySizeException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (java_lang_Class::is_primitive(element_mirror)) &#123;</span><br><span class="line">    Klass* tak = <span class="keyword">basic_type_mirror_t</span>o_arrayklass(element_mirror, CHECK_NULL);</span><br><span class="line">    <span class="keyword">return</span> TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Klass* k = java_lang_Class::as_Klass(element_mirror);</span><br><span class="line">    <span class="keyword">if</span> (k-&gt;oop_is_array() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) &#123;</span><br><span class="line">      THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oopFactory::new_objArray(k, length, THREAD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，Array类的set()和get()方法都为Native方法，在HotSpot JVM里分别对应Reflection::array_set和Reflection::array_get方法，这里就不详细解析了。</p>
<h2 id="四、反射的一些注意事项（待补充）">四、反射的一些注意事项（待补充）</h2><p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。<br>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。<br><img src="http://img.my.csdn.net/uploads/201508/02/1438529905_8952.jpg" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reflection/">Reflection</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-jvm-memory" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-memory/" class="article-date">
      <time datetime="2015-06-23T16:00:00.000Z" itemprop="datePublished">2015-06-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-memory/">深入探究JVM | Java的内存区域解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Java 虚拟机在执行Java程序的时候会把它管理的内存区域划为几部分，这一节我们就来解析一下Java的内存区域。</p>
<hr>
<p>有的人把JVM管理的内存简单地分为堆内存和栈内存，这样分未免有些太肤浅了。<br>Java的内存区域主要分为五部分：</p>
<ul>
<li>程序计数器(PC)</li>
<li>虚拟机栈(JVM Stack)</li>
<li>本地方法栈(Native Method Stack)</li>
<li>Java 堆内存(Java Heap)</li>
<li>方法区(Method Area)</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150626182021585" alt="Java内存区域"><br>（图转自网络）</p>
<p>下面我们来解析这几个区域。</p>
<h2 id="程序计数器">程序计数器</h2><p>相信学过计算机组成原理的人都知道，CPU内部的寄存器中就包含一个程序计数器（x86下为eip寄存器,ARM下为R15寄存器），存放程序执行的下一条指令地址。在程序开始执行前，将程序指令序列的起始地址，即程序的第一条指令所在的内存单元地址送入PC，CPU按照PC的地址从内存中读取第一条指令。每一条指令执行时，CPU会自动修改PC的量至下一条指令的地址，指令之间的跳转离不开PC。JVM内存中的程序计数器也是这样的作用，它储存JVM当前执行bytecode的地址。</p>
<p>Java虚拟机允许多个线程同时执行指令。如果有多个线程正在执行指令，那么每个线程都会有一个程序计数器，它是线程私有的。在任意时刻，一个线程只允许执行一个方法的代码。每当执行到一条Java方法的指令时，程序计数器保存当前执行字节码的地址；若执行的为native方法，则PC的值为undefined。</p>
<h2 id="Java_虚拟机栈">Java 虚拟机栈</h2><p>Java虚拟机栈也是线程私有的，每一条线程都拥有自己私有的Java 虚拟机栈，它与线程同时创建。它描述了Java方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong>，用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。每一个方法从调用直至完成的过程，都对应一个栈帧从入栈到出栈的过程。关于栈帧详细的内容在后边复习虚拟机字节码执行引擎的时候再说吧。<br>Java 虚拟机栈在方法调用和返回中也扮演了很重要的角色。因为除了栈帧的入栈和出栈之外，Java虚拟机栈不会再受其它因素的影响，因此栈帧可在<strong>系统的堆</strong>上分配内存（<strong>注意</strong>，是系统的Heap而不是Java Heap）。Java虚拟机栈所使用的内存不需要保证是连续的。</p>
<h2 id="本地方法栈">本地方法栈</h2><p>本地方法栈和Java虚拟机栈的作用相似，Java虚拟机栈执行的是字节码，而本地方法栈执行的是native方法。本地方法栈使用<strong>传统的栈</strong>（C Stack）来支持native方法。在HotSpot JVM中Java虚拟机栈和本地方法栈合二为一。</p>
<h2 id="Java_堆">Java 堆</h2><p>在JVM中，Java 堆是可供各线程共享的运行时内存区域，是Java 虚拟机所管理的内存区域中最大的一块。此区域非常重要，<strong>几乎所有的对象实例和数组实例都要在Java堆上分配</strong>，但随着JIT编译器及逃逸分析技术的发展，也可能会被优化为栈上分配，高大上。。。）。同时，Java 堆也是发生GC收集的主要区域。<br>从内存回收的角度来看，它可以分为<strong>新生代</strong>和<strong>老年代</strong>，再细分可以分为Eden Space,From Survivor Space,To Survivor Space区域。Java堆的容量可以是固定的，也可以随着需要来扩展，并且在用不到的时候自动收缩。</p>
<h2 id="方法区">方法区</h2><p>方法区是线程共享的，它储存了<strong>每一个类的结构信息</strong>，比如运行时常量池（runtime constant pool）、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些初始化的时候用到的特殊方法。<strong>方法区是堆的逻辑部分。</strong><br>在JDK1.7及以前的HotSpot JVM中，方法区位于<em>永久代</em>（Permanent Generation，<em>PermGen</em>）中。由于永久代内可能会发生内存泄露或溢出等问题而导致的<em>java.lang.OutOfMemoryError: PermGen </em>，JEP小组从JDK1.7开始就筹划移除永久代（<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a>），并且在JDK 1.7中把字符串常量，符号引用等移出了永久代。到了Java 8，永久代被彻底地移出了JVM，取而代之的是<em>元空间</em>（Metaspace）：</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.</p>
</blockquote>
<p>所以从Java 8开始，方法区被移至 <em>Metaspace</em> 内。有关Metaspace的相关总结，见下一篇文章。</p>
<h2 id="运行时常量池">运行时常量池</h2><p>运行时常量池是class文件中每一个类或接口的常量池表的运行时表示形式，是方法区的一部分。它包括了若干种不同的常量。常量池表存放<strong>编译器生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池具有动态性，运行期间也可以将新的量放到运行时常量池中，典型的应用是String类的intern方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>JDK 1.7开始，字符串常量和符号引用等就被移出永久代：</p>
<ul>
<li>符号引用迁移至系统堆内存(<em>Native Heap</em>)</li>
<li>字符串字面量迁移至Java堆(<em>Java Heap</em>)</li>
</ul>
<p><strong>下一篇文章我将会总结Java 8中的Metaspace相关知识</strong>。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》，周志明 著</li>
<li><a href="http://stackoverflow.com/questions/24074164/what-is-the-use-of-metaspace-in-java-8" target="_blank" rel="external">What is the use of Metaspace in Java 8? - StackOverflow</a></li>
<li><a href="https://blogs.oracle.com/poonam/entry/about_g1_garbage_collector_permanent" target="_blank" rel="external">About G1 Garbage Collector, Permanent Generation and Metaspace</a></li>
<li><em>The Java Virtual Machine Specification, Java SE 8 Edition, Oracle</em></li>
<li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存区域/">内存区域</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-docker-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Architecture/docker-tutorial/" class="article-date">
      <time datetime="2015-06-08T16:12:36.000Z" itemprop="datePublished">2015-06-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Architecture/docker-tutorial/">Docker入门学习札记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>很早之前就听说过Docker，但一直木有实践过。前一阵子参加OSC的源创会时，里面嘉宾讲的东西提到了Docker，感觉Docker是一个很有意义的工具，于是就学习了一下它的基本用法，在此总结一下。</p>
<p>以我的理解，Docker是一种虚拟化容器，这个容器里可以运行各种程序，是一种轻量级的虚拟化技术，使用Golang编写。它与传统的虚拟化技术（KVM和Xen）的区别是，Docker容器是操作系统层面上的虚拟化（<strong>内核级</strong>），基于LXC技术，直接服用本地操作系统，而传统的虚拟化技术则是从硬件方面进行虚拟化。它的好处是，启动特别快，而且对系统资源的利用率较高，一台机器上可以运行很多Docker容器，而且因为Docker非常轻量，它为快速部署提供了很好的技术支持。并且Docker引入了版本控制的思想，可以更好地持续构建和部署。</p>
<p>下面总结一下Docker的基本用法：</p>
<h2 id="安装">安装</h2><p>用apt-get或者yum安装都是坑，基本上都不是最新版本的。要安装还是用官方的命令安装：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL http<span class="variable">s:</span>//<span class="built_in">get</span>.docker.<span class="keyword">com</span>/ | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>不过由于Docker的安装文件存放在Amazon S3上，会间接性抽风，因此最好找个国内的源。</p>
<p>（2015-7 补充：DaoCloud是不错的选择，服务很好）</p>
<h2 id="容器与镜像">容器与镜像</h2><p>Docker容器可以理解为运行在沙盒里的进程。</p>
<p>通俗地讲，镜像（images）相当于一个类，而容器（container）相当于类的一个实例。容器可以不断地被修改，并通过commit化为一个镜像。</p>
<h2 id="基本命令">基本命令</h2><p>主要有：</p>
<h3 id="Docker信息">Docker信息</h3><p>查看Docker版本：<code>docker version</code><br>登录至远程库：<code>docker login</code></p>
<h3 id="镜像操作">镜像操作</h3><p>列出镜像列表：<code>docker images</code><br>删除镜像：<code>docker rmi [id]</code><br>搜索镜像：<code>docker search [name]</code><br>从远程拉取镜像：<code>docker pull [name]:[tag]</code><br>将镜像发布至远程：<code>docker push [name]</code></p>
<h3 id="容器运行"><strong>容器运行</strong></h3><p>容器运行用<code>docker run</code>命令，它有一些详细的参数很有用，比如：<br>以交互模式启动容器centos:latest : <code>docker run -i - t centos:latest /bin/bash</code><br><code>-i</code>表示支持输入，<code>-t</code>表示命令行交互。<br>以后台模式运行，并进行端口映射: <code>docker run -d -p 8080:8080 sczyh30/tomcat:v1 /start.sh</code><br><code>-d</code>表示daemon，即以后台方式运行。<code>-p</code>表示端口映射。<br>这里用的时候有个比较fucking的地方，如果运行容器的时候相应的命令不阻塞，那么容器会自动结束运行（比如resin）。看来以后运行命令要加个阻塞的命令咯~<br>另外对于在容器里自动执行apt-get命令时，一定要加上-y，否则容器虽然进入交互模式但却无法响应，运行完即退出。</p>
<h3 id="容器管理">容器管理</h3><p>查看正在运行的容器：<code>docker ps</code><br>查看所有容器：<code>docker ps -a</code><br>删除容器：<code>docker rm [name/id]</code><br>删除所有容器：<code>docker rm &#39;docker ps -a -q&#39;</code><br>停止、启动、杀死一个容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> stop [Name/ID]</span><br><span class="line"><span class="variable">$docker</span> start [Name/ID]</span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">kill</span> [Name/ID]</span><br></pre></td></tr></table></figure></p>
<p>从容器中读取日志：<code>docker logs [Name/ID]</code><br>列出更改项：<code>docker diff [Name/ID]</code><br>从容器中拷贝文件至本机：<code>docker cp ID:/container_path to_path</code><br>附加到一个运行的容器上：<code>docker attach [ID]</code></p>
<h2 id="容器的简单构建">容器的简单构建</h2><p>通过命令操作来部署容器显然很麻烦，所以通过Dockerfile进行自动化容器构建是非常方便的。<br>这里我自己写了一个简单的Dockerfile来练练手，这是一个用于构建Hexo博客的Dockerfile：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构建的镜像基础</span></span><br><span class="line"><span class="built_in">FROM</span> node:slim</span><br><span class="line"><span class="comment">#维护者</span></span><br><span class="line"><span class="built_in">MAINTAINER</span> sczyh30 root@sczyh30.com</span><br><span class="line"><span class="comment">#执行命令用RUN，注意要遇到需要交互的地方加-y</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y git ssh-client ca-certificates --no-install-recommends \</span><br><span class="line">    &amp;&amp; rm -r /var/lib/apt/lists/*</span><br><span class="line"></span><span class="comment">#更改时区</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash"><span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone \</span><br><span class="line">    &amp;&amp; dpkg-reconfigure <span class="operator">-f</span> noninteractive tzdata</span><br><span class="line"></span><span class="comment">#安装hexo</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">npm install hexo-cli -g</span><br><span class="line"></span><span class="comment">#初始化</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash"><span class="built_in">cd</span> / &amp;&amp; hexo init blog &amp;&amp; <span class="built_in">cd</span> blog &amp;&amp; npm install</span><br><span class="line"></span><span class="comment">#设定默认工作目录</span></span><br><span class="line"><span class="built_in">WORKDIR</span> <span class="bash">/blog</span><br><span class="line"></span><span class="comment">#设定暴露端口</span></span><br><span class="line"><span class="built_in">EXPOSE</span> <span class="number">4000</span></span><br><span class="line"><span class="comment">#设定容器运行时执行的命令，只能有一条，若多条则执行最后一条</span></span><br><span class="line">CMD hexo s</span><br></pre></td></tr></table></figure></p>
<p>然后在此目录执行构建：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t sczyh30/simple_<span class="built_in">test</span>:v1 .</span><br></pre></td></tr></table></figure></p>
<p>.表示在当前目录构建<br>docker build的一些参数：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-no-cache=<span class="keyword">false</span> <span class="constant">Do</span> <span class="keyword">not</span> use cache <span class="keyword">when</span> building the image</span><br><span class="line"></span>     -<span class="ruby">q, --quiet=<span class="keyword">false</span> <span class="constant">Suppress</span> the verbose output generated by the containers</span><br><span class="line"></span>     -<span class="ruby">-rm=<span class="keyword">true</span> <span class="constant">Remove</span> intermediate containers after a successful build</span><br><span class="line"></span>     -<span class="ruby">t, --tag=<span class="string">""</span> <span class="constant">Repository</span> name (<span class="keyword">and</span> optionally a tag) to be applied to the resulting image <span class="keyword">in</span> <span class="keyword">case</span> of success</span></span><br></pre></td></tr></table></figure></p>
<p>执行后就会按照Dockerfile的内容进行构建，过几分钟构建成功，用docker run运行一下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="operator">-d</span> -p <span class="number">80</span>:<span class="number">4000</span> sczyh30/simple_<span class="built_in">test</span>:v1</span><br></pre></td></tr></table></figure></p>
<p>运行成功~在docker ps里可以看到容器已成功运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS              PORTS                  NAMES</span><br><span class="line"><span class="number">45782259</span>f2c3        sczyh30/simple_<span class="built_in">test</span>:v1     <span class="string">"/bin/sh -c 'hexo s'"</span>   <span class="number">2</span> minutes ago        Up <span class="number">2</span> minutes         <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">80</span>-&gt;<span class="number">4000</span>/tcp   trusting_ramanujan</span><br></pre></td></tr></table></figure></p>
<p>在浏览器中打开，一个简单的Hexo已经搭好咯~</p>
<p>总结一下，Dockerfile非常方便，以后用它构建容器进行集群部署貌似是不错的选择呢~<br>后面将进行更多的关于Docker的实践。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Architecture/">Architecture</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟化/">虚拟化</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-game-dev-ue4ce3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Develop/game-dev-ue4ce3/" class="article-date">
      <time datetime="2015-03-17T16:12:36.000Z" itemprop="datePublished">2015-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Develop/game-dev-ue4ce3/">UE4/CE3游戏开发总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>记录我在2015.1 - 2015.3用Unreal Engine 4和CryEngine 3的简单体验~（仅为体验，不涉及具体开发）</p>
<h2 id="Prolouge">Prolouge</h2><p>UE4和CE3是游戏界中两大游戏引擎元老呀~两个游戏引擎都非常强大，广泛用于大型游戏的开发（像寒霜3、RAGE之类的引擎也是非常牛，但无奈只供内部使用，我们木有办法去体验开发的过程。。）这次寒假便体验了一下这两大引擎开发的魅力~而且3月份虚幻4引擎宣布开源，这真是喜大普奔呀！想研究游戏引擎的话可以看UE4的源代码了话说UE4的代码写的非常规范，不像传说中的CE3的代码风格凌乱（虽然性能比UE4好，代码风格这取决于公司的风格吧）<br>先来UE4吧~</p>
<h2 id="UE4使用体验">UE4使用体验</h2><p>UE4相比Unity而言真是复杂太多了，从各种组件和编辑器上就能看出。Unity还要自己写大气散射，UE4的组件里直接就有，而且可以根据需求自定义，真方便~不过每一次改动Map都要重新烘焙一次光照，组件多了会很慢。。</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-06.jpg" alt="部分组件"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-10.jpg" alt="编辑器界面"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-07.jpg" alt="一个虚拟现实的Demo"></p>
<p>体验了一番材质编辑器（Material Designer），非常高级（不是美工不会玩），而且翻译很有问题（Normal本该翻译成法线结果翻译成正常，然后我就愉快的把正常的贴图贴到了法线贴图通道上，然后。。。就没有然后了。。调成英文才发现不对劲。。。官方也玩机翻呀。。）</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-03.jpg" alt="这是自己搓的一个材质"></p>
<p>下面是系统自带的一个材质的一部分配置，注意是一个材质！！碉堡了。</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-08.jpg" alt="系统自带的一个材质 - 冰山一角"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-04.jpg" alt="系统自带材质 - 冰山一角"></p>
<p>UE4提供了可视化编程脚本 Blueprint（蓝图），可以很方便的通过拖拽来完成一些功能，甚至可以用Blueprint完成整个游戏的开发，不需要写代码。（感觉很适合美工诶。。掌握触发器相关蓝图，做个虚拟现实Demo不成问题）至于编程，UE4终于抛弃了UnrealScript，投向了C++的怀抱(C++大法好！)</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-02.jpg" alt="爆炸效果模拟蓝图"></p>
<p>贴图精度高了，不加法线贴图，立体感也很强：</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-05.jpg" alt="对比图"></p>
<p>UE4特别适合做虚拟现实，如果美工给力，场景很真实，再自己搓个AI系统，做出一小个真实世界也是很有可能的~</p>
<p>这是一个虚拟现实的实例：</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-UE4Editor%202015-03-08%2020-15-01-24.png" alt="超级虚拟现实"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-UE4Editor%202015-03-08%2020-16-24-68.png" alt="超级虚拟现实"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-UE4Editor%202015-03-08%2020-16-34-74.png" alt="超级虚拟现实"></p>
<p>总之，UE4的各种特效做的特别好，再配上高精度的材质，智能的脚本，好的创意，细致的优化，定能用UE4做出一款好游戏。而且UE4开源，可以根据自己的需要定制引擎，这一点是CE3无法比拟的。（除非有钱，花几百万买下CE3源码，有这钱还不如自己研发一套呢。。）</p>
<p>由于接下来Web方面有任务，UE4的学习就告一段落咯~以后有机会做个虚拟现实系统还是很好的~</p>
<h2 id="CE3使用体验">CE3使用体验</h2><p>CE3的Editor就更强大了，各种特效、脚本设置满天飞，连一个昼夜循环的系统都做得非常心细，不得不说CE3在各方面非常强大。由于这玩意对电脑要求太高，怕把显卡烧了，因此最后就搓了搓demo，玩了玩系统自带的sample，体验了一把以后老老实实继续用UE4和U3D了（逃</p>
<p>CE3的资料甚少，学起来还是有些费事的，只好自己乱捣鼓着玩。</p>
<p>对于CE3的编程，貌似是Flowgraph(FG,类似于虚幻4的Blueprint)，扩展可以用C++、C#和lua，具体的不太了解。。</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ce3-01.png" alt="超级CE3"><br>研究Sample的时候，被它的各种控制组件惊呆了，各种分工明确，非常便于开发（没敢改组件，怕改坏了）</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ce3-02.png" alt="一个完整sample的各种控制"><br><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ce3-03.png" alt="水面效果"></p>
<p>总之，CE3非常强大，但难度系数也很高，对硬件要求也很高。做大型游戏可以用，要不然授权费太高受不了。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CE3/">CE3</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Engine/">Engine</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Game/">Game</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UE4/">UE4</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/7/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2016 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30.
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>