<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="sczyh30" />


    
    


<meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「浮生若梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/page/8/index.html">
<meta property="og:site_name" content="「浮生若梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「浮生若梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="「浮生若梦」 - sczyh30&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>「浮生若梦」 - sczyh30&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="http://7xkkgd.com1.z0.glb.clouddn.com/blog-default-lambda-avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMQP/">AMQP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/APT/">APT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Akka/">Akka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-14/">C++ 14</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/">CAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CE3/">CE3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPS/">CPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/">Cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Category-Theory/">Category Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Continuation/">Continuation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DI/">DI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Engine/">Engine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Euterpea/">Euterpea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Loop/">Event Loop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GDB/">GDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game/">Game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC/">JUC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Klass-oop/">Klass-oop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda-Calculus/">Lambda Calculus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIDI/">MIDI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mathematical-Logic/">Mathematical Logic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metaspace/">Metaspace</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netflix-Hystrix/">Netflix Hystrix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-Model/">Object Model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PLT/">PLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Play-Framework/">Play Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quorum/">Quorum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reflection/">Reflection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheme/">Scheme</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slick/">Slick</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sort/">Sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Summary/">Summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Class/">Type Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Lambda/">Type Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-System/">Type System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Theory/">Type Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UE4/">UE4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中间件/">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云服务/">云服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存区域/">内存区域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式计算/">分布式计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息系统/">消息系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/滑动窗口/">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程安全/">线程安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/限流降级/">限流降级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高可用架构/">高可用架构</a></li></ul>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Distributed System/Deep Learning/PLT</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="http://7xkkgd.com1.z0.glb.clouddn.com/blog-default-lambda-avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-jvm-gc-hotspot-implements" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-gc-hotspot-implements/" class="article-date">
      <time datetime="2015-07-07T16:00:00.000Z" itemprop="datePublished">2015-07-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-gc-hotspot-implements/">深入探究JVM | HotSpot JVM的GC实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>HotSpot JVM中GC的实现主要有以下的几种：</p>
<ul>
<li>Serial/Serial Old</li>
<li>ParNew</li>
<li>Parallel Scavenge/Parallel Old</li>
<li>Concurrent Mark Sweep(CMS)</li>
<li>Garbage First(G1)</li>
</ul>
<p>分别简单总结一下。</p>
<hr>
<h1 id="Serial/Serial_Old">Serial/Serial Old</h1><p>Serial 收集器是最基本的、历史最悠久的收集器。从字面上就能看出，这是一个单线程的收集器，即在进行GC时必须STW。</p>
<p>Serial收集器在新生代采用复制算法，在老年代采用标记-清理-压缩算法(Serial Old)。</p>
<hr>
<h1 id="ParNew">ParNew</h1><p>ParNew收集器是Serial收集器的多线程版本，采用多线程进行收集，但一样要STW。</p>
<p>与Serial类似，ParNew收集器在新生代采用复制算法，在老年代采用标记-清理-压缩算法。</p>
<p>ParNew比较重要，因为它可以配合CMS收集器一起使用(Parallel Scavenge则不行)。ParNew是<code>-XX:+UseConcMarkSweepGC</code>选项下默认的新生代收集器。</p>
<hr>
<h1 id="Parallel_Scavenge">Parallel Scavenge</h1><p>Parallel Scavenge是一个新生代收集器，它与ParNew最主要的区别是它的目标是<strong>吞吐量优先</strong>而不是时间优先（注意这两个不能兼得）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU运行总时间的比值。吞吐量优先适合在后台完成计算而不需要太多交互的业务，而时间优先适合需要交互和实时性的业务。<br>Parallel Scavenge可以精确控制吞吐量，通过两个参数：控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。它还可以通过打开<code>-XX:+UseAdaptiveSizePolicy</code>参数进行自适应调节(<strong>GC Ergonomics</strong>)，打开后JVM会根据当前运行状况收集监控信息并动态调整参数来提供最合适的吞吐量，配合前两个参数使用更好。</p>
<hr>
<h1 id="Parallel_Old">Parallel Old</h1><p>Parallel Old是Parallel Scavenge对应的老年代版本，目标也是吞吐量优先，可以与Parallel Scavenge结合。</p>
<hr>
<h1 id="Concurrent_Mark_Sweep">Concurrent Mark Sweep</h1><p>CMS是真正意义上的并发收集器，作用于老年代。CMS的目标是时间优先（最短停顿时间），像服务器之类的就很适合跑在CMS收集器下，因为互联网服务重视服务的响应速度，希望系统延迟时间短。CMS通常与ParNew配合使用。</p>
<h2 id="CMS的过程">CMS的过程</h2><p>CMS是基于标记-清除算法实现的，整个过程分几步：</p>
<ul>
<li>初始标记(initial-mark)：从GC Root开始，仅扫描与根节点直接关联的对象并标记，这个过程需要STW，但是GC Root数量有限，因此时间较短</li>
<li>并发标记(concurrent-marking)：这个阶段在初始标记的基础上继续向下进行遍历标记。这个阶段与用户线程并发执行，因此不停顿</li>
<li>并发预清理(concurrent-precleaning)：上一阶段执行期间，会出现一些刚刚晋升老年代的对象，该阶段通过重新扫描减少下一阶段的工作。该阶段并发执行，不停顿</li>
<li>重新标记(remark)：重新标记阶段会对CMS堆上的对象进行扫描，以对并发标记阶段遭到破坏的对象引用关系进行修复，以保证执行清理之前对象引用关系是正确的。这一阶段需要STW，时间也比较短暂</li>
<li>并发清理(concurrent-sweeping)：清理垃圾对象，这个过程与用户线程并发执行，不停顿</li>
<li>并发重置(reset)：重置CMS收集器的数据结构，等待下一次GC</li>
</ul>
<p>可以看到，整个过程中需要STW的阶段仅有<strong>初始标记</strong>和<strong>*重新标记</strong>阶段，所以可以说它的停顿时间比较短（当然吞吐量可能会受影响）。</p>
<h2 id="CMS的缺陷">CMS的缺陷</h2><p>由于CMS是基于 <strong>标记-清理</strong> 算法的，因此会产生大量的内存碎片。这很可能会出现老年代虽然有大量不连续的空闲内存，但很难找到连续的内存空间来给对象分配，不得不提前触发一次Full GC的情况。针对这一点，CMS提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关（默认开启），用于在CMS要gg的时候进行内存碎片整理从而得到连续的内存空间。这样内存碎片的问题可以解决，但STW的时间也相应变长。</p>
<p>另外，CMS收集器无法处理 <strong>浮动垃圾</strong>（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉，这一部分垃圾就称为“浮动垃圾”。由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了92%的空间后就会被激活(JDK 1.6)。可以通过设置<code>-XX:CMSInitiatingOccupancyFraction</code>的值来改变这个阈值。注意一定要结合实际的运行情况，不要设的太大，假如内存真的太满，CMS要gg的时候就会临时召唤出Serial Old对老年代进行Full GC，停顿时间长，因此一定要合理设置这个参数的值。</p>
<h2 id="日志分析">日志分析</h2><p>我们可以通过日志观察一次完整的CMS GC过程(参数：<code>-XX:+UseConcMarkSweepGC -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</code>)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">50.201: [GC (CMS Initial Mark) [1 CMS-initial-mark: 47452K(174784K)] 349898K(489344K), 0.0289564 secs] [Times: user=0.22 sys=0.00, real=0.03 secs]</div><div class="line">50.230: [CMS-concurrent-mark-start]</div><div class="line">50.265: [CMS-concurrent-mark: 0.035/0.035 secs] [Times: user=0.07 sys=0.00, real=0.03 secs]</div><div class="line">50.265: [CMS-concurrent-preclean-start]</div><div class="line">50.268: [CMS-concurrent-preclean: 0.003/0.003 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</div><div class="line">50.268: [CMS-concurrent-abortable-preclean-start]</div><div class="line"> CMS: abort preclean due to time 55.290: [CMS-concurrent-abortable-preclean: 1.618/5.022 secs] [Times: user=1.66 sys=0.02, real=5.02 secs]</div><div class="line">55.290: [GC (CMS Final Remark) [YG occupancy: 302446 K (314560 K)]55.290: [Rescan (parallel) , 0.0252109 secs]55.315: [weak refs processing, 0.0000131 secs]55.315: [class unloading, 0.0122450 secs]55.327: [scrub symbol table, 0.0103126 secs]55.338: [scrub string table, 0.0007051 secs][1 CMS-remark: 47452K(174784K)] 349898K(489344K), 0.0503070 secs] [Times: user=0.22 sys=0.00, real=0.05 secs]</div><div class="line">55.340: [CMS-concurrent-sweep-start]</div><div class="line">55.356: [CMS-concurrent-sweep: 0.016/0.016 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</div><div class="line">55.356: [CMS-concurrent-reset-start]</div><div class="line">55.357: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</div></pre></td></tr></table></figure>
<p><strong>【关于CMS-concurrent-abortable-preclean】</strong>：从日志中我们还发现了一个细节叫做<code>CMS-concurrent-abortable-preclean</code>，这就要从Concurrent precleaning阶段说起了。Concurrent precleaning阶段的实际行为是：针对新生代做抽样，等待新生代在某个时间段（默认5秒，可以通过<code>CMSMaxAbortablePrecleanTime</code>参数设置）执行一次Minor GC，如果这个时间段内GC没有发生，那么就继续进行下一阶段（Remark）；如果时间段内触发了Minor GC，则可能会执行一些优化（具体可以参考<a href="这篇文章">https://blogs.oracle.com/jonthecollector/entry/did_you_know</a>）</p>
<hr>
<h1 id="G1">G1</h1><p>G1(Garbage First)收集器是HotSpot JVM最新的垃圾收集器，它最大的特点就是将堆内存划分成多个连续的区域(region)，每个区域大小相等。因此在G1中新生代与老年代都是由若干个Region组成(不需要连续)。Region的大小是可以重新设置的。</p>
<p>G1的优点：可以<strong>非常精确地控制停顿</strong>；老年代采用<strong>标记-压缩</strong>算法，避免了内存碎片的问题。</p>
<p>G1会在内部维护一个优先列表，通过一个合理的模型，计算出每个Region的收集成本和收益期望并量化，这样每次进行GC时，G1总是会选择<strong>最适合</strong>的Region（通常垃圾比较多）进行回收，使GC时间满足设置的条件。</p>
<h2 id="G1新生代GC过程">G1新生代GC过程</h2><p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png" alt=""></p>
<p>G1的新生代收集类似于ParNew，同样是基于复制的算法（英文叫evacuation），存活的对象会被移至Survivor区，空间不够则一些对象需要晋升至老年代。新生代收集同样会有STW。</p>
<p>每次GC中，Eden区和Survivor区的大小都会被重新计算来提供给下一次Minor GC（根据内部记录的一些信息以及设置的期望停顿时间）。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png" alt=""><br><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png" alt=""></p>
<h2 id="Remembered_Set">Remembered Set</h2><p>G1通过引入Remembered Set来避免全堆扫描。Remembered Set用于<strong>跟踪对象引用</strong>。G1中每个Region都有对应的Remembered Set。当JVM发现内部的一个引用关系需要更新（对Reference类型进行写操作），则立即产生一个Write Barrier中断这个写操作，并检查Reference引用的对象是否处于不同的Region之间（用分代的思想，就是新生代和老年代之间的引用）。如果是，则通过CardTable通知G1，G1根据CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中，并将Remembered Set加入GC Root。这样，在G1进行根节点枚举时就可以扫描到该对象而不会出现遗漏。</p>
<h2 id="G1老年代GC过程">G1老年代GC过程</h2><p>一共六步，直接放上官方的解释：</p>
<h3 id="Initial_Mark(STW)">Initial Mark(STW)</h3><p>This is a stop the world event. With G1, it is piggybacked on a normal young GC. Mark survivor regions (root regions) which may have references to objects in old generation.</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide13.png" alt="Initial Marking Phase"></p>
<h3 id="Root_Region_Scanning">Root Region Scanning</h3><p>Scan survivor regions for references into the old generation. This happens while the application continues to run. The phase must be completed before a young GC can occur.</p>
<h3 id="Concurrent_Marking">Concurrent Marking</h3><p>Find live objects over the entire heap. This happens while the application is running. This phase can be interrupted by young generation garbage collections.</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide14.png" alt=""></p>
<h3 id="Remark(STW)">Remark(STW)</h3><p>Completes the marking of live object in the heap. Uses an algorithm called snapshot-at-the-beginning (<strong>SATB</strong>) which is much faster than what was used in the CMS collector.</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide15.png" alt=""></p>
<h3 id="Cleanup(STW_and_concurrent)">Cleanup(STW and concurrent)</h3><ul>
<li>Performs accounting on live objects and completely free regions. (Stop the world)</li>
<li>Scrubs the Remembered Sets. (Stop the world)</li>
<li>Reset the empty regions and return them to the free list. (Concurrent)</li>
</ul>
<h3 id="Copying(STW)">Copying(STW)</h3><p>These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as [GC pause (young)]. Or both young and old generation regions which are logged as [GC Pause (mixed)].</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide16.png" alt=""><br><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide17.png" alt=""></p>
<h3 id="总结">总结</h3><p>G1老年代收集的几个要点：</p>
<ul>
<li>Concurrent Marking Phase<ul>
<li>Liveness information is calculated concurrently while the application is running.</li>
<li>This liveness information identifies which regions will be best to reclaim during an evacuation pause.</li>
<li>There is no sweeping phase like in CMS.</li>
</ul>
</li>
<li>Remark Phase<ul>
<li>Uses the Snapshot-at-the-Beginning (SATB) algorithm which is much faster then what was used with CMS.</li>
<li>Completely empty regions are reclaimed.</li>
</ul>
</li>
<li>Copying/Cleanup Phase<ul>
<li>Young generation and old generation are reclaimed at the same time.</li>
<li>Old generation regions are selected based on their liveness.</li>
</ul>
</li>
</ul>
<h2 id="日志分析-1">日志分析</h2><p>分析日志可以清晰地观察G1的收集阶段（JVM参数<code>-XX:+UseG1GC -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</code>）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="number">5.891</span>: [<span class="function">GC <span class="title">pause</span> <span class="params">(G1 Evacuation Pause)</span> <span class="params">(young)</span>, 0.0288342 secs]</span></div><div class="line">   [Parallel Time: 22.9 ms, GC Workers: 8]</div><div class="line">      [GC Worker <span class="title">Start</span> <span class="params">(ms)</span>: Min: 5891.4, Avg: 5891.4, Max: 5891.5, Diff: 0.1]</div><div class="line">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 1.1, Avg: 3.0, Max: 13.6, Diff: 12.5, Sum: 24.1]</div><div class="line">      [Update <span class="title">RS</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.3, Max: 0.7, Diff: 0.7, Sum: 2.1]</div><div class="line">         [Processed Buffers: Min: 0, Avg: 3.9, Max: 10, Diff: 10, Sum: 31]</div><div class="line">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.5, Max: 0.8, Diff: 0.7, Sum: 3.8]</div><div class="line">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.1, Max: 0.4, Diff: 0.4, Sum: 1.0]</div><div class="line">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>: Min: 3.3, Avg: 13.8, Max: 20.2, Diff: 16.9, Sum: 110.5]</div><div class="line">      [<span class="title">Termination</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 5.1, Max: 5.8, Diff: 5.8, Sum: 40.8]</div><div class="line">         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 8]</div><div class="line">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</div><div class="line">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>: Min: 22.8, Avg: 22.8, Max: 22.8, Diff: 0.1, Sum: 182.4]</div><div class="line">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>: Min: 5914.2, Avg: 5914.2, Max: 5914.3, Diff: 0.0]</div><div class="line">   [Code Root Fixup: 0.2 ms]</div><div class="line">   [Code Root Purge: 0.0 ms]</div><div class="line">   [Clear CT: 0.3 ms]</div><div class="line">   [Other: 5.4 ms]</div><div class="line">      [Choose CSet: 0.0 ms]</div><div class="line">      [Ref Proc: 4.8 ms]</div><div class="line">      [Ref Enq: 0.1 ms]</div><div class="line">      [Redirty Cards: 0.2 ms]</div><div class="line">      [Humongous Register: 0.0 ms]</div><div class="line">      [Humongous Reclaim: 0.0 ms]</div><div class="line">      [Free CSet: 0.2 ms]</div><div class="line">   [Eden: 251.0<span class="title">M</span><span class="params">(<span class="number">251.0</span>M)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">273.0</span>M)</span> Survivors: 14.0M-&gt;34.0M Heap: 286.6<span class="title">M</span><span class="params">(<span class="number">512.0</span>M)</span>-&gt;58.6<span class="title">M</span><span class="params">(<span class="number">512.0</span>M)</span>]</div><div class="line"> [Times: user=<span class="number">0.18</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</div><div class="line"></div><div class="line"> <span class="number">8.119</span>: [<span class="function">GC <span class="title">pause</span> <span class="params">(Metadata GC Threshold)</span> <span class="params">(young)</span> <span class="params">(initial-mark)</span>, 0.0240591 secs]</span></div><div class="line">   [Parallel Time: 14.9 ms, GC Workers: 8]</div><div class="line">      [GC Worker <span class="title">Start</span> <span class="params">(ms)</span>: Min: 8119.1, Avg: 8119.4, Max: 8120.3, Diff: 1.1]</div><div class="line">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.5, Avg: 2.3, Max: 9.7, Diff: 9.2, Sum: 18.2]</div><div class="line">      [Update <span class="title">RS</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.2, Max: 0.4, Diff: 0.4, Sum: 1.2]</div><div class="line">         [Processed Buffers: Min: 0, Avg: 2.5, Max: 6, Diff: 6, Sum: 20]</div><div class="line">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.7, Max: 0.9, Diff: 0.9, Sum: 5.4]</div><div class="line">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.2, Max: 0.4, Diff: 0.4, Sum: 1.3]</div><div class="line">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>: Min: 4.9, Avg: 11.1, Max: 12.4, Diff: 7.5, Sum: 89.2]</div><div class="line">      [<span class="title">Termination</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.7]</div><div class="line">         [Termination Attempts: Min: 1, Avg: 20.9, Max: 31, Diff: 30, Sum: 167]</div><div class="line">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</div><div class="line">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>: Min: 13.7, Avg: 14.5, Max: 14.8, Diff: 1.1, Sum: 116.1]</div><div class="line">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>: Min: 8133.9, Avg: 8134.0, Max: 8134.0, Diff: 0.0]</div><div class="line">   [Code Root Fixup: 0.3 ms]</div><div class="line">   [Code Root Purge: 0.0 ms]</div><div class="line">   [Clear CT: 0.2 ms]</div><div class="line">   [Other: 8.6 ms]</div><div class="line">      [Choose CSet: 0.0 ms]</div><div class="line">      [Ref Proc: 8.2 ms]</div><div class="line">      [Ref Enq: 0.0 ms]</div><div class="line">      [Redirty Cards: 0.1 ms]</div><div class="line">      [Humongous Register: 0.0 ms]</div><div class="line">      [Humongous Reclaim: 0.0 ms]</div><div class="line">      [Free CSet: 0.1 ms]</div><div class="line">   [Eden: 159.0<span class="title">M</span><span class="params">(<span class="number">273.0</span>M)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">291.0</span>M)</span> Survivors: 34.0M-&gt;16.0M Heap: 219.6<span class="title">M</span><span class="params">(<span class="number">512.0</span>M)</span>-&gt;68.1<span class="title">M</span><span class="params">(<span class="number">512.0</span>M)</span>]</div><div class="line"> [Times: user=<span class="number">0.11</span> sys=<span class="number">0.00</span>, real=<span class="number">0.03</span> secs]</div><div class="line"><span class="number">8.143</span>: [GC concurrent-root-region-scan-start]</div><div class="line"><span class="number">8.151</span>: [GC concurrent-root-region-scan-end, <span class="number">0.0081611</span> secs]</div><div class="line"><span class="number">8.151</span>: [GC concurrent-mark-start]</div><div class="line"><span class="number">8.191</span>: [GC concurrent-mark-end, <span class="number">0.0399863</span> secs]</div><div class="line"><span class="number">8.192</span>: [GC remark <span class="number">8.192</span>: [Finalize Marking, <span class="number">0.0005544</span> secs] <span class="number">8.192</span>: [GC ref-proc, <span class="number">0.0002680</span> secs] <span class="number">8.192</span>: [Unloading, <span class="number">0.0068146</span> secs], <span class="number">0.0079309</span> secs]</div><div class="line"> [Times: user=<span class="number">0.04</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</div><div class="line"><span class="number">8.200</span>: [GC cleanup <span class="number">74</span>M-&gt;<span class="number">66</span>M(<span class="number">512</span>M), <span class="number">0.0005223</span> secs]</div><div class="line"> [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</div><div class="line"><span class="number">8.201</span>: [GC concurrent-cleanup-start]</div><div class="line"><span class="number">8.201</span>: [GC concurrent-cleanup-end, <span class="number">0.0000154</span> secs]</div></pre></td></tr></table></figure></p>
<p>目前来说，大内存对G1支持的较好，其余的情况有待观察。是否将GC替换为G1还有待实验（何况很多公司还在用JDK 1.7）。有消息称JDK 9会把G1作为默认的GC。</p>
<hr>
<h1 id="其他的JVM_GC实现">其他的JVM GC实现</h1><p>关于低延时的GC实现，Azul的<strong>C4: The Continuously Concurrent Compacting Collector</strong>做的挺好的，STW时间非常低，而且对超大堆支持的很好（据说能支持2T的内存。。），当然吞吐量会稍弱。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》，周志明 著</li>
<li><em>Garbage Collection Understanding Java, Azul</em></li>
<li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="external">Getting Started with the G1 Garbage Collector</a></li>
<li><em>Garbage-First Garbage Collection, David Detlefs, Christine Flood, Steve Heller, Tony Printezis, Sun Microsystems, Inc.</em></li>
<li><a href="https://blogs.oracle.com/jonthecollector/entry/did_you_know" target="_blank" rel="external">Jon Masamitsu’s Weblog - an article about CMS</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jvm-gc-safepoint-condition" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-gc-safepoint-condition/" class="article-date">
      <time datetime="2015-06-30T16:00:00.000Z" itemprop="datePublished">2015-07-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-gc-safepoint-condition/">深入探究JVM | Safepoint及GC的触发条件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近看JVM看得火热。。在这里我们来总结一下HotSpot JVM里GC Safepoint以及触发GC的条件相关的一些知识。</p>
<h1 id="GC_Safepoint">GC Safepoint</h1><p>如果要触发一次GC，那么JVM中所有Java线程都必须到达GC Safepoint。</p>
<p>JVM只会在特定位置放置safepoint，比如：</p>
<ul>
<li>内存分配的地方（allocation，即new一个新对象的时候）</li>
<li>长时间执行区块结束的时刻（如方法调用，循环跳转等）</li>
</ul>
<p>之所以只在特定的位置放置safepoint，是因为OopMap要占用空间，如果设太多safepoint那么占用空间会太大；再者，safepoint会影响优化，如果某个无用的值处设置了safepoint，那么JIT就无法优化掉这些无用变量，这会影响性能。</p>
<p>HotSpot JVM在通过JIT编译时，会在所有方法返回之前以及循环跳转、异常跳转之前放置Safepoint，并且在每个Safepoint都生成一些信息存储哪些地方是引用（<strong>OopMap</strong>），以便JVM能找到需要的引用。</p>
<p>那么如何确保GC时所有线程都到达GC Safepoint呢？有两种方法：<strong>抢占式中断</strong>(Preemptive Suspension)和<strong>主动式中断</strong>(Voluntary Suspension)。</p>
<p>抢占式中断不需要线程的执行代码去主动配合，当触发GC时，JVM会中断所有线程，然后依次检查每个线程中断的位置是否为Safepoint，如果不是则恢复线程，让它执行至Safepoint再进行终端。</p>
<p>大部分JVM实现（如HotSpot JVM）都是采用<strong>主动式中断</strong>，即GC需要中断线程的时候，它仅仅简单地设个标志，执行线程会主动轮询这个标志位，如果标志位就绪的话就自行中断。Polling Point与Safepoint是重合的。主动式中断的思想是一种hand-shacking protocol的思想。</p>
<p>通过对Safepoint的研究，我们了解到了GC触发的时刻主要是在<strong>new一个新的对象</strong>或者在<strong>循环跳转或方法返回之前</strong>。</p>
<p>【扩展】Safepoint有好几种，比如还有<strong>deoptimization safepoint</strong>之类的，作用不同。</p>
<h1 id="Safe-Region">Safe-Region</h1><p>只有GC Safepoint是不足的，因为我们发现，有一种情况，线程无法响应JVM的中断请求，也无法去轮询标志位：</p>
<ul>
<li>线程处于阻塞或等待状态</li>
</ul>
<p>对于这种情况，引入了safe-region的概念。</p>
<p>Safe-Region是指在代码片段中，引用关系不会发生变化，因此GC可以随心所欲地在任何地方执行。在线程执行到Safe Region里面的代码时，首先标识自己已经进入了Safe Region，那样当这段时间里JVM要发起GC，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<p>另外，当一个线程在执行native方法时，由于此时该线程在执行JVM管理之外的代码，不能对JVM的执行状态做任何修改，因而JVM要进入safepoint不需要关心它。所以也可以把正在执行native函数的线程看作“已经进入了safepoint”，或者把这种情况叫做“在safe-region里”。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://www.infoq.com/cn/articles/jvm-memory-collection" target="_blank" rel="external">JVM内存回收理论与实现, 周志明</a></li>
<li><a href="http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html" target="_blank" rel="external">GC safe-point (or safepoint) and safe-region, Xiao-Feng Li</a></li>
<li><a href="https://www.zhihu.com/question/29268019" target="_blank" rel="external">现代JVM中的Safe Region和Safe Point到底是如何定义和划分的? - RednaxelaFX的回答</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jvm-gc-method-types" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-gc-method-types/" class="article-date">
      <time datetime="2015-06-30T16:00:00.000Z" itemprop="datePublished">2015-07-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-gc-method-types/">深入探究JVM | 初探GC算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>GC算法的思想主要有三种：</p>
<ul>
<li>Mark-Sweep</li>
<li>Mark-Compact</li>
<li>Copying</li>
</ul>
<p>另外，当前JVM的GC一般都是分代收集，几种垃圾回收算法进行组合。</p>
<h1 id="分代收集">分代收集</h1><p>根据分代收集的模型，一般将内存区域分为<strong>新生代(Young Generation)</strong>和<strong>老年代(Old Generation)</strong>。</p>
<p>新生代对应那些<strong>新产生的，存活时间较短的对象</strong>。如果一个对象在新生代内经历了一定次数（默认15）的收集后，它就会晋升至老年代（大对象也可以直接进入老年代，可以调参数）。一般会把新生代划分为Eden区和Suvivor区，在HotSpot JVM中E:2S=8:2。后面会说到，新生代一般使用基于复制的GC算法。新生代对应Minor GC。</p>
<p>老年代对应那些存活时间较长，容量较大的对象。老年代GC对应Full GC，此时需要STW。</p>
<p>JDK1.8之前还存在永久代（PermGen），它用于存放类的元数据和常量，这里偶尔也会发生GC（回收无用的类和常量等等的）。由于永久代经常会OOM，JDK1.8移除了永久代，用Metaspace代替PermGen。具体可以看我之前总结的<a href="http://www.sczyh30.com/posts/Java/jvm-metaspace/">深入探究JVM | 探秘Metaspace</a>。</p>
<h1 id="基于标记-清理的GC">基于标记-清理的GC</h1><p>基于标记-清理(Mark-Sweep)的GC是比较基础的一种实现，它的思想比较简单，首先根据可达性分析对不可达对象进行标记，标记完成后统一清理这些对象。它的缺点有两个：</p>
<ul>
<li>标记和清理的效率都不算高</li>
<li>会产生大量的内存碎片，如果这时候有大对象需要连续的内存空间进行分配，很可能会因为没有足够的连续内存空间而又触发一次GC</li>
</ul>
<p>基于Mark-Sweep的GC多用于老年代。</p>
<h1 id="基于标记-压缩的GC">基于标记-压缩的GC</h1><p>基于标记-压缩(Mark-Compact)的GC可以解决内存碎片的问题。它的思想是，在标记好待回收对象后，将存活的对象移至一端(reallocate)然后对剩余的部分进行回收。这个过程需要进行<code>remapping</code>，即修复线程与对象之间的引用映射关系。</p>
<p>基于Mark-Compact的GC多用于老年代。</p>
<h1 id="基于复制的GC">基于复制的GC</h1><p>基于复制(Copy)的GC比较高效，它的思路是，将内存容量划分为相同的两份，每次只用一块。当这一块内存用完了，就把还存活的对象移到另一块内存，然后对这一块内存（整个半区）进行清理操作。这样内存分配时也就不用考虑内存碎片了，只需要移动指针，按顺序分配即可。但是这种算法是拿空间换时间，而且一下子就是50%的内存空间，一般受不了。并且这种算法需要频繁GC。而新生代的对象一般是存活时间较短的对象，GC频率较高，占内存较少，因此新生代一般都采用基于复制的GC。</p>
<p>HotSpot JVM将新生代划分为一个Eden区和两个Survivor区，默认比例为8:2，其中对象可使用1E+1S，留出空闲的1S。每次进行GC的时候收集器就会将存活对象移至那个空闲S区，然后将其余的部分进行回收，这样默认空间利用率可达90%。当然也有很多时候一个S区无法容纳所有的存货对象，那么某些对象就需要通过分配担保机制(Handle Promotion)直接进入老年代。</p>
<h1 id="当前商用实现">当前商用实现</h1><p>这是现有的商用GC对应的算法：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/jvm-gc-impl-all-algo.PNG" alt=""></p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》，周志明 著</li>
<li><em>Garbage Collection Understanding Java, Azul</em></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-reference-type" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-reference-type/" class="article-date">
      <time datetime="2015-06-28T16:00:00.000Z" itemprop="datePublished">2015-06-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-reference-type/">Java中的几种引用 | 弱引用、软引用、虚引用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Java中存在四种引用：强引用、软引用、弱引用、虚引用，这里来分别分析一下。</p>
<h1 id="StrongReference">StrongReference</h1><p><strong>StrongReference</strong>（强引用）是最普通的引用类型，只要强引用存在，GC就不会进行垃圾回收。</p>
<h1 id="SoftReference">SoftReference</h1><p><strong>SoftReference</strong>（软引用）用来描述一些有用但是非必需的对象。如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM就会把这个软引用加入到与之关联的引用队列中。软引用可用来实现内存敏感的高速缓存。</p>
<h1 id="WeakReference">WeakReference</h1><p><strong>WeakReference</strong>（弱引用）是一种生命周期比软引用更短的引用。当GC扫描启动时，只要扫描到只具有弱引用的对象，<strong>无论内存是否够用都会执行GC</strong>，但由于GC线程优先级很低，因此并不一定能迅速发现这些弱引用对象。弱引用也可以和一个引用队列联合使用。<br>WeakReference在Android中用的挺多。</p>
<h1 id="PhantomReference">PhantomReference</h1><p><strong>PhantomReference</strong>（虚引用）不同于其余三种引用，虚引用不会影响对象的生命周期，也无法通过虚引用获得对象的一个实例；如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动，它必须和引用队列联合使用。</p>
<p>【2015-7-16补充】逛InfoQ的时候又发现了一种FinalReference。。用的不多就不总结了，文章：<a href="http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference" target="_blank" rel="external">JVM源码分析之FinalReference完全解读</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jvm-gc-intro-count-vs-reachability" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-gc-intro-count-vs-reachability/" class="article-date">
      <time datetime="2015-06-28T16:00:00.000Z" itemprop="datePublished">2015-06-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-gc-intro-count-vs-reachability/">深入探究JVM | 初探GC - 引用计数 VS 可达分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>主流的垃圾回收主要分两大类：引用计数和可达性分析。</p>
<h1 id="引用计数法">引用计数法</h1><p>引用计数的实现很简单，它的思想就是给一个对象增加一个引用计数器，每当一个新的对象引用它时就给计数器加1，不引用了就减1，当计数器为0时即可认为对象无用了，可进行回收。</p>
<p>这个思想很简单，而且很多语言的底层（如Swift，Python）都是基于引用计数法进行回收的。但是引用计数法有一个很大的缺陷：它无法解决循环引用的问题，比如A引用B，B引用A，这样两对象的引用计数器永远不为0，两对象不能被回收，从而造成内存不能被及时清理。</p>
<p>JVM没有使用引用计数法，而是使用了可达性分析来进行GC。</p>
<p>题外话：C++ 11的智能指针就是基于引用计数的，它提供了<code>weak_ptr</code>来解决循环引用的问题。（类似于Java中的<code>WeakReference</code>，作用类似）</p>
<h1 id="可达性分析">可达性分析</h1><p>可达性分析是基于图论的分析方法，它会找一组对象作为GC Root（根结点），并从根结点进行遍历，遍历结束后如果发现某个对象是不可达的（即从GC Root到此对象没有路径），那么它就会被标记为不可达对象，等待GC。比如，假设下图中obj1位GC Root，那么obj5和obj6就是不可达的：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/graph-gc-reachable.png" alt=""></p>
<h1 id="哪些对象可以作为GC_Root">哪些对象可以作为GC Root</h1><p>能作为GC Root的对象必定为可以存活的对象，比如全局性的引用（<strong>静态变量和常量</strong>）以及某些方法的<strong>局部变量</strong>（栈帧中的本地变量表）。</p>
<p>以下对象通常可以作为GC Root：</p>
<ul>
<li>存活的线程</li>
<li><strong>虚拟机栈(栈桢中的本地变量表)中的引用的对象</strong></li>
<li><strong>方法区中的类静态属性以及常量引用的对象</strong></li>
<li><strong>本地方法栈中JNI引用的局部变量以及全局变量</strong></li>
</ul>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="https://www.yourkit.com/docs/java/help/gc_roots.jsp" target="_blank" rel="external">GC roots</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jvm-metaspace" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-metaspace/" class="article-date">
      <time datetime="2015-06-25T16:00:00.000Z" itemprop="datePublished">2015-06-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-metaspace/">深入探究JVM | 探秘 Metaspace</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Java 8 彻底将永久代 (PermGen) 移除出了 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Metaspace。这一篇文章我们来总结一下Metaspace（元空间）的特性。如有错误，敬请指出，谢谢~</p>
<h1 id="引言：永久代为什么被移出HotSpot_JVM了？">引言：永久代为什么被移出HotSpot JVM了？</h1><p>在 HotSpot JVM 中，永久代中用于存放类和方法的元数据以及常量池，比如<code>Class</code>和<code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p>
<p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <em>java.lang.OutOfMemoryError: PermGen</em> ，为此我们不得不对虚拟机做调优。</p>
<p>那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？我总结了两个主要原因（详见：<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a>）：</p>
<ol>
<li>由于 PermGen 内存经常会溢出，引发恼人的 <em>java.lang.OutOfMemoryError: PermGen</em>，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li>
<li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li>
</ol>
<p>根据上面的各种原因，PermGen 最终被移除，<strong>方法区移至 Metaspace，字符串常量移至 Java Heap</strong>。</p>
<h1 id="探秘元空间">探秘元空间</h1><p>由于 Metaspace 的资料比较少，这里主要是依据Oracle官方的Java虚拟机规范及Oracle Blog里的几篇文章来总结的。</p>
<p>首先，Metaspace（元空间）是哪一块区域？官方的解释是：</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p>
</blockquote>
<p>也就是说，JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace，中文名叫元空间。</p>
<h2 id="优点">优点</h2><p>使用本地内存有什么好处呢？最直接的表现就是OOM问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让 Metaspace 变得无限大显然是不现实的，因此我们也要限制 Metaspace 的大小：使用 <strong>-XX:MaxMetaspaceSize</strong> 参数来指定 Metaspace 区域的大小。JVM 默认在运行时根据需要动态地设置 <strong>MaxMetaspaceSize</strong> 的大小。</p>
<p>除此之外，它还有以下优点：</p>
<ul>
<li>Take advantage of Java Language Specification property : Classes and associated metadata lifetimes match class loader’s</li>
<li>Linear allocation only</li>
<li>No individual reclamation (except for RedefineClasses and class loading failure)</li>
<li>No GC scan or compaction</li>
<li>No relocation for metaspace objects</li>
</ul>
<h2 id="GC">GC</h2><p>如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）。</p>
<p>为了减少垃圾回收的频率及时间，控制吞吐量，对Metaspace进行适当的监控和调优是非常有必要的。如果在Metaspace区发生了频繁的Full GC，那么可能表示存在内存泄露或Metaspace区的空间太小了。</p>
<h2 id="新增的_JVM_参数">新增的 JVM 参数</h2><ul>
<li><strong>-XX:MetaspaceSize</strong> 是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，<em>the initial high-water-mark</em> )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li>
<li><strong>-XX:MaxMetaspaceSize</strong> 是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</li>
<li><strong>-XX:MinMetaspaceFreeRatio</strong> 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</li>
<li><strong>-XX:MaxMetaspaceFreeRatio</strong> 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</li>
</ul>
<h2 id="监控与调优（待补充）">监控与调优（待补充）</h2><p><code>VisualVM</code>、<code>jstat</code>、<code>jstack</code> 可以监测 Metaspace 的动态，后续将更新这里。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><em>The Java Virtual Machine Specification, Java SE 8 Edition, Oracle</em></li>
<li><a href="http://java-latte.blogspot.sg/2014/03/metaspace-in-java-8.html" target="_blank" rel="external">Metaspace in Java 8</a></li>
<li><a href="http://stackoverflow.com/questions/24074164/what-is-the-use-of-metaspace-in-java-8" target="_blank" rel="external">What is the use of Metaspace in Java 8? - StackOverflow</a></li>
<li><a href="https://blogs.oracle.com/poonam/entry/about_g1_garbage_collector_permanent" target="_blank" rel="external">About G1 Garbage Collector, Permanent Generation and Metaspace</a></li>
<li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a></li>
<li><a href="http://stackoverflow.com/questions/18339707/permgen-elimination-in-jdk-8/22509753#22509753" target="_blank" rel="external">PermGen elimination in JDK 8 - StackOverflow</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Metaspace/">Metaspace</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-reflection-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-reflection-2/" class="article-date">
      <time datetime="2015-06-24T16:00:00.000Z" itemprop="datePublished">2015-06-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-reflection-2/">深入解析Java反射（2） - invoke方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>上篇文章中回顾了一下Java反射相关的基础内容。这一节我们来深入研究Method类中的invoke方法，探寻它的奥秘。<br>注:本篇文章的所有源码都基于OpenJDK 1.8。</p>
<hr>
<h1 id="引入">引入</h1><p>即使没有学过反射，大家也一定会见过invoke方法。因为很多方法调用都是靠invoke方法，所以很多异常的抛出都会定位到invoke方法，比如下面的情形大家会很熟悉:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">java.lang.NullPointerException</div><div class="line">  at ......</div><div class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</div><div class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</div><div class="line">  at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</div></pre></td></tr></table></figure></p>
<p>大家在看到异常抛出时，除了想要排除Bug，是不是同时也对这个神秘的invoke乃至invoke0方法有一些好奇呢？我们下面就来揭开它神秘的面纱，探寻底层的机制。</p>
<h1 id="浅析invoke过程">浅析invoke过程</h1><p>上一篇文章我们讲过，invoke方法用来在运行时动态地调用某个实例的方法。它的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallerSensitive</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></div><div class="line">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</div><div class="line">       InvocationTargetException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!override) &#123;</div><div class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</div><div class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</div><div class="line">            checkAccess(caller, clazz, obj, modifiers);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></div><div class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</div><div class="line">        ma = acquireMethodAccessor();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们根据invoke方法的实现，将其分为以下几步：</p>
<h2 id="1、权限检查">1、权限检查</h2><p>invoke方法会首先检查AccessibleObject的override属性的值。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。<br>override的值默认是false,表示需要权限调用规则，调用方法时需要检查权限;我们也可以用setAccessible方法设置为true,若override的值为true，表示忽略权限规则，调用方法时无需检查权限（也就是说可以调用任意的private方法，违反了封装）。<br>如果override属性为默认值false，则进行进一步的权限检查：<br>（1）首先用Reflection.quickCheckMemberAccess(clazz, modifiers)方法检查方法是否为public，如果是的话跳出本步；如果不是public方法，那么用Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallerSensitive</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getCallerClass();</div></pre></td></tr></table></figure></p>
<p>在OpenJDK的源码中找到此方法的JNI入口(Reflection.c):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jclass JNICALL <span class="title">Java_sun_reflect_Reflection_getCallerClass__</span></span></div><div class="line"><span class="params">(JNIEnv *env, jclass unused)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> JVM_GetCallerClass(env, JVM_CALLER_DEPTH);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中JVM_GetCallerClass的源码如下，有兴趣的可以研究一下(位于jvm.cpp):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env, <span class="keyword">int</span> depth))</div><div class="line">  JVMWrapper(<span class="string">"JVM_GetCallerClass"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Pre-JDK 8 and early builds of JDK 8 don't have a CallerSensitive annotation; or</span></div><div class="line">  <span class="comment">// sun.reflect.Reflection.getCallerClass with a depth parameter is provided</span></div><div class="line">  <span class="comment">// temporarily for existing code to use until a replacement API is defined.</span></div><div class="line">  <span class="keyword">if</span> (SystemDictionary::reflect_CallerSensitive_klass() == <span class="literal">NULL</span> || depth != JVM_CALLER_DEPTH) &#123;</div><div class="line">    Klass* k = thread-&gt;security_get_caller_class(depth);</div><div class="line">    <span class="keyword">return</span> (k == <span class="literal">NULL</span>) ? <span class="literal">NULL</span> : (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Getting the class of the caller frame.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// The call stack at this point looks something like this:</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]</span></div><div class="line">  <span class="comment">// [1] [ @CallerSensitive API.method                                   ]</span></div><div class="line">  <span class="comment">// [.] [ (skipped intermediate frames)                                 ]</span></div><div class="line">  <span class="comment">// [n] [ caller                                                        ]</span></div><div class="line">  <span class="function">vframeStream <span class="title">vfst</span><span class="params">(thread)</span></span>;</div><div class="line">  <span class="comment">// Cf. LibraryCallKit::inline_native_Reflection_getCallerClass</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; !vfst.at_end(); vfst.security_next(), n++) &#123;</div><div class="line">    Method* m = vfst.method();</div><div class="line">    assert(m != <span class="literal">NULL</span>, <span class="string">"sanity"</span>);</div><div class="line">    <span class="keyword">switch</span> (n) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">      <span class="comment">// This must only be called from Reflection.getCallerClass</span></div><div class="line">      <span class="keyword">if</span> (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) &#123;</div><div class="line">        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), <span class="string">"JVM_GetCallerClass must only be called from Reflection.getCallerClass"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// fall-through</span></div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">      <span class="comment">// Frame 0 and 1 must be caller sensitive.</span></div><div class="line">      <span class="keyword">if</span> (!m-&gt;caller_sensitive()) &#123;</div><div class="line">        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(<span class="string">"CallerSensitive annotation expected at frame %d"</span>, n));</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">if</span> (!m-&gt;is_ignored_by_security_stack_walk()) &#123;</div><div class="line">        <span class="comment">// We have reached the desired frame; return the holder class.</span></div><div class="line">        <span class="keyword">return</span> (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">JVM_END</div></pre></td></tr></table></figure></p>
<p>获取了这个Class对象caller后用checkAccess方法做一次快速的权限校验，其实现为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> Object securityCheckCache;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkAccess</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; clazz, Object obj, <span class="keyword">int</span> modifiers)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalAccessException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (caller == clazz) &#123;  <span class="comment">// 快速校验</span></div><div class="line">            <span class="keyword">return</span>;             <span class="comment">// 权限通过校验</span></div><div class="line">        &#125;</div><div class="line">        Object cache = securityCheckCache;  <span class="comment">// read volatile</span></div><div class="line">        Class&lt;?&gt; targetClass = clazz;</div><div class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span></div><div class="line">            &amp;&amp; Modifier.isProtected(modifiers)</div><div class="line">            &amp;&amp; ((targetClass = obj.getClass()) != clazz)) &#123;</div><div class="line">            <span class="comment">// Must match a 2-list of &#123; caller, targetClass &#125;.</span></div><div class="line">            <span class="keyword">if</span> (cache <span class="keyword">instanceof</span> Class[]) &#123;</div><div class="line">                Class&lt;?&gt;[] cache2 = (Class&lt;?&gt;[]) cache;</div><div class="line">                <span class="keyword">if</span> (cache2[<span class="number">1</span>] == targetClass &amp;&amp;</div><div class="line">                    cache2[<span class="number">0</span>] == caller) &#123;</div><div class="line">                    <span class="keyword">return</span>;     <span class="comment">// ACCESS IS OK</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">// (Test cache[1] first since range check for [1]</span></div><div class="line">                <span class="comment">// subsumes range check for [0].)</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache == caller) &#123;</div><div class="line">            <span class="comment">// Non-protected case (or obj.class == this.clazz).</span></div><div class="line">            <span class="keyword">return</span>;             <span class="comment">// ACCESS IS OK</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If no return, fall through to the slow path.</span></div><div class="line">        slowCheckMemberAccess(caller, clazz, obj, modifiers, targetClass);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先先执行一次快速校验，一旦调用方法的Class正确则权限检查通过。<br>若未通过，则创建一个缓存，中间再进行一堆检查（比如检验是否为protected属性）。<br>如果上面的所有权限检查都未通过，那么将执行更详细的检查，其实现为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Keep all this slow stuff out of line:</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slowCheckMemberAccess</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; clazz, Object obj, <span class="keyword">int</span> modifiers,</span></span></div><div class="line">                           Class&lt;?&gt; targetClass)</div><div class="line">    <span class="keyword">throws</span> IllegalAccessException</div><div class="line">&#123;</div><div class="line">    Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);</div><div class="line"></div><div class="line">    <span class="comment">// Success: Update the cache.</span></div><div class="line">    Object cache = ((targetClass == clazz)</div><div class="line">                    ? caller</div><div class="line">                    : <span class="keyword">new</span> Class&lt;?&gt;[] &#123; caller, targetClass &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// Note:  The two cache elements are not volatile,</span></div><div class="line">    <span class="comment">// but they are effectively final.  The Java memory model</span></div><div class="line">    <span class="comment">// guarantees that the initializing stores for the cache</span></div><div class="line">    <span class="comment">// elements will occur before the volatile write.</span></div><div class="line">    securityCheckCache = cache;         <span class="comment">// write volatile</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大体意思就是，用Reflection.ensureMemberAccess方法继续检查权限，若检查通过就更新缓存，这样下一次同一个类调用同一个方法时就不用执行权限检查了，这是一种简单的缓存机制。由于JMM的happens-before规则能够保证缓存初始化能够在写缓存之前发生，因此两个cache不需要声明为volatile。<br>到这里，前期的权限检查工作就结束了。如果没有通过检查则会抛出异常，如果通过了检查则会到下一步。</p>
<h2 id="2、调用MethodAccessor的invoke方法">2、调用MethodAccessor的invoke方法</h2><p>Method.invoke()实际上并不是自己实现的反射调用逻辑，而是委托给sun.reflect.MethodAccessor来处理。<br>首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。root对象其声明及注释为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> MethodAccessor methodAccessor;</div><div class="line"><span class="comment">// For sharing of MethodAccessors. This branching structure is</span></div><div class="line"><span class="comment">// currently only two levels deep (i.e., one root Method and</span></div><div class="line"><span class="comment">// potentially many Method objects pointing to it.)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If this branching structure would ever contain cycles, deadlocks can</span></div><div class="line"><span class="comment">// occur in annotation code.</span></div><div class="line"><span class="keyword">private</span> Method  root;</div></pre></td></tr></table></figure></p>
<p>那么MethodAccessor到底是个啥玩意呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** This interface provides the declaration for</span></div><div class="line">    java.lang.reflect.Method.invoke(). Each Method object is</div><div class="line">    configured with a (possibly dynamically-generated) class which</div><div class="line">    implements this interface.</div><div class="line">*/</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</div><div class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Method&#125; */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到MethodAccessor是一个接口，定义了invoke方法。分析其Usage可得它的具体实现类有:</p>
<ul>
<li>sun.reflect.DelegatingMethodAccessorImpl</li>
<li>sun.reflect.MethodAccessorImpl</li>
<li>sun.reflect.NativeMethodAccessorImpl</li>
</ul>
<p>第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建；等第一次调用时才新创建MethodAccessor并更新给root，然后调用MethodAccessor.invoke()完成反射调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NOTE that there is no synchronization used here. It is correct</span></div><div class="line"><span class="comment">// (though not efficient) to generate more than one MethodAccessor</span></div><div class="line"><span class="comment">// for a given Method. However, avoiding synchronization will</span></div><div class="line"><span class="comment">// probably make the implementation more scalable.</span></div><div class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></div><div class="line">    <span class="comment">// if so</span></div><div class="line">    MethodAccessor tmp = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</div><div class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</div><div class="line">        methodAccessor = tmp;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></div><div class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</div><div class="line">        setMethodAccessor(tmp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到methodAccessor实例由reflectionFactory对象操控生成，它在AccessibleObject下的声明如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Reflection factory used by subclasses for creating field,</span></div><div class="line"><span class="comment">// method, and constructor accessors. Note that this is called</span></div><div class="line"><span class="comment">// very early in the bootstrapping process.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ReflectionFactory reflectionFactory =</div><div class="line">    AccessController.doPrivileged(</div><div class="line">        <span class="keyword">new</span> sun.reflect.ReflectionFactory.GetReflectionFactoryAction());</div></pre></td></tr></table></figure>
<p>再研究一下sun.reflect.ReflectionFactory类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Permission reflectionFactoryAccessPerm</div><div class="line">        = <span class="keyword">new</span> RuntimePermission(<span class="string">"reflectionFactoryAccess"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReflectionFactory soleInstance = <span class="keyword">new</span> ReflectionFactory();</div><div class="line">    <span class="comment">// Provides access to package-private mechanisms in java.lang.reflect</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LangReflectAccess langReflectAccess;</div><div class="line"></div><div class="line">    <span class="comment">// 这里设计得非常巧妙</span></div><div class="line">    <span class="comment">// "Inflation" mechanism. Loading bytecodes to implement</span></div><div class="line">    <span class="comment">// Method.invoke() and Constructor.newInstance() currently costs</span></div><div class="line">    <span class="comment">// 3-4x more than an invocation via native code for the first</span></div><div class="line">    <span class="comment">// invocation (though subsequent invocations have been benchmarked</span></div><div class="line">    <span class="comment">// to be over 20x faster). Unfortunately this cost increases</span></div><div class="line">    <span class="comment">// startup time for certain applications that use reflection</span></div><div class="line">    <span class="comment">// intensively (but only once per class) to bootstrap themselves.</span></div><div class="line">    <span class="comment">// To avoid this penalty we reuse the existing JVM entry points</span></div><div class="line">    <span class="comment">// for the first few invocations of Methods and Constructors and</span></div><div class="line">    <span class="comment">// then switch to the bytecode-based implementations.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Package-private to be accessible to NativeMethodAccessorImpl</span></div><div class="line">    <span class="comment">// and NativeConstructorAccessorImpl</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> noInflation        = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>     inflationThreshold = <span class="number">15</span>;</div><div class="line"></div><div class="line">    <span class="comment">//......</span></div><div class="line"></div><div class="line">	<span class="comment">//这是生成MethodAccessor的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">        checkInitted();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</div><div class="line">                generateMethod(method.getDeclaringClass(),</div><div class="line">                               method.getName(),</div><div class="line">                               method.getParameterTypes(),</div><div class="line">                               method.getReturnType(),</div><div class="line">                               method.getExceptionTypes(),</div><div class="line">                               method.getModifiers());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            NativeMethodAccessorImpl acc =</div><div class="line">                <span class="keyword">new</span> NativeMethodAccessorImpl(method);</div><div class="line">            DelegatingMethodAccessorImpl res =</div><div class="line">                <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</div><div class="line">            acc.setParent(res);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//......</span></div><div class="line"></div><div class="line">    <span class="comment">/** We have to defer full initialization of this class until after</span></div><div class="line">    the static initializer is run since java.lang.reflect.Method's</div><div class="line">    static initializer (more properly, that for</div><div class="line">    java.lang.reflect.AccessibleObject) causes this class's to be</div><div class="line">    run, before the system properties are set up. */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkInitted</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initted) <span class="keyword">return</span>;</div><div class="line">        AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="comment">// Tests to ensure the system properties table is fully</span></div><div class="line">                    <span class="comment">// initialized. This is needed because reflection code is</span></div><div class="line">                    <span class="comment">// called very early in the initialization process (before</span></div><div class="line">                    <span class="comment">// command-line arguments have been parsed and therefore</span></div><div class="line">                    <span class="comment">// these user-settable properties installed.) We assume that</span></div><div class="line">                    <span class="comment">// if System.out is non-null then the System class has been</span></div><div class="line">                    <span class="comment">// fully initialized and that the bulk of the startup code</span></div><div class="line">                    <span class="comment">// has been run.</span></div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (System.out == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// java.lang.System not yet fully initialized</span></div><div class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    String val = System.getProperty(<span class="string">"sun.reflect.noInflation"</span>);</div><div class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span> &amp;&amp; val.equals(<span class="string">"true"</span>)) &#123;</div><div class="line">                        noInflation = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    val = System.getProperty(<span class="string">"sun.reflect.inflationThreshold"</span>);</div><div class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            inflationThreshold = Integer.parseInt(val);</div><div class="line">                        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to parse property sun.reflect.inflationThreshold"</span>, e);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    initted = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>观察前面的声明部分的注释，我们可以发现一些有趣的东西。就像注释里说的，实际的MethodAccessor实现有两个版本，一个是Java版本，一个是native版本，两者各有特点。初次启动时Method.invoke()和Constructor.newInstance()方法采用native方法要比Java方法快3-4倍，而启动后native方法又要消耗额外的性能而慢于Java方法。也就是说，Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。这是HotSpot的优化方式带来的性能特性，同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。</p>
<p>为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。</p>
<p>研究ReflectionFactory.newMethodAccessor()生产MethodAccessor对象的逻辑，一开始(native版)会生产NativeMethodAccessorImpl和DelegatingMethodAccessorImpl两个对象。<br>DelegatingMethodAccessorImpl的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Delegates its invocation to another MethodAccessorImpl and can</span></div><div class="line">    change its delegate at run time. */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</div><div class="line"></div><div class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;</div><div class="line">        setDelegate(delegate);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl delegate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.delegate = delegate;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它其实是一个中间层，方便在native版与Java版的MethodAccessor之间进行切换。<br>然后下面就是native版MethodAccessor的Java方面的声明：<br>sun.reflect.NativeMethodAccessorImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Used only for the first few invocations of a Method; afterward,</span></div><div class="line">    switches to bytecode-based implementation */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Method method;</div><div class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</div><div class="line"></div><div class="line">    NativeMethodAccessorImpl(Method method) &#123;</div><div class="line">        <span class="keyword">this</span>.method = method;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// We can't inflate methods belonging to vm-anonymous classes because</span></div><div class="line">        <span class="comment">// that kind of class can't be referred to by name, hence can't be</span></div><div class="line">        <span class="comment">// found from the generated bytecode.</span></div><div class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</div><div class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</div><div class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</div><div class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</div><div class="line">                    generateMethod(method.getDeclaringClass(),</div><div class="line">                                   method.getName(),</div><div class="line">                                   method.getParameterTypes(),</div><div class="line">                                   method.getReturnType(),</div><div class="line">                                   method.getExceptionTypes(),</div><div class="line">                                   method.getModifiers());</div><div class="line">            parent.setDelegate(acc);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每次NativeMethodAccessorImpl.invoke()方法被调用时，程序调用计数器都会增加1，看看是否超过阈值；一旦超过，则调用MethodAccessorGenerator.generateMethod()来生成Java版的MethodAccessor的实现类，并且改变DelegatingMethodAccessorImpl所引用的MethodAccessor为Java版。后续经由DelegatingMethodAccessorImpl.invoke()调用到的就是Java版的实现了。<br>到这里，我们已经追寻到native版的invoke方法在Java一侧声明的最底层 - invoke0了，下面我们将深入到HotSpot JVM中去研究其具体实现。</p>
<h1 id="寻根溯源_-_在JVM层面探究invoke0方法">寻根溯源 - 在JVM层面探究invoke0方法</h1><p>invoke0方法是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jobject JNICALL <span class="title">Java_sun_reflect_NativeMethodAccessorImpl_invoke0</span></span></div><div class="line"><span class="params">(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> JVM_InvokeMethod(env, m, obj, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>openjdk/hotspot/src/share/vm/prims/jvm.cpp<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))</div><div class="line">  JVMWrapper("JVM_InvokeMethod");</div><div class="line">  Handle method_handle;</div><div class="line">  if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) &#123;</div><div class="line">    method_handle = Handle(THREAD, JNIHandles::resolve(method));</div><div class="line">    Handle receiver(THREAD, JNIHandles::resolve(obj));</div><div class="line">    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</div><div class="line">    oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);</div><div class="line">    jobject res = JNIHandles::make_local(env, result);</div><div class="line">    if (JvmtiExport::should_post_vm_object_alloc()) &#123;</div><div class="line">      oop ret_type = java_lang_reflect_Method::return_type(method_handle());</div><div class="line">      assert(ret_type != NULL, "sanity check: ret_type oop must not be NULL!");</div><div class="line">      if (java_lang_Class::is_primitive(ret_type)) &#123;</div><div class="line">        // Only for primitive type vm allocates memory for java object.</div><div class="line">        // See box() method.</div><div class="line">        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">  &#125; else &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_StackOverflowError());</div><div class="line">  &#125;</div><div class="line">JVM_END</div></pre></td></tr></table></figure></p>
<p>其关键部分为Reflection::invoke_method:<br>openjdk/hotspot/src/share/vm/runtime/reflection.cpp<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) &#123;</div><div class="line">  oop mirror             = java_lang_reflect_Method::clazz(method_mirror);</div><div class="line">  int slot               = java_lang_reflect_Method::slot(method_mirror);</div><div class="line">  bool override          = java_lang_reflect_Method::override(method_mirror) != 0;</div><div class="line">  objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));</div><div class="line"></div><div class="line">  oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);</div><div class="line">  BasicType rtype;</div><div class="line">  if (java_lang_Class::is_primitive(return_type_mirror)) &#123;</div><div class="line">    rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);</div><div class="line">  &#125; else &#123;</div><div class="line">    rtype = T_OBJECT;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));</div><div class="line">  Method* m = klass-&gt;method_with_idnum(slot);</div><div class="line">  if (m == NULL) &#123;</div><div class="line">    THROW_MSG_0(vmSymbols::java_lang_InternalError(), "invoke");</div><div class="line">  &#125;</div><div class="line">  methodHandle method(THREAD, m);</div><div class="line"></div><div class="line">  return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面又会涉及到Java的对象模型(klass和oop)，以后继续补充。(<strong>留坑</strong>)</p>
<h1 id="寻根溯源_-_Java版的实现">寻根溯源 - Java版的实现</h1><p>Java版MethodAccessor的生成使用MethodAccessorGenerator实现，由于代码太长，这里就不贴代码了，只贴一下开头的注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Generator for sun.reflect.MethodAccessor and</span></div><div class="line">    sun.reflect.ConstructorAccessor objects using bytecodes to</div><div class="line">    implement reflection. A java.lang.reflect.Method or</div><div class="line">    java.lang.reflect.Constructor object can delegate its invoke or</div><div class="line">    newInstance method to an accessor using native code or to one</div><div class="line">    generated by this class. (Methods and Constructors were merged</div><div class="line">    together in this class to ensure maximum code sharing.) */</div></pre></td></tr></table></figure></p>
<p>这里运用了asm动态生成字节码技术（sun.reflect.ClassFileAssembler)，原理比较复杂，后面讲到AOP要用到asm技术的时候再深入了解一下吧。</p>
<h1 id="本篇总结">本篇总结</h1><p>简单地画了个图表示invoke方法的过程，日后再更时序图：</p>
<p><img src="http://img.blog.csdn.net/20150626130739796" alt="invoke方法的过程"></p>
<h1 id="番外篇">番外篇</h1><ol>
<li>MagicAccessorImpl是什么鬼？</li>
</ol>
<p>原本Java的安全机制使得不同类之间不是任意信息都可见，但JDK里面专门设了个MagicAccessorImpl标记类开了个后门来允许不同类之间信息可以互相访问（由JVM管理）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** &lt;P&gt; MagicAccessorImpl (named for parity with FieldAccessorImpl and</span></div><div class="line">    others, not because it actually implements an interface) is a</div><div class="line">    marker class in the hierarchy. All subclasses of this class are</div><div class="line">    "magically" granted access by the VM to otherwise inaccessible</div><div class="line">    fields and methods of other classes. It is used to hold the code</div><div class="line">    for dynamically-generated FieldAccessorImpl and MethodAccessorImpl</div><div class="line">    subclasses. (Use of the word "unsafe" was avoided in this class's</div><div class="line">    name to avoid confusion with &#123;<span class="doctag">@link</span> sun.misc.Unsafe&#125;.) &lt;/P&gt;</div><div class="line"></div><div class="line">    &lt;P&gt; The bug fix for 4486457 also necessitated disabling</div><div class="line">    verification for this class and all subclasses, as opposed to just</div><div class="line">    SerializationConstructorAccessorImpl and subclasses, to avoid</div><div class="line">    having to indicate to the VM which of these dynamically-generated</div><div class="line">    stub classes were known to be able to pass the verifier. &lt;/P&gt;</div><div class="line"></div><div class="line">    &lt;P&gt; Do not change the name of this class without also changing the</div><div class="line">    VM's code. &lt;/P&gt; */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicAccessorImpl</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>@CallerSensitive注解又是什么鬼？</li>
</ol>
<p>详见：<a href="http://openjdk.java.net/jeps/176" target="_blank" rel="external">JEP 176: Mechanical Checking of Caller-Sensitive Methods</a></p>
<blockquote>
<p>Summary: Improve the security of the JDK’s method-handle implementation by replacing the existing hand-maintained list of caller-sensitive methods with a mechanism that accurately identifies such methods and allows their callers to be discovered reliably.</p>
</blockquote>
<p>JDK 1.8才引进了这个注解，因此在老版本的反射实现里并没有这个玩意。这是它的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A method annotated <span class="doctag">@CallerSensitive</span> is sensitive to its calling class,</div><div class="line"> * via &#123;<span class="doctag">@link</span> sun.reflect.Reflection#getCallerClass Reflection.getCallerClass&#125;,</div><div class="line"> * or via some equivalent.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> John R. Rose</div><div class="line"> */</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;METHOD&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CallerSensitive &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简而言之，用<code>@CallerSensitive</code>注解修饰的方法从一开始就知道具体调用它的对象，这样就不用再经过一系列的检查才能确定具体调用它的对象了。它实际上是调用<code>sun.reflect.Reflection.getCallerClass</code>方法。</p>
<p>Reflection类位于调用栈中的0帧位置，<code>sun.reflect.Reflection.getCallerClass()</code>方法返回调用栈中从0帧开始的第x帧中的类实例。该方法提供的机制可用于确定调用者类，从而实现“感知调用者（Caller Sensitive）”的行为，即允许应用程序根据调用类或调用栈中的其它类来改变其自身的行为。</p>
<hr>
<h1 id="Reference">Reference</h1><ul>
<li><a href="http://openjdk.java.net/jeps/176" target="_blank" rel="external">JEP 176: Mechanical Checking of Caller-Sensitive Methods</a></li>
<li><a href="http://stackoverflow.com/questions/22626808/what-does-the-sun-reflect-callersensitive-annotation-mean" target="_blank" rel="external">StackOverflow上关于@CallerSensitive的回答</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/548536" target="_blank" rel="external">关于反射调用方法的一个log (R大的一篇文章)</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reflection/">Reflection</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-reflection-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-reflection-1/" class="article-date">
      <time datetime="2015-06-23T16:00:00.000Z" itemprop="datePublished">2015-06-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-reflection-1/">深入解析Java反射（1） - 基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>因为本人最近正筹备<a href="http://www.sczyh30.com/samsara">Samsara</a>框架的开发，而其中的IOC部分非常依靠反射，因此趁这个机会来总结一下关于Java反射的一些知识。本篇为基本篇，基于JDK 1.8。</p>
<hr>
<h2 id="一、回顾：什么是反射？">一、回顾：什么是反射？</h2><p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>Oracle官方对反射的解释是</p>
<blockquote>
<p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p>
</blockquote>
<p>&emsp;简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。<br>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br>&emsp;反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java反射框架主要提供以下功能：</p>
<ul>
<li>1.在运行时判断任意一个对象所属的类；</li>
<li>2.在运行时构造任意一个类的对象；</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>4.在运行时调用任意一个对象的方法<h5 id="重点：是运行时而不是编译时">重点：<strong>是运行时而不是编译时</strong></h5></li>
</ul>
<h2 id="二、反射的主要用途">二、反射的主要用途</h2><p>&emsp;很多人都认为反射在实际的Java开发应用中并不广泛，其实不然。<br>&emsp;当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。<br>&emsp;<strong>反射最重要的用途就是开发各种通用框架。</strong><br>&emsp;很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。<br>&emsp;举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span></span></div><div class="line">               <span class="attr">class</span>=<span class="string">"org.ScZyhSoft.test.action.SimpleLoginAction"</span></div><div class="line">               <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</div><div class="line">           <span class="tag">&lt;<span class="name">result</span>&gt;</span>/shop/shop-index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。<br>——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。<br>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
<h2 id="三、反射的基本运用">三、反射的基本运用</h2><p>上面我们提到了反射可以用于判断任意对象所属的类，获得Class对象，构造任意一个对象以及调用一个对象。这里我们介绍一下基本反射功能的实现(反射相关的类一般都在java.lang.relfect包里)。</p>
<h4 id="1、获得Class对象">1、获得Class对象</h4><p>方法有三种<br>(1)使用Class类的forName静态方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</div><div class="line">``` </div><div class="line">在JDBC开发中常用此方法加载数据库驱动:</div><div class="line">```java</div><div class="line"> Class.forName(driver);</div></pre></td></tr></table></figure></p>
<p>(2)直接获取某一个对象的class，比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</div><div class="line">Class&lt;?&gt; classInt = Integer.TYPE;</div></pre></td></tr></table></figure></p>
<p>(3)调用某个对象的getClass()方法,比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</div><div class="line">Class&lt;?&gt; klass = str.getClass();</div></pre></td></tr></table></figure></p>
<h4 id="2、判断是否为某个类的实例">2、判断是否为某个类的实例</h4><p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="3、创建实例">3、创建实例</h4><p>通过反射来生成对象主要有两种方式。<br>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line">Object str = c.newInstance();</div></pre></td></tr></table></figure></p>
<p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取String所对应的Class对象</span></div><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line"><span class="comment">//获取String类带一个String参数的构造器</span></div><div class="line">Constructor constructor = c.getConstructor(String.class);</div><div class="line"><span class="comment">//根据构造器创建实例</span></div><div class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</div><div class="line">System.out.println(obj);</div></pre></td></tr></table></figure></p>
<h4 id="4、获取方法">4、获取方法</h4><p>获取某个Class对象的方法集合，主要有以下几个方法：<br>getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></div></pre></td></tr></table></figure></p>
<p>只是这样描述的话可能难以理解，我们用例子来理解这三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.ScZyhSoft.common;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line">	        Class&lt;?&gt; c = methodClass.class;</div><div class="line">	        Object object = c.newInstance();</div><div class="line">	        Method[] methods = c.getMethods();</div><div class="line">	        Method[] declaredMethods = c.getDeclaredMethods();</div><div class="line">	        <span class="comment">//获取methodClass类的add方法</span></div><div class="line">	        Method method = c.getMethod(<span class="string">"add"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</div><div class="line">	        <span class="comment">//getMethods()方法获取的所有方法</span></div><div class="line">	        System.out.println(<span class="string">"getMethods获取的方法："</span>);</div><div class="line">	        <span class="keyword">for</span>(Method m:methods)</div><div class="line">	            System.out.println(m);</div><div class="line">	        <span class="comment">//getDeclaredMethods()方法获取的所有方法</span></div><div class="line">	        System.out.println(<span class="string">"getDeclaredMethods获取的方法："</span>);</div><div class="line">	        <span class="keyword">for</span>(Method m:declaredMethods)</div><div class="line">	            System.out.println(m);</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序运行的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">getMethods获取的方法：</div><div class="line">public int org.ScZyhSoft.common.methodClass.add(int,int)</div><div class="line">public int org.ScZyhSoft.common.methodClass.sub(int,int)</div><div class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</div><div class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</div><div class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</div><div class="line">public boolean java.lang.Object.equals(java.lang.Object)</div><div class="line">public java.lang.String java.lang.Object.toString()</div><div class="line">public native int java.lang.Object.hashCode()</div><div class="line">public final native java.lang.Class java.lang.Object.getClass()</div><div class="line">public final native void java.lang.Object.notify()</div><div class="line">public final native void java.lang.Object.notifyAll()</div><div class="line">getDeclaredMethods获取的方法：</div><div class="line">public int org.ScZyhSoft.common.methodClass.add(int,int)</div><div class="line">public int org.ScZyhSoft.common.methodClass.sub(int,int)</div></pre></td></tr></table></figure></p>
<p>可以看到，通过getMethods()获取的方法可以获取到父类的方法,比如java.lang.Object下定义的各个方法。</p>
<h4 id="5、获取构造器信息">5、获取构造器信息</h4><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></div></pre></td></tr></table></figure></p>
<p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例~</p>
<h4 id="6、获取类的成员变量（字段）信息">6、获取类的成员变量（字段）信息</h4><p>主要是这几个方法，在此不再赘述：<br><em>getFiled</em>: 访问公有的成员变量<br><em>getDeclaredField</em>：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）</p>
<h4 id="7、调用方法">7、调用方法</h4><p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</div><div class="line">           InvocationTargetException</div></pre></td></tr></table></figure></p>
<p>下面是一个实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line">        Class&lt;?&gt; klass = methodClass.class;</div><div class="line">        <span class="comment">//创建methodClass的实例</span></div><div class="line">        Object obj = klass.newInstance();</div><div class="line">        <span class="comment">//获取methodClass类的add方法</span></div><div class="line">        Method method = klass.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</div><div class="line">        <span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></div><div class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于invoke()方法的详解，后面我会专门写一篇文章来深入解析invoke的过程。</p>
<h4 id="8、利用反射创建数组">8、利用反射创建数组</h4><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);</div><div class="line">        Object array = Array.newInstance(cls,<span class="number">25</span>);</div><div class="line">        <span class="comment">//往数组里添加内容</span></div><div class="line">        Array.set(array,<span class="number">0</span>,<span class="string">"hello"</span>);</div><div class="line">        Array.set(array,<span class="number">1</span>,<span class="string">"Java"</span>);</div><div class="line">        Array.set(array,<span class="number">2</span>,<span class="string">"fuck"</span>);</div><div class="line">        Array.set(array,<span class="number">3</span>,<span class="string">"Scala"</span>);</div><div class="line">        Array.set(array,<span class="number">4</span>,<span class="string">"Clojure"</span>);</div><div class="line">        <span class="comment">//获取某一项的内容</span></div><div class="line">        System.out.println(Array.get(array,<span class="number">3</span>));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中的Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></div><div class="line">        <span class="keyword">throws</span> NegativeArraySizeException &#123;</div><div class="line">        <span class="keyword">return</span> newArray(componentType, length);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>而newArray()方法是一个Native方法，它在Hotspot JVM里的具体实现我们后边再研究，这里先把源码贴出来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newArray</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></div><div class="line">        <span class="keyword">throws</span> NegativeArraySizeException;</div></pre></td></tr></table></figure></p>
<p>源码目录:openjdk\hotspot\src\share\vm\runtime\reflection.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) &#123;</div><div class="line">  <span class="keyword">if</span> (element_mirror == <span class="literal">NULL</span>) &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_NullPointerException());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_NegativeArraySizeException());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (java_lang_Class::is_primitive(element_mirror)) &#123;</div><div class="line">    Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);</div><div class="line">    <span class="keyword">return</span> TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    Klass* k = java_lang_Class::as_Klass(element_mirror);</div><div class="line">    <span class="keyword">if</span> (k-&gt;oop_is_array() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) &#123;</div><div class="line">      THROW_0(vmSymbols::java_lang_IllegalArgumentException());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> oopFactory::new_objArray(k, length, THREAD);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外，Array类的set()和get()方法都为Native方法，在HotSpot JVM里分别对应Reflection::array_set和Reflection::array_get方法，这里就不详细解析了。</p>
<h2 id="四、反射的一些注意事项（待补充）">四、反射的一些注意事项（待补充）</h2><p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。<br>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。<br><img src="http://img.my.csdn.net/uploads/201508/02/1438529905_8952.jpg" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reflection/">Reflection</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jvm-memory" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-memory/" class="article-date">
      <time datetime="2015-06-23T16:00:00.000Z" itemprop="datePublished">2015-06-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-memory/">深入探究JVM | Java的内存区域解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Java 虚拟机在执行Java程序的时候会把它管理的内存区域划为几部分，这一节我们就来解析一下Java的内存区域。</p>
<hr>
<p>有的人把JVM管理的内存简单地分为堆内存和栈内存，这样分未免有些太肤浅了。<br>Java的内存区域主要分为五部分：</p>
<ul>
<li>程序计数器(PC)</li>
<li>虚拟机栈(JVM Stack)</li>
<li>本地方法栈(Native Method Stack)</li>
<li>Java 堆内存(Java Heap)</li>
<li>方法区(Method Area)</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150626182021585" alt="Java内存区域"><br>（图转自网络）</p>
<p>下面我们来解析这几个区域。</p>
<h2 id="程序计数器">程序计数器</h2><p>相信学过计算机组成原理的人都知道，CPU内部的寄存器中就包含一个程序计数器（x86下为eip寄存器,ARM下为R15寄存器），存放程序执行的下一条指令地址。在程序开始执行前，将程序指令序列的起始地址，即程序的第一条指令所在的内存单元地址送入PC，CPU按照PC的地址从内存中读取第一条指令。每一条指令执行时，CPU会自动修改PC的量至下一条指令的地址，指令之间的跳转离不开PC。JVM内存中的程序计数器也是这样的作用，它储存JVM当前执行bytecode的地址。</p>
<p>Java虚拟机允许多个线程同时执行指令。如果有多个线程正在执行指令，那么每个线程都会有一个程序计数器，它是线程私有的。在任意时刻，一个线程只允许执行一个方法的代码。每当执行到一条Java方法的指令时，程序计数器保存当前执行字节码的地址；若执行的为native方法，则PC的值为undefined。</p>
<h2 id="Java_虚拟机栈">Java 虚拟机栈</h2><p>Java虚拟机栈也是线程私有的，每一条线程都拥有自己私有的Java 虚拟机栈，它与线程同时创建。它描述了Java方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong>，用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。每一个方法从调用直至完成的过程，都对应一个栈帧从入栈到出栈的过程。关于栈帧详细的内容在后边复习虚拟机字节码执行引擎的时候再说吧。<br>Java 虚拟机栈在方法调用和返回中也扮演了很重要的角色。因为除了栈帧的入栈和出栈之外，Java虚拟机栈不会再受其它因素的影响，因此栈帧可在<strong>系统的堆</strong>上分配内存（<strong>注意</strong>，是系统的Heap而不是Java Heap）。Java虚拟机栈所使用的内存不需要保证是连续的。</p>
<h2 id="本地方法栈">本地方法栈</h2><p>本地方法栈和Java虚拟机栈的作用相似，Java虚拟机栈执行的是字节码，而本地方法栈执行的是native方法。本地方法栈使用<strong>传统的栈</strong>（C Stack）来支持native方法。在HotSpot JVM中Java虚拟机栈和本地方法栈合二为一。</p>
<h2 id="Java_堆">Java 堆</h2><p>在JVM中，Java 堆是可供各线程共享的运行时内存区域，是Java 虚拟机所管理的内存区域中最大的一块。此区域非常重要，<strong>几乎所有的对象实例和数组实例都要在Java堆上分配</strong>，但随着JIT编译器及逃逸分析技术的发展，也可能会被优化为栈上分配，高大上。。。）。同时，Java 堆也是发生GC收集的主要区域。<br>从内存回收的角度来看，它可以分为<strong>新生代</strong>和<strong>老年代</strong>，再细分可以分为Eden Space,From Survivor Space,To Survivor Space区域。Java堆的容量可以是固定的，也可以随着需要来扩展，并且在用不到的时候自动收缩。</p>
<h2 id="方法区">方法区</h2><p>方法区是线程共享的，它储存了<strong>每一个类的结构信息</strong>，比如运行时常量池（runtime constant pool）、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些初始化的时候用到的特殊方法。<strong>方法区是堆的逻辑部分。</strong><br>在JDK1.7及以前的HotSpot JVM中，方法区位于<em>永久代</em>（Permanent Generation，<em>PermGen</em>）中。由于永久代内可能会发生内存泄露或溢出等问题而导致的<em>java.lang.OutOfMemoryError: PermGen </em>，JEP小组从JDK1.7开始就筹划移除永久代（<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a>），并且在JDK 1.7中把字符串常量，符号引用等移出了永久代。到了Java 8，永久代被彻底地移出了JVM，取而代之的是<em>元空间</em>（Metaspace）：</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.</p>
</blockquote>
<p>所以从Java 8开始，方法区被移至 <em>Metaspace</em> 内。有关Metaspace的相关总结，见下一篇文章。</p>
<h2 id="运行时常量池">运行时常量池</h2><p>运行时常量池是class文件中每一个类或接口的常量池表的运行时表示形式，是方法区的一部分。它包括了若干种不同的常量。常量池表存放<strong>编译器生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池具有动态性，运行期间也可以将新的量放到运行时常量池中，典型的应用是String类的intern方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p>
<p>JDK 1.7开始，字符串常量和符号引用等就被移出永久代：</p>
<ul>
<li>符号引用迁移至系统堆内存(<em>Native Heap</em>)</li>
<li>字符串字面量迁移至Java堆(<em>Java Heap</em>)</li>
</ul>
<p><strong>下一篇文章我将会总结Java 8中的Metaspace相关知识</strong>。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》，周志明 著</li>
<li><a href="http://stackoverflow.com/questions/24074164/what-is-the-use-of-metaspace-in-java-8" target="_blank" rel="external">What is the use of Metaspace in Java 8? - StackOverflow</a></li>
<li><a href="https://blogs.oracle.com/poonam/entry/about_g1_garbage_collector_permanent" target="_blank" rel="external">About G1 Garbage Collector, Permanent Generation and Metaspace</a></li>
<li><em>The Java Virtual Machine Specification, Java SE 8 Edition, Oracle</em></li>
<li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存区域/">内存区域</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-docker-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Architecture/docker-tutorial/" class="article-date">
      <time datetime="2015-06-08T16:12:36.000Z" itemprop="datePublished">2015-06-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Architecture/docker-tutorial/">Docker入门学习札记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>很早之前就听说过Docker，但一直木有实践过。前一阵子参加OSC的源创会时，里面嘉宾讲的东西提到了Docker，感觉Docker是一个很有意义的工具，于是就学习了一下它的基本用法，在此总结一下。</p>
<p>以我的理解，Docker是一种虚拟化容器，这个容器里可以运行各种程序，是一种轻量级的虚拟化技术，使用Golang编写。它与传统的虚拟化技术（KVM和Xen）的区别是，Docker容器是操作系统层面上的虚拟化（<strong>内核级</strong>），基于LXC技术，直接服用本地操作系统，而传统的虚拟化技术则是从硬件方面进行虚拟化。它的好处是，启动特别快，而且对系统资源的利用率较高，一台机器上可以运行很多Docker容器，而且因为Docker非常轻量，它为快速部署提供了很好的技术支持。并且Docker引入了版本控制的思想，可以更好地持续构建和部署。</p>
<p>下面总结一下Docker的基本用法：</p>
<h2 id="安装">安装</h2><p>用apt-get或者yum安装都是坑，基本上都不是最新版本的。要安装还是用官方的命令安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.docker.com/ | sh</div></pre></td></tr></table></figure>
<p>不过由于Docker的安装文件存放在Amazon S3上，会间接性抽风，因此最好找个国内的源。</p>
<p>（2015-7 补充：DaoCloud是不错的选择，服务很好）</p>
<h2 id="容器与镜像">容器与镜像</h2><p>Docker容器可以理解为运行在沙盒里的进程。</p>
<p>通俗地讲，镜像（images）相当于一个类，而容器（container）相当于类的一个实例。容器可以不断地被修改，并通过commit化为一个镜像。</p>
<h2 id="基本命令">基本命令</h2><p>主要有：</p>
<h3 id="Docker信息">Docker信息</h3><p>查看Docker版本：<code>docker version</code><br>登录至远程库：<code>docker login</code></p>
<h3 id="镜像操作">镜像操作</h3><p>列出镜像列表：<code>docker images</code><br>删除镜像：<code>docker rmi [id]</code><br>搜索镜像：<code>docker search [name]</code><br>从远程拉取镜像：<code>docker pull [name]:[tag]</code><br>将镜像发布至远程：<code>docker push [name]</code></p>
<h3 id="容器运行"><strong>容器运行</strong></h3><p>容器运行用<code>docker run</code>命令，它有一些详细的参数很有用，比如：<br>以交互模式启动容器centos:latest : <code>docker run -i - t centos:latest /bin/bash</code><br><code>-i</code>表示支持输入，<code>-t</code>表示命令行交互。<br>以后台模式运行，并进行端口映射: <code>docker run -d -p 8080:8080 sczyh30/tomcat:v1 /start.sh</code><br><code>-d</code>表示daemon，即以后台方式运行。<code>-p</code>表示端口映射。<br>这里用的时候有个比较fucking的地方，如果运行容器的时候相应的命令不阻塞，那么容器会自动结束运行（比如resin）。看来以后运行命令要加个阻塞的命令咯~<br>另外对于在容器里自动执行apt-get命令时，一定要加上-y，否则容器虽然进入交互模式但却无法响应，运行完即退出。</p>
<h3 id="容器管理">容器管理</h3><p>查看正在运行的容器：<code>docker ps</code><br>查看所有容器：<code>docker ps -a</code><br>删除容器：<code>docker rm [name/id]</code><br>删除所有容器：<code>docker rm &#39;docker ps -a -q&#39;</code><br>停止、启动、杀死一个容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$docker</span> stop [Name/ID]</div><div class="line"><span class="variable">$docker</span> start [Name/ID]</div><div class="line"><span class="variable">$docker</span> <span class="built_in">kill</span> [Name/ID]</div></pre></td></tr></table></figure></p>
<p>从容器中读取日志：<code>docker logs [Name/ID]</code><br>列出更改项：<code>docker diff [Name/ID]</code><br>从容器中拷贝文件至本机：<code>docker cp ID:/container_path to_path</code><br>附加到一个运行的容器上：<code>docker attach [ID]</code></p>
<h2 id="容器的简单构建">容器的简单构建</h2><p>通过命令操作来部署容器显然很麻烦，所以通过Dockerfile进行自动化容器构建是非常方便的。<br>这里我自己写了一个简单的Dockerfile来练练手，这是一个用于构建Hexo博客的Dockerfile：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#构建的镜像基础</span></div><div class="line"><span class="keyword">FROM</span> node:slim</div><div class="line"><span class="comment">#维护者</span></div><div class="line"><span class="keyword">MAINTAINER</span> sczyh30 root@sczyh30.com</div><div class="line"><span class="comment">#执行命令用RUN，注意要遇到需要交互的地方加-y</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></div><div class="line">    &amp;&amp; apt-get install -y git ssh-client ca-certificates --no-install-recommends \</div><div class="line">    &amp;&amp; rm -r /var/lib/apt/lists/*</div><div class="line"><span class="comment">#更改时区</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone \</span></div><div class="line">    &amp;&amp; dpkg-reconfigure <span class="_">-f</span> noninteractive tzdata</div><div class="line"><span class="comment">#安装hexo</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> npm install hexo-cli -g</span></div><div class="line"><span class="comment">#初始化</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> / &amp;&amp; hexo init blog &amp;&amp; <span class="built_in">cd</span> blog &amp;&amp; npm install</span></div><div class="line"><span class="comment">#设定默认工作目录</span></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /blog</span></div><div class="line"><span class="comment">#设定暴露端口</span></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></div><div class="line"><span class="comment">#设定容器运行时执行的命令，只能有一条，若多条则执行最后一条</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> hexo s</span></div></pre></td></tr></table></figure></p>
<p>然后在此目录执行构建：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t sczyh30/simple_test:v1 .</div></pre></td></tr></table></figure></p>
<p>.表示在当前目录构建<br>docker build的一些参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">--no-cache=false Do not use cache when building the image</div><div class="line">     -q, --quiet=false Suppress the verbose output generated by the containers</div><div class="line">     --rm=true Remove intermediate containers after a successful build</div><div class="line">     -t, --tag=&quot;&quot; Repository name (and optionally a tag) to be applied to the resulting image in case of success</div></pre></td></tr></table></figure></p>
<p>执行后就会按照Dockerfile的内容进行构建，过几分钟构建成功，用docker run运行一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 80:4000 sczyh30/simple_test:v1</div></pre></td></tr></table></figure></p>
<p>运行成功~在docker ps里可以看到容器已成功运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS              PORTS                  NAMES</div><div class="line">45782259f2c3        sczyh30/simple_test:v1     <span class="string">"/bin/sh -c 'hexo s'"</span>   2 minutes ago        Up 2 minutes         0.0.0.0:80-&gt;4000/tcp   trusting_ramanujan</div></pre></td></tr></table></figure></p>
<p>在浏览器中打开，一个简单的Hexo已经搭好咯~</p>
<p>总结一下，Dockerfile非常方便，以后用它构建容器进行集群部署貌似是不错的选择呢~<br>后面将进行更多的关于Docker的实践。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Architecture/">Architecture</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟化/">虚拟化</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/7/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2017 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30 <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 7;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>