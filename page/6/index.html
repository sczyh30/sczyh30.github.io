<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>「千载弦歌，芳华如梦」 - sczyh30&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--<meta name="keywords" content="sczyh30, blog"/>-->
  <meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/page/6/index.html">
<meta property="og:site_name" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">
  
    <link rel="alternative" href="/atom.xml" title="「千载弦歌，芳华如梦」 - sczyh30&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="/#" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/AIO/" style="font-size: 10px;">AIO</a> <a href="/tags/AMQP/" style="font-size: 10px;">AMQP</a> <a href="/tags/APT/" style="font-size: 10px;">APT</a> <a href="/tags/Akka-Actor/" style="font-size: 10px;">Akka Actor</a> <a href="/tags/Algorithm/" style="font-size: 14px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 16px;">C++</a> <a href="/tags/C-11/" style="font-size: 10px;">C++ 11</a> <a href="/tags/CE3/" style="font-size: 10px;">CE3</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Category-Theory/" style="font-size: 10px;">Category Theory</a> <a href="/tags/Chemistry/" style="font-size: 11px;">Chemistry</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Docker/" style="font-size: 11px;">Docker</a> <a href="/tags/Engine/" style="font-size: 10px;">Engine</a> <a href="/tags/Euterpea/" style="font-size: 10px;">Euterpea</a> <a href="/tags/FRP/" style="font-size: 10px;">FRP</a> <a href="/tags/Functional-Programming/" style="font-size: 18px;">Functional Programming</a> <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/GC/" style="font-size: 13px;">GC</a> <a href="/tags/GDB/" style="font-size: 10px;">GDB</a> <a href="/tags/Game/" style="font-size: 11px;">Game</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/Haskell/" style="font-size: 14px;">Haskell</a> <a href="/tags/HotSpot/" style="font-size: 12px;">HotSpot</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 19px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Klass-oop/" style="font-size: 10px;">Klass-oop</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/MIDI/" style="font-size: 10px;">MIDI</a> <a href="/tags/Mathematical-Logic/" style="font-size: 10px;">Mathematical Logic</a> <a href="/tags/Metaspace/" style="font-size: 10px;">Metaspace</a> <a href="/tags/Netflix-Hystrix/" style="font-size: 10px;">Netflix Hystrix</a> <a href="/tags/Network/" style="font-size: 16px;">Network</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Object-Model/" style="font-size: 12px;">Object Model</a> <a href="/tags/Play-Framework/" style="font-size: 11px;">Play Framework</a> <a href="/tags/Quorum/" style="font-size: 10px;">Quorum</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Reflection/" style="font-size: 11px;">Reflection</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/STL/" style="font-size: 11px;">STL</a> <a href="/tags/Scala/" style="font-size: 19px;">Scala</a> <a href="/tags/Slick/" style="font-size: 11px;">Slick</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Struct/" style="font-size: 10px;">Struct</a> <a href="/tags/Summary/" style="font-size: 12px;">Summary</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/Type-Lambda/" style="font-size: 10px;">Type Lambda</a> <a href="/tags/Type-System/" style="font-size: 10px;">Type System</a> <a href="/tags/Type-Theory/" style="font-size: 12px;">Type Theory</a> <a href="/tags/UE4/" style="font-size: 10px;">UE4</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/Vert-x/" style="font-size: 12px;">Vert.x</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Web/" style="font-size: 12px;">Web</a> <a href="/tags/Web开发/" style="font-size: 11px;">Web开发</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/functional/" style="font-size: 10px;">functional</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/事务/" style="font-size: 10px;">事务</a> <a href="/tags/云服务/" style="font-size: 12px;">云服务</a> <a href="/tags/内存区域/" style="font-size: 10px;">内存区域</a> <a href="/tags/分布式系统/" style="font-size: 11px;">分布式系统</a> <a href="/tags/前端/" style="font-size: 12px;">前端</a> <a href="/tags/基础/" style="font-size: 10px;">基础</a> <a href="/tags/多线程/" style="font-size: 11px;">多线程</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/并发/" style="font-size: 13px;">并发</a> <a href="/tags/开发/" style="font-size: 17px;">开发</a> <a href="/tags/异步/" style="font-size: 13px;">异步</a> <a href="/tags/异步编程/" style="font-size: 11px;">异步编程</a> <a href="/tags/微服务/" style="font-size: 12px;">微服务</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 11px;">数据库</a> <a href="/tags/架构/" style="font-size: 11px;">架构</a> <a href="/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Fighting</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="/#" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-jvm-copyArray" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-copyArray/" class="article-date">
      <time datetime="2015-09-07T16:00:00.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-copyArray/">arrayCopy方法底层探究</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近在读Java集合类的源码时发现很多数组的复制操作最后都归结到arraycopy方法上，这是一个native方法。本人对JVM底层实现具有极大的兴趣，因此就探寻了一下它的底层实现。<br><code>arraycopy</code>方法的声明（Native Method）:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span><br><span class="line">                                        Object dest, <span class="keyword">int</span> destPos,</span><br><span class="line">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它的native方法入口位于openjdk-8/openjdk/hotspot/src/share/vm/prims/jvm.cpp中:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,</span><br><span class="line">                               jobject dst, jint dst_pos, jint length))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_ArrayCopy"</span>);</span><br><span class="line">  <span class="comment">// Check if we have null pointers</span></span><br><span class="line">  <span class="keyword">if</span> (src == NULL || dst == NULL) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_NullPointerException());</span><br><span class="line">  &#125;</span><br><span class="line">  arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));</span><br><span class="line">  arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));</span><br><span class="line">  assert(s-&gt;is_oop(), <span class="string">"JVM_ArrayCopy: src not an oop"</span>);</span><br><span class="line">  assert(d-&gt;is_oop(), <span class="string">"JVM_ArrayCopy: dst not an oop"</span>);</span><br><span class="line">  <span class="comment">// Do copy</span></span><br><span class="line">  s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></p>
<p>可以看到，此方法首先先解析原数组和目标数组为底层的对象模型（这里为arrayOop)<br>真正执行数组拷贝的是最后一行代码中的<code>copy_array</code>方法，它有两种实现。</p>
<h4 id="正经的copy_array方法">正经的copy_array方法</h4><p>先看简单的一种吧，它的源码位于openjdk-8/openjdk/hotspot/src/share/vm/oops/typeArrayKlass.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TypeArrayKlass::copy_array(arrayOop s, <span class="keyword">int</span> src_pos, arrayOop d, <span class="keyword">int</span> dst_pos, <span class="keyword">int</span> length, TRAPS) &#123;</span><br><span class="line">  assert(s-&gt;<span class="keyword">is_t</span>ypeArray(), <span class="string">"must be type array"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check destination</span></span><br><span class="line">  <span class="keyword">if</span> (!d-&gt;<span class="keyword">is_t</span>ypeArray() || <span class="keyword">element_t</span>ype() != TypeArrayKlass::cast(d-&gt;klass())-&gt;<span class="keyword">element_t</span>ype()) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayStoreException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check is all offsets and lengths are non negative</span></span><br><span class="line">  <span class="keyword">if</span> (src_pos &lt; <span class="number">0</span> || dst_pos &lt; <span class="number">0</span> || length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check if the ranges are valid</span></span><br><span class="line">  <span class="keyword">if</span>  ( (((<span class="keyword">unsigned</span> <span class="keyword">int</span>) length + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) src_pos) &gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>) s-&gt;length())</span><br><span class="line">     || (((<span class="keyword">unsigned</span> <span class="keyword">int</span>) length + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) dst_pos) &gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>) d-&gt;length()) ) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check zero copy</span></span><br><span class="line">  <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is an attempt to make the copy_array fast.</span></span><br><span class="line">  <span class="keyword">int</span> l2es = log2_element_size();</span><br><span class="line">  <span class="keyword">int</span> ihs = array_header_in_bytes() / wordSize;</span><br><span class="line">  <span class="keyword">char</span>* src = (<span class="keyword">char</span>*) ((oop*)s + ihs) + ((<span class="keyword">size_t</span>)src_pos &lt;&lt; l2es);</span><br><span class="line">  <span class="keyword">char</span>* dst = (<span class="keyword">char</span>*) ((oop*)d + ihs) + ((<span class="keyword">size_t</span>)dst_pos &lt;&lt; l2es);</span><br><span class="line">  Copy::conjoint_memory_atomic(src, dst, (<span class="keyword">size_t</span>)length &lt;&lt; l2es);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面仍然先是验证操作：首先验证目标对象是否为数组，再验证源数组与目标数组的类型是否相同（若不相同就会抛出ArrayStoreException异常），再验证数组的容量是否为负（若为负则抛出ArrayIndexOutOfBoundsException异常），最后再检验数组边界范围是否正常。<br>验证完操作后就开始执行复制操作（空数组则直接结束）。<br>这里首先对source和destination进行了某些优化，来让数组拷贝更快，但是木有看懂：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l2es = log2_element_size();</span><br><span class="line"><span class="keyword">int</span> ihs = array_header_in_bytes() / wordSize;</span><br><span class="line"><span class="keyword">char</span>* src = (<span class="keyword">char</span>*) ((oop*)s + ihs) + ((<span class="keyword">size_t</span>)src_pos &lt;&lt; l2es);</span><br><span class="line"><span class="keyword">char</span>* dst = (<span class="keyword">char</span>*) ((oop*)d + ihs) + ((<span class="keyword">size_t</span>)dst_pos &lt;&lt; l2es);</span><br></pre></td></tr></table></figure></p>
<p>此处先不讨论这个优化。数组真正的复制操作又落在<code>Copy::conjoint_memory_atomic</code>这个方法上：<br>（位于openjdk-8/openjdk/hotspot/src/share/vm/utilities/copy.cpp）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy bytes; larger units are filled atomically if everything is aligned.</span></span><br><span class="line"><span class="keyword">void</span> Copy::conjoint_memory_atomic(<span class="keyword">void</span>* from, <span class="keyword">void</span>* to, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">  address src = (address) from;</span><br><span class="line">  address dst = (address) to;</span><br><span class="line">  <span class="keyword">uintptr_t</span> bits = (<span class="keyword">uintptr_t</span>) src | (<span class="keyword">uintptr_t</span>) dst | (<span class="keyword">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (Note:  We could improve performance by ignoring the low bits of size,</span></span><br><span class="line">  <span class="comment">// and putting a short cleanup loop after each bulk copy loop.</span></span><br><span class="line">  <span class="comment">// There are plenty of other ways to make this faster also,</span></span><br><span class="line">  <span class="comment">// and it's a slippery slope.  For now, let's keep this code simple</span></span><br><span class="line">  <span class="comment">// since the simplicity helps clarify the atomicity semantics of</span></span><br><span class="line">  <span class="comment">// this operation.  There are also CPU-specific assembly versions</span></span><br><span class="line">  <span class="comment">// which may or may not want to include such optimizations.)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jlong) == <span class="number">0</span>) &#123;</span><br><span class="line">    Copy::conjoint_jlongs_atomic((jlong*) src, (jlong*) dst, size / <span class="keyword">sizeof</span>(jlong));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jint) == <span class="number">0</span>) &#123;</span><br><span class="line">    Copy::conjoint_jints_atomic((jint*) src, (jint*) dst, size / <span class="keyword">sizeof</span>(jint));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jshort) == <span class="number">0</span>) &#123;</span><br><span class="line">    Copy::conjoint_jshorts_atomic((jshort*) src, (jshort*) dst, size / <span class="keyword">sizeof</span>(jshort));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Not aligned, so no need to be atomic.</span></span><br><span class="line">    Copy::conjoint_jbytes((<span class="keyword">void</span>*) src, (<span class="keyword">void</span>*) dst, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法中首先会判断数据类型，进而调用对应的方法（原子操作）。如果没有字节对齐（特定的类型），也就不需要进行原子操作，接着会调用 Copy::conjoint_jbytes方法，此方法的本质就是调用C语言库函数string.h中的memmove函数。特定的三个方法大同小异，继续查看源码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jshorts,               conjoint, atomic on each jshort</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conjoint_jshorts_atomic</span><span class="params">(jshort* from, jshort* to, size_t count)</span> </span>&#123;</span><br><span class="line">    assert_params_ok(from, to, LogBytesPerShort);</span><br><span class="line">    pd_conjoint_jshorts_atomic(from, to, count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jints,                 conjoint, atomic on each jint</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conjoint_jints_atomic</span><span class="params">(jint* from, jint* to, size_t count)</span> </span>&#123;</span><br><span class="line">    assert_params_ok(from, to, LogBytesPerInt);</span><br><span class="line">    pd_conjoint_jints_atomic(from, to, count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jlongs,                conjoint, atomic on each jlong</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conjoint_jlongs_atomic</span><span class="params">(jlong* from, jlong* to, size_t count)</span> </span>&#123;</span><br><span class="line">    assert_params_ok(from, to, LogBytesPerLong);</span><br><span class="line">    pd_conjoint_jlongs_atomic(from, to, count);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，它们又调用了pd为前缀的方法，继续跟进：<br>openjdk-8/openjdk/hotspot/src/cpu/zero/vm/copy_zero.hpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pd_conjoint_jshorts_atomic</span><span class="params">(jshort* from, jshort* to, size_t count)</span> </span>&#123;</span><br><span class="line">  _Copy_conjoint_jshorts_atomic(from, to, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pd_conjoint_jints_atomic</span><span class="params">(jint* from, jint* to, size_t count)</span> </span>&#123;</span><br><span class="line">  _Copy_conjoint_jints_atomic(from, to, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pd_conjoint_jlongs_atomic</span><span class="params">(jlong* from, jlong* to, size_t count)</span> </span>&#123;</span><br><span class="line">  _Copy_conjoint_jlongs_atomic(from, to, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再往下就是平台相关的了，找到openjdk-8/openjdk/hotspot/src/os_cpu/linux_zero/vm/os_linux_zero.cpp文件：<br><code>_Copy_conjoint_jints_atomic</code>方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Copy_conjoint_jints_atomic(jint* from, jint* to, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (from &gt; to) &#123;</span><br><span class="line">      jint *end = from + count;</span><br><span class="line">      <span class="keyword">while</span> (from &lt; end)</span><br><span class="line">        *(to++) = *(from++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (from &lt; to) &#123;</span><br><span class="line">      jint *end = from;</span><br><span class="line">      from += count - <span class="number">1</span>;</span><br><span class="line">      to   += count - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (from &gt;= end)</span><br><span class="line">        *(to--) = *(from--);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>终于找到具体实现了！有一种似曾相识的感觉呢，很经典的复制代码。</p>
<p><code>_Copy_conjoint_jshorts_atomic</code>方法与其实现相同，而<code>_Copy_conjoint_jlongs_atomic</code>方法在最后一句用了细化的原子操作，以处理64位的数据：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (from &gt;= end)</span><br><span class="line">        os::atomic_copy64(from--, to--);</span><br></pre></td></tr></table></figure></p>
<p>下面就是原子操作对应的代码。在特定平台会通过汇编进行优化，其他平台都是简单的一句<code>*(jlong *) dst = *(jlong *) src</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Atomically copy 64 bits of data</span><br><span class="line">  static void atomic_copy64(volatile void *src, volatile void *dst) &#123;</span><br><span class="line">#if defined(PPC) &amp;&amp; !defined(_LP64)</span><br><span class="line">    double tmp;</span><br><span class="line">    asm volatile ("lfd  %0, 0(%1)\n"</span><br><span class="line">                  "stfd %0, 0(%2)\n"</span><br><span class="line">                  : "=f"(tmp)</span><br><span class="line">                  : "b"(src), "b"(dst));</span><br><span class="line">#elif defined(S390) &amp;&amp; !defined(_LP64)</span><br><span class="line">    double tmp;</span><br><span class="line">    asm volatile ("ld  %0, 0(%1)\n"</span><br><span class="line">                  "std %0, 0(%2)\n"</span><br><span class="line">                  : "=r"(tmp)</span><br><span class="line">                  : "a"(src), "a"(dst));</span><br><span class="line">#else</span><br><span class="line">    *(jlong *) dst = *(jlong *) src;</span><br><span class="line">#endif</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，数组复制的过程结束。下面解析另一个方法。</p>
<h4 id="对象模型里的copy_array方法">对象模型里的copy_array方法</h4><p>要想读oops文件夹里的代码，需要对JVM的对象模型（oop和klass）有一定的了解。<br>此方法，甚妙。代码在objArrayKlass.cpp文件中:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjArrayKlass::copy_array(arrayOop s, <span class="keyword">int</span> src_pos, arrayOop d,</span><br><span class="line">                               <span class="keyword">int</span> dst_pos, <span class="keyword">int</span> length, TRAPS) &#123;</span><br><span class="line">  assert(s-&gt;is_objArray(), <span class="string">"must be obj array"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!d-&gt;is_objArray()) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayStoreException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check is all offsets and lengths are non negative</span></span><br><span class="line">  <span class="keyword">if</span> (src_pos &lt; <span class="number">0</span> || dst_pos &lt; <span class="number">0</span> || length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check if the ranges are valid</span></span><br><span class="line">  <span class="keyword">if</span>  ( (((<span class="keyword">unsigned</span> <span class="keyword">int</span>) length + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) src_pos) &gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>) s-&gt;length())</span><br><span class="line">     || (((<span class="keyword">unsigned</span> <span class="keyword">int</span>) length + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) dst_pos) &gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>) d-&gt;length()) ) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Special case. Boundary cases must be checked first</span></span><br><span class="line">  <span class="comment">// This allows the following call: copy_array(s, s.length(), d.length(), 0).</span></span><br><span class="line">  <span class="comment">// This is correct, since the position is supposed to be an 'in between point', i.e., s.length(),</span></span><br><span class="line">  <span class="comment">// points to the right of the last element.</span></span><br><span class="line">  <span class="keyword">if</span> (length==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (UseCompressedOops) &#123;</span><br><span class="line">    narrowOop* <span class="keyword">const</span> src = objArrayOop(s)-&gt;obj_at_addr&lt;narrowOop&gt;(src_pos);</span><br><span class="line">    narrowOop* <span class="keyword">const</span> dst = objArrayOop(d)-&gt;obj_at_addr&lt;narrowOop&gt;(dst_pos);</span><br><span class="line">    do_copy&lt;narrowOop&gt;(s, src, d, dst, length, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oop* <span class="keyword">const</span> src = objArrayOop(s)-&gt;obj_at_addr&lt;oop&gt;(src_pos);</span><br><span class="line">    oop* <span class="keyword">const</span> dst = objArrayOop(d)-&gt;obj_at_addr&lt;oop&gt;(dst_pos);</span><br><span class="line">    do_copy&lt;oop&gt; (s, src, d, dst, length, CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，主题思想还是一样的。先做检查，然后执行复制。但是，这里的实现与上一个方法实现有很大的不同，更偏向于对象模型了。<br>UseCompressedOops是JDK 1.6新增的，在64位系统中，提供可压缩的普通对象指针。JDK 1.7开始默认启用对象压缩 。<br>貌似对象模型还分oop和narrowOop（压缩的），先检验是否压缩过，再调用do_copy方法（模板方法）:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Either oop or narrowOop depending on UseCompressedOops.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">void</span> ObjArrayKlass::do_copy(arrayOop s, T* src,</span><br><span class="line">                               arrayOop d, T* dst, <span class="keyword">int</span> length, TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  BarrierSet* bs = Universe::heap()-&gt;barrier_set();</span><br><span class="line">  <span class="comment">// For performance reasons, we assume we are that the write barrier we</span></span><br><span class="line">  <span class="comment">// are using has optimized modes for arrays of references.  At least one</span></span><br><span class="line">  <span class="comment">// of the asserts below will fail if this is not the case.</span></span><br><span class="line">  assert(bs-&gt;has_write_ref_array_opt(), <span class="string">"Barrier set must have ref array opt"</span>);</span><br><span class="line">  assert(bs-&gt;has_write_ref_array_pre_opt(), <span class="string">"For pre-barrier as well."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s == d) &#123;</span><br><span class="line">    <span class="comment">// since source and destination are equal we do not need conversion checks.</span></span><br><span class="line">    assert(length &gt; <span class="number">0</span>, <span class="string">"sanity check"</span>);</span><br><span class="line">    bs-&gt;write_ref_array_pre(dst, length);</span><br><span class="line">    Copy::conjoint_oops_atomic(src, dst, length);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We have to make sure all elements conform to the destination array</span></span><br><span class="line">    Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();</span><br><span class="line">    Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();</span><br><span class="line">    <span class="keyword">if</span> (stype == bound || stype-&gt;is_subtype_of(bound)) &#123;</span><br><span class="line">      <span class="comment">// elements are guaranteed to be subtypes, so no check necessary</span></span><br><span class="line">      bs-&gt;write_ref_array_pre(dst, length);</span><br><span class="line">      Copy::conjoint_oops_atomic(src, dst, length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// slow case: need individual subtype checks</span></span><br><span class="line">      <span class="comment">// note: don't use obj_at_put below because it includes a redundant store check</span></span><br><span class="line">      T* from = src;</span><br><span class="line">      T* end = from + length;</span><br><span class="line">      <span class="keyword">for</span> (T* p = dst; from &lt; end; from++, p++) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag"><span class="keyword">XXX</span></span> this is going to be slow.</span></span><br><span class="line">        T element = *from;</span><br><span class="line">        <span class="comment">// even slower now</span></span><br><span class="line">        <span class="keyword">bool</span> element_is_null = oopDesc::is_null(element);</span><br><span class="line">        oop new_val = element_is_null ? oop(NULL)</span><br><span class="line">                                      : oopDesc::decode_heap_oop_not_null(element);</span><br><span class="line">        <span class="keyword">if</span> (element_is_null ||</span><br><span class="line">            (new_val-&gt;klass())-&gt;is_subtype_of(bound)) &#123;</span><br><span class="line">          bs-&gt;write_ref_field_pre(p, new_val);</span><br><span class="line">          *p = *from;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We must do a barrier to cover the partial copy.</span></span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">size_t</span> pd = pointer_delta(p, dst, (<span class="keyword">size_t</span>)heapOopSize);</span><br><span class="line">          <span class="comment">// pointer delta is scaled to number of elements (length field in</span></span><br><span class="line">          <span class="comment">// objArrayOop) which we assume is 32 bit.</span></span><br><span class="line">          assert(pd == (<span class="keyword">size_t</span>)(<span class="keyword">int</span>)pd, <span class="string">"length field overflow"</span>);</span><br><span class="line">          bs-&gt;write_ref_array((HeapWord*)dst, pd);</span><br><span class="line">          THROW(vmSymbols::java_lang_ArrayStoreException());</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bs-&gt;write_ref_array((HeapWord*)dst, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，操作都是围绕着BarrierSet进行的。BarrierSet应该是内存屏障的集合，位于vm/memory/barrierSet.hpp文件内，待研究透JVM底层内存管理机制再过来填坑。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-os-learning-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Develop/os-learning-1/" class="article-date">
      <time datetime="2015-08-20T16:00:00.000Z" itemprop="datePublished">2015-08-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Develop/os-learning-1/">操作系统相关知识杂谈</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本文总结一些操作系统相关的重点知识~</p>
<hr>
<h1 id="线程栈空间">线程栈空间</h1><p>一个进程中的多个线程共享进程的栈空间(当然也有其他一些资源)；但是每一个线程也可以有自己的栈空间，叫 TLS(线程本地存储)<br><strong>注：</strong> Linux中线程与进程貌似同别的操作系统有些许不同（参照《UNIX环境高级编程》）</p>
<h1 id="IPC">IPC</h1><p>IPC（进程间通信）包括<strong>管道</strong>，<strong>命名管道</strong>，<strong>共享内存</strong>，<strong>LPC</strong>，<strong>套接字</strong>，<strong>消息队列</strong> 等等方式。</p>
<h1 id="进程间同步的几种方式的区别：">进程间同步的几种方式的区别：</h1><p><strong>几种方式：临界区，互斥，信号量，事件</strong></p>
<ul>
<li>使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</li>
<li>任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开</li>
<li>信号允许多个线程同时使用共享资源</li>
<li>如果只为了在进程内部使用的话使用临界区会带来速度上的优势并能够减少资源占用量</li>
</ul>
<p>总结：<br><strong>临界区</strong>（Critical Section）在任意时刻只允许一个线程访问资源，如果有多个线程试图访问临界区，那么一个线程进入临界区后其他线程将被挂起并持续到临界区线程离开。临界区线程释放后其余线程可进入临界区（抢占式），以此达到原子操作的要求。临界区通过对多线程的串行化来访问公共资源或一段代码，速度快，如果只在进程内部使用的话性能较高。<br><strong>互斥锁</strong>（Mutex）与临界区差不多但比其复杂。互斥锁不仅能够实现同一进程中不同线程资源的安全共享，而且还可以实现不同进程中线程资源的安全共享。<br><strong>信号量</strong>（Semaphores）涉及PV操作较复杂，以后再总结。</p>
<h1 id="文件系统相关">文件系统相关</h1><p>对于多关键字而言，哪种文件组织方便而又高效？ -&gt; <strong>倒排文件</strong>。</p>
<p>倒排文件（也称 倒排索引 ）：用记录的非主属性值（也叫副键）来查找记录而组织的文件叫倒排文件，即次索引。倒排文件中包括了所有副键值，并列出了与之有关的所有记录主键值，主要用于<strong>复杂查询</strong>。</p>
<p><strong>链式文件存储只能顺序访问，不能随机存取</strong>（链表的特性）。如果要随机访问的话只能顺序查找，效率低下。</p>
<h1 id="页式存储管理、分页算法">页式存储管理、分页算法</h1><p>交换和虚拟内存的区别：交换需要把整个程序内存区域置换出去，而虚拟内存可以根据页面置换机制，置换出部分的页面。</p>
<p>在分页内存管理中，把实际物理内存（也称主存）划分为许多个固定大小的内存块，称为物理页面，或者是页框（page frame）。</p>
<p>分页管理是在物理页面中装入一些需要使用或过去使用过的页面，但是物理页面的数量是有限的，这里就会用到一些页面置换算法，使得页面访问的效率提高。判断一个置换算法优劣的指标就是缺页率，缺页是指当前的物理页面中没有需要访问的页面，而需要将该页面加入其中一个物理页面。缺页率＝访问缺页次数/访问总次数。</p>
<p>常见的算法：FIFO、Bélády’s Algorithm(最佳页面替换算法,<strong>OPT</strong>)、Least Recently Used (<strong>LRU</strong>)、Least-Frequently Used (<strong>LFU</strong>)<br>更多的见<a href="https://en.wikipedia.org/wiki/Cache_algorithms" target="_blank" rel="external">Cache Algorithms</a><br>在请求分页存储管理的系统中，若采用FIFO页面淘汰算法，则当进程分配到的页面数增加时，缺页中断的次数<strong>可能增加也可能减少
</strong><br>原因：belady现象，见FIFO页面淘汰算法。FIFO算法具有严重的缺陷，因此不是一个很好的算法。</p>
<p><strong>LRU</strong> 和 <strong>LFU</strong> 算法很重要，LeetCode上也有个LRU Cache的题，后面会专开一篇总结。</p>
<h1 id="段式存储管理">段式存储管理</h1><p>在段式存储管理中，将程序的地址空间划分为若干个段(segment)，这样每个进程有一个二维的地址空间。在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在段式存储管理系统中，则为每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续，物理内存的管理采用动态分区的管理方法。</p>
<ul>
<li>在为某个段分配物理内存时，可以采用 <strong>首此适配法</strong>、<strong>下次适配法</strong>、<strong>最佳适配法</strong> 等方法（操作系统内存动态分配算法）</li>
<li>在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。</li>
</ul>
<h1 id="产生死锁的四个必要条件">产生死锁的四个必要条件</h1><p>（1） <strong>互斥条件</strong>：一个资源每次只能被一个进程使用。<br>（2） <strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） <strong>不剥夺条件</strong>：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） <strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。<br>破坏掉一个即可破坏死锁</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/pic1232233620.JPG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-web-frontend-02" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Web/web-frontend-02/" class="article-date">
      <time datetime="2015-08-17T15:44:19.000Z" itemprop="datePublished">2015-08-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Web/web-frontend-02/">Web开发笔记 - 前端总结(性能篇)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>从一个用户的角度来说，网站的性能就是用户在浏览器上访问网页的直观感受，加载网页的快慢，加载资源的快慢。通过对前端的性能优化，可以使浏览器尽快地显示内容，对用户更为友好。所以，为了给用户更好的体验，Web前端性能优化是非常有必要的。</p>
<p><img src="http://img.blog.csdn.net/20150901115247287" alt="浏览器请求和响应的过程"></p>
<hr>
<h1 id="CSS、JS代码优化">CSS、JS代码优化</h1><p>避免使用CSS表达式，虽然功能强大但是效率低下。<br>避免使用CSS3的@import，性能非常低。可以在Sass中使用@import，预编译后会将引用的文件合并到一个文件中，不会影响性能。<br>使用前端构建工具（比如Grunt的grunt-contrib-unglify）<strong>压缩精简CSS、JS代码</strong>（混淆），消除重复、无用代码，并且合并代码，尽量减少HTTP请求次数。</p>
<h1 id="减少DNS查询">减少DNS查询</h1><p>DNS查询会消耗一定时间。使用<strong>DNS缓存</strong>可有效减少DNS查询（只要对应的解析地址不要常变动就好）。</p>
<h1 id="使用CDN">使用<strong>CDN</strong></h1><p>CDN的本质也是缓存，并且由于CDN部署在网络运营商的机房，而这些机房又为用户提供网络服务。所以CDN是将数据缓存在离用户最近的地方，让用户以最快的速度获取资源。一般地，CDN用来缓存静态资源，如图片、CSS、JS脚本、静态网页等等的访问频率较高而变化频率低的静态资源。</p>
<h1 id="使用浏览器缓存">使用浏览器缓存</h1><p>对不经常变化的资源，在HTTP头中添加Expire或Cache-Control，可以设定浏览器缓存。</p>
<h1 id="减少HTTP请求">减少HTTP请求</h1><p><strong>合并CSS、JS文件</strong>（用构建工具）<br>合并图片文件（利用CSS Sprites），将几个相关的图片合成一张图片，使用的时候通过CSS偏移定位出图片的精确位置即可（比如小按钮）。注意响应式页面下图片的位置。</p>
<h1 id="必要的时候启用压缩">必要的时候启用压缩</h1><p>在服务端进行压缩，在浏览器端进行解压缩，可以减少传输的数据量。对HTML、CSS、JS文件启用<strong>gzip压缩</strong>可达到较好的效果，但是注意压缩会消耗一定的服务器资源，在PV量大而服务器资源不充裕时应谨慎使用。</p>
<h1 id="CSS与JS在网页中的位置">CSS与JS在网页中的位置</h1><p>浏览器在获取完所有的CSS资源后才对整个页面进行渲染，因此将CSS放在页面的<strong>最上面</strong>是最合适的。<br>而加载JS有可能会阻塞整个页面（可以添加async来达到异步加载的效果），因此JS最好放在<strong>页面的底部</strong>。当然如果页面解析需要用到JS（比如用AngularJS开发的SPA），那么就应该放在相应的位置，确保页面正常加载。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Web/">Web</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/">Web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能/">性能</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-web-frontend-01" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Web/web-frontend-01/" class="article-date">
      <time datetime="2015-08-16T11:47:36.000Z" itemprop="datePublished">2015-08-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Web/web-frontend-01/">Web开发笔记 - 前端总结(开发篇)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>终于从老家回来咯~有时间总结总结啦~这是Web前端开发篇~<br><strong>此笔记会不断补充。</strong>部分不重要的就不放上来了。</p>
<hr>
<h1 id="CSS相关">CSS相关</h1><h2 id="CSS_Position">CSS Position</h2><p>四种定位：static,relative,absolute,fixed</p>
<ul>
<li><strong>static</strong> position是HTML元素的默认值，即没有定位，元素出现在正常的流中。静态定位的元素不会受到top, bottom, left, right影响。</li>
<li><strong>fixed</strong> position是固定位置，常用于实现固定层效果。</li>
<li><strong>relative</strong> position相对于其正常位置，而<strong>absolute</strong>  position的元素的位置相对于最近的已定位父元素。</li>
</ul>
<h2 id="CSS_Float_&amp;&amp;_The_inline-block_Value">CSS Float &amp;&amp; The inline-block Value</h2><p>CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。常用于各区域的水平方向并排化。<br>横向导航栏也可用<strong>inline-block</strong>，可以更好地解决图片的排列问题，或者元素需要多个display属性时。两者各有利弊，需要根据业务需求考虑。</p>
<h2 id="元素显示与隐藏">元素显示与隐藏</h2><p>使用<code>visibility</code>或<code>display</code>属性<br>顺便提一下<code>display</code>属性，其可以控制显示方式为<strong>块级元素和内联元素</strong>。区别显而易见，块级元素（如div）占用了全部宽度，在前后都是换行符，而内联元素（如span）相当于内嵌，不强制换行。<br>而<strong>inline-block</strong>兼具inline和block的特性，可占有全部宽度而不换行。比起float，inline-block不需要再为after指定clear。当需要控制元素的垂直对齐跟水平排列时，可以使用inline-block。（可代替float）</p>
<h2 id="改变元素的明暗度">改变元素的明暗度</h2><p>改变元素的明暗度可以通过设置一个遮罩层，并改变其透明度来实现。CSS3的<code>opacity</code>属性用来设置元素的不透明级别。<br>至于IE9 below。。。看着办吧。。<br>应用：毛玻璃效果（Login界面）、购物导航（hover辅助）、配合HTML5和JS的各种cool效果。</p>
<h2 id="CSS_Box_Model">CSS Box Model</h2><ul>
<li>Margin - 清除边框区域。Margin没有背景颜色，它是完全透明的</li>
<li>Border - 边框周围的填充和内容。边框是受到盒子的背景颜色影响</li>
<li>Padding - 清除内容周围的区域。会受到框中填充的背景颜色影响</li>
<li>Content - 盒子的内容，显示文本和图像</li>
</ul>
<p><img src="http://www.runoob.com/images/box-model.gif" alt="CSS Box Model"></p>
<h2 id="超出元素的部分隐藏">超出元素的部分隐藏</h2><p>使用<code>overflow : hidden</code></p>
<h2 id="CSS3_transition/transform">CSS3 transition/transform</h2><p>CSS 3可以直接写过渡(transition)而不需要JQuery等库的帮助。<br>而transform则是做2D、3D转换。<br>用示例总结：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line"><span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">233px</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">233px</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">background</span>:<span class="value"> green</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">transition</span>:<span class="value">width <span class="number">2s</span> linear, height <span class="number">2s</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">-moz-transition</span>:<span class="value">width <span class="number">2s</span>, height <span class="number">2s</span>, -moz-transform <span class="number">2s</span></span></span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line"><span class="rule"><span class="attribute">-webkit-transition</span>:<span class="value">width <span class="number">2s</span>, height <span class="number">2s</span> linear, -webkit-transform <span class="number">2s</span></span></span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="rule"><span class="attribute">-o-transition</span>:<span class="value">width <span class="number">2s</span>, height <span class="number">2s</span>, -o-transform <span class="number">2s</span></span></span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span></span><br><span class="line"><span class="rule"><span class="attribute">div</span>:<span class="value">hover &#123;</span><br><span class="line">width:<span class="number">233px</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">233px</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">transform</span>:<span class="value"><span class="function">rotate</span>(<span class="number">180deg</span>)</span></span>;  <span class="comment">/*旋转180度*/</span></span><br><span class="line"><span class="rule"><span class="attribute">-moz-transform</span>:<span class="value"><span class="function">rotate</span>(<span class="number">180deg</span>)</span></span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line"><span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"><span class="function">rotate</span>(<span class="number">180deg</span>)</span></span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="rule"><span class="attribute">-o-transform</span>:<span class="value"><span class="function">rotate</span>(<span class="number">180deg</span>)</span></span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS:有些东西用JS比CSS3方便很多，不过还是了解一下的好~况且CSS3动画性能应该比JS要高一些</p>
<hr>
<h2 id="CSS_Enhancer">CSS Enhancer</h2><p>只用过Sass，Less.js木有用过不了解。<br>Sass是一个基于Ruby的CSS预处理器，相当于CSS的一个增强版吧。Compass则相当于一个Sass框架，提供了许多mixin的功能。<br>在Terminal里开<strong>compass watch</strong>可以实时编译sass/scss文件<br>总结一下Sass的特性</p>
<h3 id="可定义变量">可定义变量</h3><p>Sass中可以定义变量，方便统一修改和维护重复、相同的值。</p>
<h3 id="模块化思想">模块化思想</h3><p>Sass中可以导入其它sass/scss文件，但与CSS 3中的<strong>@import</strong>意义不同，Sass改写了<strong>@import</strong>的意义，Sass中的import在预编译时会将所有模块合并，因此性能优于CSS3的import。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$headline-font</span><span class="value">: 微软雅黑,Arial,sans-serif;</span></span><br><span class="line"></span><br><span class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="string">"compass/reset"</span> //这一句用来覆盖掉浏览器的默认样式</span><br><span class="line"><span class="preprocessor"></span><br><span class="line">.mian-sec</span> &#123;</span></span><br><span class="line">    <span class="attribute">font-family</span><span class="value">: <span class="variable">$headline-font</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="嵌套">嵌套</h3><p>Sass中可以进行选择器的嵌套表示层级关系，更加简便、直观。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">nav</span> &#123;</span><br><span class="line">  <span class="tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span><span class="value">: <span class="number">0</span>;</span></span><br><span class="line">    <span class="attribute">padding</span><span class="value">: <span class="number">0</span>;</span></span><br><span class="line">    <span class="attribute">list-style</span><span class="value">: none;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">li</span> &#123; <span class="attribute">display</span><span class="value">: inline-block;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span><span class="value">: block;</span></span><br><span class="line">    <span class="attribute">padding</span><span class="value">: <span class="number">6px</span> <span class="number">12px</span>;</span></span><br><span class="line">    <span class="attribute">text-decoration</span><span class="value">: none;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>顺便再总结一下CSS3中的f4cking 组合选择符：</p>
<ul>
<li>后代选取器(以空格分隔)</li>
<li>子元素选择器(以大于号分隔）</li>
<li>相邻兄弟选择器（以加号分隔）</li>
<li>普通兄弟选择器（以破折号分隔）</li>
</ul>
<p>写的时候都能晕了有木有。。所以有Sass真是方便的多。</p>
<h3 id="mixin">mixin</h3><p>Sass中可用mixin定义一些代码片段（相当于function），且可传参数，方便日后根据需求调用，这使得写CSS3浏览器兼容时更加便捷。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> box-sizing</span> (<span class="variable">$sizing</span>) &#123;</span></span><br><span class="line">    -webkit-<span class="attribute">box-sizing</span><span class="value">:<span class="variable">$sizing</span>;</span>     </span><br><span class="line">       -moz-<span class="attribute">box-sizing</span><span class="value">:<span class="variable">$sizing</span>;</span></span><br><span class="line">            <span class="attribute">box-sizing</span><span class="value">:<span class="variable">$sizing</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class">.box-border</span>&#123;</span><br><span class="line">    <span class="attribute">border</span><span class="value">:<span class="number">1px</span> solid <span class="hexcolor">#ccc</span>;</span></span><br><span class="line">    <span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> box-sizing</span>(<span class="number">2px</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展/继承">扩展/继承</h3><p>Sass可通过<strong>@extend</strong>来实现代码组合声明，使代码更加简洁优美。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.message</span> &#123;</span><br><span class="line">  <span class="attribute">border</span><span class="value">: <span class="number">1px</span> solid <span class="hexcolor">#ccc</span>;</span></span><br><span class="line">  <span class="attribute">padding</span><span class="value">: <span class="number">10px</span>;</span></span><br><span class="line">  <span class="attribute">color</span><span class="value">: <span class="hexcolor">#333</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.success</span> &#123;</span><br><span class="line">  <span class="at_rule">@<span class="keyword">extend</span><span class="preprocessor"> .message</span>;</span></span><br><span class="line">  <span class="attribute">border-color</span><span class="value">: green;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.error</span> &#123;</span><br><span class="line">  <span class="at_rule">@<span class="keyword">extend</span><span class="preprocessor"> .message</span>;</span></span><br><span class="line">  <span class="attribute">border-color</span><span class="value">: red;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其它">其它</h3><p>Sass中可以进行简单的加减乘除运算。并且Sass提供了许多操作颜色的内建函数，让调色更方便。</p>
<p>Sass可以用命令行编译，也可以用GUI工具编译~用Sublime的话推荐配合使用神器Koala，鹅厂出品，非常方便。<br>用WebStorm的话都支持自动编译sass/scss文件的，还是InteliJ大法好！</p>
<hr>
<h1 id="Bootstrap相关">Bootstrap相关</h1><p>写UI个人比较喜欢用Bootstrap及其各种变种（比如Flat-UI），其实主要还是因为懒（总感觉Bootstrap特别适合给不熟悉前端设计的后端开发者使用。。）</p>
<h2 id="重中之重-Bootstrap_Grid_System">重中之重-Bootstrap Grid System</h2><p>Bootstrap采用<strong>移动设备优先</strong>的原则。<br>Bootstrap网格系统具有响应式的特点，可随着设备大小进行分栏，响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。12个总格位主要有1<em>12、2</em>6、8+4、3<em>4、12</em>1这几种分栏方式。<br>网格系统有四种尺寸:</p>
<ul>
<li><strong>xs</strong> (for phones &lt;768px)</li>
<li><strong>sm</strong> (for tablets &gt;=768px)</li>
<li><strong>md</strong> (for desktops &gt;=992px)</li>
<li><strong>lg</strong>(for larger desktops &gt;=1200px)<br>可以一次使用多种尺寸来构建自适应的页面。<br>网格系统的结构：<br>First,create a row . Then, add the desired number of columns (tags with appropriate .col-<em>-</em> classes). Note that numbers in .col-<em>-</em> should always add up to 12 for each row.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-*-*"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>比如分三栏：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-sm-4"</span>&gt;</span>Fucking Scala<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-sm-4"</span>&gt;</span>Fucking Scala<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-sm-4"</span>&gt;</span>Fucking Scala<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>另外需要注意响应式的列重置、偏移列及嵌套列问题。<br>别的暂时没什么好总结的了，查查手册应该就可以解决。重要的是响应式页面的设计。</p>
<hr>
<h1 id="JQuery相关">JQuery相关</h1><p>项目中用的比较多，内容太多，慢慢填坑。</p>
<hr>
<h1 id="MVC、MVVM框架">MVC、MVVM框架</h1><p>目前常用的MVC/MVP/MVVM/MVW框架主要有BackboneJS（第一代前端MVC框架，仅作了解），EmberJS（MVC框架，和AngularJS思想相似，仅作了解）以及目前特别常用的MVVM框架AngularJS。这里仅总结AngularJS（目前版本为1.4.4，为什么要写版本？因为这货不一定哪一次更新就会deprecate很多旧特性。。）<br>有的人不明白AngularJS的用途，认为“万事皆可用AngularJS”，这样就没有领悟AngularJS的精髓。AngularJS最适合开发RESTful风格的SPA（国内各种云服务的Dashboard以及Gmail、Twitter都应用了AngularJS)，而如果开发非应用型网站则要看业务需求，用AngularJS不一定是最佳选择。<br>这里内容也太多，先总结思想吧。<br>AngularJS的一大特点是bi-directional data binding，即<strong>数据双向绑定</strong>。它和JQuery的思维有着天壤之别。JQuery的思想是先构建好一个页面，再通过各种DOM操作编写动作；而用AngularJS写页面时，对DOM的直接操作是完全没有必要，也是不被提倡的。在AngularJS中用声明式的数据绑定就可以很好地实现JQuery中命令式的功能。并且，我们心中要对整个页面的结构有个把握，页面分成几个组件，每个组件由不同的控制器负责，数据模型应合理设计。有重复的逻辑是否可以抽象出来，提供一个统一的函数，配合回调达到功能的可扩展化。<br>总之，AngularJS提供了一种类似于后端的思考方式，可以更好地对网页组件进行解耦，方便日后的开发和维护。后面会详细总结AngularJS的开发。</p>
<hr>
<h1 id="模板引擎">模板引擎</h1><p>主要是EJS和Jade。Jade的语法，只能说，诡异！！！所以用Node.js构建博客时页面模板引擎果断用了EJS（其实我也不知道哪个性能好些，反正EJS没有那么诡异。。）<br>待填坑 &gt;_&lt;</p>
<hr>
<h1 id="ReactJS">ReactJS</h1><p>ReactJS是一个View层组件，专门负责View层的开发。很喜欢它的<strong>Virtual DOM</strong>的设计，优化了性能（比原生DOM性能快，当然也不支持所有的DOM操作）<br>这个也没有太多实践（毕竟是View层），以后可以试试React Native构建Hybrid App，写个个人博客的管理器还是可以的~</p>
<hr>
<h1 id="构建工具">构建工具</h1><p>前端构建工具主要有流式构建工具Gulp.js及Grunt，用于压缩、合并依赖文件。前端构建工具貌似一直在改进，变化很快（后端也是，比如Java项目构建，从Maven到Gradle），不过万变不离其宗，核心流程是没有变的。<br>两者用起来比较接近，主要就是package.json + Gruntfile.js(gulp.js)的配置。<br>以Grunt为例，先<code>npm init</code>生成package.json文件，该文件主要配置项目基本信息及工具插件依赖，以让 Node.js 知道下载哪些插件，重点是<strong>devDependencies</strong>字段。<br>至于其使用，麻烦诶。。就简单用了用，不是专业写前端的话一般懒得用。。<br>Grunt的任务配置都是在Gruntfile中的grunt.initConfig方法中指定的。总结一下常用插件吧</p>
<h4 id="grunt-contrib-unglify">grunt-contrib-unglify</h4><p>grunt-contrib-unglify 用来压缩代码（混淆）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    uglify: &#123;</span><br><span class="line">      my_target: &#123;</span><br><span class="line">        files: &#123;</span><br><span class="line">          <span class="string">'dest/libs.min.js'</span>: [<span class="string">'src/jquery.js'</span>, <span class="string">'src/underscoce.js'</span>,<span class="string">'src/bootstrap.js'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="grunt-contrib-concat">grunt-contrib-concat</h4><p>grunt-contrib-concat 用来将多个文件合并为一个，并且可添加分隔符、头尾注释等等的。</p>
<h4 id="grunt-contrib-jshint">grunt-contrib-jshint</h4><p>grunt-contrib-jshint 用来检测js语法问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    jshint: &#123;</span><br><span class="line">      all: [<span class="string">'test.js'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-jshint'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他的暂时还没用，后面业务中用到再总结。</p>
<hr>
<h1 id="依赖包管理">依赖包管理</h1><p>我主要用过<strong>bower</strong>和<strong>npm</strong>，很方便。<br>Bower节省了时间，相当于建立了一个本地仓库（类似于Maven的.m2仓库），并且bower.json可以很容易地展现各种依赖关系。给依赖库升级也更加方便了，一句<code>bower update &lt;package-name&gt;</code>完事。Bower的优点是约束比较松散，使用很简单，缺点就是不提供构建工具，需要配合Glup.js或Grunt<br>配合Grunt的一些<a href="http://bower.io/docs/tools/" target="_blank" rel="external">插件</a></p>
<ul>
<li>grunt-bower-concat</li>
<li>grunt-wiredep</li>
<li>grunt-bower-requirejs</li>
<li>grunt-bower-task</li>
<li>grunt-preen</li>
</ul>
<p>配合Glup.js的一些插件</p>
<ul>
<li>gulp-google-cdn（国内呵呵）</li>
<li>main-bower-files</li>
<li>preen</li>
<li>gulp-bower-normalize</li>
</ul>
<p><strong>npm</strong> 和<strong>Browserify</strong>配合相当于间接给浏览器提供了npm的功能（Browserify本身不是模块管理器，只是让服务器端的CommonJS格式的模块可以运行在浏览器端）<br>另外还有前端大神玩的Component,DuoJS之类的，木有用过。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Web/">Web</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/">Web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-algorithm-linkedlist-cycle-join" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Algorithm/algorithm-linkedlist-cycle-join/" class="article-date">
      <time datetime="2015-08-16T10:15:09.000Z" itemprop="datePublished">2015-08-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Algorithm/algorithm-linkedlist-cycle-join/">链表相关算法总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这里总结一下常见的与链表有关的算法</p>
<h1 id="链表成环的各种问题">链表成环的各种问题</h1><h2 id="1、判断一个单链表是否存在环">1、判断一个单链表是否存在环</h2><p>这个思路比较简单，用<strong>两个指针代表快、慢指针</strong>，然后从头指针开始，快指针一次前进两个结点，慢指针一次前进一个结点，则如果两个指针相遇（相等），则一定有环。若两指针不相遇，则fast指针遇到空指针后便结束循环。</p>
<p><strong>扩展</strong>：这种快、慢指针的思路还可用于找到无环链表的中间元素，当快指针到尾部时，慢指针正好到中间元素的位置。可用于链表的归并排序。</p>
<p><strong>扩展</strong>：这种两个指针的思路还可以用于寻找链表的第k个结点，思路同上。</p>
<p>对应：<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">LeetCode 141 - Linked List Cycle</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2、若存在环，求环的长度">2、若存在环，求环的长度</h2><p>此处有定理I：<strong>两指针（fast和slow）从第一次碰撞点出发到第二次碰撞所走的长度即为环的长度。</strong><br>证明略。<br><img src="http://img.blog.csdn.net/20151024011135661" alt="链表成环的情况"></p>
<h2 id="3、若存在环，求环的入口（连接点）">3、若存在环，求环的入口（连接点）</h2><p>此处有定理II：<strong>第一次碰撞点到环的入口的距离，等于头指针到环的入口的距离。因此，分别从头指针和碰撞点遍历链表，第一次相遇的点即为换的入口（连接点）。</strong></p>
<p>证明如下：<br>设单链表的总长度为L，头结点到环入口的距离为a，环入口到快慢指针相遇的结点距离为x，环的长度为r，慢指针总共走了s步，则快指针走了2s步。<br>并且，快指针要追赶上慢指针，在环内的圈数n &gt;= 1；<br>因此我们可以列出式子：</p>
<p>$$s = a + x$$<br>$$2s = a + nr + x$$<br>$$=&gt; a = nr - x = (n-1)r + y$$</p>
<p>由上式可知成立。<br>对应：<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">LeetCode 142 - Linked List Cycle II</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                ListNode *q = head;</span><br><span class="line">                <span class="keyword">while</span>(q != slow) &#123;</span><br><span class="line">                    q = q-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="链表相交的各种问题">链表相交的各种问题</h1><h2 id="如何判断链表相交，若相交则找到第一个交点">如何判断链表相交，若相交则找到第一个交点</h2><p>Question：给出两个单向链表的头指针，而两个链表都可能带环，判断这两个链表是否相交，并且给出他们相交的第一个节点。<br>思路：<br>首先根据上边的算法判断链表是否成环。<br><strong>第一种情况：两个链表都不成环</strong><br>思路1：将其中一个链表首尾相连，判断另一个链表是否存在环，如果存在，则两个链表相交，且找出来的环入口点即为相交的第一个点。<br>思路2：若如果两个不成环的链表相交，那么两个链表从相交点到尾结点都是相同的结点。首先先遍历两个链表，记录下两个链表的长度（长链表a，短链表b）。然后先让长链表移动a-b长度，然后两链表开始同步前进，相遇的第一个点即为环的第一个交点。</p>
<p><pre><br>    A:          a1 → a2<br>                       ↘<br>                         c1 → c2 → c3<br>                       ↗<br>    B:     b1 → b2 → b3<br></pre><br>对应：<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">LeetCode 160 - Intersection of Two Linked Lists</a><br><strong>第二种情况：两个链表都成环</strong></p>
<p><strong>不可能的情况：一个有环，一个没有环</strong><br>很好想的，如果两个链表一个有环，一个无环的话，那么它们不可能相交。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LinkedList/">LinkedList</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-web-frontend-plan" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Web/web-frontend-plan/" class="article-date">
      <time datetime="2015-08-13T12:27:28.000Z" itemprop="datePublished">2015-08-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Web/web-frontend-plan/">Web开发笔记 - 前端总结计划</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这半年修炼了不少前端的知识~本来想今晚上系统地总结总结前端开发相关的东西的（把以前写的八九个文档规整规整），结果在家收拾书房，收拾东西收拾了几个小时。。那只有等过几天咯~<br>今天就先列个总结计划吧，前端总结主要分为两部分：开发篇和性能优化篇~<br>前端开发对我来说本不是重点，但俗话说得好，<strong>不会做前端的后端不是好后端</strong>。毕竟不搞搞前端，设计出的网页自己看着都不舒服，做外包接单子的时候想做个好看而符合要求的前端还很麻烦（对于给设计图然后要求前端自动化测试的，主动逃），因此就学了学前端的核心内容（设计学不来，给FEX的各位大牛跪了）。<br>毕竟做一个真正的full-stack dev&amp;arch是很难的(本渣渣逃→_→ 所以了解了解前端性能优化还是很有必要的。</p>
<hr>
<h2 id="总结计划-开发篇">总结计划-开发篇</h2><ul>
<li><strong>页面布局与设计</strong></li>
<li><strong>CSS 3</strong> + JS动画</li>
<li>CSS Enhancer（主要是<strong>Sass</strong>，Less没用过。另外，模块化工具<strong>PostCSS</strong>值得关注）</li>
<li>响应式页面的设计</li>
<li><strong>Bootstrap</strong> &amp; Flat-UI（个人比较喜欢这个）</li>
<li>JQuery UI（当时撸搓比的教务系统就用了这个，还算凑合吧。然而学校URP连这个都不用。。）</li>
<li><strong>JQuery</strong>及其各种插件 （基于DOM）</li>
<li><strong>AngularJS</strong>（典型的MVVM或者叫MVW框架，非常喜欢其设计思想，是最近重点研究的对象。最大特点是数据双向绑定+DI。思想更接近于后端的思想，与Spring MVC及安卓的MVVM框架有异曲同工之妙。写的时候要抛掉JQuery的DOM Selector的思想！）</li>
<li><strong>模板引擎</strong>（EJS和Jade。Jade那诡异的语法呀！！！我只能呵呵了。。无奈写静态博客配合Node.JS构建的时候还是老老实实用了EJS。。其实这两个在性能上貌似也有些许差别，没深入研究。）</li>
<li><strong>ReactJS</strong>（View层框架，很喜欢它的Virtual DOM的设计，优化了性能。它的Material Design UI插件很不错~同时React Native支持用JS写Native App，成功的应用为天猫iOS客户端。10月份将会支持android端，到时候可以一试，可以写一些不需要太好性能的小应用。）</li>
<li><strong>模块化</strong>（ES6已经有模块化了，然而Java 9的模块化提案还在热火朝天的讨论呢。。论Jigsaw与OSGI之争。。悲惨）</li>
<li>前端构建工具，主要是<strong>Gulp.js</strong>及<strong>Grunt</strong>（package.json及Gruntfile的写法），重点是构建思想（和Gradle有些许相同）</li>
<li>前端依赖包管理，主要是<strong>bower</strong>和<strong>npm</strong>（NPM用了淘宝的镜像后速度终于快多了！）</li>
<li><strong>ES6</strong>初步总结（好多非常好的新特性有木有有木有！很有用！）</li>
</ul>
<hr>
<h2 id="总结计划-性能篇">总结计划-性能篇</h2><ul>
<li><strong>前端与后端的分离思考 - 参考阿里</strong></li>
<li><strong>SPA应用的性能优化</strong></li>
<li>前端开发的ASM - <strong>WebAssembly</strong>（类似于汇编的玩意，还在不断讨论中。在Github上参与这个项目，大家又是讨论GC又是讨论各种指令又是在YY大犇@dcodeIO设计的WASM的LOGO，讨论的不亦乐乎。就是喜欢这种开源社区活跃的氛围和对开发的这种热爱！）</li>
<li>资源加载的一些探讨</li>
</ul>
<hr>
<p>未开待续。<br>坐等过几天来填坑。。<br>踏歌长行，梦想永在。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Web/">Web</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/">Web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-database-transaction-lock" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Summary/database-transaction-lock/" class="article-date">
      <time datetime="2015-08-11T08:19:48.000Z" itemprop="datePublished">2015-08-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Summary/database-transaction-lock/">数据库事务中的隔离级别和锁</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>数据库事务在后端开发中占非常重要的地位，如何确保数据读取的正确性、安全性也是我们需要研究的问题。</p>
<h1 id="ACID">ACID</h1><p>首先总结一下数据库事务正确执行的四个要素（ACID）：</p>
<ul>
<li><strong>原子性</strong>（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做，不能只做一部分；</li>
<li><strong>一致性</strong>（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是处于正确的状态，即数据完整性约束没有被破坏；比如我们做银行转账的相关业务，A转账给B，要求A转的钱B一定要收到。如果A转了钱而B没有收到，那么数据库数据的一致性就得不到保障，在做高并发业务时要注意合理的设计。</li>
<li><strong>隔离性</strong>（Isolation）：并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性；</li>
<li><strong>持久性</strong>（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因各种异常导致数据不一致或丢失。</li>
</ul>
<hr>
<h1 id="事务隔离级别">事务隔离级别</h1><p>大部分数据库事务操作都是并发执行的，这就可能遇到下面的几种问题：</p>
<ul>
<li><strong>丢失更新</strong>：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，后果比较严重。一般是由于没加锁的原因造成的。</li>
<li><strong>脏读</strong>（Dirty reads）：一个事务A读取到了另一个事务B还没有提交的数据，并在此基础上进行操作。如果B事务rollback，那么A事务所读取到的数据就是不正确的，会带来问题。</li>
<li><strong>不可重复读</strong>（Non-repeatable reads）：在同一事务范围内读取两次相同的数据，所返回的结果不同。比如事务B第一次读数据后，事务A更新数据并commit，那么事务B第二次读取的数据就与第一次是不一样的。</li>
<li><strong>幻读</strong>（Phantom reads）：一个事务A读取到了另一个事务B新提交的数据。比如，事务A对一个表中所有行的数据按照某规则进行修改（整表操作），同时，事务B向表中插入了一行原始数据，那么后面事务A再对表进行操作时，会发现表中居然还有一行数据没有被修改，就像发生了幻觉，飘飘欲仙一样。</li>
</ul>
<p><strong>注意</strong>：不可重复读和幻读的区别是，不可重复读对应的表的操作是<strong>更改(UPDATE)</strong>，而幻读对应的表的操作是<strong>插入(INSERT)</strong>，两种的应对策略不一样。对于不可重复读，只需要采用<strong>行级锁</strong>防止该记录被更新即可，而对于幻读必须加个<strong>表级锁</strong>，防止在表中插入数据。有关锁的问题，下面会讨论。</p>
<p>为了处理这几种问题，SQL定义了下面的4个等级的事务隔离级别：</p>
<ul>
<li>未提交读（<strong>READ UNCOMMITTED</strong> ）：最低隔离级别，一个事务能读取到别的事务未提交的更新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；</li>
<li>提交读（<strong>READ COMMITTED</strong>）：一个事务能读取到别的事务提交的更新数据，不能看到未提交的更新数据，不会出现丢失更新、脏读，但可能出现不可重复读、幻读；</li>
<li>可重复读（<strong>REPEATABLE READ</strong>）：保证同一事务中先后执行的多次查询将返回同一结果，不受其他事务影响，不可能出现丢失更新、脏读、不可重复读，但可能出现幻读；</li>
<li>序列化（<strong>SERIALIZABLE</strong>）：最高隔离级别，不允许事务并发执行，而必须串行化执行，最安全，不可能出现更新、脏读、不可重复读、幻读，但是效率最低。</li>
</ul>
<p>隔离级别越高，数据库事务并发执行性能越差，能处理的操作越少。所以一般地，推荐使用REPEATABLE READ级别保证数据的读一致性。对于幻读的问题，可以通过加锁来防止。<br>MySQL支持这四种事务等级，默认事务隔离级别是<strong>REPEATABLE READ</strong>。Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别，所以Oracle数据库不支持脏读。Oracle数据库默认的事务隔离级别是<strong>READ COMMITTED</strong>。</p>
<hr>
<h1 id="各种锁">各种锁</h1><p>下面总结一下MySQL中的锁，有好几种分类。其它RDBMS也差不多是这样。<br>首先最重要的分类就是<strong>乐观锁</strong>(Optimistic Lock)和<strong>悲观锁</strong>(Pessimistic Lock)，这实际上是两种锁策略。<br>乐观锁，顾名思义就是非常乐观，非常相信真善美，每次去读数据都认为其它事务没有在写数据，所以就不上锁，快乐的读取数据，而只在提交数据的时候判断其它事务是否搞过这个数据了，如果搞过就rollback。乐观锁相当于一种检测冲突的手段，可通过为记录添加版本或添加时间戳来实现。<br>悲观锁，对其它事务抱有保守的态度，每次去读数据都认为其它事务想要作祟，所以每次读数据的时候都会上锁，直到取出数据。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性，但随之而来的是各种开销。悲观锁相当于一种避免冲突的手段。<br>选择标准：如果并发量不大，或数据冲突的后果不严重，则可以使用乐观锁；而如果并发量大或数据冲突后果比较严重（对用户不友好），那么就使用悲观锁。</p>
<p>从读写角度，分<strong>共享锁</strong>（S锁，Shared Lock）和<strong>排他锁</strong>（X锁，Exclusive Lock），也叫<strong>读锁</strong>（Read Lock）和<strong>写锁</strong>（Write Lock）。<br>理解：</p>
<ul>
<li>持有S锁的事务只读不可写。如果事务A对数据D加上S锁后，其它事务只能对D加上S锁而不能加X锁。</li>
<li>持有X锁的事务可读可写。如果事务A对数据D加上X锁后，其它事务不能再对D加锁，直到A对D的锁解除。</li>
</ul>
<p>从锁的粒度角度，主要分为<strong>表级锁</strong>（Table Lock）和<strong>行级锁</strong>（Row Lock）。<br>表级锁将<strong>整个表</strong>加锁，性能开销最小。用户可以同时进行读操作。当一个用户对表进行写操作时，用户可以获得一个写锁，写锁禁止其他的用户读写操作。写锁比读锁的优先级更高，即使有读操作已排在队列中，一个被申请的写锁仍可以排在所队列的前列。<br>行级锁仅对<strong>指定的记录</strong>进行加锁，这样其它进程可以对同一个表中的其它记录进行读写操作。行级锁粒度最小，开销大，能够支持高并发，可能会出现死锁。</p>
<p>MySQL的MyISAM引擎使用<strong>表级锁</strong>，而InnoDB支持表级锁和行级锁，默认是<strong>行级锁</strong>。<br>还有BDB引擎使用<strong>页级锁</strong>，即一次锁定一组记录，并发性介于行级锁和表级锁之间。</p>
<hr>
<h1 id="三级锁协议">三级锁协议</h1><p>三级加锁协议是为了保证正确的事务并发操作，事务在读、写数据库对象是需要遵循的加锁规则。</p>
<ul>
<li><strong>一级封锁协议</strong>：事务T在修改数据R之前必须对它加<strong>X锁</strong>，直到事务结束方可释放。而若事务T只是读数据，不进行修改，则不需加锁，因此一级加锁协议下可能会出现脏读和不可重复读。</li>
<li><strong>二级加锁协议</strong>：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加<strong>S锁</strong>，直到<strong>读取完毕以后</strong>释放。二级加锁协议下可能会出现不可重复读。</li>
<li><strong>三级加锁协议</strong>：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加<strong>S锁</strong>，直到<strong>事务结束</strong>方可释放。三级加锁协议避免了脏读和不可重复读的问题。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Summary/">Summary</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事务/">事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-jvm-classloader-parent-delegation-model" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-classloader-parent-delegation-model/" class="article-date">
      <time datetime="2015-08-05T16:00:00.000Z" itemprop="datePublished">2015-08-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-classloader-parent-delegation-model/">深入探究JVM | 类加载器与双亲委派模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>类的加载过程指通过一个类的全限定名来获取描述此类的二进制字节流，并将其转化为方法区的数据结构，进而生成一个<code>java.lang.Class</code>对象作为方法区这个类各种数据访问的入口。这个过程通过Java中的类加载器(ClassLoader)来完成。</p>
<h1 id="类与类加载器">类与类加载器</h1><p>类加载器非常重要，因为每个类加载器都有一个独立的类名称空间。比如我们要加载两个类，如果要比较两个类是否相等（包括<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法），只有在这两个类被<strong>同一个类加载器</strong>加载的前提下，比较才有意义。否则，即使两个类来自同一个class文件，被同一个JVM加载，但是加载它们的类加载器不同，则这两个类就不相等。这就相当于两个命名空间中的等价类<code>LoaderA::C</code>和<code>LoaderB::C</code>。</p>
<h1 id="类加载器的种类">类加载器的种类</h1><p>从一般角度来分的话，ClassLoader分为根加载器（Bootstrap ClassLoader）和其它的加载器。其中Bootstrap ClassLoader负责加载Java的核心类，由JVM实现(C++)，而其它类加载器都由Java层实现并继承<code>java.lang.ClassLoader</code>。</p>
<p>更细分的话，ClassLoader分为：</p>
<ul>
<li>Bootstrap ClassLoader（启动类加载器）负责将<code>%JAVA_HOME%/lib</code>目录中或<code>-Xbootclasspath</code>中参数指定的路径中的，并且是虚拟机识别的（按名称）类库加载到JVM中</li>
<li>Extension ClassLoader（扩展类加载器）负责加载<code>%JAVA_HOME%/lib/ext</code>中的所有类库</li>
<li>System ClassLoader（加载<code>%CLASSPATH%</code>路径的类库）以及其它自定义的ClassLoader</li>
</ul>
<h1 id="双亲委派模型">双亲委派模型</h1><p>JVM中类加载的机制——双亲委派模型。这个模型要求除了Bootstrap ClassLoader外，其余的类加载器都要有自己的父加载器。子加载器通过组合来复用父加载器的代码，而不是使用继承。在某个类加载器加载class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器(Bootstrap)。如果顶层加载不了（它的搜索范围中找不到此类），子加载器才会尝试加载这个类。</p>
<p>双亲委派模型最大的好处就是<strong>让Java类同其类加载器一起具备了一种带优先级的层次关系</strong>。这句话可能不好理解，我们举个例子。比如我们要加载顶层的Java类——<code>java.lang.Object</code>类，无论我们用哪个类加载器去加载Object类，这个加载请求最终都会委托给Bootstrap ClassLoader，这样就保证了所有加载器加载的Object类都是同一个类。如果没有双亲委派模型，那就乱了套了，完全可以搞出<code>Root::Object</code>和<code>L1::Object</code>这样两个不同的Object类。</p>
<p>双亲委派模型的实现比较简单，在<code>java.lang.ClassLoader</code>的<code>loadClass</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意JVM的双亲委派模型也会遭到破坏（Java自己就破坏好几次）。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-algorithm-advanced-a1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Algorithm/algorithm-advanced-a1/" class="article-date">
      <time datetime="2015-07-22T10:15:09.000Z" itemprop="datePublished">2015-07-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Algorithm/algorithm-advanced-a1/">高级算法总结（1）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="本文章总结一些比较高级的算法~这是第一弹~">本文章总结一些比较高级的算法~这是第一弹~</h2><h1 id="0x00_质因数分解">0x00 质因数分解</h1><h2 id="普通数域筛选法（GNFS）">普通数域筛选法（GNFS）</h2><p>待补充</p>
<h2 id="秀尔算法（Shor算法）">秀尔算法（Shor算法）</h2><p>以数学家彼得・秀尔命名，是一个在1994年发现的，针对整数分解这题目的的量子算法（在量子计算机上面运作的算法）。比较不正式的说，它解决题目如下：给定一个整数N，找出他的质因数。</p>
<p>在一个量子计算机上面，要分解整数N,秀尔算法的运作需要多项式时间（时间是log N的某个多项式这么长,log N在这里的意义是输入的档案长度）。更精确的说，这个算法花费O((log N)3)的时间，展示出质因数分解问题可以使用量子计算机以多项式时间解出，因此在复杂度类BQP里面。这比起传统已知最快的因数分解算法，普通数域筛选法，其花费次指数时间 — 大约O(e1.9 (log N)1/3 (log log N)2/3)，还要快了一个指数的差异。</p>
<p>秀尔算法非常重要，因为它代表使用量子计算机的话，我们可以用来破解已被广泛使用的公开密钥加密方法，也就是RSA加密算法。RSA算法的基础在于假设了我们不能很有效率的分解一个已知的整数。就目前所知，这假设对传统的（也就是非量子）电脑为真；没有已知传统的算法可以在多项式时间内解决这个问题。然而，秀尔算法展示了因数分解这问题在量子计算机上可以很有效率的解决，所以一个足够大的量子计算机可以破解RSA。这对于鼓吹我们去建立量子计算机和去研究新的量子计算机算法，是一个非常大的动力。</p>
<p>在2001年，IBM的一个小组展示了秀尔算法的实例，使用NMR实做的量子计算机，以及7个量子位元，将15分解成3×5。然而，对IBM的实验的是否是量子计算的真实展示，则有一些疑虑出现，因为没有缠结现象被发现。在IBM的实做之后，有其他的团队以光学量子位元实做秀尔算法，并强调其缠结现象可被观察到。</p>
<p>有望解决：人机对弈围棋（通过机器学习+量子计算机解决）</p>
<h2 id="0x01_平方根倒数速算法(0x5f3759df)">0x01 平方根倒数速算法(0x5f3759df)</h2><p>[IEEE Standard 754 for Binary Floating-Point Arithmetic][FAST INVERSE SQUARE ROOT]</p>
<p>这一算法的优势在于减少了求平方根倒数时浮点运算操作带来的巨大的运算耗费，而在计算机图形学领域，若要求取照明和投影的波动角度与反射效果，就常需计算平方根倒数。<br>详见：<a href="http://zh.wikipedia.org/wiki/平方根倒数速算法" target="_blank" rel="external">Wiki-平方根倒数速算法</a><br>相关代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Q_rsqrt</span><span class="params">( <span class="keyword">float</span> number )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> i;</span><br><span class="line">	<span class="keyword">float</span> x2, y;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line"></span><br><span class="line">	x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">	y  = number;</span><br><span class="line">	i  = * ( <span class="keyword">long</span> * ) &amp;y;                       <span class="comment">// evil floating point bit level hacking</span></span><br><span class="line">	i  = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );               <span class="comment">// what the fuck?</span></span><br><span class="line">	y  = * ( <span class="keyword">float</span> * ) &amp;i;</span><br><span class="line">	y  = y * ( threehalfs - ( x2 * y * y ) );   <span class="comment">// 1st iteration</span></span><br><span class="line"><span class="comment">//      y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随着硬件的进步，目前此算法已不太常用。</p>
<h2 id="0x02_伸展树(Splay_Tree)">0x02 伸展树(Splay Tree)</h2><p>Splay Tree是一种二叉排序树，主要操作有zig和zag操作（无机化学中的zig-zag Borate)。</p>
<p>假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。</p>
<p>待补充~</p>
<h2 id="0x03_FFT进行大数乘法">0x03 FFT进行大数乘法</h2><p>向量 {ck} 是向量 {ai} 和向量 {bj} 的卷积。根据卷积定理，向量卷积的离散傅里叶变换是向量离散傅里叶变换的乘积。于是，我们可以按照以下步骤来计算大整数乘法：<br>1、分别求出向量 {ai} 和向量 {bj} 的离散傅里叶变换 {Ai} 和 {Bj}。<br>2、将 {Ai} 和 {Bj} 逐项相乘得到向量 {Ck}。<br>3、对 {Ck} 求离散傅里叶逆变换，得到的向量 {ck} 就是向量 {ai} 和向量 {bj} 的卷积。<br>4、对的向量 {ck} 进行适当的进位就得到了大整数 a 和 b 的乘积 c。<br>用FFT进行大数乘法，其时间复杂度可至O（NlogN），优化的十分有效（相对于传统的O（N^2）而言）</p>
<hr>
<p>未完待续~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-test-migrate" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Life/test-migrate/" class="article-date">
      <time datetime="2015-07-22T09:38:31.000Z" itemprop="datePublished">2015-07-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Life/test-migrate/">博客搬迁咯~</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="此文章仅为测试用">此文章仅为测试用</h3><p>以前那个VPS真的太慢了。。旧博客系统一时脑残用了WordPress，对md的支持很不好，所以这次换了支持md比较好的博客系统Hexo。<br>说起来发现Hexo这个博客系统还真是偶然，当时是练习Dockerfile构建的时候看到了这个玩意，构建完后便试用了一下发现很方便，很好用，正好以前的VPS到期了，所以就趁着这个机会把博客迁移到Hexo上。<br>至于以前的文章，有意义的还会贴上来，有些比较麻烦不好转换成md的就先不贴了。<br>新的开始~<br>（PS：期末考试终于快结束啦哈哈哈！！！）<br><img src="http://7xkkgd.com1.z0.glb.clouddn.com/pic57261028.JPG" alt=""><br>附赠薛定谔方程，测试一下LaTex引擎:<br>$$ i\hbar\frac{\partial \psi}{\partial t}<br>= \frac{-\hbar^2}{2m} \left(<br>\frac{\partial^2}{\partial x^2}+ \frac{\partial^2}{\partial y^2}+ \frac{\partial^2}{\partial z^2}<br>\right) \psi + V \psi $$</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Life/">Life</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2016 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30.
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>