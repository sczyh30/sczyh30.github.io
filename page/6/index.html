<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>「千载弦歌，芳华如梦」 - sczyh30&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--<meta name="keywords" content="sczyh30, blog"/>-->
  <meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/page/6/index.html">
<meta property="og:site_name" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">
  
    <link rel="alternative" href="/atom.xml" title="「千载弦歌，芳华如梦」 - sczyh30&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/AIO/" style="font-size: 10px;">AIO</a> <a href="/tags/AMQP/" style="font-size: 10px;">AMQP</a> <a href="/tags/APT/" style="font-size: 10px;">APT</a> <a href="/tags/Akka-Actor/" style="font-size: 10px;">Akka Actor</a> <a href="/tags/Algorithm/" style="font-size: 13px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 16px;">C++</a> <a href="/tags/C-11/" style="font-size: 10px;">C++ 11</a> <a href="/tags/CE3/" style="font-size: 10px;">CE3</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Category-Theory/" style="font-size: 10px;">Category Theory</a> <a href="/tags/Chemistry/" style="font-size: 11px;">Chemistry</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Docker/" style="font-size: 11px;">Docker</a> <a href="/tags/Engine/" style="font-size: 10px;">Engine</a> <a href="/tags/Euterpea/" style="font-size: 10px;">Euterpea</a> <a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/FRP/" style="font-size: 10px;">FRP</a> <a href="/tags/Functional-Programming/" style="font-size: 18px;">Functional Programming</a> <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/GC/" style="font-size: 13px;">GC</a> <a href="/tags/GDB/" style="font-size: 10px;">GDB</a> <a href="/tags/Game/" style="font-size: 11px;">Game</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/Haskell/" style="font-size: 14px;">Haskell</a> <a href="/tags/HotSpot/" style="font-size: 12px;">HotSpot</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 19px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Klass-oop/" style="font-size: 10px;">Klass-oop</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/MIDI/" style="font-size: 10px;">MIDI</a> <a href="/tags/Mathematical-Logic/" style="font-size: 10px;">Mathematical Logic</a> <a href="/tags/Metaspace/" style="font-size: 10px;">Metaspace</a> <a href="/tags/Netflix-Hystrix/" style="font-size: 10px;">Netflix Hystrix</a> <a href="/tags/Network/" style="font-size: 16px;">Network</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Object-Model/" style="font-size: 12px;">Object Model</a> <a href="/tags/Play-Framework/" style="font-size: 11px;">Play Framework</a> <a href="/tags/Quorum/" style="font-size: 10px;">Quorum</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Reflection/" style="font-size: 11px;">Reflection</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/STL/" style="font-size: 11px;">STL</a> <a href="/tags/Scala/" style="font-size: 19px;">Scala</a> <a href="/tags/Slick/" style="font-size: 11px;">Slick</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Struct/" style="font-size: 10px;">Struct</a> <a href="/tags/Summary/" style="font-size: 12px;">Summary</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/Type-Lambda/" style="font-size: 10px;">Type Lambda</a> <a href="/tags/Type-System/" style="font-size: 10px;">Type System</a> <a href="/tags/Type-Theory/" style="font-size: 12px;">Type Theory</a> <a href="/tags/UE4/" style="font-size: 10px;">UE4</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/Vert-x/" style="font-size: 19px;">Vert.x</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Web/" style="font-size: 12px;">Web</a> <a href="/tags/Web开发/" style="font-size: 12px;">Web开发</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/functional/" style="font-size: 10px;">functional</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/事务/" style="font-size: 10px;">事务</a> <a href="/tags/云服务/" style="font-size: 12px;">云服务</a> <a href="/tags/内存区域/" style="font-size: 10px;">内存区域</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/分布式系统/" style="font-size: 12px;">分布式系统</a> <a href="/tags/前端/" style="font-size: 12px;">前端</a> <a href="/tags/基础/" style="font-size: 10px;">基础</a> <a href="/tags/多线程/" style="font-size: 11px;">多线程</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/开发/" style="font-size: 17px;">开发</a> <a href="/tags/异步/" style="font-size: 13px;">异步</a> <a href="/tags/异步编程/" style="font-size: 18px;">异步编程</a> <a href="/tags/微服务/" style="font-size: 13px;">微服务</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 11px;">数据库</a> <a href="/tags/架构/" style="font-size: 11px;">架构</a> <a href="/tags/消息系统/" style="font-size: 10px;">消息系统</a> <a href="/tags/源码分析/" style="font-size: 14px;">源码分析</a> <a href="/tags/生活/" style="font-size: 10px;">生活</a> <a href="/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Fighting</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-cpp-stl-hashmap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/C-C/cpp-stl-hashmap/" class="article-date">
      <time datetime="2015-10-23T16:00:00.000Z" itemprop="datePublished">2015-10-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/C-C/cpp-stl-hashmap/">C++ STL之哈希表 | unordered_map</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>C++ STL中，哈希表对应的容器是<code>unordered_map</code>（since C++ 11）。<br>根据C++ 11标准的推荐，用<code>unordered_map</code>代替<code>hash_map</code>。</p>
<h1 id="Prolouge">Prolouge</h1><p>先来回顾一下数据结构中哈希表相关的知识。<br>哈希表是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。<br>哈希表的一个重要问题就是如何解决映射冲突的问题。常用的有两种：<strong>开放地址法</strong> 和 <strong>链地址法</strong>。</p>
<h1 id="与map的区别">与map的区别</h1><p>STL中，map对应的数据结构是<strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 <strong>O(logN)</strong>。而unordered_map对应 <strong>哈希表</strong>，哈希表的特点就是查找效率高，时间复杂度为常数级别 <strong>O(1)</strong>， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用unordered_map容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用map容器。</p>
<h1 id="基本使用">基本使用</h1><p>unordered_map的用法和map大同小异，一个简单示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unordered_map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">1</span>, <span class="string">"Scala"</span>));</span><br><span class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">2</span>, <span class="string">"Haskell"</span>));</span><br><span class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">3</span>, <span class="string">"C++"</span>));</span><br><span class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">6</span>, <span class="string">"Java"</span>));</span><br><span class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">14</span>, <span class="string">"Erlang"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">if</span> ((it = <span class="built_in">map</span>.find(<span class="number">6</span>)) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="使用自定义类">使用自定义类</h1><p>要使用哈希表，必须要有对应的计算散列值的算法以及判断两个值（或对象）是否相等的方法。<br>在Java中，Object类里有两个重要方法：<code>hashCode</code>和<code>equals</code>方法。其中<code>hashCode</code>方法便是为散列存储结构服务的，用来计算散列值；而<code>equals</code>方法则是用来判断两对象是否等价。由于所有的类都继承自<code>java.lang.Object</code>类，因此所有类相当于都拥有了这两个方法。</p>
<p>而在C++中没有自动声明这类函数，STL只为C++常用类提供了散列函数，因此如果想在<code>unordered_map</code>中使用自定义的类，则必须为此类提供一个哈希函数和一个判断对象是否相等的函数（e.g. 重载==运算符）。下面是一个简单示例（扒自数据结构上机作业的部分代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="comment">//    string phone;</span></span><br><span class="line"><span class="comment">//    string name;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> phone;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">string</span> phone, <span class="built_in">string</span> address)</span>: <span class="title">name</span><span class="params">(name)</span>, <span class="title">phone</span><span class="params">(phone)</span>, <span class="title">address</span><span class="params">(address)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overload operator==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;phone == p.phone &amp;&amp; <span class="keyword">this</span>-&gt;name == p.name</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>-&gt;address == p.address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, Person&amp; p) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">"[Person] -&gt; ("</span> &lt;&lt; p.name &lt;&lt; <span class="string">", "</span> &lt;&lt; p.phone &lt;&lt; <span class="string">", "</span></span><br><span class="line">           &lt;&lt; p.address &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare hash&lt;Person&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"> <span class="keyword">template</span> &lt;&gt;</span><br><span class="line"> <span class="keyword">struct</span> hash&lt;Person&gt; &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> Person&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line">      <span class="keyword">using</span> <span class="built_in">std</span>::hash;</span><br><span class="line">      <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line">      <span class="comment">// Compute individual hash values for first,</span></span><br><span class="line">      <span class="comment">// second and third and combine them using XOR</span></span><br><span class="line">      <span class="comment">// and bit shifting:</span></span><br><span class="line">      <span class="keyword">return</span> ((hash&lt;<span class="built_in">string</span>&gt;()(p.phone)</span><br><span class="line">        ^ (hash&lt;<span class="built_in">string</span>&gt;()(p.name) &lt;&lt; <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        ^ (hash&lt;<span class="built_in">string</span>&gt;()(p.address) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, Person&gt; phoneMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectByPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> phone;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input the phone number: "</span>; <span class="built_in">cin</span> &gt;&gt; phone;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, Person&gt;::iterator it;</span><br><span class="line">    <span class="keyword">int</span> size = phoneMap.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pc = <span class="number">0</span>; pc &lt; size; pc++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((it = phoneMap.find(phone)) != phoneMap.end()) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\033[32mQuery result: "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">"\033[0m"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\033[33mQuery result : target_not_found\033[0m"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于哈希值如何计算，前面我写过一篇文章专门介绍这个：<a href="http://www.sczyh30.com/posts/Java/java-hashcode-equal">hashCode方法及equals方法的规范</a>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/">STL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Summary/">Summary</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-android-performance-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Develop/android-performance-1/" class="article-date">
      <time datetime="2015-10-23T10:36:00.000Z" itemprop="datePublished">2015-10-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Develop/android-performance-1/">对Android应用性能优化的一些总结（1）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在移动端内存非常宝贵，我们要尽可能地去优化内存以达到最佳性能，并努力地去避免OOM问题。这篇文章总结一些最常见的Android性能优化的一些事项~</p>
<hr>
<h2 id="图片加载">图片加载</h2><p>在移动端，图片的加载往往是最消耗内存的，OOM也经常会发生在加载图片时。以下是加载图片的几个注意事项：</p>
<ul>
<li>按需要的大小加载。缩略图加载成原图的精细度并不会提升视觉上的效果，但会额外占用不少内存。</li>
<li>图片的缓存使用<strong>LruCache</strong>，并且合理地设置缓存大小（有关LRU Cache的原理见<a href="http://www.sczyh30.com/posts/Algorithm/algorithm-cache/">这里</a>)</li>
<li>可以用一些高效的图片加载库，比如Facebook的Fresco</li>
</ul>
<h2 id="注意一些额外的内存消耗">注意一些额外的内存消耗</h2><ul>
<li>应特别注意HashMap这个数据结构，必要的时候可以用<strong>SparseArray</strong>等等的数据结构代替以节省内存</li>
<li>需要频繁修改字符串的地方考虑用<strong>StringBuilder</strong>代替String</li>
<li>避免创建无用的实例</li>
</ul>
<h2 id="有限度地使用Service">有限度地使用Service</h2><p>当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p>
<p>因此，控制好Service的生命周期是很重要的。切忌一个无用的Service跑在后台，这会非常影响性能。如果一个逻辑只需要进行一次，那么可以用<strong>IntentService</strong>代替。</p>
<h2 id="Handler必须为静态内部类">Handler必须为静态内部类</h2><p>首先复习一下Java几种内部类的语言规范，Java中的<strong>inner class</strong>（内部类）定义在一个类的内部，它有一个<strong>指向外部类的引用</strong>。这就有可能导致一个问题，其外部类的生命周期已经结束，而由于inner class持有外部类的引用，并且inner class与其它对象还有引用关联，因此GC进行可达性分析时发现内部类与外部类仍有引用关系，因此不会cause GC，从而导致内存泄露。<br>而<strong>static nested class</strong>（静态内部类）虽定义在类的内部，但是它<strong>不持有外部类的引用</strong>，只能访问外部类的静态实例和方法。</p>
<p>在安卓开发中，一个典型的例子是Handler的使用，它会有这样的问题：</p>
<blockquote>
<p>In Android, Handler classes should be static or leaks might occur. Messages enqueued on the application thread’s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class.</p>
</blockquote>
<p>这句话的主旨就是，Handler类必须声明为静态（内部）类（static nested class），否则可能会发生内存泄露。因为，进入MessageQueue的Message会持有它们目标Handler的引用；这就可能出现一种情况，一个消息还在排队，而此时目标Handler类所对应的外部类的生命周期已到onDestroy，即将被GC，但由于目标Handler类仍持有其外部类的引用，使得外部类不能被回收，从而导致内存泄露。这一点说明了<strong>Handler类型的对象，生命周期是未知的</strong>。</p>
<p>然而如果声明为static，又会有许多不方便的地方，比如很多逻辑需要访问外部类的非静态变量和非静态方法。此时，我们应该使用外部类的<strong>弱引用</strong>（WeakReference），举例表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;DeviceUserFragment&gt; mFragment;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(DeviceUserFragment fragment)</span> </span>&#123;</span><br><span class="line">            mFragment = <span class="keyword">new</span> WeakReference&lt;&gt;(fragment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            Object object = msg.obj;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> HWServiceConfig.GET_DEVICE_USER_INFO:</span><br><span class="line">                    mFragment.get().mInfo = (DataUserInfo)object;</span><br><span class="line">                    mFragment.get().isInfoOK = <span class="keyword">true</span>;</span><br><span class="line">                    mFragment.get().updateUI();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里顺便复习一下JVM中的四种引用的知识吧（直接扒的以前自己的文章）：</p>
<ul>
<li><strong>StrongReference</strong>（强引用）是最普通的引用类型，只要强引用存在，GC就不会进行垃圾回收。</li>
<li><strong>SoftReference</strong>（软引用）用来描述一些有用但是非必需的对象。如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM就会把这个软引用加入到与之关联的引用队列中。软引用可用来实现内存敏感的高速缓存。</li>
<li><strong>WeakReference</strong>（弱引用）是一种生命周期比软引用更短的引用。当GC扫描启动时，只要扫描到只具有弱引用的对象，<strong>无论内存是否够用都会执行GC</strong>；但由于GC线程优先级很低，因此并不一定能迅速发现这些弱引用对象。弱引用也可以和一个引用队列联合使用。</li>
<li><strong>PhantomReference</strong>（虚引用）不同于其余三种引用，虚引用不会影响对象的生命周期，也无法通过虚引用获得对象的一个实例；如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动，它必须和引用队列联合使用。</li>
</ul>
<p>明白了弱引用的生命周期，此处想必就很好理解了。构造一个外部类的弱引用，然后通过<code>get</code>方法获得其实例进行操作即可，既避免了内存泄露，又可以自由地调用外部类的方法。<br><strong>WeakReference</strong>和<strong>SoftReference</strong>在其他很多地方也都有运用，以后再补充~</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践 - 郭霖的专栏</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能优化/">性能优化</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-android-aysnc-message" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Develop/android-aysnc-message/" class="article-date">
      <time datetime="2015-10-22T07:35:00.000Z" itemprop="datePublished">2015-10-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Develop/android-aysnc-message/">Android异步消息处理机制总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本次项目完成，对安卓的异步消息处理机制有了更深的了解，在这里总结一下。</p>
<h1 id="Prolouge">Prolouge</h1><p>先来回顾一下基础，Android中的异步消息处理主要由<code>Message</code>, <code>Handler</code>, <code>MessageQueue</code>和<code>Looper</code>四部分组成。</p>
<h2 id="Message">Message</h2><p><code>Message</code>主要作为线程之间传递的信息，它可以携带一些数据。它的<code>what</code>字段（一般用来表示消息类型）、<code>arg0</code>、<code>arg1</code>字段可以携带一些整型数据，<code>obj</code>字段可以携带一个对象，并且可以用<code>setData</code>方法传输一个<code>Bundle</code>对象。</p>
<p><code>Message</code>的创建方法有两种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message msg0 = <span class="keyword">new</span> Message(); <span class="comment">//调用Message的构造方法</span></span><br><span class="line">Message msg1 = Message.obtain(); <span class="comment">//从消息池中获取</span></span><br><span class="line">Message message = mHandler.obtainMessage(); <span class="comment">//或者这样从消息池中获取</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>Handler</code>的<code>obtainMessage</code>方法也是调用了<code>obtain</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Returns a new &#123;<span class="doctag">@link</span> android.os.Message Message&#125; from the global message pool. More efficient than</span><br><span class="line">     * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).</span><br><span class="line">     *  If you don't want that facility, just call Message.obtain() instead.</span><br><span class="line">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种方法的本质区别是，<code>obtain</code>方法直接从消息池中获取<code>Message</code>对象，这样很多时候可以避免创建新对象，减少内存开销，从<code>obtain</code>方法的源码中就能看出这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Return a new Message instance from the global pool. Allows us to</span><br><span class="line">     * avoid allocating new objects in many cases.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因此，获取<code>Message</code>时尽量使用<code>obtain</code>方法。</p>
<h2 id="Handler">Handler</h2><p><code>Handler</code>用于发送和处理信息，相当于生产者和消费者。<code>Handler</code>通过<code>sendMessage</code>方法将Message传入<code>MessageQueue</code>消息队列，经<code>Looper</code>轮询后将<code>Message</code>传递至<code>handleMessage</code>方法中。</p>
<p>最常见的一个应用就是需要在子线程中处理UI，这时候就需要借助<code>Handler</code>实现。</p>
<h2 id="MessageQueue">MessageQueue</h2><p><code>MessageQueue</code>，顾名思义就是消息队列，它用来存放<code>Handler</code>发送的消息，直到消息被处理。每个线程中只能有一个消息队列。</p>
<h2 id="Looper">Looper</h2><p><code>Looper</code>相当于<code>MessageQueue</code>的监视器。首先调用<code>Looper.loop()</code>方法进入无限循环状态，每当一个新的<code>Message</code>进入<code>MessageQueue</code>，<code>Looper</code>就会轮询，将此<code>Message</code>传递给<code>handleMessage</code>方法。每个线程中只能有一个<code>Looper</code>对象。</p>
<h1 id="底层实现">底层实现</h1><p>一个标准的异步处理流程应该是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"></span><br><span class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                  <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Looper.loop();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们从<code>Handler</code>的构造函数开始分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们直接在子线程中创建<code>Handler</code>，会抛出异常，提示 “Can’t create handler inside thread that has not called Looper.prepare()”，也就是要调用<code>Looper.prepare()</code>方法。根据源码，这是因为子线程的Looper为空所致，而观察<code>prepare</code>方法的源码可知，此方法的作用就是创建一个<code>Looper</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而主线程也没有调用<code>Looper.prepare()</code>，为什么没有崩溃呢？显然是系统自动地帮我们调用了这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> AndroidKeyStoreProvider());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">        <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>Looper.prepareMainLooper()</code>方法最后调用了<code>Looper.prepare()</code>方法，创建了主线程的Looper。而子线程则不会主动创建Looper，必须自己调用方法创建。</p>
<p>创建完了Handler，下一步就是创建Message然后<code>sendMessage</code>了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>sendMessage</code>的结果是将此Message入队。注意到MessageQueue中只保存了当前待处理的一个对象，而不是一个集合；出队则是由<code>Looper.loop()</code>进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>出队的逻辑为<code>queue.next()</code>，其逻辑为：如果MessageQueue的待处理消息对象不为空，那么就出队并让下一个消息入队，否则阻塞。消息出队后经由dispatchMessage方法回调，以便在handleMessage中接收到Message并进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个完整的异步消息处理机制，用网上的一幅图总结：</p>
<p><img src="http://img.blog.csdn.net/20151023143204457" alt="消息处理机制（图片来自网络）"></p>
<h1 id="AsyncTask">AsyncTask</h1><p>当然从Android 1.5开始，谷歌就引入了一个更方便使用的<code>AsyncTask</code>类用于处理异步任务，非常轻量级，通过实现其回调函数来实现相应逻辑。比如我写了一个异步读取缓存的Task：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Void</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;Context&gt; mContext;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CacheTask</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            mContext = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> User <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">            Serializable object = XmlCacheManager.readObject(mContext.get(), <span class="string">"user"</span>);</span><br><span class="line">            <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (User) object;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(User info)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPostExecute(info);</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mContext.get().mInfo = info;</span><br><span class="line">                mContext.get().mErrorLayout.setType(AppConstant.HIDE_ERROR_LAYOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mContext.get().mErrorLayout.setType(AppConstant.NETWORK_ERROR_LAYOUT);</span><br><span class="line">            &#125;</span><br><span class="line">            mContext.get().updateUI();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在此逻辑中，<code>doInBackground</code>方法用于执行具体的缓存读取，而<code>onPostExecute</code>方法用于通知UI更新任务的结果（即更新UI）。其实AsyncTask底层也是利用上边的异步消息机制实现的，只不过它封装地非常好，免去了开发者自己写Message和Handler的环节，减少编码量。</p>
<p>粗略看了一下AsyncTask的源码，发现其的底层实现用了各种JUC的东西，以后有时间再研究研究它的源码。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-struct_sizeof" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Summary/struct_sizeof/" class="article-date">
      <time datetime="2015-09-25T16:00:00.000Z" itemprop="datePublished">2015-09-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Summary/struct_sizeof/">C/C++结构体字节对齐</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近在群里看到不少人在讨论结构体字节对齐的问题，就顺便看了看，总结一下。<br>在C中，计算一个结构体的大小不是简单地将其各成员所占空间的大小相加，而是有特定的规则 - <strong>字节对齐</strong>。使用字节对齐的原因有两个，第一是某些平台只能在特定地址访问特定的数据，二是提高数据存取的速度（尽量减少存取次数）。C99标准并没有明确规定内存字节对齐的细节，具体细则应由编译器决定。</p>
<p>这里首先引入<strong>对齐参数</strong>这一概念，这是结构体字节对齐的一个参考量，对于每种变量的对齐参数，不同编译器实现不同，这里参考网上列出GCC和MSVC两种编译器对应的对齐参数（均为32位）：</p>
<table>
<thead>
<tr>
<th>编译器</th>
<th>对应量</th>
<th>char</th>
<th>bool(cpp)</th>
<th>short</th>
<th>int</th>
<th>float</th>
<th>double</th>
<th>指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>VC++2015</td>
<td>所占空间</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>VC++2015</td>
<td>对齐参数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>gcc 4.8.2(linux)</td>
<td>所占空间</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>gcc 4.8.2(linux)</td>
<td>对齐参数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>编译器还可以设置默认对齐参数，用预编译语句<code>#pragma pack(n)</code>表示，在Windows（32位）下n可取1,2,4,8，默认为8；在Linux（32位）下可取1,2,4，默认为4。</p>
<p>最后，每个变量实际的对齐参数为每个成员变量的对齐参数和编译器的默认对齐参数中较小的一个，比如一个float型变量的对齐参数为4，编译器设定的<code>#pragma pack(8)</code>，则此变量实际的对齐参数就为4；对于结构体变量，它的自身对齐参数就为它里面各个变量最终对齐参数的最大值。</p>
<p>结构体字节对齐的原则主要有两点：</p>
<ol>
<li><strong>结构体的每一个成员相对结构体首地址的偏移量应该是对其参数的整数倍，如果不满足则补足前面的字节使其满足</strong></li>
<li><strong>结构体的最终大小应该是其对应参数的整数倍</strong></li>
</ol>
<p>下面用例子来说明(C++)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node1 &#123;</span><br><span class="line">&#125; S1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node2 &#123;  </span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125; S2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node3 &#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125; S3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node4 &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c; <span class="comment">//静态变量单独存放在静态数据区</span></span><br><span class="line">&#125; S4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node5 &#123;</span><br><span class="line">    <span class="keyword">bool</span> a;</span><br><span class="line">    S1 b;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125; S5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node6 &#123;</span><br><span class="line">    <span class="keyword">bool</span> a;</span><br><span class="line">    S2 b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125; S6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node7 &#123;</span><br><span class="line">    <span class="keyword">bool</span> a;</span><br><span class="line">    S2 b;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125; S7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node8 &#123;</span><br><span class="line">    <span class="keyword">bool</span> a;</span><br><span class="line">    S2 b;</span><br><span class="line">    <span class="keyword">char</span>* c;</span><br><span class="line">&#125; S8;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>node1</code>为一个空结构体，在C中空结构体的大小为0字节，在C++中空结构体的大小为1字节。</li>
<li><code>node2</code>的内存结构：（4 — 1 — 1（补） — 2），总大小为8字节。</li>
<li><code>node3</code>的内存结构：（1 — 3（补） — 4 — 4），总大小为12字节。</li>
<li><code>node4</code>的内存结构：（4 — 2 — 2（补）），总大小为8字节，注意静态变量被分配到静态数据区，不在sizeof计算的范围内。</li>
<li><code>node5</code>的内存结构：（1 — 1 — 2），总大小为4字节。</li>
<li><code>node6</code>的内存结构：（1 — 3（补） — 8 — 4），总大小为16字节，注意结构体变量的对齐参数的计算。</li>
<li><code>node7</code>的内存结构：（1 — 3（补）— 8  — 4（补） — 8 — 4 — 4（补）），总大小为32字节。</li>
<li><code>node8</code>的内存结构：（1 — 3（补） — 8 — 4），总大小为16字节。</li>
</ul>
<p>详细分析一下node7，其余的也类似：</p>
<p><code>#pragma pack(n)</code>为8<br>对于a变量，其对齐参数为1，此时offset=0，可以被1整除，因此为其分配1字节空间；<br>对于b变量，其对齐参数为4（s2结构体的成员变量最大对齐参数为int =&gt; 4），此时offset=1，不能被4整除，因此填充3字节后为其分配8字节空间；<br>对于d变量，其对齐参数为8，此时offset=12，不能被8整除，因此填充4字节后为其分配8字节空间。<br>对于c变量，其对齐参数为4，此时offset=24，可以被4整除，因此为其分配4字节空间。<br>此时所有变量都分配完，但此时offset=28，不能被最大对齐参数8整除，因此填充4字节使其可以被8整除。所以最后node7的大小为32字节。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/struct-sizeof-bq.png" alt="node7 内存分配"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Summary/">Summary</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Struct/">Struct</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-java-hashcode-equal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-hashcode-equal/" class="article-date">
      <time datetime="2015-09-20T16:00:00.000Z" itemprop="datePublished">2015-09-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-hashcode-equal/">hashCode方法及equals方法的规范</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在Java中，<code>hashCode</code>方法和<code>equals</code>方法都是java.lang.Object类的方法，在 <em>The Java Language Specification, Java SE 8 Edition</em> 中定义如下：</p>
<ul>
<li>The method <code>equals</code> defines a notion of object equality, which is based on value,<br>not reference, comparison.</li>
<li>The method <code>hashCode</code> is very useful, together with the method <code>equals</code> , in<br>hashtables such as <code>java.util.HashMap</code> .</li>
</ul>
<p>简而言之，<code>equals</code>法是判断两个对象是否等价的方法，而<code>hashCode</code>则是为散列数据结构服务的计算散列值的方法。下面分别对这两个方法进行讨论。</p>
<h1 id="equals方法">equals方法</h1><h2 id="重写规则">重写规则</h2><p>equals方法注重<strong>两个对象在逻辑上是否相等</strong>。重写equals方法看似比较简单，但实际编写的时候还是要考虑具体类的意义。<br>一般来说，以下几种情况不需要重写equals方法：</p>
<ul>
<li>一个类的每个实例在本质上都是独立的、不同的，比如Thread类</li>
<li>不需要equals方法，也就是判断对象相等的逻辑是没有必要的</li>
<li>父类已重写equals方法，并且子类的判断逻辑与父类相符</li>
<li>一个类的访问权限为private或package-private，并且可以确定equals方法不会被调用</li>
</ul>
<p>那么，另外的情况通常需要重写equals方法。一般来说，equals方法遵循离散数学中的<strong>等价关系</strong>（equivalence relation）。从OOP的角度来说，等价关系三原则如下（离散数学终于派上用场了！虽然还没学到这里。。）：</p>
<ul>
<li>自反性（Reflexive）：<strong>一个对象与自身相等</strong>，即$x = x$。对任何非空对象x， x.equals(x)必定为true</li>
<li>对称性（Symmetric）：<strong>对象之间的等价关系是可交换的</strong>，即$a=b \Leftrightarrow b=a$。对任何非空对象x、y， x.equals(y)为true，当且仅当y.equals(x)为true</li>
<li>传递性（Transitive）：$(a=b)\wedge(b=c) \Rightarrow (a=c)$。对任何非空对象x、y、z， 若x.equals(y)为true且y.equals(z)为true，则x.equals(z)为true</li>
</ul>
<p>除了遵循这三原则之外，还要遵循：</p>
<ul>
<li>一致性（Consistent）：对任何非空对象x、y，只要所比较的信息未变，则连续调用x.equals(y)总是得到一致的结果。这要求了equals所依赖的值必须是可靠的</li>
<li>对任何非空对象x， x.equals(null)必定为false</li>
</ul>
<p>所以，根据上面的原则，equals函数的一个比较好的实践如下：</p>
<p>（1）<strong>首先先判断传入的对象与自身是否为同一对象</strong>，如果是的话直接返回true<br>这相当于一种性能优化，尤其是在各种比较操作代价高昂的时候，这种优化非常有效。<br>（2）<strong>判断这个对象是否为正确的类型</strong><br>若此方法接受子类，即子类判断等价的逻辑与父类相同，则可以用<code>instanceof</code>操作符；若逻辑不同，即仅接受当前类型，则可以用<code>getClass</code>方法获取Class对象来判断。注意使用getClass方法时必须保证非空，而用instanceof操作符则不用非空（null instanceof o的值为false）。<br>（3）<strong>类型转换为相应的类型</strong><br>由于前面已经做过校验，因此这里做类型转换的时候不应当抛出ClassCastException异常。<br>（4）<strong>写相关的判断逻辑</strong></p>
<p>一个简单的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fucker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fucker</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Fucker))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Fucker fucker = (Fucker) o;</span><br><span class="line">        <span class="keyword">return</span> id == fucker.id &amp;&amp; !(name != <span class="keyword">null</span> ? !name.equals(fucker.name) : fucker.name != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>几个注意事项：</p>
<ul>
<li>我们无法在扩展一个可实例化的类的同时，即增加新的成员变量，同时又保留原先的equals约定</li>
<li>注意不要写错equals方法的参数类型，标准的应该是<code>public boolean equals(Object o)</code>，若写错就变成重载而不是重写了</li>
<li>不要让equals变得太“智能”而使其性能下降</li>
<li>如果重写了equals方法，则一定要重写hashCode方法（具体见下面）</li>
</ul>
<h2 id="老生常谈的equals和==">老生常谈的equals和==</h2><p>上面提到过，<code>equals</code>方法用来判断<strong>两个对象在逻辑上是否相等</strong>，而<code>==</code>用来判断两个引用对象是否指向同一个对象（是否为同一个对象）。<br>用烂了的例子，注意常量池：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"Fucking Scala"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"Fucking Scala"</span>);</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"Fucking Scala"</span>);</span><br><span class="line">String str4 = <span class="string">"Fucking Scala"</span>;</span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line">System.out.println(str2 == str3); <span class="comment">// false</span></span><br><span class="line">System.out.println(str2.equals(str3)); <span class="comment">// true</span></span><br><span class="line">System.out.println(str1 == str4); <span class="comment">// true</span></span><br><span class="line">str4 = <span class="string">"Fuck again!"</span>;</span><br><span class="line">String str5 = <span class="string">"Fuck again!"</span>;</span><br><span class="line">System.out.println(str1 == str4); <span class="comment">// false</span></span><br><span class="line">System.out.println(str4 == str5); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h1 id="hashCode方法">hashCode方法</h1><p><strong>如果重写了equals方法，则一定要重写hashCode方法</strong>。</p>
<p>重写hashCode方法的原则如下：</p>
<ul>
<li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数</li>
<li>如果两个对象通过equals方法比较得到的结果是相等的，那么对这两个对象进行hashCode得到的值应该相同</li>
<li>两个不同的对象，hashCode的结果可能是相同的，这就是哈希表中的冲突。为了保证哈希表的效率，哈希算法应尽可能的避免冲突</li>
</ul>
<p>关于相应的哈希算法，一个简单的算法如下:</p>
<ul>
<li>永远不要让哈希算法返回一个常值，这时哈希表将退化成链表，查找时间复杂度也从O(1)退化到O(N)</li>
<li>如果参数是boolean型，计算(f ? 1 : 0)</li>
<li>如果参数是byte, char, short或者int型，计算(int) f</li>
<li>如果参数是long型，计算(int) (f ^ (f &gt;&gt;&gt; 32))</li>
<li>如果参数是float型，计算Float.floatToIntBits(f)</li>
<li>如果参数是double型，计算Double.doubleToLongBits(f)得到long类型的值，再根据公式计算出相应的hash值</li>
<li>如果参数是Object型，那么应计算其有用的成员变量的hash值，并按照下面的公式计算最终的hash值</li>
<li>如果参数是个数组，那么把数组中的每个值都当做单独的值，分别按照上面的方法单独计算hash值，最后按照下面的公式计算最终的hash值</li>
</ul>
<p>组合公式：<code>result = 31 * result + c</code></p>
<p>比如，String类的hashCode方法如下（JDK 1.8）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>举个自定义类的hashCode例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> height;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Duck duck = (Duck) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != duck.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Double.compare(duck.weight, weight) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Float.compare(duck.height, height) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> ? !name.equals(duck.name) : duck.name != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> !(note != <span class="keyword">null</span> ? !note.equals(duck.note) : duck.note != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        temp = Double.doubleToLongBits(weight);</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="keyword">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        result = <span class="number">31</span> * result + (height != +<span class="number">0.0f</span> ? Float.floatToIntBits(height) : <span class="number">0</span>);</span><br><span class="line">        result = <span class="number">31</span> * result + (note != <span class="keyword">null</span> ? note.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想找到一个不冲突的哈希算法不是非常容易，具体的属于数据结构部分知识，这里就不再赘述了。</p>
<hr>
<h1 id="其他语言">其他语言</h1><h2 id="C_Sharp">C Sharp</h2><p>C#与Java大同小异，规则都可以参考上面的。方法名稍微改了改，分别为<code>Equals</code>方法和<code>GetHashCode</code>方法。</p>
<h2 id="C++">C++</h2><p>C++不像Java那样所有的类都继承一个共同的根基类，因此在写自定义的类时，需要自己写这两个方法。<br>在C++里，一般通过重载<code>==</code>运算符来实现判断两对象等价的逻辑，而实现计算散列值的函数则需要特化std::hash模板结构体，并且重载<code>()</code>运算符。</p>
<p>如果用不到散列数据结构的话，则无需定义对应的散列函数。</p>
<p>【2015-10 Update】C++示例可见<a href="http://www.sczyh30.com/posts/C-C/cpp-stl-hashmap/">C++ STL之哈希表|unordered_map</a>。</p>
<hr>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/005tNQILjw1ey5049hlosj30c807nt8r.jpg" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-java-basic-summary-01" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-basic-summary-01/" class="article-date">
      <time datetime="2015-09-17T16:00:00.000Z" itemprop="datePublished">2015-09-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-basic-summary-01/">Java基础技术细节总结 - 语言规范</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>开发莫忘基础，写业务写多了很多基础内容容易忘。这里将寻根溯源，总结Java语言规范和基础类中的一些细节问题。所有关于Java语言规范的细节问题，都可以参考  <em>The Java® Language Specification, Java SE 8 Edition</em>(JLS8) .</p>
<p>本文将不断补充。。</p>
<h2 id="小数化为整数">小数化为整数</h2><ul>
<li><code>Math.floor(x)</code>返回小于等于x的最接近整数，返回类型为double;</li>
<li><code>Math.round(x)</code>相当于四舍五入，返回值为long或int;</li>
<li><code>Math.ceil(x)</code>返回大于等于x的最接近整数，返回类型为double。</li>
</ul>
<h2 id="静态块与构造块">静态块与构造块</h2><p><strong>静态块</strong>：用static申明，JVM加载类时执行，仅执行一次且优先于主函数。<br><strong>构造块</strong>：类中直接用{}定义，每一次创建对象时执行，相当于往构造器最前面加上构造块的内容（很像往每个构造器那里插了内联函数，构造块就相当于内联函数）。</p>
<p>执行顺序优先级：<strong>静态块 &gt; 构造块 &gt; 构造方法</strong></p>
<p>有继承关系时，执行顺序通常是：父类静态块=&gt;子类静态块=&gt;父类构造块=&gt;父类构造方法=&gt;子类构造块=&gt;子类构造方法<br>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Derived();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"fucking =&gt; Base::static"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"fucking =&gt; Base::before"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Base::Base&lt;init&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"fucking =&gt; Derived::static"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"fucking =&gt; Derived::before"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Derived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            System.out.println(<span class="string">"Derived::Derived&lt;init&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fucking =&gt; Base::<span class="keyword">static</span></span><br><span class="line">fucking =&gt; Derived::<span class="keyword">static</span></span><br><span class="line">fucking =&gt; Base::before</span><br><span class="line">Base::Base&lt;init&gt;</span><br><span class="line">fucking =&gt; Derived::before</span><br><span class="line">Derived::Derived&lt;init&gt;</span><br></pre></td></tr></table></figure>
<h2 id="运算符规则_-_加法规则">运算符规则 - 加法规则</h2><p>代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">1</span>, b2 = <span class="number">2</span>, b3, b6;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4 = <span class="number">4</span>, b5 = <span class="number">6</span>;</span><br><span class="line">b6 = b4 + b5;</span><br><span class="line">b3 = (b1 + b2);</span><br><span class="line">System.out.println(b3 + b6);</span><br></pre></td></tr></table></figure>
<p>结果：第四行编译错误。</p>
<p>表达式的数据类型自动提升, 关于类型的自动提升，注意下面的规则。</p>
<ol>
<li>所有的<code>byte</code>,<code>short</code>,<code>char</code>型的值将被提升为<code>int</code>型</li>
<li>如果有一个操作数是<code>long</code>型，计算结果是<code>long</code>型</li>
<li>如果有一个操作数是<code>float</code>型，计算结果是<code>float</code>型</li>
<li>如果有一个操作数是<code>double</code>型，计算结果是<code>double</code>型</li>
</ol>
<p>而声明为<code>final</code>的变量会被JVM优化，因此第三句在编译时就会优化为<code>b6 = 10</code>，不会出现问题。</p>
<h2 id="float_x_与“零值”比较的if语句">float x 与“零值”比较的if语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fabs(x) &lt; <span class="number">0.00001f</span>)</span><br></pre></td></tr></table></figure>
<p>float类型的还有double类型的，这些小数类型在趋近于0的时候不会直接等于零，一般都是无限趋近于0。因此不能用==来判断。应该用<code>|x-0| &lt; err</code>来判断，这里|x-0|表示绝对值，err表示限定误差，用程序表示就是<code>fabs(x) &lt; 0.00001f</code>。</p>
<h2 id="关于try和finally">关于try和finally</h2><p>1.首先执行到<code>try</code>里的<code>return</code>，但是有<code>finally</code>语句还要执行，于是先执行<code>return</code>后面的语句，例如（<code>x++</code>），把要返回的值保存到局部变量。<br>2.执行<code>finally</code>语句的内容，其中有<code>return</code>语句，这时就会忽略try中的<code>return</code>，直接返回。</p>
<p>返回值问题。可以认为<code>try</code>（或者<code>catch</code>）中的<code>return</code>语句的返回值放入线程栈的顶部：如果返回值是基本类型则顶部存放的就是值，如果返回值是引用类型，则顶部存放的是引用。finally中的<code>return</code>语句可以修改引用所对应的对象，无法修改基本类型。但不管是基本类型还是引用类型，都可以被<code>finally</code>返回的“具体值”具体值覆盖。</p>
<h2 id="三目运算符的类型转换问题">三目运算符的类型转换问题</h2><p>三目运算符里的类型必须一致，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> i = <span class="number">40</span>;</span><br><span class="line">String as_e1 = String.valueOf(i &lt; <span class="number">50</span> ? <span class="number">233</span> : <span class="number">666</span>);</span><br><span class="line">String as_e2 = String.valueOf(i &lt; <span class="number">50</span> ? <span class="number">233</span> : <span class="number">666.0</span>);</span><br><span class="line">assertEquals(<span class="keyword">true</span>, as_e1.equals(as_e2));</span><br></pre></td></tr></table></figure>
<p>结果是测试不通过，这里就涉及到三元操作符的转换规则：</p>
<ol>
<li>如果两个操作数无法转换，则不进行转换，返回<code>Object</code>对象</li>
<li>如果两个操作数是正常的类型，那么按照正常情况进行类型转换，比如<code>int =&gt; long =&gt; float =&gt; double</code></li>
<li>如果两个操作数都是字面量数字，那么返回范围较大的类型</li>
</ol>
<h2 id="Java中自增操作符的一些陷阱">Java中自增操作符的一些陷阱</h2><p>观察下面的一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoIncTraps</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            count = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码的打印结果是<code>0</code>，也就是说自增在这里并没有什么卵用，这和C++是不一样的。反编译一下看一下字节码（main函数部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 6 L0</span><br><span class="line">    ICONST_0</span><br><span class="line">    ISTORE 1</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER 7 L1</span><br><span class="line">    ICONST_0</span><br><span class="line">    ISTORE 2</span><br><span class="line">   L2</span><br><span class="line">   FRAME APPEND [I I]</span><br><span class="line">    ILOAD 2</span><br><span class="line">    BIPUSH 10</span><br><span class="line">    IF_ICMPGE L3</span><br><span class="line">   L4</span><br><span class="line">    LINENUMBER 8 L4</span><br><span class="line">    ILOAD 1</span><br><span class="line">    IINC 1 1</span><br><span class="line">    ISTORE 1</span><br><span class="line">   L5</span><br><span class="line">    LINENUMBER 7 L5</span><br><span class="line">    IINC 2 1</span><br><span class="line">    GOTO L2</span><br><span class="line">   L3</span><br><span class="line">    LINENUMBER 10 L3</span><br><span class="line">   FRAME CHOP 1</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">    ILOAD <span class="number">1</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br><span class="line">   L6</span><br><span class="line">    LINENUMBER <span class="number">11</span> L6</span><br><span class="line">    RETURN</span><br></pre></td></tr></table></figure>
<p>这里相当于创建了一个局部变量存放<code>count++</code>，但没有返回，因此<code>count</code>相当于没变。看了字节码后可能没感觉，写一下编译器处理后的代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoIncTraps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutoIncTraps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> var3 = count + <span class="number">1</span>;</span><br><span class="line">            count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下这里<code>count</code>的处理流程：</p>
<ol>
<li>JVM把count值（其值是0）拷贝到临时变量区。</li>
<li>count值加1，这时候count的值是1。</li>
<li>返回临时变量区的值，注意这个值是0，没有修改过。</li>
<li>返回值赋值给count，此时count值被重置成0。</li>
</ol>
<p>单纯看这一个的字节码比较抽象，来看一下这三句的字节码，比较一下更容易理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count = ++count;</span><br><span class="line">count = count++;</span><br><span class="line">count++;</span><br></pre></td></tr></table></figure>
<p>字节码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> L4</span><br><span class="line"> LINENUMBER <span class="number">9</span> L4</span><br><span class="line"> IINC <span class="number">1</span> <span class="number">1</span></span><br><span class="line"> ILOAD <span class="number">1</span></span><br><span class="line"> ISTORE <span class="number">1</span></span><br><span class="line">L5</span><br><span class="line"> LINENUMBER <span class="number">10</span> L5</span><br><span class="line"> ILOAD <span class="number">1</span></span><br><span class="line"> IINC <span class="number">1</span> <span class="number">1</span></span><br><span class="line"> ISTORE <span class="number">1</span></span><br><span class="line">L6</span><br><span class="line"> LINENUMBER <span class="number">11</span> L6</span><br><span class="line"> IINC <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>另外，<strong>自增操作不是原子操作</strong>，在后边总结并发编程的时候会涉及到。</p>
<h2 id="instanceof操作符的注意事项">instanceof操作符的注意事项</h2><p><code>instanceof</code>操作符左右两边的操作数必须有继承或派生关系，否则不会编译成功。因此，<code>instanceof</code>操作符只能用于对象，不能用于基本类型（不会自动拆包）。</p>
<p>下面是一些典型的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FuckingIOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"String"</span> <span class="keyword">instanceof</span> Object);</span><br><span class="line">        list.add(<span class="keyword">new</span> String() <span class="keyword">instanceof</span> Object);</span><br><span class="line">        list.add(<span class="keyword">new</span> Object() <span class="keyword">instanceof</span> String);</span><br><span class="line">        <span class="comment">//list.add('a' instanceof Character); //此句会编译错误</span></span><br><span class="line">        list.add(<span class="keyword">null</span> <span class="keyword">instanceof</span> String);</span><br><span class="line">        list.add((String)<span class="keyword">null</span> <span class="keyword">instanceof</span> String);</span><br><span class="line">        list.add(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);</span><br><span class="line">        list.add(<span class="keyword">new</span> Generic&lt;String&gt;().isDataInstance(<span class="string">""</span>));</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDataInstance</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t <span class="keyword">instanceof</span> Date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果和分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span> =&gt; String是Object的子类</span><br><span class="line"><span class="keyword">true</span> =&gt; 同上</span><br><span class="line"><span class="keyword">false</span> =&gt; 同上</span><br><span class="line"><span class="keyword">false</span> =&gt; Java语言规范规定<span class="keyword">null</span> <span class="keyword">instanceof</span> ? 都是<span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span> =&gt; 同上，无论怎么转换还是<span class="keyword">null</span></span><br><span class="line"><span class="keyword">false</span> =&gt; 同上</span><br><span class="line"><span class="keyword">false</span> =&gt; 由于Java泛型在编译时会进行类型擦除，因此这里相当于Object <span class="keyword">instanceof</span> Date了</span><br></pre></td></tr></table></figure>
<h2 id="诡异的NaN类型">诡异的NaN类型</h2><p>根据 <em>JLS8 4.2.3</em>，对<code>NaN</code>有以下规定：</p>
<ul>
<li>The numerical comparison operators &lt; , &lt;= , &gt; , and &gt;= return false if either or both operands are NaN (§15.20.1).</li>
<li>The equality operator == returns false if either operand is NaN.</li>
<li>In particular, (x<y) =="!(x">=y) will be false if x or y is NaN.</y)></li>
<li>The inequality operator != returns true if either operand is NaN (§15.21.1).</li>
<li>In particular, x!=x is true if and only if x is NaN.</li>
</ul>
<p>注意到<code>Double.NaN == Double.NaN</code>返回<strong>false</strong>，这其实是遵循了IEEE 754 standard。<strong>NaN</strong> 代表一个非正常的数（比如除以0得到的数），其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A constant holding a Not-a-Number (NaN) value of type</span><br><span class="line"> * &#123;<span class="doctag">@code</span> double&#125;. It is equivalent to the value returned by</span><br><span class="line"> * &#123;<span class="doctag">@code</span> Double.longBitsToDouble(0x7ff8000000000000L)&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN = <span class="number">0.0</span>d / <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Integer类的静态缓存_&amp;&amp;_valueOf和parseInt的对比">Integer类的静态缓存 &amp;&amp; valueOf和parseInt的对比</h2><p>这个问题是在StackOverflow上看到的。以下三个表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.valueOf(<span class="string">"127"</span>) == Integer.valueOf(<span class="string">"127"</span>));</span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">"128"</span>) == Integer.valueOf(<span class="string">"128"</span>));</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">"128"</span>) == Integer.valueOf(<span class="string">"128"</span>));</span><br></pre></td></tr></table></figure>
<p>结果分别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>为什么是这样的结果呢？我们看一下valueOf方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(parseInt(s, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>valueOf</code>方法是在<code>parseInt</code>方法的基础上加了一个读取缓存的过程。我们再看一下IntegerCache类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line"> * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line"> *</span><br><span class="line"> * The cache is initialized on first usage.  The size of the cache</span><br><span class="line"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class="line"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line"> * may be set and saved in the private system properties in the</span><br><span class="line"> * sun.misc.VM class.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来JVM会缓存一部分的Integer对象（默认范围为<code>-128 - 127</code>），在通过<code>valueOf</code>获取Integer对象时，如果是缓存范围内的就直接返回缓存的Integer对象，否则就会new一个Integer对象。返回的上限可通过JVM的参数<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>设置，而且不能小于127（参照JLS 5.1.7）。这样我们就可以解释<code>Integer.valueOf(&quot;127&quot;) == Integer.valueOf(&quot;127&quot;)</code>为什么是true了，因为它们获取的都是同一个缓存对象，而默认情况下<code>Integer.valueOf(&quot;128&quot;) == Integer.valueOf(&quot;128&quot;)</code>等效于<code>new Integer(128) == new Integer(128)</code>,结果自然是false。</p>
<p>我们再来看一下<code>parseInt</code>方法的原型，它返回一个原生int值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException</span></span><br></pre></td></tr></table></figure>
<p>由于一个原生值与一个包装值比较时，包装类型会自动拆包，因此<code>Integer.parseInt(&quot;128&quot;) == Integer.valueOf(&quot;128&quot;)</code>就等效于<code>128 == 128</code>，结果自然是true。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-android_summary_2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Develop/android_summary_2/" class="article-date">
      <time datetime="2015-09-17T12:27:28.000Z" itemprop="datePublished">2015-09-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Develop/android_summary_2/">安卓开发中的一些总结（2）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>半年没写安卓了，最近要复习一下，写个小项目玩玩。这是一些总结：</p>
<h2 id="AppCompatActivity中设置去标题和全屏">AppCompatActivity中设置去标题和全屏</h2><p>在AppCompatActivity(或ActionBarActivity)中不能再用<code>requestWindowFeature(Window.FEATURE_NO_TITLE)</code> 的方法设置去掉标题（早已淘汰）。以后直接在在style.xml里更改主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;!<span class="tag">--</span> <span class="tag">Customize</span> <span class="tag">your</span> <span class="tag">theme</span> <span class="tag">here</span>. <span class="tag">--</span>&gt;</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Activity无标题栏+全屏 开始--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"NoTitle"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="rule"><span class="attribute">android</span>:<span class="value">windowNoTitle<span class="string">"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;!-- 兼容API 7--&gt;</span><br><span class="line">        &lt;item name="</span>android:windowActionBar<span class="string">"&gt;false&lt;/item&gt;</span><br><span class="line">        &lt;!-- Activity全屏 开始--&gt;</span><br><span class="line">        &lt;item name="</span>android:windowFullscreen<span class="string">"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="</span>android:windowContentOverlay<span class="string">"&gt;@null&lt;/item&gt;</span><br><span class="line">    </span></span></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Activity无标题栏 结束--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在AndroidManifest.xml里将android:theme更改为<code>android:theme=&quot;@style/NoTitle&quot;</code>即可。</p>
<h2 id="让API_22-1以下版本兼容API_22-1以上的特性">让API 22.1以下版本兼容API 22.1以上的特性</h2><p>最新 22.1 版本的支持包引入了大量酷炫的新特性，这些特性将允许我们轻易地将Material Design风格应用到API 21以下版本。</p>
<p>API 22.1引入了<code>AppCompatDelegate</code>。<code>AppCompatDelegate</code> 是一个委托代表，它将 <code>AppCompatActivity</code> 的特性提供给 <code>Activity</code>。这在做兼容4.x的应用时比较方便（其实我只想兼容API 21+，逃</p>
<h2 id="在Android_Studio中解决各种依赖问题：">在Android Studio中解决各种依赖问题：</h2><p>合理配置，遇到坑爹的包（比如某公司某包的v4库与当前不兼容），果断拆包删掉不兼容的，如果有老代码不兼容果断逆向替换掉，再重新打包，方便快捷。</p>
<h2 id="API_21上bindService的问题">API 21上bindService的问题</h2><p>Android 5.0开始，跨App的<code>bindService</code>将不再有效：</p>
<blockquote>
<p>To ensure your app is secure, always use an explicit intent when starting a Service and do not declare intent filters for your services. Using an implicit intent to start a service is a security hazard because you cannot be certain what service will respond to the intent, and the user cannot see which service starts. Beginning with Android 5.0 (API level 21), the system throws an exception if you call bindService() with an implicit intent.</p>
</blockquote>
<p>Android API 21以上对Intent的要求：</p>
<blockquote>
<p>Service Intent must be explicit</p>
</blockquote>
<p>即Service必须以显式方法启动。如果按照以前的方法，会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FATAL EXCEPTION: main</span><br><span class="line">    Process: com.m1racle.testhwapi, PID: <span class="number">13488</span></span><br><span class="line">    java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.m1racle.testhwapi/com.m1racle.testhwapi.MainActivity&#125;: java.lang.IllegalArgumentException: Service Intent must be explicit: Intent &#123; act=action_bind_health_huawei_service (has extras) &#125;</span><br><span class="line">            at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:<span class="number">2693</span>)</span><br><span class="line">            at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:<span class="number">2758</span>)</span><br><span class="line">            at android.app.ActivityThread.access$<span class="number">900</span>(ActivityThread.java:<span class="number">177</span>)</span><br><span class="line">            at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">1448</span>)</span><br><span class="line">            at android.os.Handler.dispatchMessage(Handler.java:<span class="number">102</span>)</span><br><span class="line">            at android.os.Looper.loop(Looper.java:<span class="number">145</span>)</span><br><span class="line">            at android.app.ActivityThread.main(ActivityThread.java:<span class="number">5942</span>)</span><br><span class="line">            at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">            at java.lang.reflect.Method.invoke(Method.java:<span class="number">372</span>)</span><br><span class="line">            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:<span class="number">1399</span>)</span><br><span class="line">            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">1194</span>)</span><br><span class="line">     Caused by: java.lang.IllegalArgumentException: Service Intent must be explicit: Intent &#123; act=action_bind_health_huawei_service (has extras) &#125;</span><br><span class="line">            at android.app.ContextImpl.validateServiceIntent(ContextImpl.java:<span class="number">2052</span>)</span><br><span class="line">            at android.app.ContextImpl.startServiceCommon(ContextImpl.java:<span class="number">2090</span>)</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>解决方法有两个：</p>
<p>I、设置<code>Action</code>和<code>packageName</code>（推荐）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"org.samsara.addUserAction"</span>);</span><br><span class="line">intent.setPackage(getPackageName());</span><br><span class="line">context.startService(intent);</span><br></pre></td></tr></table></figure>
<p>II、写个方法将显式转化为隐式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">getExplicitIapIntent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PackageManager pm = mContext.getPackageManager();</span><br><span class="line">        Intent implicitIntent = <span class="keyword">new</span> Intent(<span class="string">"org.samsara.GET"</span>);</span><br><span class="line">        List&lt;ResolveInfo&gt; resolveInfos = pm.queryIntentServices(implicitIntent, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Is somebody else trying to intercept our IAP call?</span></span><br><span class="line">        <span class="keyword">if</span> (resolveInfos == <span class="keyword">null</span> || resolveInfos.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ResolveInfo serviceInfo = resolveInfos.get(<span class="number">0</span>);</span><br><span class="line">        String packageName = serviceInfo.serviceInfo.packageName;</span><br><span class="line">        String className = serviceInfo.serviceInfo.name;</span><br><span class="line">        ComponentName component = <span class="keyword">new</span> ComponentName(packageName, className);</span><br><span class="line">        Intent iapIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">        iapIntent.setComponent(component);</span><br><span class="line">        <span class="keyword">return</span> iapIntent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>顺便吐槽一下，老代码、老依赖包坑死人呀，某公司不遵循API 21规范的bind导致API 21+闪退，最后解决方法：逆向一下，找到目标包名，然后<code>setPackage</code>就好。</p>
<h2 id="Message和obtainMessage的区别：">Message和obtainMessage的区别：</h2><p><code>Message</code>构造是用<code>new Message()</code>，<code>obtainMessage</code>在使用时是调用<code>handler.obtainMessage()</code>。一个比较好理解的区别是<code>obtainMessage</code>不需要重新new出对象，而是直接取自消息池，节省了内存开销；另外一个重要的用法是，涉及到自定义thread时，建议使用<code>obtainMessage</code>，因为使用message可能会导致null异常或其他异常。</p>
<h2 id="FragmentPagerAdapter的兼容性问题">FragmentPagerAdapter的兼容性问题</h2><p>v4的包是不兼容android.app.Fragment的，需要兼容的话得导入support-v13包。</p>
<h2 id="Application及四大金刚的作用">Application及四大金刚的作用</h2><p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/android-4compoments-fn.png" alt=""></p>
<hr>
<p>这几天仍在做项目，此文章将不断补充。好久不做安卓开发，手有点生。。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-gdb-simple" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Develop/gdb-simple/" class="article-date">
      <time datetime="2015-09-11T17:12:36.000Z" itemprop="datePublished">2015-09-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Develop/gdb-simple/">gdb用法总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>以前写C++时，遇到需要调试的程序都是放在VS下进行debug，方便快捷。但是某些时候需要在Linux下进行debug，这时候显然不能用VS了，所以要祭出我们的法宝——gdb。<br>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。<br>这里总结一下gdb的一些常用命令和简单使用方法，为以后调试Hotspot JVM以及Golang编译的程序做准备。（顺便吐槽一下Golang，都出到1.5版本了官方还不发布一个调试器，还得借助gdb。。）</p>
<hr>
<p>放上一段简单的程序(klass.cpp):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Bean &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T object;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Bean</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Bean</span><span class="params">(T obj,<span class="built_in">string</span> name)</span></span>;</span><br><span class="line">        T&amp; getObject();</span><br><span class="line">        <span class="built_in">string</span>&amp; getName() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Bean&lt;T&gt;&amp; bean);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> BeanFactory &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Bean&lt;T&gt; bean;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> Bean&lt;T&gt; getBean() = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="built_in">string</span> s)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> ApplicationContext : <span class="keyword">public</span> BeanFactory&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Bean&lt;T&gt; bean;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ApplicationContext</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ApplicationContext</span><span class="params">(Bean&lt;T&gt; bean)</span></span>;</span><br><span class="line">        ApplicationContext(<span class="keyword">const</span> BeanFactory&lt;T&gt;&amp; b) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="keyword">virtual</span> Bean&lt;T&gt; getBean();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Bean&lt;T&gt;::Bean(T obj,<span class="built_in">string</span> name):object(obj),name(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Bean&lt;T&gt;::getObject() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Bean&lt;T&gt;::<span class="keyword">operator</span>==(<span class="keyword">const</span> Bean&lt;T&gt;&amp; bean) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;object == bean.getObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ApplicationContext&lt;T&gt;::ApplicationContext() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;bean = <span class="keyword">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ApplicationContext&lt;T&gt;::ApplicationContext(Bean&lt;T&gt; bean) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;bean = bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Bean&lt;T&gt; ApplicationContext&lt;T&gt;::getBean() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> ApplicationContext&lt;T&gt;::debug(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"debug:"</span>&lt;&lt;bean.getName()&lt;&lt;<span class="string">" + "</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bean&lt;<span class="built_in">string</span>&gt; bean(<span class="string">"Scala"</span>,<span class="string">"fucking"</span>);</span><br><span class="line">    BeanFactory&lt;<span class="built_in">string</span>&gt; *context = <span class="keyword">new</span> ApplicationContext&lt;<span class="built_in">string</span>&gt;(bean);</span><br><span class="line">    context-&gt;debug(<span class="string">"hahaha"</span>);</span><br><span class="line">    context-&gt;debug(bean.getObject());</span><br><span class="line">    <span class="keyword">delete</span> context;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<code>g++ klass.cpp -o klass -g -std=c++11</code><br><strong>注意</strong>：需要调试的时候，最好在用g++编译的时候加上-g参数，以便将源代码信息编译到可执行文件中。当然玩逆向的话就看汇编代码吧→_→<br>进入gdb，然后使用<code>file &lt;filename&gt;</code>命令加载文件。<br>然后可使用<code>r</code>命令(run)执行可执行文件。若没下断点，则相当于正常执行：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">debug:</span>fucking + hahaha</span><br><span class="line"><span class="label">debug:</span>fucking + Scala</span><br></pre></td></tr></table></figure></p>
<p>下面在main函数处下一个断点(Breakpoint)：<code>b main</code><br>反馈：<code>Breakpoint 1 at 0x400e61: file klass.cpp, line 75.</code>表示断点地址在0x400e61处<br>然后我们再次使用<code>r</code>命令执行，程序将停在断点处：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Breakpoint</span> <span class="tag">1</span>, <span class="tag">main</span> () <span class="tag">at</span> <span class="tag">klass</span><span class="class">.cpp</span><span class="pseudo">:75</span></span><br><span class="line"><span class="tag">75</span>      <span class="tag">int</span> <span class="tag">main</span>() &#123;</span><br></pre></td></tr></table></figure></p>
<p>此界面中可以查看汇编代码、表达式、历史记录、内存使用、寄存器值、源代码（如果有的话）、堆栈信息和线程信息<br><img src="http://7xkkgd.com1.z0.glb.clouddn.com/gdb-simple-01.jpg" alt="gdb"><br>接着使用<code>s</code>命令(step into)步入执行下面的语句，遇到函数调用则步入此函数。在生成Bean对象实例的时候步入Bean的构造函数：<br><img src="http://7xkkgd.com1.z0.glb.clouddn.com/gdb-simple-02.jpg" alt="Bean的构造函数信息"><br>顺着下去，可以观察完整的过程。这里只是总结gdb的使用，就不再阐述了。<br>下面是关于断点的一些用法：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>b &lt;行号&gt;</td>
<td>在此行号处下断点</td>
<td>b 75</td>
</tr>
<tr>
<td>b &lt;函数名称&gt;</td>
<td>在此函数处下断点</td>
<td>b service</td>
</tr>
<tr>
<td>b *&lt;函数名称&gt;</td>
<td>在此函数的入口点（prolog）处下断点</td>
<td>b *main</td>
</tr>
<tr>
<td>b *&lt;函数地址&gt;</td>
<td>在此函数地址处下断点</td>
<td>b *0x400e61</td>
</tr>
<tr>
<td>d &lt;编号&gt;</td>
<td>删除指定编号的断点或删除所有断点</td>
<td>d</td>
</tr>
</tbody>
</table>
<p>查看某个变量可以用<code>p &lt;变量名&gt;</code>命令，比如查看bean的详细信息：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; p bean         </span><br><span class="line"><span class="variable">$1</span> = &#123;             </span><br><span class="line">  object = <span class="string">"Scala"</span>,</span><br><span class="line">  name = <span class="string">"fucking"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续执行可以用<code>c</code>命令，若下面还有断点则中断到下一个断点。<br>若需要看本行代码对应的汇编代码可用<code>display /i $pc</code>命令，这样就能在Outputs一栏显示出当前汇编代码，比如：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">debug<span class="value">:fucking + hahaha</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">4</span>, main () at klass.cpp:<span class="number">79</span></span><br><span class="line"><span class="number">79</span>              context-&gt;<span class="function">debug</span>(bean.<span class="function">getObject</span>());</span></span><br><span class="line">1<span class="value">: x/i <span class="variable">$pc</span></span><br><span class="line">=&gt; <span class="number">0</span>x400f8f &lt;<span class="function">main</span>()+<span class="number">313</span>&gt;:       mov    <span class="function">-0x48</span>(%rbp),%rax</span></span><br></pre></td></tr></table></figure></p>
<p>若想逐行汇编代码步入执行，可以用<code>si</code>命令。<br>下面总结一下step命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td>step into(单步跟踪进入）</td>
</tr>
<tr>
<td>n</td>
<td>step over（单步跟踪）</td>
</tr>
<tr>
<td>si</td>
<td>逐行汇编代码步入</td>
</tr>
<tr>
<td>ni</td>
<td>逐行汇编代码步出</td>
</tr>
</tbody>
</table>
<p>还有一个非常有用的命令就是<code>i &lt;信息&gt;</code>，用于显示对应信息，简单总结一下常用的：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>i args</td>
<td>显示当前栈帧上的变量信息</td>
</tr>
<tr>
<td>i address &lt;name&gt;</td>
<td>显示对应对象、方法或变量name的地址</td>
</tr>
<tr>
<td>i breakpoints（缩写<code>i b</code>）</td>
<td>显示当前的所有断点</td>
</tr>
<tr>
<td>i variables</td>
<td>显示当前所有的静态变量和全局变量</td>
</tr>
<tr>
<td>i vtbl &lt;object&gt;</td>
<td>显示object对象的虚函数表(vtable)</td>
</tr>
<tr>
<td>i frame（缩写<code>i f</code></td>
<td>显示栈帧信息</td>
</tr>
<tr>
<td>i registers(缩写<code>i r</code>）</td>
<td>显示寄存器信息</td>
</tr>
</tbody>
</table>
<p>比如查看context对象的虚函数表：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; i vtbl context</span><br><span class="line"><span class="symbol">warning:</span> <span class="constant">RTTI</span> symbol <span class="keyword">not</span> found <span class="keyword">for</span> <span class="class"><span class="keyword">class</span> '<span class="title">ApplicationContext</span><span class="inheritance">&lt;<span class="parent">std::string</span></span>&gt;'</span></span><br><span class="line">vtable <span class="keyword">for</span> <span class="string">'BeanFactory&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;'</span> @ <span class="number">0x401530</span> (subobject @ <span class="number">0x603070</span>)<span class="symbol">:</span></span><br><span class="line">[<span class="number">0</span>]<span class="symbol">:</span> <span class="number">0x40139a</span> &lt;<span class="constant">ApplicationContext</span>&lt;<span class="symbol">std:</span><span class="symbol">:string&gt;</span><span class="symbol">:</span><span class="symbol">:getBean</span>()&gt;</span><br><span class="line">[<span class="number">1</span>]<span class="symbol">:</span> <span class="number">0x4013c8</span> &lt;<span class="constant">ApplicationContext</span>&lt;<span class="symbol">std:</span><span class="symbol">:string&gt;</span><span class="symbol">:</span><span class="symbol">:debug</span>(<span class="symbol">std:</span><span class="symbol">:string</span>)&gt;</span><br></pre></td></tr></table></figure></p>
<p>最后退出当然是命令<code>q</code>咯~</p>
<p>后面将用gdb调试HotSpot JVM以便更深入地了解JVM的运行原理。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GDB/">GDB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-algorithm-cache" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Algorithm/algorithm-cache/" class="article-date">
      <time datetime="2015-09-09T17:15:09.000Z" itemprop="datePublished">2015-09-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Algorithm/algorithm-cache/">缓存算法（页面置换算法）总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>前边总结操作系统知识的时候提到过缓存算法，这里将总结有关缓存算法的内容。<br>首先解释一下，缓存算法和内存页面置换算法(Page Replacement Algorithm)的核心思想是一样的，都是给定一个有限的空间，设计一个算法来更新和访问里面的数据，所以把它们放在一起讨论总结。下面提到缓存算法的同时，也指代页面置换算法。</p>
<p>常见的缓存算法有FIFO、Least Recently Used (<strong>LRU</strong>)、Least Frequently Used (<strong>LFU</strong>)。</p>
<hr>
<h2 id="FIFO算法">FIFO算法</h2><p>FIFO算法是一种比较容易实现的算法。它的思想是先进先出（FIFO，队列），这是最简单、最公平的一种思想，即<strong>如果一个数据是最先进入的，那么可以认为在将来它被访问的可能性很小。空间满的时候，最先进入的数据会被最早置换（淘汰）掉</strong>。<br>FIFO算法的描述：<br>设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：<br>1，set(key,value)：将记录(key,value)插入该结构。当缓存满时，将最先进入缓存的数据置换掉。<br>2，get(key)：返回key对应的value值。<br>实现：维护一个FIFO队列，按照时间顺序将各数据（已分配页面）链接起来组成队列，并将置换指针指向队列的队首。再进行置换时，只需把置换指针所指的数据（页面）顺次换出，并把新加入的数据插到队尾即可。<br>缺点：判断一个页面置换算法优劣的指标就是缺页率，而FIFO算法的一个显著的缺点是，在某些特定的时刻，缺页率反而会随着分配页面的增加而增加，这称为Belady现象。产生Belady现象现象的原因是，FIFO置换算法与进程访问内存的动态特征是不相容的，被置换的内存页面往往是被频繁访问的，或者没有给进程分配足够的页面，因此FIFO算法会使一些页面频繁地被替换和重新申请内存，从而导致缺页率增加。因此，现在不再使用FIFO算法。</p>
<h2 id="LRU算法（重要）">LRU算法（<strong>重要</strong>）</h2><p>LRU（The Least Recently Used，最近最久未使用算法）是一种常见的缓存算法，在很多分布式缓存系统（如Redis，Memcached）中都有广泛使用。<br>LRU算法的思想是：<strong>如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）</strong>。<br>LRU算法的描述：<br>设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：<br>1，set(key,value)：将记录(key,value)插入该结构。当缓存满时，将最久未使用的数据置换掉。<br>2，get(key)：返回key对应的value值。<br>实现：最朴素的思想就是用数组+时间戳的方式，不过这样做效率较低。<br>因此，我们可以用双向链表（LinkedList）+哈希表（HashMap）实现（链表用来表示位置，哈希表用来存储和查找），在Java里有对应的数据结构<strong>LinkedHashMap</strong>。</p>
<p>LeetCode上有关于LRU的一道题（<a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="external">LeetCode #146</a>）：</p>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>这里我用了双向链表+哈希表实现的。<br>C++ code(72 ms):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFAULT_LIST_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LRUCache &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">class</span> Node &#123;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="keyword">int</span> key;</span><br><span class="line">                <span class="keyword">int</span> value;</span><br><span class="line">                Node* pre;</span><br><span class="line">                Node* next;</span><br><span class="line">                Node(<span class="keyword">int</span> key,<span class="keyword">int</span> value,Node* pre,Node* next) &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;pre = pre;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node*&gt; mp;</span><br><span class="line">        Node* cacheHead;</span><br><span class="line">        Node* cacheTail;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(Node* cur)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">1</span> || cur == cacheHead) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur == cacheTail) &#123;</span><br><span class="line">                cacheTail = cur-&gt;pre;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;pre-&gt;next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next != <span class="keyword">nullptr</span>) &#123;</span><br><span class="line">                cur-&gt;next-&gt;pre = cur-&gt;pre;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = cacheHead;</span><br><span class="line">            cur-&gt;pre = <span class="keyword">nullptr</span>;</span><br><span class="line">            cacheHead-&gt;pre = cur;</span><br><span class="line">            cacheHead = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        LRUCache() &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;size = DEFAULT_LIST_SIZE;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;cacheHead = <span class="keyword">nullptr</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;cacheTail = <span class="keyword">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LRUCache(<span class="keyword">int</span> capacity):size(capacity) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;cacheHead = <span class="keyword">nullptr</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;cacheTail = <span class="keyword">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cacheHead == <span class="keyword">nullptr</span>) &#123;</span><br><span class="line">                cacheHead = <span class="keyword">new</span> Node(key,value,<span class="keyword">nullptr</span>,<span class="keyword">nullptr</span>);</span><br><span class="line">                mp[key] = cacheHead;</span><br><span class="line">                cacheTail = cacheHead;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node*&gt;::iterator it = mp.find(key);</span><br><span class="line">                <span class="keyword">if</span>(it == mp.end()) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(count == size) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(cacheHead == cacheTail &amp;&amp; cacheHead != <span class="keyword">nullptr</span>) &#123;</span><br><span class="line">                            mp.erase(cacheHead-&gt;key);</span><br><span class="line">                            cacheHead-&gt;key = key;</span><br><span class="line">                            cacheHead-&gt;value = value;</span><br><span class="line">                            mp[key] = cacheHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            Node *p = cacheTail;</span><br><span class="line">                            cacheTail-&gt;pre-&gt;next = cacheTail-&gt;next;</span><br><span class="line">                            cacheTail = cacheTail-&gt;pre;</span><br><span class="line">                            mp.erase(p-&gt;key);</span><br><span class="line">                            p-&gt;key = key;</span><br><span class="line">                            p-&gt;value = value;</span><br><span class="line">                            p-&gt;next = cacheHead;</span><br><span class="line">                            p-&gt;pre = cacheHead-&gt;pre;</span><br><span class="line">                            cacheHead-&gt;pre = p;</span><br><span class="line">                            cacheHead = p;</span><br><span class="line">                            mp[cacheHead-&gt;key] = cacheHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Node* p = <span class="keyword">new</span> Node(key,value,<span class="keyword">nullptr</span>,cacheHead);</span><br><span class="line">                        cacheHead-&gt;pre = p;</span><br><span class="line">                        cacheHead = p;</span><br><span class="line">                        mp[cacheHead-&gt;key] = cacheHead;</span><br><span class="line">                        count++;    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node *p = it-&gt;second;</span><br><span class="line">                    p-&gt;value = value;</span><br><span class="line">                    pushFront(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cacheHead == <span class="keyword">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node*&gt;::iterator it = mp.find(key);</span><br><span class="line">            <span class="keyword">if</span>(it == mp.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node* p = it-&gt;second;</span><br><span class="line">                pushFront(p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cacheHead-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="LFU算法">LFU算法</h2><p>LFU（Least Frequently Used ，最近最少使用算法）也是一种常见的缓存算法。<br>顾名思义，LFU算法的思想是：<strong>如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰</strong>。<br>LFU算法的描述：<br>设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：<br>1，set(key,value)：将记录(key,value)插入该结构。当缓存满时，将访问频率最低的数据置换掉。<br>2，get(key)：返回key对应的value值。<br>算法实现：常规的解法是，哈希表+链表+维护频率，平均时间复杂度为O(n)<br>比较优的解法是，用小顶堆+哈希表，平均时间复杂度为O(logn)<br>有点蛋疼，后面有时间再实现实现吧→_→</p>
<h2 id="OPT算法">OPT算法</h2><p>最佳页面置换算法（OPT，Bélády’s Algorithm）是一种理论上最佳的页面置换算法。它的思想是，试图淘汰掉以后永远也用不到的页面，如果没有则淘汰最久以后再用到的页面。因为这种算法必须知道进程访问页面的序列，而这是无法实现的，因此仅有理论意义。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cache/">Cache</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-jvm-copyArray" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/jvm-copyArray/" class="article-date">
      <time datetime="2015-09-07T16:00:00.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/jvm-copyArray/">arrayCopy方法底层探究</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近在读Java集合类的源码时发现很多数组的复制操作最后都归结到arraycopy方法上，这是一个native方法。本人对JVM底层实现具有极大的兴趣，因此就探寻了一下它的底层实现。<br><code>arraycopy</code>方法的声明（Native Method）:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span><br><span class="line">                                        Object dest, <span class="keyword">int</span> destPos,</span><br><span class="line">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它的native方法入口位于openjdk-8/openjdk/hotspot/src/share/vm/prims/jvm.cpp中:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,</span><br><span class="line">                               jobject dst, jint dst_pos, jint length))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_ArrayCopy"</span>);</span><br><span class="line">  <span class="comment">// Check if we have null pointers</span></span><br><span class="line">  <span class="keyword">if</span> (src == NULL || dst == NULL) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_NullPointerException());</span><br><span class="line">  &#125;</span><br><span class="line">  arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));</span><br><span class="line">  arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));</span><br><span class="line">  assert(s-&gt;is_oop(), <span class="string">"JVM_ArrayCopy: src not an oop"</span>);</span><br><span class="line">  assert(d-&gt;is_oop(), <span class="string">"JVM_ArrayCopy: dst not an oop"</span>);</span><br><span class="line">  <span class="comment">// Do copy</span></span><br><span class="line">  s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></p>
<p>可以看到，此方法首先先解析原数组和目标数组为底层的对象模型（这里为arrayOop)<br>真正执行数组拷贝的是最后一行代码中的<code>copy_array</code>方法，它有两种实现。</p>
<h4 id="正经的copy_array方法">正经的copy_array方法</h4><p>先看简单的一种吧，它的源码位于openjdk-8/openjdk/hotspot/src/share/vm/oops/typeArrayKlass.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TypeArrayKlass::copy_array(arrayOop s, <span class="keyword">int</span> src_pos, arrayOop d, <span class="keyword">int</span> dst_pos, <span class="keyword">int</span> length, TRAPS) &#123;</span><br><span class="line">  assert(s-&gt;<span class="keyword">is_t</span>ypeArray(), <span class="string">"must be type array"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check destination</span></span><br><span class="line">  <span class="keyword">if</span> (!d-&gt;<span class="keyword">is_t</span>ypeArray() || <span class="keyword">element_t</span>ype() != TypeArrayKlass::cast(d-&gt;klass())-&gt;<span class="keyword">element_t</span>ype()) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayStoreException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check is all offsets and lengths are non negative</span></span><br><span class="line">  <span class="keyword">if</span> (src_pos &lt; <span class="number">0</span> || dst_pos &lt; <span class="number">0</span> || length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check if the ranges are valid</span></span><br><span class="line">  <span class="keyword">if</span>  ( (((<span class="keyword">unsigned</span> <span class="keyword">int</span>) length + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) src_pos) &gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>) s-&gt;length())</span><br><span class="line">     || (((<span class="keyword">unsigned</span> <span class="keyword">int</span>) length + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) dst_pos) &gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>) d-&gt;length()) ) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check zero copy</span></span><br><span class="line">  <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is an attempt to make the copy_array fast.</span></span><br><span class="line">  <span class="keyword">int</span> l2es = log2_element_size();</span><br><span class="line">  <span class="keyword">int</span> ihs = array_header_in_bytes() / wordSize;</span><br><span class="line">  <span class="keyword">char</span>* src = (<span class="keyword">char</span>*) ((oop*)s + ihs) + ((<span class="keyword">size_t</span>)src_pos &lt;&lt; l2es);</span><br><span class="line">  <span class="keyword">char</span>* dst = (<span class="keyword">char</span>*) ((oop*)d + ihs) + ((<span class="keyword">size_t</span>)dst_pos &lt;&lt; l2es);</span><br><span class="line">  Copy::conjoint_memory_atomic(src, dst, (<span class="keyword">size_t</span>)length &lt;&lt; l2es);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面仍然先是验证操作：首先验证目标对象是否为数组，再验证源数组与目标数组的类型是否相同（若不相同就会抛出ArrayStoreException异常），再验证数组的容量是否为负（若为负则抛出ArrayIndexOutOfBoundsException异常），最后再检验数组边界范围是否正常。<br>验证完操作后就开始执行复制操作（空数组则直接结束）。<br>这里首先对source和destination进行了某些优化，来让数组拷贝更快，但是木有看懂：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l2es = log2_element_size();</span><br><span class="line"><span class="keyword">int</span> ihs = array_header_in_bytes() / wordSize;</span><br><span class="line"><span class="keyword">char</span>* src = (<span class="keyword">char</span>*) ((oop*)s + ihs) + ((<span class="keyword">size_t</span>)src_pos &lt;&lt; l2es);</span><br><span class="line"><span class="keyword">char</span>* dst = (<span class="keyword">char</span>*) ((oop*)d + ihs) + ((<span class="keyword">size_t</span>)dst_pos &lt;&lt; l2es);</span><br></pre></td></tr></table></figure></p>
<p>此处先不讨论这个优化。数组真正的复制操作又落在<code>Copy::conjoint_memory_atomic</code>这个方法上：<br>（位于openjdk-8/openjdk/hotspot/src/share/vm/utilities/copy.cpp）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy bytes; larger units are filled atomically if everything is aligned.</span></span><br><span class="line"><span class="keyword">void</span> Copy::conjoint_memory_atomic(<span class="keyword">void</span>* from, <span class="keyword">void</span>* to, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">  address src = (address) from;</span><br><span class="line">  address dst = (address) to;</span><br><span class="line">  <span class="keyword">uintptr_t</span> bits = (<span class="keyword">uintptr_t</span>) src | (<span class="keyword">uintptr_t</span>) dst | (<span class="keyword">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (Note:  We could improve performance by ignoring the low bits of size,</span></span><br><span class="line">  <span class="comment">// and putting a short cleanup loop after each bulk copy loop.</span></span><br><span class="line">  <span class="comment">// There are plenty of other ways to make this faster also,</span></span><br><span class="line">  <span class="comment">// and it's a slippery slope.  For now, let's keep this code simple</span></span><br><span class="line">  <span class="comment">// since the simplicity helps clarify the atomicity semantics of</span></span><br><span class="line">  <span class="comment">// this operation.  There are also CPU-specific assembly versions</span></span><br><span class="line">  <span class="comment">// which may or may not want to include such optimizations.)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jlong) == <span class="number">0</span>) &#123;</span><br><span class="line">    Copy::conjoint_jlongs_atomic((jlong*) src, (jlong*) dst, size / <span class="keyword">sizeof</span>(jlong));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jint) == <span class="number">0</span>) &#123;</span><br><span class="line">    Copy::conjoint_jints_atomic((jint*) src, (jint*) dst, size / <span class="keyword">sizeof</span>(jint));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jshort) == <span class="number">0</span>) &#123;</span><br><span class="line">    Copy::conjoint_jshorts_atomic((jshort*) src, (jshort*) dst, size / <span class="keyword">sizeof</span>(jshort));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Not aligned, so no need to be atomic.</span></span><br><span class="line">    Copy::conjoint_jbytes((<span class="keyword">void</span>*) src, (<span class="keyword">void</span>*) dst, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法中首先会判断数据类型，进而调用对应的方法（原子操作）。如果没有字节对齐（特定的类型），也就不需要进行原子操作，接着会调用 Copy::conjoint_jbytes方法，此方法的本质就是调用C语言库函数string.h中的memmove函数。特定的三个方法大同小异，继续查看源码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jshorts,               conjoint, atomic on each jshort</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conjoint_jshorts_atomic</span><span class="params">(jshort* from, jshort* to, size_t count)</span> </span>&#123;</span><br><span class="line">    assert_params_ok(from, to, LogBytesPerShort);</span><br><span class="line">    pd_conjoint_jshorts_atomic(from, to, count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jints,                 conjoint, atomic on each jint</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conjoint_jints_atomic</span><span class="params">(jint* from, jint* to, size_t count)</span> </span>&#123;</span><br><span class="line">    assert_params_ok(from, to, LogBytesPerInt);</span><br><span class="line">    pd_conjoint_jints_atomic(from, to, count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jlongs,                conjoint, atomic on each jlong</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conjoint_jlongs_atomic</span><span class="params">(jlong* from, jlong* to, size_t count)</span> </span>&#123;</span><br><span class="line">    assert_params_ok(from, to, LogBytesPerLong);</span><br><span class="line">    pd_conjoint_jlongs_atomic(from, to, count);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，它们又调用了pd为前缀的方法，继续跟进：<br>openjdk-8/openjdk/hotspot/src/cpu/zero/vm/copy_zero.hpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pd_conjoint_jshorts_atomic</span><span class="params">(jshort* from, jshort* to, size_t count)</span> </span>&#123;</span><br><span class="line">  _Copy_conjoint_jshorts_atomic(from, to, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pd_conjoint_jints_atomic</span><span class="params">(jint* from, jint* to, size_t count)</span> </span>&#123;</span><br><span class="line">  _Copy_conjoint_jints_atomic(from, to, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pd_conjoint_jlongs_atomic</span><span class="params">(jlong* from, jlong* to, size_t count)</span> </span>&#123;</span><br><span class="line">  _Copy_conjoint_jlongs_atomic(from, to, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再往下就是平台相关的了，找到openjdk-8/openjdk/hotspot/src/os_cpu/linux_zero/vm/os_linux_zero.cpp文件：<br><code>_Copy_conjoint_jints_atomic</code>方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Copy_conjoint_jints_atomic(jint* from, jint* to, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (from &gt; to) &#123;</span><br><span class="line">      jint *end = from + count;</span><br><span class="line">      <span class="keyword">while</span> (from &lt; end)</span><br><span class="line">        *(to++) = *(from++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (from &lt; to) &#123;</span><br><span class="line">      jint *end = from;</span><br><span class="line">      from += count - <span class="number">1</span>;</span><br><span class="line">      to   += count - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (from &gt;= end)</span><br><span class="line">        *(to--) = *(from--);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>终于找到具体实现了！有一种似曾相识的感觉呢，很经典的复制代码。</p>
<p><code>_Copy_conjoint_jshorts_atomic</code>方法与其实现相同，而<code>_Copy_conjoint_jlongs_atomic</code>方法在最后一句用了细化的原子操作，以处理64位的数据：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (from &gt;= end)</span><br><span class="line">        os::atomic_copy64(from--, to--);</span><br></pre></td></tr></table></figure></p>
<p>下面就是原子操作对应的代码。在特定平台会通过汇编进行优化，其他平台都是简单的一句<code>*(jlong *) dst = *(jlong *) src</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Atomically copy 64 bits of data</span><br><span class="line">  static void atomic_copy64(volatile void *src, volatile void *dst) &#123;</span><br><span class="line">#if defined(PPC) &amp;&amp; !defined(_LP64)</span><br><span class="line">    double tmp;</span><br><span class="line">    asm volatile ("lfd  %0, 0(%1)\n"</span><br><span class="line">                  "stfd %0, 0(%2)\n"</span><br><span class="line">                  : "=f"(tmp)</span><br><span class="line">                  : "b"(src), "b"(dst));</span><br><span class="line">#elif defined(S390) &amp;&amp; !defined(_LP64)</span><br><span class="line">    double tmp;</span><br><span class="line">    asm volatile ("ld  %0, 0(%1)\n"</span><br><span class="line">                  "std %0, 0(%2)\n"</span><br><span class="line">                  : "=r"(tmp)</span><br><span class="line">                  : "a"(src), "a"(dst));</span><br><span class="line">#else</span><br><span class="line">    *(jlong *) dst = *(jlong *) src;</span><br><span class="line">#endif</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，数组复制的过程结束。下面解析另一个方法。</p>
<h4 id="对象模型里的copy_array方法">对象模型里的copy_array方法</h4><p>要想读oops文件夹里的代码，需要对JVM的对象模型（oop和klass）有一定的了解。<br>此方法，甚妙。代码在objArrayKlass.cpp文件中:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjArrayKlass::copy_array(arrayOop s, <span class="keyword">int</span> src_pos, arrayOop d,</span><br><span class="line">                               <span class="keyword">int</span> dst_pos, <span class="keyword">int</span> length, TRAPS) &#123;</span><br><span class="line">  assert(s-&gt;is_objArray(), <span class="string">"must be obj array"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!d-&gt;is_objArray()) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayStoreException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check is all offsets and lengths are non negative</span></span><br><span class="line">  <span class="keyword">if</span> (src_pos &lt; <span class="number">0</span> || dst_pos &lt; <span class="number">0</span> || length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check if the ranges are valid</span></span><br><span class="line">  <span class="keyword">if</span>  ( (((<span class="keyword">unsigned</span> <span class="keyword">int</span>) length + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) src_pos) &gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>) s-&gt;length())</span><br><span class="line">     || (((<span class="keyword">unsigned</span> <span class="keyword">int</span>) length + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) dst_pos) &gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>) d-&gt;length()) ) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Special case. Boundary cases must be checked first</span></span><br><span class="line">  <span class="comment">// This allows the following call: copy_array(s, s.length(), d.length(), 0).</span></span><br><span class="line">  <span class="comment">// This is correct, since the position is supposed to be an 'in between point', i.e., s.length(),</span></span><br><span class="line">  <span class="comment">// points to the right of the last element.</span></span><br><span class="line">  <span class="keyword">if</span> (length==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (UseCompressedOops) &#123;</span><br><span class="line">    narrowOop* <span class="keyword">const</span> src = objArrayOop(s)-&gt;obj_at_addr&lt;narrowOop&gt;(src_pos);</span><br><span class="line">    narrowOop* <span class="keyword">const</span> dst = objArrayOop(d)-&gt;obj_at_addr&lt;narrowOop&gt;(dst_pos);</span><br><span class="line">    do_copy&lt;narrowOop&gt;(s, src, d, dst, length, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oop* <span class="keyword">const</span> src = objArrayOop(s)-&gt;obj_at_addr&lt;oop&gt;(src_pos);</span><br><span class="line">    oop* <span class="keyword">const</span> dst = objArrayOop(d)-&gt;obj_at_addr&lt;oop&gt;(dst_pos);</span><br><span class="line">    do_copy&lt;oop&gt; (s, src, d, dst, length, CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，主题思想还是一样的。先做检查，然后执行复制。但是，这里的实现与上一个方法实现有很大的不同，更偏向于对象模型了。<br>UseCompressedOops是JDK 1.6新增的，在64位系统中，提供可压缩的普通对象指针。JDK 1.7开始默认启用对象压缩 。<br>貌似对象模型还分oop和narrowOop（压缩的），先检验是否压缩过，再调用do_copy方法（模板方法）:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Either oop or narrowOop depending on UseCompressedOops.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">void</span> ObjArrayKlass::do_copy(arrayOop s, T* src,</span><br><span class="line">                               arrayOop d, T* dst, <span class="keyword">int</span> length, TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  BarrierSet* bs = Universe::heap()-&gt;barrier_set();</span><br><span class="line">  <span class="comment">// For performance reasons, we assume we are that the write barrier we</span></span><br><span class="line">  <span class="comment">// are using has optimized modes for arrays of references.  At least one</span></span><br><span class="line">  <span class="comment">// of the asserts below will fail if this is not the case.</span></span><br><span class="line">  assert(bs-&gt;has_write_ref_array_opt(), <span class="string">"Barrier set must have ref array opt"</span>);</span><br><span class="line">  assert(bs-&gt;has_write_ref_array_pre_opt(), <span class="string">"For pre-barrier as well."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s == d) &#123;</span><br><span class="line">    <span class="comment">// since source and destination are equal we do not need conversion checks.</span></span><br><span class="line">    assert(length &gt; <span class="number">0</span>, <span class="string">"sanity check"</span>);</span><br><span class="line">    bs-&gt;write_ref_array_pre(dst, length);</span><br><span class="line">    Copy::conjoint_oops_atomic(src, dst, length);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We have to make sure all elements conform to the destination array</span></span><br><span class="line">    Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();</span><br><span class="line">    Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();</span><br><span class="line">    <span class="keyword">if</span> (stype == bound || stype-&gt;is_subtype_of(bound)) &#123;</span><br><span class="line">      <span class="comment">// elements are guaranteed to be subtypes, so no check necessary</span></span><br><span class="line">      bs-&gt;write_ref_array_pre(dst, length);</span><br><span class="line">      Copy::conjoint_oops_atomic(src, dst, length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// slow case: need individual subtype checks</span></span><br><span class="line">      <span class="comment">// note: don't use obj_at_put below because it includes a redundant store check</span></span><br><span class="line">      T* from = src;</span><br><span class="line">      T* end = from + length;</span><br><span class="line">      <span class="keyword">for</span> (T* p = dst; from &lt; end; from++, p++) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag"><span class="keyword">XXX</span></span> this is going to be slow.</span></span><br><span class="line">        T element = *from;</span><br><span class="line">        <span class="comment">// even slower now</span></span><br><span class="line">        <span class="keyword">bool</span> element_is_null = oopDesc::is_null(element);</span><br><span class="line">        oop new_val = element_is_null ? oop(NULL)</span><br><span class="line">                                      : oopDesc::decode_heap_oop_not_null(element);</span><br><span class="line">        <span class="keyword">if</span> (element_is_null ||</span><br><span class="line">            (new_val-&gt;klass())-&gt;is_subtype_of(bound)) &#123;</span><br><span class="line">          bs-&gt;write_ref_field_pre(p, new_val);</span><br><span class="line">          *p = *from;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We must do a barrier to cover the partial copy.</span></span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">size_t</span> pd = pointer_delta(p, dst, (<span class="keyword">size_t</span>)heapOopSize);</span><br><span class="line">          <span class="comment">// pointer delta is scaled to number of elements (length field in</span></span><br><span class="line">          <span class="comment">// objArrayOop) which we assume is 32 bit.</span></span><br><span class="line">          assert(pd == (<span class="keyword">size_t</span>)(<span class="keyword">int</span>)pd, <span class="string">"length field overflow"</span>);</span><br><span class="line">          bs-&gt;write_ref_array((HeapWord*)dst, pd);</span><br><span class="line">          THROW(vmSymbols::java_lang_ArrayStoreException());</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bs-&gt;write_ref_array((HeapWord*)dst, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，操作都是围绕着BarrierSet进行的。BarrierSet应该是内存屏障的集合，位于vm/memory/barrierSet.hpp文件内，待研究透JVM底层内存管理机制再过来填坑。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2016 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30.
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>