<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="sczyh30" />


    
    


<meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「浮生若梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/page/4/index.html">
<meta property="og:site_name" content="「浮生若梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「浮生若梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="「浮生若梦」 - sczyh30&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>「浮生若梦」 - sczyh30&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="http://7xkkgd.com1.z0.glb.clouddn.com/blog-default-lambda-avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMQP/">AMQP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/APT/">APT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Akka/">Akka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-14/">C++ 14</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/">CAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CE3/">CE3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPS/">CPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/">Cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Category-Theory/">Category Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Continuation/">Continuation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DI/">DI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Engine/">Engine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Euterpea/">Euterpea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Loop/">Event Loop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GDB/">GDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game/">Game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC/">JUC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Klass-oop/">Klass-oop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda-Calculus/">Lambda Calculus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIDI/">MIDI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mathematical-Logic/">Mathematical Logic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metaspace/">Metaspace</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netflix-Hystrix/">Netflix Hystrix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-Model/">Object Model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PLT/">PLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Play-Framework/">Play Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quorum/">Quorum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reflection/">Reflection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheme/">Scheme</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slick/">Slick</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sort/">Sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Summary/">Summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Class/">Type Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Lambda/">Type Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-System/">Type System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Theory/">Type Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UE4/">UE4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中间件/">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云服务/">云服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存区域/">内存区域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式计算/">分布式计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息系统/">消息系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/滑动窗口/">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程安全/">线程安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/限流降级/">限流降级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高可用架构/">高可用架构</a></li></ul>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Distributed System/Deep Learning/PLT</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="http://7xkkgd.com1.z0.glb.clouddn.com/blog-default-lambda-avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-play-framework-2-5-dependency-injection-di" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/play-framework-2-5-dependency-injection-di/" class="article-date">
      <time datetime="2016-03-28T16:00:00.000Z" itemprop="datePublished">2016-03-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/play-framework-2-5-dependency-injection-di/">Play Framework 2.5 | Dependency Injection总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近在将Samsara Aquarius从Play 2.4.6迁移至Play 2.5.0的时候发现，Play 2.5将一些全局对象deprcated了，并强烈建议全面使用依赖注入来代替全局对象，所以就把Aquarius的代码用DI重构了一下。其实从Play 2.4.0开始就引入了依赖注入了(基于<a href="https://jcp.org/en/jsr/detail?id=330" target="_blank" rel="external">JSR 330</a>标准)，只不过还没有很好地推广。这里就来总结一下Play Framework中DI的使用。（本来开发的时候想保持FP风格的，无奈DI更多的是偏OO的风格。。FP与OO杂糅不好把握呀。。）</p>
<h1 id="为何需要引入依赖注入">为何需要引入依赖注入</h1><p>依赖注入(Dependency Injection)在OOP中早已是一个耳熟能详的原则了，其中Spring里用DI都用烂了。简单来说，依赖注入使得我们不需要自己创建对象，而是由容器来帮我们创建。每个组件之间不再是直接相互依赖，而是通过容器进行注入，这降低了组件之间的耦合度。这个容器就像是一个全局的大工厂，专门“生产”对象，而我们只需要进行配置（常见的通过XML文件或通过注解）。</p>
<p>在Play API中有一个<code>Global</code>对象，保存着一些全局的可变状态。另外还有一个Application对象相当于当前正在运行的Play实例。这两个伴生对象经常会在测试和部署的时候引发问题，并且也会影响Play实例的生命周期以及插件系统的工作。因此从Play 2.4开始，开发者对底层的结构做了很大的调整，底层所有的组件（包括Application、Route、Controller）都通过依赖注入进行管理，而不再使用Global和Application对象。后面版本中这两个对象只是从DI中获取实例的引用。从Play 2.5开始，这些全局对象被deprecated。</p>
<p>Play内部的DI组件都用的是 <strong>Google Guice</strong>。只要是符合JSR-330标准的DI组件都可用于Play Framework中。</p>
<h1 id="DI_in_Play_Framework">DI in Play Framework</h1><h2 id="如何使用">如何使用</h2><p>比如我们的B组件需要A组件的实例作为依赖，我们可以这么定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.inject.<span class="type">Inject</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">a: <span class="type">A</span></span>)</span></div></pre></td></tr></table></figure>
<p>注意，<code>@Inject()</code>需要插入在类名之后，构造参数列表之前，后边跟上需要注入的对象列表。</p>
<p>Guice里面的依赖注入有<a href="https://github.com/google/guice/wiki/Injections" target="_blank" rel="external">好几种方式</a>：<strong>构造注入</strong>、<strong>方法注入</strong> 等等。这里采用最常用的构造注入。</p>
<h2 id="生命周期及范围">生命周期及范围</h2><p>依赖注入系统管理着各个注入组件的生命周期和范围。有以下规则：</p>
<ul>
<li>每次从Injector里取出的都是新的对象，即每次需要此组件的时候都会创建新的实例，用Spring IoC的话来说就是Bean的范围是 <strong>Prototype</strong> 。这一点和Spring不同(Spring默认是Singleton)。当然可以通过给待注入的类加上<code>@Singleton</code>注解来实现 <strong>Singleton</strong> 。</li>
<li>遵循懒加载原则，即不用的时候就不创建。如果需要提前创建实例的话可以使用 <strong>Eager Binding</strong> 。</li>
</ul>
<h2 id="ApplicationLifecycle">ApplicationLifecycle</h2><p>有些组件需要在Play结束运行的时候进行一些清理工作，如关闭连接、关闭句柄。Play提供了<code>ApplicationLifecycle</code>类，可以通过<code>addStopHook</code>函数给组件注册回调，在Play结束运行的时候进行清理工作。<code>addStopHook</code>函数有两个版本，常用的是第一个：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStopHook</span></span>(hook: () =&gt; <span class="type">Future</span>[_]): <span class="type">Unit</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStopHook</span></span>(hook: <span class="type">Callable</span>[_ &lt;: <span class="type">CompletionStage</span>[_]]): <span class="type">Unit</span></div></pre></td></tr></table></figure>
<p>底层实现嘛比较直观，默认的实现是<code>DefaultApplicationLifecycle</code>类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Default implementation of the application lifecycle.</div><div class="line"> */</div><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultApplicationLifecycle</span> <span class="keyword">extends</span> <span class="title">ApplicationLifecycle</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mutex = <span class="keyword">new</span> <span class="type">Object</span>()</div><div class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> hooks = <span class="type">List</span>.empty[() =&gt; <span class="type">Future</span>[_]]</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addStopHook</span></span>(hook: () =&gt; <span class="type">Future</span>[_]) = mutex.synchronized &#123;</div><div class="line">    hooks = hook :: hooks</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(): <span class="type">Future</span>[_] = &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Do we care if one hook executes on another hooks redeeming thread? Hopefully not.</span></div><div class="line">    <span class="keyword">import</span> play.api.libs.iteratee.<span class="type">Execution</span>.<span class="type">Implicits</span>.trampoline</div><div class="line"></div><div class="line">    hooks.foldLeft(<span class="type">Future</span>.successful[<span class="type">Any</span>](())) &#123; (future, hook) =&gt;</div><div class="line">      future.flatMap &#123; _ =&gt;</div><div class="line">        hook().recover &#123;</div><div class="line">          <span class="keyword">case</span> e =&gt; <span class="type">Logger</span>.error(<span class="string">"Error executing stop hook"</span>, e)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>DefaultApplicationLifecycle</code>类里维护了一个钩子列表hook用于存储所有注册的回调函数，类型为<code>List[() =&gt; Future[_]]</code>。由于<code>DefaultApplicationLifecycle</code>组件为单例，因此为避免资源争用，将hook变量声明为<code>@volatile</code>，并且注册回调函数时需要加锁。注意回调函数是按注册的顺序进行存储的。在应用结束时，会调用<code>stop</code>函数，通过<code>foldLeft</code>依次调用各个回调函数。</p>
<h1 id="Play_应用重构实例">Play 应用重构实例</h1><p>之前我把部分的Service设计成了Object（脑残了），并且在获取Slick的<code>DatabaseConfig</code>的时候使用了全局变量<code>play.api.Play.current</code>。这里我们来重构一下。</p>
<p>首先把Service重构为单例的类，并且通过DI的方式获取<code>db</code>。可以继承<code>HasDatabaseConfigProvider[JdbcProfile]</code>接口并注入<code>DatabaseConfigProvider</code>，这样Service就可以直接使用<code>HasDatabaseConfigProvider</code>的<code>db</code>对象了。当然如果不想继承<code>HasDatabaseConfigProvider</code>接口的话也可以仅注入<code>DatabaseConfigProvider</code>并自己在类中获取<code>dbConfig</code>和<code>db</code>(其它方式见Play-Slcik的文档)。</p>
<p>代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">protected val dbConfigProvider: <span class="type">DatabaseConfigProvider</span></span>) <span class="keyword">extends</span> <span class="title">HasDatabaseConfigProvider</span>[<span class="type">JdbcProfile</span>] </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">import</span> driver.api._</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> users = <span class="type">TableQuery</span>[<span class="type">UserTable</span>]</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(user: <span class="type">User</span>): <span class="type">Future</span>[<span class="type">Int</span>] = &#123;</div><div class="line">    db.run(users += user) recover &#123;</div><div class="line">      <span class="keyword">case</span> duplicate: com.mysql.jdbc.exceptions.<span class="type">MySQLIntegrityConstraintViolationException</span> =&gt; <span class="type">DB_ADD_DUPLICATE</span></div><div class="line">      <span class="keyword">case</span> _: <span class="type">Exception</span> =&gt; <span class="number">-2</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 其他代码略......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是在Controller里配置DI将Service注入至Controller中。以UserController为例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">service: <span class="type">UserService</span></span>) <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loginIndex</span> </span>= <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request =&gt;</div><div class="line">    request.session.get(<span class="string">"aq_token"</span>) <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(user) =&gt; <span class="type">Redirect</span>(routes.<span class="type">Application</span>.index())</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">Ok</span>(views.html.login(<span class="type">LoginForm</span>.form))</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="comment">// 其他代码略......</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="DI底层调用过程">DI底层调用过程</h2><p>Play API中所有的DI都用的 <strong>Google Guice</strong>。它们最后都是调用了<code>GuiceInjector</code>类的<code>instanceOf</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Play Injector backed by a Guice Injector.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuiceInjector</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">injector: com.google.inject.<span class="type">Injector</span></span>) <span class="keyword">extends</span> <span class="title">PlayInjector</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Get an instance of the given class from the injector.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instanceOf</span></span>[<span class="type">T</span>](<span class="keyword">implicit</span> ct: <span class="type">ClassTag</span>[<span class="type">T</span>]) = instanceOf(ct.runtimeClass.asInstanceOf[<span class="type">Class</span>[<span class="type">T</span>]])</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Get an instance of the given class from the injector.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instanceOf</span></span>[<span class="type">T</span>](clazz: <span class="type">Class</span>[<span class="type">T</span>]) = injector.getInstance(clazz)</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Get an instance bound to the given binding key.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instanceOf</span></span>[<span class="type">T</span>](key: <span class="type">BindingKey</span>[<span class="type">T</span>]) = injector.getInstance(<span class="type">GuiceKey</span>(key))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再往底层调用<code>com.google.inject.internal#getProvider</code>方法获取Provider，最终都会调用到某个种类的Injector的<code>inject</code>、<code>provision</code>、<code>construct</code>方法。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/play-scala-injector-dbg-01.png" alt="Call Stack"></p>
<h1 id="题外话-函数式编程中的DI">题外话-函数式编程中的DI</h1><p>以前用DI的时候一直在想，这玩意在OOP中用途这么广泛，那么在FP里会是什么光景呢？其实在FP里，<strong>Currying</strong> 就可以当做是OOP中的DI。这里先挖个坑，待填坑:)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DI/">DI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Play-Framework/">Play Framework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-functional-programming-type-and-kind" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Functional-Programming/functional-programming-type-and-kind/" class="article-date">
      <time datetime="2016-03-15T16:00:00.000Z" itemprop="datePublished">2016-03-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Functional-Programming/functional-programming-type-and-kind/">FP :: Type Theory | Type, Type Constructor 与 Kind</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>以前忘了总结了。。正好在这里总结一下 <strong>Type</strong>, <strong>Type Constructor</strong> 与 <strong>Kind</strong> 这几个概念，结合Haskell和Scala。</p>
<blockquote>
<p><strong>TODO</strong>(2016.12): GHC 8.0的kind system(<code>TypeInType</code>); Dependent Type; Lambda Cube</p>
</blockquote>
<h1 id="Type,_Type_Constructor_与_Kind_(Haskell)">Type, Type Constructor 与 Kind (Haskell)</h1><p><em>Types and Programming Languages</em> 里的一张图非常直观地表现了Kind与Type的意义：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/tapl-type-kind.png" alt=""></p>
<p>其中，上图的Term就是值(Value)的意思，比如<code>1</code>、<code>&quot;haha&quot;</code>之类的，都是Term。</p>
<p>而Type，则是 <strong>Value的类型</strong>，比如<code>1</code>的Type是<code>Num</code>(Haskell)，<code>&quot;haha&quot;</code>的Type是<code>String</code>。然后我们引入Type Constructor的概念，它接受一个或多个类型参数(type parameter)并构造出一个新Type，比如<code>Maybe</code>是一个Unary Type Constructor，它接受一个类型参数，可以构造出<code>Maybe Int</code>和<code>Maybe String</code>等等的不同的Type。再比如<code>Either</code>的定义为<code>data Either a b = Left a | Right b</code>，它接受两个类型参数，可以构造出像<code>Either Bool</code>和<code>Either Int Bool</code>这样的Type Constructor。其实，我们也可以把这些Primitive Type看作是一种特殊的Type Constructor，即接受零个类型参数(Nullary Type Constructor)。</p>
<p>有了Type和Type Constructor的概念以后，我们就可以定义Kind了。Kind表示 <strong>Type Constructor的类型</strong> ，在Haskell中有以下定义：</p>
<ul>
<li>Nullary Type Constructor（即普通的Type）的kind为<code>*</code></li>
<li>如果k1和k2是kind，那么<code>k1 -&gt; k2</code>代表一个Type constructor的kind，这个Constructor接受kind为k1的类型参数，返回kind为k2的类型参数。<br>比如<code>Either String</code>的kind为<code>* -&gt; *</code></li>
</ul>
<p>这样，从Value到Type、Type Constructor，再到Kind，每上一个层次都是一个抽象。Type Constructor是Value的类型，Kind又是Type Constructor的类型。</p>
<h1 id="Kind_Polymorphism_(Haskell)">Kind Polymorphism (Haskell)</h1><p>默认情况下，Haskell不允许kind具有多态性(Kind polymorphism)。比如我们的Either的定义如下:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Either</span> a b = <span class="type">Left</span> a | <span class="type">Right</span> b 	<span class="comment">-- Defined in ‘Data.Either’</span></span></div></pre></td></tr></table></figure></p>
<p>a和b的kind是任意的，可以是<code>*</code>，也可以是<code>* -&gt; *</code>。Haskell默认将它们的kind都推导为<code>*</code>，因此下面的定义是不允许的：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">T1</span> = <span class="type">Either</span> []</span></div><div class="line"></div><div class="line">&lt;interactive&gt;:<span class="number">123</span>:<span class="number">18</span>:</div><div class="line">    <span class="type">Expecting</span> one more argument to ‘[]’</div><div class="line">    <span class="type">Expected</span> a <span class="class"><span class="keyword">type</span>, but ‘[]’ has kind ‘* -&gt; *’</span></div><div class="line">    <span class="type">In</span> the <span class="class"><span class="keyword">type</span> ‘[]’</span></div><div class="line">    <span class="type">In</span> the definition <span class="keyword">of</span> <span class="class"><span class="keyword">data</span> constructor ‘<span class="type">Either</span>’</span></div><div class="line">    <span class="type">In</span> the <span class="class"><span class="keyword">data</span> declaration for ‘<span class="type">T1</span>’</span></div></pre></td></tr></table></figure></p>
<p>当然有些时候Haskell也是可以推导出来某些Higher-order kind的，比如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">A</span> t k p = <span class="type">A</span> &#123; <span class="title">s1</span> :: <span class="title">p</span>, <span class="title">s2</span> :: <span class="title">t</span> <span class="title">k</span> &#125;</span></div></pre></td></tr></table></figure></p>
<p>由于<code>s2 :: t k</code>，而k默认被推导为<code>*</code>，因此t的kind就会被推导为<code>* -&gt; *</code>，那么A的kind最终被推导为<code>(* -&gt; *) -&gt; * -&gt; * -&gt; *</code>。</p>
<p>如果要使Haskell支持 <strong>polymorphic kinds</strong> ，可以利用GHC的扩展<code>-XPolyKinds</code>，就不再展开总结了，详情可以参考<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#kind-polymorphism" target="_blank" rel="external">这里</a>。</p>
<h1 id="Data_Kinds/Datatype_promotion_(Haskell)">Data Kinds/Datatype promotion (Haskell)</h1><p>Datatype promotion是GHC的一个扩展(<code>-XDataKinds</code>)，可以将部分的Datatype给自动promote成kind。比如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">Prelude</span>&gt; :k <span class="type">Left</span></div><div class="line"><span class="type">Left</span> :: k -&gt; <span class="type">Either</span> k k1</div><div class="line"><span class="type">Prelude</span>&gt; :k <span class="number">3</span></div><div class="line"><span class="number">3</span> :: <span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">Nat</span></div><div class="line"><span class="type">Prelude</span>&gt; :k <span class="string">""</span></div><div class="line"><span class="string">""</span> :: <span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">Symbol</span></div><div class="line"><span class="type">Prelude</span>&gt; :k <span class="type">Just</span></div><div class="line"><span class="type">Just</span> :: k -&gt; <span class="type">Maybe</span> k</div></pre></td></tr></table></figure></p>
<p>具体的应用还没实践过，等实践过再来总结。。</p>
<h1 id="Scala中的Type和Kind">Scala中的Type和Kind</h1><p>Scala中的Type和Kind用一张图总结：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/scala-type-kind-higher.png" alt=""></p>
<p>我觉得Scala中的Kind比较混乱，至少每次试的时候出的结果总与想象的不对应，或许还没有理解吧。。。举几个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Functor</span>[<span class="type">M</span>[_]]</span></div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">Functor</span></div><div class="line">&lt;console&gt;:<span class="number">11</span>: error: not found: value <span class="type">Functor</span></div><div class="line">       <span class="type">Functor</span></div><div class="line">       ^</div><div class="line"></div><div class="line">scala&gt; :k -v <span class="keyword">new</span> <span class="type">Functor</span></div><div class="line"><span class="type">Functor</span><span class="symbol">'s</span> kind is <span class="type">X</span>[<span class="type">F</span>[<span class="type">A</span>]]</div><div class="line">(* -&gt; *) -&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span> <span class="title">that</span> <span class="title">takes</span> <span class="title">type</span> <span class="title">constructor</span>(<span class="params">s</span>)</span>: a higher-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">List</span></div><div class="line">scala.collection.immutable.<span class="type">List</span><span class="symbol">'s</span> kind is <span class="type">F</span>[+<span class="type">A</span>]</div><div class="line">* -(+)-&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span></span>: a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">List</span>[<span class="type">Int</span>]</div><div class="line">scala.collection.immutable.<span class="type">List</span><span class="symbol">'s</span> kind is <span class="type">F</span>[+<span class="type">A</span>]</div><div class="line">* -(+)-&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span></span>: a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">scala.collection.immutable.<span class="type">List</span><span class="symbol">'s</span> kind is <span class="type">A</span></div><div class="line">*</div><div class="line"><span class="type">This</span> is a proper <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">Either</span></div><div class="line">scala.util.<span class="type">Either</span><span class="symbol">'s</span> kind is <span class="type">F</span>[+<span class="type">A1</span>,+<span class="type">A2</span>]</div><div class="line">* -(+)-&gt; * -(+)-&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span></span>: a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v (<span class="type">Int</span>, <span class="type">String</span>) =&gt; <span class="type">Option</span>[_]</div><div class="line">scala.<span class="type">Function2</span><span class="symbol">'s</span> kind is <span class="type">F</span>[-<span class="type">A1</span>,-<span class="type">A2</span>,+<span class="type">A3</span>]</div><div class="line">* -(-)-&gt; * -(-)-&gt; * -(+)-&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span></span>: a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span></div></pre></td></tr></table></figure>
<p>感觉Scala REPL中的<code>:kind</code>是针对value的而不是type的，非常蛋疼，估计是让JVM的泛型类型擦除搞得Parametric Polymorphism都不爽了。。另外Scala中也分 <strong>1st-order-kinded type</strong> 和 <strong>higher-kinded type</strong> 。所谓higher-kinded type就是类似于<code>A[B[_]]</code>这样的type constructor，比如下面的这个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">T3</span>[<span class="type">Q</span>[<span class="type">A</span>], <span class="title">P</span>[<span class="type">B</span>]]</span></div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">T3</span></span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="keyword">new</span> <span class="type">T3</span></div><div class="line"><span class="type">T3</span><span class="symbol">'s</span> kind is <span class="type">X</span>[<span class="type">F1</span>[<span class="type">A1</span>],<span class="type">F2</span>[<span class="type">A2</span>]]</div><div class="line">(* -&gt; *) -&gt; (* -&gt; *) -&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span> <span class="title">that</span> <span class="title">takes</span> <span class="title">type</span> <span class="title">constructor</span>(<span class="params">s</span>)</span>: a higher-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">T4</span>[<span class="type">Tuple2</span>[<span class="type">A</span>, <span class="type">B</span>], <span class="title">P</span>[<span class="type">Option</span>[<span class="type">C</span>]], <span class="title">D</span>, <span class="title">E</span>]</span></div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">T4</span></span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="keyword">new</span> <span class="type">T4</span></div><div class="line"><span class="type">T4</span><span class="symbol">'s</span> kind is <span class="type">Y</span>[<span class="type">F1</span>[<span class="type">A1</span>,<span class="type">A2</span>],<span class="type">X</span>[<span class="type">F2</span>[<span class="type">A3</span>]],<span class="type">A4</span>,<span class="type">A5</span>]</div><div class="line">(* -&gt; * -&gt; *) -&gt; ((* -&gt; *) -&gt; *) -&gt; * -&gt; * -&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span> <span class="title">that</span> <span class="title">takes</span> <span class="title">type</span> <span class="title">constructor</span>(<span class="params">s</span>)</span>: a higher-kinded <span class="class"><span class="keyword">type</span>.</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><em>Types and Programming Languages</em></li>
<li><em>Generics of a Higher Kind</em>, Martin Odersky</li>
<li><a href="https://wiki.haskell.org/Kind" target="_blank" rel="external">Kind - HaskellWiki</a></li>
<li><a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala" target="_blank" rel="external">What is a higher kinded type in Scala?</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Functional-Programming/">Functional Programming</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Type-Theory/">Type Theory</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-typeclass-scala-haskell" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Functional-Programming/typeclass-scala-haskell/" class="article-date">
      <time datetime="2016-03-06T16:00:00.000Z" itemprop="datePublished">2016-03-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Functional-Programming/typeclass-scala-haskell/">Scala | Haskell | Type Class总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Type_class_in_Haskell">Type class in Haskell</h1><p>Type class是Haskell中最重要的概念之一，它可以看做是 <strong>对一系列具有某种性质的type的抽象</strong> (比如<code>Eq</code>, <code>Functor</code>, <code>Monad</code>之类的)。每个type class都定义了一组函数。一个type如果要成为某个type class，就必须成为其实例(<code>instance)</code>并实现type class定义的函数。表面上看起来type class和OOP中的接口(interface)的作用类似，但是type class有着更多的优点，我们将在后面比较type class与interface的特点。</p>
<p>在Haskell中，我们通过<code>class</code>关键字来定义type class。比如<code>Monad</code>的定义如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></div><div class="line">    (&gt;&gt;=)       :: <span class="keyword">forall</span> a b. m a -&gt; (a -&gt; m b) -&gt; m b</div><div class="line">    (&gt;&gt;)        :: <span class="keyword">forall</span> a b. m a -&gt; m b -&gt; m b</div><div class="line"></div><div class="line">    return      :: a -&gt; m a</div><div class="line"></div><div class="line">    fail        :: <span class="type">String</span> -&gt; m a</div></pre></td></tr></table></figure>
<p>其中<code>Applicative m =&gt; Monad m</code>代表类型m(更严谨地说应该是type constructor，因为<code>(m :: * -&gt; *)</code>)同样是<code>Applicative</code>的实例。</p>
<p>我们可以通过<code>instance</code>关键字来实现type class的实例。比如Maybe Monad的实现如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span>  <span class="type">Maybe</span> a  =  <span class="type">Nothing</span> | <span class="type">Just</span> a</span></div><div class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>)</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span>  <span class="type">Monad</span> <span class="type">Maybe</span>  <span class="keyword">where</span></div><div class="line">    (<span class="type">Just</span> x) &gt;&gt;= k      = k x</div><div class="line">    <span class="type">Nothing</span>  &gt;&gt;= _      = <span class="type">Nothing</span></div><div class="line"></div><div class="line">    (&gt;&gt;) = (*&gt;)</div><div class="line"></div><div class="line">    fail _              = <span class="type">Nothing</span></div></pre></td></tr></table></figure>
<p>Haskell引入type class是为了解决 <strong>Ad-hoc polymorphism</strong> 的问题。所谓的Ad-hoc polymorphism可以用一句话概括：</p>
<blockquote>
<p>In programming languages, ad-hoc polymorphism is a kind of polymorphism in which polymorphic functions can be applied to arguments of different types, because a polymorphic function can denote a number of distinct and potentially heterogeneous implementations depending on the type of argument(s) to which it is applied.</p>
</blockquote>
<p>即函数根据不同的参数类型选择不同版本的函数进行调用。Ad-hoc polymorphism在OOP里一般通过函数重载或运算符重载实现，而在Haskell中ad-hoc polymorphism就通过type class实现。比如<code>show</code>函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">show</span> :: <span class="type">Show</span> a =&gt; a -&gt; <span class="type">String</span></div></pre></td></tr></table></figure>
<p>类型<code>a</code>必须是<code>Show</code>的实例，对于不同的类型<code>a</code>，<code>show</code>函数会选择对应的函数实现来进行调用，这就实现了上面所说的ad-hoc polymorphism(编译期):</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">Prelude</span>&gt; show [<span class="number">1.7</span>, <span class="number">6.4</span>]</div><div class="line"><span class="string">"[1.7,6.4]"</span></div><div class="line"><span class="type">Prelude</span>&gt; show <span class="number">2</span></div><div class="line"><span class="string">"2"</span></div><div class="line"><span class="type">Prelude</span>&gt; show $ <span class="type">Just</span> <span class="number">4</span></div><div class="line"><span class="string">"Just 4"</span></div></pre></td></tr></table></figure>
<p>Type class在Haskell中其实是一种语法糖，因此下面我们就来看一下GHC是如何desugar它的。</p>
<h1 id="GHC处理type_class的方式">GHC处理type class的方式</h1><p>我们来看一下GHC处理type class的方式。由于对于某个type，作用域内最多只能有一种某个type class的实例，因此type class可以被GHC处理成一种 <strong>“dictionary-passing style”</strong>。这里参考一下 <em>A History of Haskell</em> 中的例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></div><div class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span></div><div class="line">    (/=) :: a -&gt; a -&gt; <span class="type">Bool</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">Int</span> <span class="keyword">where</span></div><div class="line">  i1 == i2 = eqInt i1 i2</div><div class="line">  i1 /= i2 = not (i1 == i2)</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> (<span class="type">Eq</span> <span class="title">a</span>) =&gt; <span class="type">Eq</span> [a] <span class="keyword">where</span></div><div class="line">  [] == [] = <span class="type">True</span></div><div class="line">  (x:xs) == (y:ys) = (x == y) &amp;&amp; (xs == ys)</div><div class="line">  xs /= ys = not (xs == ys)</div><div class="line"></div><div class="line"><span class="title">member</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></div><div class="line"><span class="title">member</span> x [] = <span class="type">False</span></div><div class="line"><span class="title">member</span> x (y:ys) | x == y = <span class="type">True</span></div><div class="line">                | otherwise = member x ys</div></pre></td></tr></table></figure>
<p>它可以被转化成为以下形式：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Eq</span> a = <span class="type">MkEq</span> (<span class="title">a</span> -&gt; <span class="title">a</span> -&gt; <span class="type">Bool</span>) (<span class="title">a</span> -&gt; <span class="title">a</span> -&gt; <span class="type">Bool</span>)</span></div><div class="line"><span class="title">eq</span> (<span class="type">MkEq</span> e _) = e</div><div class="line"><span class="title">ne</span> (<span class="type">MkEq</span> _ n) = n</div><div class="line"></div><div class="line"><span class="title">dEqInt</span> :: <span class="type">Eq</span> <span class="type">Int</span></div><div class="line"><span class="title">dEqInt</span> = <span class="type">MkEq</span> eqInt (\x y -&gt; not (eqInt x y))</div><div class="line"></div><div class="line"><span class="title">dEqList</span> :: <span class="type">Eq</span> a -&gt; <span class="type">Eq</span> [a]</div><div class="line"><span class="title">dEqList</span> d = <span class="type">MkEq</span> el (\x y -&gt; not (el x y))</div><div class="line">  <span class="keyword">where</span></div><div class="line">    el [] [] = <span class="type">True</span></div><div class="line">    el (x:xs) (y:ys) = eq d x y &amp;&amp; el xs ys</div><div class="line">    el _ _ = <span class="type">False</span></div><div class="line"></div><div class="line"><span class="title">member</span> :: <span class="type">Eq</span> a -&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></div><div class="line"><span class="title">member</span> d x [] = <span class="type">False</span></div><div class="line"><span class="title">member</span> d x (y:ys) | eq d x y = <span class="type">True</span></div><div class="line">                  | otherwise = member d x ys</div></pre></td></tr></table></figure>
<p>我们看到，type class的定义部分被转换成了一个data type，它定义了对应type class的字典(dictionary)，里面记录了type class里的函数。上面的例子中，转换后的<code>eq</code>和<code>ne</code>函数会从这个字典里选择对应的函数。我们再来看一下转换后的<code>member</code>函数。它会接受对应的字典参数，并通过<code>eq</code>函数从字典中提取出对应的判断函数。最后就是对应的instance实现部分了。instance部分被转换成了一个选择函数，返回一个完整的字典。比如<code>dEqList</code>函数会接受一个<code>Eq a</code>类型的字典，返回一个<code>Eq [a]</code>类型的字典。</p>
<p>简单总结一下转换过程：</p>
<ul>
<li><code>class</code> -&gt; data type (dictionary)</li>
<li><code>instance</code> -&gt; selector function</li>
</ul>
<h1 id="Type_class_pattern_in_Scala:_Implicit_Objects">Type class pattern in Scala: Implicit Objects</h1><p>Scala中并没有直接通过关键字支持type class(毕竟还混合了OOP)。Scala中type class成为了一种pattern，可以通过<code>trait</code>加上<code>implicit</code>来实现。</p>
<p>比如要对一组“可加的元素”（即我们熟悉的幺半群<code>Monoid</code>）进行求和(<code>concat</code>)操作，在Haskell里可以这么写(和默认的<code>Monoid</code>实现有差别)：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">class</span> <span class="type">Monoid</span> a <span class="keyword">where</span></div><div class="line">  mempty :: a</div><div class="line">  mappend :: a -&gt; a -&gt; a</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Integer</span> <span class="keyword">where</span></div><div class="line">  mempty = <span class="number">0</span></div><div class="line">  mappend a b = a + b</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">String</span> <span class="keyword">where</span></div><div class="line">  mempty = <span class="string">""</span></div><div class="line">  mappend a b = a ++ b</div><div class="line"></div><div class="line"><span class="title">mconcat</span> :: <span class="type">Monoid</span> a =&gt; [a] -&gt; a</div><div class="line"><span class="title">mconcat</span> xs = foldl mappend mempty xs</div></pre></td></tr></table></figure>
<p>而在Scala中，我们可以通过Implicit Object来实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mempty</span></span>: <span class="type">A</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mappend</span></span>(a: <span class="type">A</span>, b: <span class="type">A</span>): <span class="type">A</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">IntMonoid</span> <span class="keyword">extends</span> <span class="title">Monoid</span>[<span class="type">Int</span>] </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">mempty</span> </span>= <span class="number">0</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">mappend</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = a + b</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">StringMonoid</span> <span class="keyword">extends</span> <span class="title">Monoid</span>[<span class="type">String</span>] </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">mempty</span> </span>= <span class="string">""</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">mappend</span></span>(a: <span class="type">String</span>, b: <span class="type">String</span>) = a + b</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mconcat</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> monoid: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">A</span> = &#123;</div><div class="line">  xs.foldLeft(monoid.mempty)(monoid.mappend)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们定义了一个<code>Monoid</code> trait代表幺半群（性质：封闭、可结合、有幺元），这个trait就对应Haskell中type class的定义。接着我们分别为<code>Int</code>类型和<code>String</code>类型实现了对应的<code>Monoid</code>实例，注意对应的<code>Monoid</code>实例都是<strong>implicit object</strong>。最后我们要实现一个<code>mconcat</code>对一组具有幺半群性质的类型的值进行”求和”计算，这里我们将<code>Monoid</code>实例作为了implicit参数传递进了<code>mconcat</code>方法中，这样根据Scala的类型系统以及implicit匹配过程，当<code>xs</code>的类型是<code>List[Int]</code>的时候，<code>IntMonoid</code>会作为implicit参数传入<code>mconcat</code>方法；而当<code>xs</code>的类型是<code>List[String]</code>的时候，<code>StringMonoid</code>会作为implicit参数传入<code>mconcat</code>方法；如果没有匹配的implicit参数就会编译失败，从而确保了类型安全。是不是很奇妙呢？当然我们也可以用Scala的context bound语法糖省略掉implicit参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mconcat</span></span>[<span class="type">A</span> : <span class="type">Monoid</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">A</span> = &#123;</div><div class="line">  <span class="keyword">val</span> monoid = implicitly[<span class="type">Monoid</span>[<span class="type">A</span>]]</div><div class="line">  xs.foldLeft(monoid.mempty)(monoid.mappend)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Type_class与接口的对比及优点">Type class与接口的对比及优点</h1><p>从上面的代码，我们可以看出，type class和trait/interface作用类似，都是对某一系列类型抽象出特定的行为。那么type class与trait/interface相比有什么优点呢？想象一下，如果用interface的话，每个sub-class都要在其body内实现对应的函数。这样如果要给现有的类实现这个interface的话，就必须要修改原类，在原类中增加对应的实现，这显然不符合Open Closed Principle(对扩展开放，对修改关闭)。所以OOP中提出了诸如 <em>适配器模式</em> 这样的设计模式用于扩展已有的类，但写各种adapter增加了代码的冗杂程度。</p>
<p>而对于type class pattern来说，实现type class实例的代码并不写在类型定义中，而是在外部实现一个对应type class的实例。这样，我们要给现有的类型实现一个type class的话就不需要更改原有类型的定义了，只需要实现对应的type class实例就可以了。这其实就是 <strong>抽象与实现分离</strong>，即类型定义与约束实现是分离的，某个类型并不清楚自己属于某个type class。与接口的方式相比，type class符合Open Closed Principle。</p>
<p>上面我们提到过，编译器会根据一定的机制在 <strong>编译期</strong> 自动寻找需要的type class实例，其中Haskell底层是通过转换成字典的形式让编译器寻找type class实例，而Scala中则是通过传入implicit参数的方式让编译器寻找type class实例，这保证了类型安全。</p>
<p>相比Haskell而言，Scala中的type class pattern更加灵活（托<code>implicit</code>的福），比如:</p>
<ul>
<li>结合context bound语法糖，Scala中可以方便的组合多个type class，如<code>A : Eq : Ord</code></li>
<li>Type class可以有默认实现(default implicit parameter)</li>
<li>Scala中type class实例是具名的(implicit object)，因此同一种类型可以有不同的type class实例，并且可以通过控制作用域(通过<code>import</code>)来选择不同的实例</li>
</ul>
<p>当然type class还有更多的高级玩法，以后实践的多了再慢慢总结。。。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://ropas.snu.ac.kr/~bruno/papers/TypeClasses.pdf" target="_blank" rel="external">Bruno C. d. S. Oliveira, Adriaan Moors, Martin Odersky. <em>Type Classes as Objects and Implicits.</em></a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf" target="_blank" rel="external">Paul Hudak, John Hughes, Simon Peyton Jones, Philip Wadler. <em>A History of Haskell: Being Lazy With Class.</em></a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/haskell-retrospective/ECOOP-July09.pdf" target="_blank" rel="external">Classes, Jim, but not as we know them (ECOOP 2009)</a></li>
<li><a href="https://www.youtube.com/watch?v=hIZxTQP1ifo" target="_blank" rel="external">Edward Kmett - Type Classes vs. the World</a></li>
<li><a href="http://stackoverflow.com/questions/5408861/what-are-type-classes-in-scala-useful-for" target="_blank" rel="external">What are type classes in Scala useful for?</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Functional-Programming/">Functional Programming</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Type-Class/">Type Class</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-concurrent-threadlocal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-concurrent-threadlocal/" class="article-date">
      <time datetime="2016-03-04T16:00:00.000Z" itemprop="datePublished">2016-03-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-concurrent-threadlocal/">并发编程 | ThreadLocal源码深入分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>以前只知道ThreadLocal的大致思路，没有去深入研究。今天读了读源码，果然博大精深～</p>
<p>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为<code>private static</code>类型。</p>
<p>假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用<code>HashMap</code>来实现，Thread作为<code>key</code>，变量作为<code>value</code>。事实上，JDK中确实使用了类似<code>Map</code>的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中<code>ThreadLocal</code>的实现。</p>
<h1 id="初探ThreadLocal">初探ThreadLocal</h1><p>我们从ThreadLocal的几个成员变量入手：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The next hash code to be given out. Updated atomically. Starts at</div><div class="line"> * zero.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</div><div class="line">    <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The difference between successively generated hash codes - turns</div><div class="line"> * implicit sequential thread-local IDs into near-optimally spread</div><div class="line"> * multiplicative hash values for power-of-two-sized tables.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the next hash code.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ThreadLocal通过<code>threadLocalHashCode</code>来标识每一个ThreadLocal的唯一性。<code>threadLocalHashCode</code>通过<code>CAS操作</code>进行更新，每次hash操作的增量为<strong>0x61c88647</strong>(这个数的原理没有探究)。<br>再看<code>set</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Sets the current thread's copy of this thread-local variable</div><div class="line"> * to the specified value.  Most subclasses will have no need to</div><div class="line"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</div><div class="line"> * method to set the values of thread-locals.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</div><div class="line"> *        this thread-local.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到通过<code>Thread.currentThread()</code>方法获取了当前的线程引用，并传给了<code>getMap(Thread)</code>方法获取一个<code>ThreadLocalMap</code>的实例。我们继续跟进<code>getMap(Thread)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到<code>getMap(Thread)</code>方法直接返回Thread实例的成员变量<code>threadLocals</code>。它的定义在Thread内部，访问级别为package级别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line"> * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>到了这里，我们可以看出，每个<code>Thread</code>里面都有一个<code>ThreadLocal.ThreadLocalMap</code>成员变量，也就是说每个线程通过<code>ThreadLocal.ThreadLocalMap</code>与ThreadLocal相绑定，这样可以确保每个线程访问到的thread-local variable都是本线程的。</p>
<p>我们往下继续分析。获取了<code>ThreadLocalMap</code>实例以后，如果它不为空则调用<code>ThreadLocalMap.ThreadLocalMap#set</code>方法设值；若为空则调用<code>ThreadLocal#createMap</code>方法new一个<code>ThreadLocalMap</code>实例并赋给<code>Thread.threadLocals</code>。</p>
<p><code>ThreadLocal#createMap</code>方法的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面我们探究一下<code>ThreadLocalMap</code>的实现。</p>
<h1 id="ThreadLocalMap">ThreadLocalMap</h1><p>ThreadLocalMap是ThreadLocal的静态内部类，它的结构如下：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/threadlocal-map-structure.png" alt="ThreadLocalMap"></p>
<p>可以看到ThreadLocalMap有一个常量和三个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The initial capacity -- MUST be a power of two.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The table, resized as necessary.</div><div class="line"> * table.length MUST always be a power of two.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> Entry[] table;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of entries in the table.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The next size value at which to resize.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></div></pre></td></tr></table></figure></p>
<p>其中<code>INITIAL_CAPACITY</code>代表这个Map的初始容量；1是一个Entry类型的数组，用于存储数据；<code>size</code>代表表中的存储数目；<code>threshold</code>代表需要扩容时对应size的阈值。</p>
<p><code>Entry</code>类是<code>ThreadLocalMap</code>的静态内部类，用于存储数据。它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The entries in this hash map extend WeakReference, using</div><div class="line"> * its main ref field as the key (which is always a</div><div class="line"> * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line"> * == null) mean that the key is no longer referenced, so the</div><div class="line"> * entry can be expunged from table.  Such entries are referred to</div><div class="line"> * as "stale entries" in the code that follows.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Entry</code>类继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。</p>
<p><code>ThreadLocalMap</code>类有两个构造函数，其中常用的是<code>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Construct a new map initially containing (firstKey, firstValue).</div><div class="line"> * ThreadLocalMaps are constructed lazily, so we only create</div><div class="line"> * one when we have at least one entry to put in it.</div><div class="line"> */</div><div class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</div><div class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</div><div class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</div><div class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</div><div class="line">    size = <span class="number">1</span>;</div><div class="line">    setThreshold(INITIAL_CAPACITY);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造函数的第一个参数就是本ThreadLocal实例(<code>this</code>)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。</p>
<p>注意一个细节，计算hash的时候里面采用了<code>hashCode &amp; (size - 1)</code>的算法，这相当于取模运算<code>hashCode % size</code>的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是<strong>2的指数</strong>，因为这可以使得hash发生冲突的次数减小。</p>
<p>接下来我们来看<code>ThreadLocalMap#set</code>方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Set the value associated with key.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key the thread local object</div><div class="line"> * <span class="doctag">@param</span> value the value to be set</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></div><div class="line">    <span class="comment">// least as common to use set() to create new entries as</span></div><div class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></div><div class="line">    <span class="comment">// path would fail more often than not.</span></div><div class="line"></div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            replaceStaleEntry(key, value, i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</div><div class="line">    <span class="keyword">int</span> sz = ++size;</div><div class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">        rehash();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果冲突了，就会通过<code>nextIndex</code>方法再次计算哈希值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Increment i modulo len.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，我们看到<code>ThreadLocalMap</code>解决冲突的方法是<strong>线性探测法</strong>（不断加1），而不是HashMap的<strong>链地址法</strong>，这一点也能从Entry的结构上推断出来。</p>
<p>如果entry里对应的key为<code>null</code>的话，表明此entry为<code>staled entry</code>，就将其替换为当前的key和value：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Replace a stale entry encountered during a set operation</div><div class="line"> * with an entry for the specified key.  The value passed in</div><div class="line"> * the value parameter is stored in the entry, whether or not</div><div class="line"> * an entry already exists for the specified key.</div><div class="line"> *</div><div class="line"> * As a side effect, this method expunges all stale entries in the</div><div class="line"> * "run" containing the stale entry.  (A run is a sequence of entries</div><div class="line"> * between two null slots.)</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  key the key</div><div class="line"> * <span class="doctag">@param</span>  value the value to be associated with key</div><div class="line"> * <span class="doctag">@param</span>  staleSlot index of the first stale entry encountered while</div><div class="line"> *         searching for key.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></div><div class="line">                               <span class="keyword">int</span> staleSlot) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    Entry e;</div><div class="line"></div><div class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></div><div class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></div><div class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></div><div class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></div><div class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">         i = prevIndex(i, len))</div><div class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</div><div class="line">            slotToExpunge = i;</div><div class="line"></div><div class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></div><div class="line">    <span class="comment">// occurs first</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">        <span class="comment">// If we find key, then we need to swap it</span></div><div class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></div><div class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></div><div class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></div><div class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line"></div><div class="line">            tab[i] = tab[staleSlot];</div><div class="line">            tab[staleSlot] = e;</div><div class="line"></div><div class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></div><div class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</div><div class="line">                slotToExpunge = i;</div><div class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If we didn't find stale entry on backward scan, the</span></div><div class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></div><div class="line">        <span class="comment">// first still present in the run.</span></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</div><div class="line">            slotToExpunge = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></div><div class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</div><div class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</div><div class="line"></div><div class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></div><div class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</div><div class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。</p>
<p>若是经历了上面步骤没有命中hash，也没有发现无用的Entry，<code>set</code>方法就会创建一个新的Entry，并会进行<strong>启发式的垃圾清理</strong>，用于清理无用的Entry。主要通过<code>cleanSomeSlots</code>方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Heuristically scan some cells looking for stale entries.</div><div class="line"> * This is invoked when either a new element is added, or</div><div class="line"> * another stale one has been expunged. It performs a</div><div class="line"> * logarithmic number of scans, as a balance between no</div><div class="line"> * scanning (fast but retains garbage) and a number of scans</div><div class="line"> * proportional to number of elements, that would find all</div><div class="line"> * garbage but would cause some insertions to take O(n) time.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> i a position known NOT to hold a stale entry. The</div><div class="line"> * scan starts at the element after i.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> n scan control: &#123;<span class="doctag">@code</span> log2(n)&#125; cells are scanned,</div><div class="line"> * unless a stale entry is found, in which case</div><div class="line"> * &#123;<span class="doctag">@code</span> log2(table.length)-1&#125; additional cells are scanned.</div><div class="line"> * When called from insertions, this parameter is the number</div><div class="line"> * of elements, but when from replaceStaleEntry, it is the</div><div class="line"> * table length. (Note: all this could be changed to be either</div><div class="line"> * more or less aggressive by weighting n instead of just</div><div class="line"> * using straight log n. But this version is simple, fast, and</div><div class="line"> * seems to work well.)</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> true if any stale entries have been removed.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        i = nextIndex(i, len);</div><div class="line">        Entry e = tab[i];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</div><div class="line">            n = len;</div><div class="line">            removed = <span class="keyword">true</span>;</div><div class="line">            i = expungeStaleEntry(i);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> removed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一旦发现一个位置对应的Entry所持有的ThreadLocal弱引用为null，就会把此位置当做staleSlot并调用<code>expungeStaleEntry</code>方法进行整理(rehashing)的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Expunge a stale entry by rehashing any possibly colliding entries</div><div class="line"> * lying between staleSlot and the next null slot.  This also expunges</div><div class="line"> * any other stale entries encountered before the trailing null.  See</div><div class="line"> * Knuth, Section 6.4</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</div><div class="line"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</div><div class="line"> * (all between staleSlot and this slot will have been checked</div><div class="line"> * for expunging).</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="comment">// expunge entry at staleSlot</span></div><div class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</div><div class="line">    tab[staleSlot] = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    <span class="comment">// Rehash until we encounter null</span></div><div class="line">    Entry e;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            e.value = <span class="keyword">null</span>;</div><div class="line">            tab[i] = <span class="keyword">null</span>;</div><div class="line">            size--;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (h != i) &#123;</div><div class="line">                tab[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></div><div class="line">                <span class="comment">// null because multiple entries could have been stale.</span></div><div class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                tab[h] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要没有清理任何的<strong>stale entries</strong>并且size达到阈值的时候（即table已满，所有元素都可用），都会触发<code>rehashing</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Re-pack and/or re-size the table. First scan the entire</div><div class="line"> * table removing stale entries. If this doesn't sufficiently</div><div class="line"> * shrink the size of the table, double the table size.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</div><div class="line">    expungeStaleEntries();</div><div class="line"></div><div class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></div><div class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</div><div class="line">        resize();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Expunge all stale entries in the table.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        Entry e = tab[j];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</div><div class="line">            expungeStaleEntry(j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>rehash操作会执行一次全表的扫描清理工作，并在size大于等于threshold的四分之三时进行resize，即扩容一倍。因此<code>ThreadLocalMap</code>的加载因子一样为<strong>0.75</strong>。</p>
<p>我们继续看<code>getEntry</code>的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Get the entry associated with key.  This method</div><div class="line"> * itself handles only the fast path: a direct hit of existing</div><div class="line"> * key. It otherwise relays to getEntryAfterMiss.  This is</div><div class="line"> * designed to maximize performance for direct hits, in part</div><div class="line"> * by making this method readily inlinable.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  key the thread local object</div><div class="line"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</div><div class="line">    Entry e = table[i];</div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Version of getEntry method for use when key is not found in</div><div class="line"> * its direct hash slot.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  key the thread local object</div><div class="line"> * <span class="doctag">@param</span>  i the table index for key's hash code</div><div class="line"> * <span class="doctag">@param</span>  e the entry at table[i]</div><div class="line"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="keyword">if</span> (k == key)</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</div><div class="line">            expungeStaleEntry(i);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            i = nextIndex(i, len);</div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用<code>getEntryAfterMiss</code>方法，根据线性探测法继续查找，直到找到或对应entry为<code>null</code>，并返回。</p>
<p>ThreadLocal的get方法就是调用了<code>ThreadLocalMap</code>的getEntry方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>remove</code>方法的思想类似，直接放源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Remove the entry for key.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</div><div class="line">            e.clear();</div><div class="line">            expungeStaleEntry(i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>remove的时候同样也会调用<code>expungeStaleEntry</code>方法执行清理工作。</p>
<h1 id="总结">总结</h1><p>每个Thread里都含有一个ThreadLocalMap的成员变量，这种机制将ThreadLocal和线程巧妙地绑定在了一起，即可以保证无用的ThreadLocal被及时回收，不会造成内存泄露，又可以提升性能。假如我们把ThreadLocalMap做成一个<code>Map&lt;t extends Thread, ?&gt;</code>类型的Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而JDK里的这种利用ThreadLocal作为key，再将ThreadLocalMap与线程相绑定的实现，完美地解决了这个问题。</p>
<p>总结一下什么时候无用的Entry会被清理：</p>
<ul>
<li>Thread结束的时候</li>
<li>插入元素时，发现<strong>staled entry</strong>，则会进行替换并清理</li>
<li>插入元素时，<code>ThreadLocalMap</code>的<code>size</code>达到<code>threshold</code>，并且没有任何<strong>staled entries</strong>的时候，会调用<code>rehash</code>方法清理并扩容</li>
<li>调用<code>ThreadLocalMap</code>的<code>remove</code>方法或<code>set(null)</code>时</li>
</ul>
<p>尽管不会造成内存泄露，但是可以看到无用的Entry只会在以上四种情况下才会被清理，这就可能导致一些Entry虽然无用但还占内存的情况。因此，我们在使用完ThreadLocal后一定要<code>remove</code>一下，保证及时回收掉无用的Entry。</p>
<p>【场景】当应用线程池的时候，由于线程池的线程一般会复用，Thread不结束，这时候用完更需要<code>remove</code>了。</p>
<p>总的来说，对于多线程资源共享的问题，同步机制采用了“<strong>以时间换空间</strong>”的方式，而ThreadLocal采用了“<strong>以空间换时间</strong>”的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<h1 id="应用">应用</h1><p>应用太多了。。。各大框架都有应用，比如Spring。Spring对一些Bean中的成员变量采用ThreadLocal进行处理，让它们可以成为线程安全的。举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.context.request;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestContextHolder</span>  </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsfPresent =</div><div class="line">			ClassUtils.isPresent(<span class="string">"javax.faces.context.FacesContext"</span>, RequestContextHolder.class.getClassLoader());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder =</div><div class="line">			<span class="keyword">new</span> NamedThreadLocal&lt;RequestAttributes&gt;(<span class="string">"Request attributes"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder =</div><div class="line">			<span class="keyword">new</span> NamedInheritableThreadLocal&lt;RequestAttributes&gt;(<span class="string">"Request context"</span>);</div><div class="line"></div><div class="line">            <span class="comment">//......下面省略</span></div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>再比如Spring MVC中的Controller默认是<strong>singleton</strong>的，因此如果Controller或其对应的Service里存在非静态成员变量的话，并发访问就会出现race condition问题，这也可以通过<strong>ThreadLocal</strong>解决。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程安全/">线程安全</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-8-completable-future" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Java/java-8-completable-future/" class="article-date">
      <time datetime="2016-02-29T16:00:00.000Z" itemprop="datePublished">2016-03-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Java/java-8-completable-future/">并发编程 | JDK 1.8中的CompletableFuture | FRP风格</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在异步编程中，Future/Promise模式是一种广泛使用的异步开发模式，其中 <code>Future</code> 对象代表一个尚未完成异步操作的结果。从JDK 1.5以来，JUC包一直提供着最基本的<code>Future</code>，不过它太鸡肋了，除了<code>get</code>、<code>cancel</code>、<code>isDone</code>和<code>isCancelled</code>方法之外就没有其他的操作了，这样很不方便。好在JDK 1.8中引入了具有FRP风格的 <code>CompletableFuture</code>，它类似于Scala中的 <code>Future</code>。<code>CompletableFuture</code> 属于Monad， 因此支持一系列的函数式的组合、运算操作，非常方便，可以写出很FRP风格的代码而摆脱callback hell。</p>
<p>下面我们来结合FRP的思想，总结一下这些操作（<em>有的时候为了方便表示，我会用Haskell或Scala的语法来表示类型，毕竟Java的类型系统太渣</em>）：</p>
<h1 id="构造CompletableFuture对象">构造CompletableFuture对象</h1><p>CompletableFuture类通过工厂模式创建<code>CompletableFuture</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,</span></span></div><div class="line">                                                   Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable,</span></span></div><div class="line">                                               Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们的异步操作不需要返回值，那么可以通过<code>runAsync</code>方法提供一个Runnable创建一个<code>CompletableFuture&lt;Void&gt;</code>对象。如果我们的异步操作需要返回值，那么可以通过<code>supplyAsync</code>方法提供一个<code>Supplier&lt;U&gt;</code>对象来创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; longTask(param));</div></pre></td></tr></table></figure>
<p>如果不提供<code>Executor</code>的话，默认使用<code>ForkJoinPool.commonPool()</code>作为线程池。</p>
<p>后缀为<code>Async</code>的方法代表异步执行。</p>
<h1 id="变换(fmap)">变换(fmap)</h1><p>假如我们要通过CompletableFuture来异步获取一组数据，并对数据进行一些处理（变换），我们可以使用<code>thenApply</code>和<code>thenApplyAsync</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> uniApplyStage(<span class="keyword">null</span>, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> uniApplyStage(asyncPool, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它其实就是<code>fmap</code>函数，用Haskell表示原型为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 对比一下fmap</span></div><div class="line"><span class="title">fmap</span> :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</div><div class="line"></div><div class="line"><span class="title">thenApply</span> :: (a -&gt; b) -&gt; <span class="type">CompletableFuture</span> a -&gt; <span class="type">CompletableFuture</span> b</div></pre></td></tr></table></figure>
<p>它们不仅可以变换数据的值，也可以变换数据的类型，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CompletableFuture&lt;Double&gt; f = CompletableFuture.supplyAsync(() -&gt; <span class="string">"4"</span>)</div><div class="line">                .thenApply(Integer::parseInt)</div><div class="line">                .thenApply(r -&gt; r * r * Math.PI);</div></pre></td></tr></table></figure>
<p>fmap以后，数据流的类型进行了以下变换：<code>String -&gt; Integer -&gt; Double</code>。</p>
<h1 id="组合(bind)">组合(bind)</h1><p>有的时候，我们需要在异步操作完成的时候对异步操作的结果进行一些操作，并且操作仍然返回<code>CompletableFuture</code>类型。我们可以利用<code>thenCompose</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> uniComposeStage(<span class="keyword">null</span>, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> uniComposeStage(asyncPool, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</div><div class="line">    Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> uniComposeStage(screenExecutor(executor), fn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出它其实对应了Monad里的<code>bind</code>操作(Java和Scala中为<code>flatMap</code>)，用Haskell表示原型为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(&gt;&gt;=) :: <span class="type">Monad</span> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</div><div class="line"></div><div class="line"><span class="title">thenCompose</span> :: <span class="type">CompletableFuture</span> a -&gt; (a -&gt; <span class="type">CompletableFuture</span> b) -&gt; <span class="type">CompletableFuture</span> b</div></pre></td></tr></table></figure>
<p><code>thenCompose</code>是一个非常重要的操作，它对于构建异步的pipeline非常有用。举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskWorkI</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;List&lt;Integer&gt;&gt; longTask(Integer i) &#123;</div><div class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pc = <span class="number">0</span>; pc &lt; i; pc++)</div><div class="line">                list.add(pc);</div><div class="line">            <span class="keyword">return</span> Optional.of(list);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> Optional.empty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Long&gt; <span class="title">getResultFuture</span><span class="params">(Optional&lt;List&lt;Integer&gt;&gt; op)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (op.isPresent())</div><div class="line">                <span class="keyword">return</span> op.get().stream()</div><div class="line">                        .map(Integer::toUnsignedLong)</div><div class="line">                        .reduce(<span class="number">0L</span>, (x, y) -&gt; x + y);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> -<span class="number">1L</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        CompletableFuture&lt;Long&gt; f = CompletableFuture.supplyAsync(() -&gt; longTask(<span class="number">1000000</span>))</div><div class="line">                .thenComposeAsync(TaskWorkI::getResultFuture);</div><div class="line">        Long result = f.get();</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="超级变换(liftM2)">超级变换(liftM2)</h1><p><code>CompletableFuture</code>类里面还有个<code>thenCombine</code>操作，它的原型看起来非常晕：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(</span></span></div><div class="line">    CompletionStage&lt;? extends U&gt; other,</div><div class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> biApplyStage(<span class="keyword">null</span>, other, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(</span></span></div><div class="line">    CompletionStage&lt;? extends U&gt; other,</div><div class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> biApplyStage(asyncPool, other, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(</span></span></div><div class="line">    CompletionStage&lt;? extends U&gt; other,</div><div class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn, Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java类型系统过于坑爹，我们用Haskell表示其原型就一目了然了：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">thenCombine</span> :: <span class="type">CompletableFuture</span> a -&gt; <span class="type">CompletableFuture</span> b -&gt; (a -&gt; b -&gt; c) -&gt; <span class="type">CompletableFuture</span> c</div></pre></td></tr></table></figure>
<p>把参数调调位置，可以发现<code>thenCombine</code>其实类似于Haskell中的<code>liftM2</code>操作：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">liftM2</span> :: <span class="type">Monad</span> m =&gt; (a1 -&gt; a2 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m r</div><div class="line"></div><div class="line"><span class="title">thenCombine</span> :: <span class="type">CompletableFuture</span> m =&gt; (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c</div></pre></td></tr></table></figure>
<h1 id="简单示例">简单示例</h1><p>下面我们用一个简单的例子来说明<code>CompletableFuture</code>的使用。假设我们需要获取一篇文章(Article)的信息、对应分类(Category)信息以及对应的评论数，而且从数据库中query的操作是异步的（每个DB操作都返回一个<code>CompletableFuture</code>），我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleWithCategory</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Article article;</div><div class="line">    <span class="keyword">private</span> Category category;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArticleWithCategory</span><span class="params">(Article article, Category category)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.article = article;</div><div class="line">        <span class="keyword">this</span>.category = category;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwcWithCount</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArticleWithCategory awc;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwcWithCount</span><span class="params">(ArticleWithCategory awc, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.awc = awc;</div><div class="line">        <span class="keyword">this</span>.count = count;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;ArticleWithCategory&gt; <span class="title">fetchAWC</span><span class="params">(<span class="keyword">int</span> aid)</span> </span>&#123;</div><div class="line">    <span class="comment">// 从数据库中异步获取文章信息与分类信息</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Integer&gt; <span class="title">getCount</span><span class="params">(<span class="keyword">int</span> aid)</span> </span>&#123;</div><div class="line">    <span class="comment">// 从数据库中异步获取评论数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;AwcWithCount&gt; <span class="title">fetchWithAWCC</span><span class="params">(<span class="keyword">int</span> aid)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> fetchAWC(aid).thenCompose(x -&gt; <span class="comment">// flatMap</span></div><div class="line">            getCount(aid).thenApply(y -&gt; <span class="comment">// map</span></div><div class="line">                <span class="keyword">new</span> AwcWithCount(x, y)</div><div class="line">    ));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这其实和Scala中的Slick的各种组合特别相似：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithAWCC</span></span>(aid: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Option</span>[(<span class="type">Article</span>, <span class="type">Category</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    db.run((<span class="keyword">for</span> &#123;</div><div class="line">        a &lt;- articles <span class="keyword">if</span> _.aid === aid</div><div class="line">        c &lt;- categories <span class="keyword">if</span> _.cid === a.cid</div><div class="line">    &#125; <span class="keyword">yield</span>(a, c)).result.headOption) flatMap &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Some</span>(a, c) =&gt;</div><div class="line">            db.run(comments.filter(_.aid === aid).length) map &#123; <span class="keyword">case</span> res =&gt;</div><div class="line">                <span class="type">Some</span>(a, c, res)</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">            <span class="type">Future</span>(<span class="type">None</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Rx中同样也提供了类似的组合操作，而且更为丰富。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JUC/">JUC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-scala-fp-union-curry-howard-isomorphism" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/scala-fp-union-curry-howard-isomorphism/" class="article-date">
      <time datetime="2016-02-25T16:00:00.000Z" itemprop="datePublished">2016-02-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/scala-fp-union-curry-howard-isomorphism/">Scala | 利用Curry-Howard Isomorphism实现union type</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>所谓的联合类型(union type)，在逻辑上是“或”的意思，如<code>A or B or C</code>。</p>
<p>假设我们想实现这样一个函数size，它可以计算一个联合类型对象（Int与String）的长度。我们期望size函数只接受Int类型或String类型（以及它们的子类型，如Null和Nothing）的对象，而不接受任何其他类型的对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(x: <span class="type">Int</span> ∨ <span class="type">String</span>) = x <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i</div><div class="line">  <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.length</div><div class="line">&#125;</div><div class="line"></div><div class="line">size(<span class="number">24</span>) == <span class="number">24</span>   <span class="comment">// OK</span></div><div class="line">size(<span class="string">"fuck"</span>) == <span class="number">4</span> <span class="comment">// OK</span></div><div class="line">size(<span class="number">1.0</span>)        <span class="comment">// 编译错误</span></div></pre></td></tr></table></figure></p>
<p>Scala中的<code>Either</code>类型可以提供一种不支持子类型的联合类型。举个例子，用<code>Either</code>实现size函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(x: <span class="type">Either</span>[<span class="type">Int</span>, <span class="type">String</span>]) = x <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Left</span>(i) =&gt; i</div><div class="line">  <span class="keyword">case</span> <span class="type">Right</span>(s) =&gt; s.length</div><div class="line">&#125;</div><div class="line"></div><div class="line">size(<span class="type">Left</span>(<span class="number">24</span>)) == <span class="number">24</span>    <span class="comment">// OK</span></div><div class="line">size(<span class="type">Right</span>(<span class="string">"fuck"</span>)) == <span class="number">4</span> <span class="comment">// OK</span></div><div class="line">size(<span class="type">Left</span>(<span class="string">"lv"</span>)) <span class="comment">// error: type mismatch</span></div></pre></td></tr></table></figure></p>
<p>我们可以观察出一个问题，那就是要使用Either类型就不可避免要把对象包装成Either类型（<code>Left</code>或<code>Right</code>），这是不方便的。我们需要一些奇技淫巧来实现一个原生类型版本(unboxed)的size函数，这就是下面要介绍的<strong>Curry-Howard Isomorphism</strong>（柯里-霍华德同构）。</p>
<h1 id="Curry-Howard_Isomorphism">Curry-Howard Isomorphism</h1><p><a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" target="_blank" rel="external">Curry-Howard Isomorphism</a> 通过命题表示了计算机程序与数理逻辑之间的直接联系(逻辑上的等价关系)，即我们可以利用数理逻辑中的某些东西来去表示程序中的特定逻辑。比如在Curry-Howard 同构中，有以下的等价关系：</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>类型系统(Scala)</th>
<th>命题逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>联合类型（并，析取）</td>
<td>A ∨ B（∨为自定义的析取类型）</td>
<td>A ∨ B</td>
</tr>
<tr>
<td>交集类型（交，合取）</td>
<td>A with B</td>
<td>A ∧ B</td>
</tr>
<tr>
<td>子类型（蕴含）</td>
<td>A &lt;: B</td>
<td>A ⇒ B</td>
</tr>
</tbody>
</table>
<p>因此联合类型可以表示为析取式，如<code>P ∨ Q ∨ R</code>。</p>
<p>那么如何根据Curry-Howard 同构实现一个析取类型呢？我们可以先利用<strong>德摩根定律</strong>(De Morgan’s laws)做一个转化。已知德摩根定律：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(A ∨ B) ⇔ ¬(¬A ∧ ¬B)</div></pre></td></tr></table></figure></p>
<p>用Scala代码就可以表示为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="type">A</span> ∨ <span class="type">B</span>) =:= ¬[¬[<span class="type">A</span>] <span class="keyword">with</span> ¬[<span class="type">B</span>]]</div></pre></td></tr></table></figure></p>
<p>这样，问题就转化成了如何实现一个否定类型(¬)。我们从另一个角度去利用Curry-Howard 同构。在类型系统理论中，存在以下等价关系：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>Scala Type</th>
<th>对应命题逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum Type</td>
<td>A ∨ B（∨为自定义的析取类型）</td>
<td>析取(A ∨ B)</td>
</tr>
<tr>
<td>Product Type</td>
<td>(A, B)</td>
<td>合取(A ∧ B)</td>
</tr>
<tr>
<td>Function Type</td>
<td>Function1[A, B]</td>
<td>蕴含(A ⇒ B)</td>
</tr>
</tbody>
</table>
<p>再根据以下的等价关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(A ⇒ False) ⇔ ¬A</div></pre></td></tr></table></figure></p>
<p>我们就可以写出Scala中对应的类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">A</span> =&gt; <span class="type">Nothing</span></div></pre></td></tr></table></figure></p>
<p>这样我们就可以定义两个类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬</span>[<span class="type">A</span>] </span>= <span class="type">A</span> =&gt; <span class="type">Nothing</span></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">∨</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= ¬[¬[<span class="type">T</span>] <span class="keyword">with</span> ¬[<span class="type">U</span>]]</div></pre></td></tr></table></figure></p>
<p>在REPL里测试一下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">¬</span>[<span class="type">A</span>] </span>= <span class="type">A</span> =&gt; <span class="type">Nothing</span></div><div class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">$u00AC</span></span></div><div class="line"></div><div class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">∨</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= ¬[¬[<span class="type">T</span>] <span class="keyword">with</span> ¬[<span class="type">U</span>]]</div><div class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">$u2228</span></span></div><div class="line"></div><div class="line">scala&gt; implicitly[<span class="type">Int</span> &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div><div class="line">&lt;console&gt;:<span class="number">13</span>: error: <span class="type">Cannot</span> prove that <span class="type">Int</span> &lt;:&lt; ∨[<span class="type">Int</span>,<span class="type">String</span>].</div><div class="line">       implicitly[<span class="type">Int</span> &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div></pre></td></tr></table></figure></p>
<p>嗯？哪里出问题了？我们来分析一下<code>(Int ∨ String)</code>这个类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; :k ∨[<span class="type">Int</span>, <span class="type">String</span>]</div><div class="line">scala.<span class="type">Function1</span><span class="symbol">'s</span> kind is <span class="type">F</span>[-<span class="type">A1</span>,+<span class="type">A2</span>]</div></pre></td></tr></table></figure></p>
<p>原来(Int ∨ String)的类型是函数类型，也就是说我们创造的Union Type是函数类型，那Int类型自然不是(Int ∨ String)的子类型了，因为它连函数类型都不是。我们需要将<code>&lt;:&lt;</code>操作符左边的类型转化成函数类型，比如双重否定类型（逻辑上相当于原类型，但其类型为函数类型）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬¬</span>[<span class="type">A</span>] </span>= ¬[¬[<span class="type">A</span>]]</div></pre></td></tr></table></figure>
<p>再测试一下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">¬¬</span>[<span class="type">A</span>] </span>= ¬[¬[<span class="type">A</span>]]</div><div class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">$u00AC$u00AC</span></span></div><div class="line"></div><div class="line">scala&gt; implicitly[¬¬[<span class="type">Int</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div><div class="line">res2: &lt;:&lt;[¬¬[<span class="type">Int</span>],∨[<span class="type">Int</span>,<span class="type">String</span>]] = &lt;function1&gt;</div><div class="line"></div><div class="line">scala&gt; implicitly[¬¬[<span class="type">String</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div><div class="line">res3: &lt;:&lt;[¬¬[<span class="type">String</span>],∨[<span class="type">Int</span>,<span class="type">String</span>]] = &lt;function1&gt;</div><div class="line"></div><div class="line">scala&gt; implicitly[¬¬[<span class="type">Double</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div><div class="line">&lt;console&gt;:<span class="number">14</span>: error: <span class="type">Cannot</span> prove that ¬¬[<span class="type">Double</span>] &lt;:&lt; ∨[<span class="type">Int</span>,<span class="type">String</span>].</div><div class="line">       implicitly[¬¬[<span class="type">Double</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div></pre></td></tr></table></figure>
<p>成功了！<code>¬¬[Int]</code>和<code>¬¬[String]</code>都是<code>∨[Int,String]</code>的子类型。把Int换成Double，无法通过编译。下面我们就可以利用隐式转换实现我们的size函数了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>[<span class="type">T</span>](t: <span class="type">T</span>)(<span class="keyword">implicit</span> ev: (¬¬[<span class="type">T</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>))) = t <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i</div><div class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.length</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试一下，结果very good～</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">scala&gt; size(<span class="number">24</span>)</div><div class="line">res5: <span class="type">Int</span> = <span class="number">24</span></div><div class="line"></div><div class="line">scala&gt; size(<span class="string">"Scala"</span>)</div><div class="line">res6: <span class="type">Int</span> = <span class="number">5</span></div><div class="line"></div><div class="line">scala&gt; size(<span class="number">6.666</span>)</div><div class="line">&lt;console&gt;:<span class="number">15</span>: error: <span class="type">Cannot</span> prove that ¬¬[<span class="type">Double</span>] &lt;:&lt; ∨[<span class="type">Int</span>,<span class="type">String</span>].</div><div class="line">       size(<span class="number">6.666</span>)</div><div class="line">           ^</div></pre></td></tr></table></figure>
<p>最后还可以用type lambda来简化函数的参数，省掉<code>implicit</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">|∨|</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= &#123; <span class="class"><span class="keyword">type</span> <span class="title">λ</span>[<span class="type">X</span>] </span>= ¬¬[<span class="type">X</span>] &lt;:&lt; (<span class="type">T</span> ∨ <span class="type">U</span>) &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>[<span class="type">T</span>: (<span class="type">Int</span> |∨| <span class="type">String</span>)#λ](t: <span class="type">T</span>) =</div><div class="line">  t <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i</div><div class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.length</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>所以我们union type及size函数的最终实现为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬</span>[<span class="type">A</span>] </span>= <span class="type">A</span> ⇒ <span class="type">Nothing</span></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">∨</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= ¬[¬[<span class="type">T</span>] <span class="keyword">with</span> ¬[<span class="type">U</span>]]</div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬¬</span>[<span class="type">A</span>] </span>= ¬[¬[<span class="type">A</span>]]</div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">|∨|</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= &#123; <span class="class"><span class="keyword">type</span> <span class="title">λ</span>[<span class="type">X</span>] </span>= ¬¬[<span class="type">X</span>] &lt;:&lt; (<span class="type">T</span> ∨ <span class="type">U</span>) &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>[<span class="type">T</span> : (<span class="type">Int</span> |∨| <span class="type">String</span>)#λ](t : <span class="type">T</span>) = t <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> i : <span class="type">Int</span> ⇒ i</div><div class="line">    <span class="keyword">case</span> s : <span class="type">String</span> ⇒ s.length</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结一下，整个过程的本质都是在进行类型推导和证明，因此我们可以将Curry-Howard Isomorphism理解为<strong>类型证明即程序</strong>。</p>
<p>其实类型系统还有很多好玩的东西，比如<strong>dependent type</strong>。。后边可以用Scala玩玩~</p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/" target="_blank" rel="external">Unboxed union types in Scala via the Curry-Howard isomorphism, Miles Sabin</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mathematical-Logic/">Mathematical Logic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-scala-for-comprehensions-detail" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/scala-for-comprehensions-detail/" class="article-date">
      <time datetime="2016-02-24T16:00:00.000Z" itemprop="datePublished">2016-02-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/scala-for-comprehensions-detail/">Scala | for-comprehension底层转换 | withFilter解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Scala 中的 for-comprehension 是一种方便的语法糖，它实际上是几种操作<code>map</code>、<code>flatMap</code>和<code>filter</code>的组合。for-comprehension 的 EBNF 表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Expr1          ::=  ‘for’ (‘(’ Enumerators ‘)’ | ‘&#123;’ Enumerators ‘&#125;’)</div><div class="line">                       &#123;nl&#125; [‘yield’] Expr</div><div class="line">Enumerators    ::=  Generator &#123;semi Generator&#125;</div><div class="line">Generator      ::=  Pattern1 ‘&lt;-’ Expr &#123;[semi] Guard | semi Pattern1 ‘=’ Expr&#125;</div><div class="line">Guard          ::=  ‘if’ PostfixExpr</div></pre></td></tr></table></figure>
<p>Scala 中的 for-comprehension 与 Haskell 中的 do-notation 类似，都是对操作组合过程的简化，操作的对象都是 Monad。这里就类比 Haskell 中的 do-notation 来总结 Scala 中的 for-comprehension 转换规则。</p>
<h1 id="First_step">First step</h1><p>第一步 Scala 会处理 generator 中的 <strong>refutable pattern</strong>。所谓的 refutable pattern 就是模式匹配中可能失败的情况，而 irrefutable pattern 就是模式匹配中一定会匹配成功的情况（如variables）。对于每个可能匹配失败的 generator <code>p &lt;- e</code>，Scala 会将其转化为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p &lt;- e.withFilter &#123; <span class="keyword">case</span> p =&gt; <span class="literal">true</span>; <span class="keyword">case</span> _ =&gt; <span class="literal">false</span> &#125;</div></pre></td></tr></table></figure>
<p>比如 <code>for (1 &lt;- List(1, 2)) &quot;ha&quot;</code> 这段表达式的转化结果为:（直接在REPL里通过宏查看AST）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; reify( <span class="keyword">for</span> (<span class="number">1</span> &lt;- <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="string">"ha"</span> )</div><div class="line">res1: reflect.runtime.universe.<span class="type">Expr</span>[<span class="type">Unit</span>] =</div><div class="line"><span class="type">Expr</span>[<span class="type">Unit</span>](<span class="type">List</span>.apply(<span class="number">1</span>, <span class="number">2</span>).withFilter(((check$ifrefutable$<span class="number">1</span>) =&gt; check$ifrefutable$<span class="number">1</span>: <span class="meta">@unchecked</span> <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="literal">true</span></div><div class="line">  <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></div><div class="line">&#125;)).foreach(((x$<span class="number">1</span>) =&gt; x$<span class="number">1</span>: <span class="meta">@unchecked</span> <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"ha"</span></div><div class="line">&#125;)))</div></pre></td></tr></table></figure>
<h1 id="单个generator的for-comprehension">单个generator的for-comprehension</h1><p>只有一个 generator 的 for-comprehension：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1)</div><div class="line">    <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>它会被转化为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1 map &#123;x =&gt; e2&#125;</div></pre></td></tr></table></figure>
<p>我们通过 Quasiquotes 获取AST来验证：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> e1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">e1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(x: <span class="type">Int</span>) = x * <span class="number">2</span></div><div class="line">f1: (x: <span class="type">Int</span>)<span class="type">Int</span></div><div class="line"></div><div class="line">scala&gt; <span class="string">q" for (x &lt;- e1) yield f1 _ "</span></div><div class="line">res2: reflect.runtime.universe.<span class="type">Tree</span> = e1.map(((x) =&gt; (f1: (() =&gt; &lt;empty&gt;))))</div></pre></td></tr></table></figure>
<p>在Haskell中原表达式等价于：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">do</span></div><div class="line">    x &lt;- e1</div><div class="line">    return e2</div></pre></td></tr></table></figure>
<p>转换为非do-notation：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">e1</span> &gt;&gt;=</div><div class="line">     \x -&gt; return e2</div></pre></td></tr></table></figure>
<p>根据 Monad Laws 推导出的 <code>fmap f ma = ma &gt;&gt;= (return . f)</code> 转化：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(\x -&gt; e2) &lt;$&gt; e1</div></pre></td></tr></table></figure>
<h1 id="多个generator的for-comprehension">多个generator的for-comprehension</h1><p>多个generator其实就是<code>map</code>和<code>flatMap</code>(<code>fmap</code>和<code>&gt;&gt;=</code>)的组合，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1; y &lt;- e2)</div><div class="line">    <span class="keyword">yield</span> e3</div></pre></td></tr></table></figure>
<p>会转化为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1.flatMap(x =&gt; <span class="keyword">for</span> (y &lt;- e2) <span class="keyword">yield</span> e3)</div></pre></td></tr></table></figure>
<p>即</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">e1 flatMap &#123; x =&gt;</div><div class="line">    e2 map &#123; y =&gt; e3 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>REPL里验证：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">q"for(x &lt;- e1; y &lt;- e2) yield x + y"</span></div><div class="line">res3: reflect.runtime.universe.<span class="type">Tree</span> = e1.flatMap(((x) =&gt; e2.map(((y) =&gt; x.$plus(y)))))</div></pre></td></tr></table></figure>
<p>举例(Scala):</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> e1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> e2 = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> f1 = <span class="keyword">for</span>(x &lt;- e1; y &lt;- e2)</div><div class="line">  <span class="keyword">yield</span> x + y <span class="comment">// List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> f2 = e1 flatMap &#123; x =&gt;</div><div class="line">  e2 map &#123; y =&gt; x + y &#125;</div><div class="line">&#125; <span class="comment">// List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span></div></pre></td></tr></table></figure>
<p>在Haskell中原表达式等价于：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">do</span></div><div class="line">    x &lt;- e1</div><div class="line">    y &lt;- e2</div><div class="line">    return e3</div></pre></td></tr></table></figure>
<p>转换为非do-notation：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">e1</span> &gt;&gt;=</div><div class="line">     \x -&gt; e2 &gt;&gt;=</div><div class="line">         \y -&gt; return e3</div></pre></td></tr></table></figure>
<p>根据 Monad Laws 推导出的 <code>fmap f ma = ma &gt;&gt;= (return . f)</code> 转化：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">e1</span> &gt;&gt;=</div><div class="line">    \x -&gt; fmap (\y -&gt; e3) e2</div></pre></td></tr></table></figure>
<p>举例(Haskell)：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- result: [5,6,7,6,7,8,7,8,9]</span></div><div class="line"><span class="title">f2</span> :: (<span class="type">Num</span> a) =&gt; [a]</div><div class="line"><span class="title">f2</span> = <span class="keyword">do</span></div><div class="line">    x &lt;- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">    y &lt;- [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">    return (x + y)</div><div class="line"></div><div class="line"><span class="title">f3</span> :: (<span class="type">Num</span> a) =&gt; [a]</div><div class="line"><span class="title">f3</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &gt;&gt;=</div><div class="line">     \x -&gt; [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] &gt;&gt;=</div><div class="line">          \y -&gt; return (x + y)</div><div class="line"></div><div class="line"><span class="title">f4</span> :: (<span class="type">Num</span> a) =&gt; [a]</div><div class="line"><span class="title">f4</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &gt;&gt;=</div><div class="line">     \x -&gt; fmap (\y -&gt; x + y) [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<h1 id="for-loop">for-loop</h1><p>Scala中，for表达式也有支持side effects的版本(for-loop)，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(x &lt;- e1; y &lt;- e2)</div><div class="line">    println(x * y)</div></pre></td></tr></table></figure>
<p>它的转化和含yield的差不多，只不过它用含副作用的<code>foreach</code>操作替代了<code>map</code>和<code>flatMap</code>算子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">e1 foreach &#123;</div><div class="line">    x =&gt; e2 foreach &#123;</div><div class="line">        y =&gt; println(x * y)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="含条件的for表达式">含条件的for表达式</h1><p>Scala支持含有条件判断(if guard)的for表达式，其中<code>if guard</code>对应<code>withFilter</code>算子。</p>
<p>转换规则：<code>p &lt;- e if g</code> 会转换为 <code>p &lt;- e.withFilter(p =&gt; g)</code>。</p>
<p>比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1 <span class="keyword">if</span> p)</div><div class="line">    <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>会转化为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1 withFilter &#123;x =&gt; p&#125;)</div><div class="line">    <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>即：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1 withFilter &#123;x =&gt; f&#125; map &#123;x =&gt; e2&#125;</div></pre></td></tr></table></figure>
<p>REPL里验证：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; reify( <span class="keyword">for</span>(x &lt;- e1 <span class="keyword">if</span> x &gt; <span class="number">2</span>) <span class="keyword">yield</span> f1 _ )</div><div class="line">res20: reflect.runtime.universe.<span class="type">Expr</span>[<span class="type">List</span>[<span class="type">Int</span> =&gt; <span class="type">Int</span>]] =</div><div class="line"><span class="type">Expr</span>[<span class="type">List</span>[<span class="type">Int</span> =&gt; <span class="type">Int</span>]]($read.e1.withFilter(((x) =&gt; x.$greater(<span class="number">2</span>))).map(((x) =&gt; &#123;</div><div class="line">  ((x) =&gt; $read.f1(x))</div><div class="line">&#125;))(<span class="type">List</span>.canBuildFrom))</div><div class="line"></div><div class="line">scala&gt; <span class="string">q" for(x &lt;- e1 if x &gt; 2) yield f1 _ "</span></div><div class="line">res21: reflect.runtime.universe.<span class="type">Tree</span> = e1.withFilter(((x) =&gt; x.$greater(<span class="number">2</span>))).map(((x) =&gt; (f1: (() =&gt; &lt;empty&gt;))))</div></pre></td></tr></table></figure>
<h1 id="含有value_definition的for表达式">含有value definition的for表达式</h1><p>这种情况下generator中含有value definition，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p &lt;- e</div><div class="line">p1 = e1</div></pre></td></tr></table></figure>
<p>这种转换要稍微啰嗦一点。对于 <code>p &lt;- e; p1 = e1</code> 这样的generator，Scala会将其转换为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(p, p1) &lt;- <span class="keyword">for</span> (x<span class="meta">@p</span>&lt;- e) <span class="keyword">yield</span> &#123;</div><div class="line">  <span class="keyword">val</span> x1<span class="meta">@p</span>1 = e1</div><div class="line">  (x, x1)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到展开的结果是多了一次for-comprehension，也就是多了一层<code>map</code>，这可能会带来一些效率问题。</p>
<p>在REPL里验证：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">"+"</span>, <span class="string">"1"</span>, <span class="string">"s"</span>)</div><div class="line">list: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(+, <span class="number">1</span>, s)</div><div class="line"></div><div class="line">scala&gt; reify ( <span class="keyword">for</span>(p &lt;- list; x = p; y = p) <span class="keyword">yield</span> y )</div><div class="line">res29: reflect.runtime.universe.<span class="type">Expr</span>[<span class="type">List</span>[<span class="type">String</span>]] =</div><div class="line"><span class="type">Expr</span>[<span class="type">List</span>[<span class="type">String</span>]]($read.list.map(((p) =&gt; &#123;</div><div class="line">  <span class="keyword">val</span> x = p;</div><div class="line">  <span class="keyword">val</span> y = p;</div><div class="line">  <span class="type">Tuple3</span>.apply(p, x, y)</div><div class="line">&#125;))(<span class="type">List</span>.canBuildFrom).map(((x$<span class="number">1</span>) =&gt; x$<span class="number">1</span>: <span class="meta">@unchecked</span> <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Tuple3</span>((p @ _), (x @ _), (y @ _)) =&gt; y</div><div class="line">&#125;))(<span class="type">List</span>.canBuildFrom))</div></pre></td></tr></table></figure>
<h1 id="withFilter">withFilter</h1><p>最后再来谈一下上面出现的<code>withFilter</code>函数，它于Scala 2.8引入，是<code>filter</code>的lazy版本。那么为什么要引入<code>withFilter</code>呢？为何不能直接用<code>filter</code>呢？我们先来看两段代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span></div><div class="line"><span class="keyword">for</span> (x &lt;- <span class="type">List</span>.range(<span class="number">1</span>, <span class="number">10</span>); <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; !found)</div><div class="line">  <span class="keyword">if</span> (x == <span class="number">5</span>) found = <span class="literal">true</span> <span class="keyword">else</span> println(x)</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span></div><div class="line"><span class="keyword">for</span> (x &lt;- <span class="type">Stream</span>.range(<span class="number">1</span>, <span class="number">10</span>); <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; !found)</div><div class="line">  <span class="keyword">if</span> (x == <span class="number">5</span>) found = <span class="literal">true</span> <span class="keyword">else</span> println(x)</div></pre></td></tr></table></figure>
<p>其中，<code>Stream</code>是<code>List</code>的lazy版本，只在需要的时候求值。按照上面总结的for-comprehension转换规则，我们可以将上面的代码转换为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span></div><div class="line"><span class="type">List</span>.range(<span class="number">1</span>,<span class="number">10</span>).f(_ % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; !found).foreach(x =&gt; <span class="keyword">if</span> (x == <span class="number">5</span>) found = <span class="literal">true</span> <span class="keyword">else</span> println(x))</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span></div><div class="line"><span class="type">Stream</span>.range(<span class="number">1</span>,<span class="number">10</span>).f(_ % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; !found).foreach(x =&gt; <span class="keyword">if</span> (x == <span class="number">5</span>) found = <span class="literal">true</span> <span class="keyword">else</span> println(x))</div></pre></td></tr></table></figure>
<p>这里我们暂时用<code>f</code>来代表某个filter函数。如果令<code>f = filter</code>的话，上面两段程序的运行结果分别是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// List</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Stream</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>可以看到<code>Stream</code>在对每个元素filter的时候，都会重新计算filter对应的<code>predicate</code>，所以上面的代码中<code>found</code>改变会对filter有影响；而<code>List</code>在filter元素的时候，对应的<code>predicate</code>是已经计算好的，不会再变更，因此<code>found</code>改变对filter没有影响。想必大家已经看出问题了，我们在使用for-comprehension的时候，总是希望if guard里的条件是按需求值的(on-demand)，而不是一开始就计算好的，因此把if guard转换成<code>filter</code>函数的话语义会有问题。所以，为了保持<code>filter</code>的语义不变，同时确保for-comprehension语义正确，Scala 2.8引入了<code>withFilter</code>函数作为<code>filter</code>的lazy实现，它的<code>predicate</code>是on-demand的。这样，for-comprehension中的guard就可以转换成<code>withFilter</code>函数，从而实现正确的语义。</p>
<p><code>withFilter</code>的实现也非常简单，既然需要on-demand evaluation，那么就把predicate函数保存下来，到需要的时候再调用。<code>withFilter</code>函数会生成一个<code>WithFilter</code>对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">withFilter</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">FilterMonadic</span>[<span class="type">A</span>, <span class="type">Repr</span>] = <span class="keyword">new</span> <span class="type">WithFilter</span>(p)</div><div class="line"></div><div class="line"><span class="comment">/** A class supporting filtered operations. Instances of this class are</span></div><div class="line"> *  returned by method `withFilter`.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithFilter</span>(<span class="params">p: <span class="type">A</span> =&gt; <span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">FilterMonadic</span>[<span class="type">A</span>, <span class="type">Repr</span>] </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>, <span class="type">That</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>)(<span class="keyword">implicit</span> bf: <span class="type">CanBuildFrom</span>[<span class="type">Repr</span>, <span class="type">B</span>, <span class="type">That</span>]): <span class="type">That</span> = &#123;</div><div class="line">    <span class="keyword">val</span> b = bf(repr)</div><div class="line">    <span class="keyword">for</span> (x &lt;- self)</div><div class="line">      <span class="keyword">if</span> (p(x)) b += f(x)</div><div class="line">    b.result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>, <span class="type">That</span>](f: <span class="type">A</span> =&gt; <span class="type">GenTraversableOnce</span>[<span class="type">B</span>])(<span class="keyword">implicit</span> bf: <span class="type">CanBuildFrom</span>[<span class="type">Repr</span>, <span class="type">B</span>, <span class="type">That</span>]): <span class="type">That</span> = &#123;</div><div class="line">    <span class="keyword">val</span> b = bf(repr)</div><div class="line">    <span class="keyword">for</span> (x &lt;- self)</div><div class="line">      <span class="keyword">if</span> (p(x)) b ++= f(x).seq</div><div class="line">    b.result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>](f: <span class="type">A</span> =&gt; <span class="type">U</span>): <span class="type">Unit</span> =</div><div class="line">    <span class="keyword">for</span> (x &lt;- self)</div><div class="line">      <span class="keyword">if</span> (p(x)) f(x)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withFilter</span></span>(q: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">WithFilter</span> =</div><div class="line">    <span class="keyword">new</span> <span class="type">WithFilter</span>(x =&gt; p(x) &amp;&amp; q(x))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>WithFilter</code>里只允许<code>map</code>, <code>flatMap</code>, <code>foreach</code>和<code>withFilter</code>这四种操作，其中<code>map</code>和<code>flatMap</code>会得到原来的集合类型。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>Scala Language Specification</em>, 6.19</li>
<li><a href="http://docs.scala-lang.org/tutorials/FAQ/yield" target="_blank" rel="external">How does yield work? - Scala Documentation</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-algorithm-quicksort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Algorithm/algorithm-quicksort/" class="article-date">
      <time datetime="2016-02-22T16:00:00.000Z" itemprop="datePublished">2016-02-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Algorithm/algorithm-quicksort/">快速排序实现及优化 | DualPivotQuicksort</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="快速排序的基本实现">快速排序的基本实现</h1><p>快速排序算法是一种基于交换的高效的排序算法，它采用了<strong>分治法</strong>的思想：</p>
<ol>
<li>从数列中取出一个数作为基准数（枢轴，pivot）。</li>
<li>将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。</li>
<li>再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。</li>
</ol>
<p>快排最重要的一步就是划分了。划分的过程用通俗的语言讲就是“挖坑”和“填坑”。</p>
<p>举个例子，首先给一组数组：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>36</td>
<td>9</td>
<td>-7</td>
<td>45</td>
<td>23</td>
<td>61</td>
<td>15</td>
</tr>
</tbody>
</table>
<p>为了方便起见，我们选择第一个元素36作为基准数，这样就腾出了第一个位置（挖坑），下面首先自右向左寻找比基准数小的元素填至第一个位置（填坑）：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>9</td>
<td>-7</td>
<td>45</td>
<td>23</td>
<td>61</td>
<td></td>
<td>36</td>
</tr>
</tbody>
</table>
<p>第七个位置被腾出，然后再自左向右寻找比基准元素大的元素填在空位处：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>9</td>
<td>-7</td>
<td></td>
<td>23</td>
<td>61</td>
<td>45</td>
<td>36</td>
</tr>
</tbody>
</table>
<p>再重复上面的动作，直到第一趟划分完毕。此时[a0,a3]都是小于基准值a4的，[a5,a6]都是大于基准值a4的：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>9</td>
<td>-7</td>
<td>23</td>
<td>36</td>
<td>61</td>
<td>45</td>
<td>36</td>
</tr>
</tbody>
</table>
<p>然后再对两个子序列递归地进行上述的过程，最终可得到有序序列。</p>
<p>总结一下这个划分的过程：</p>
<ol>
<li>设两个指示i=left，j=right；设arr[left]为基准数</li>
<li>从后向前寻找比基准元素大的元素，填至空位处</li>
<li>从前向后寻找比基准元素小的元素，填至空位处</li>
<li>重复执行2、3步，直到两指示相等，将基准元素填至指示的位置，本次划分结束</li>
</ol>
<p>用代码表示为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = left, j = right;</div><div class="line">    <span class="keyword">int</span> tmp = arr[left];</div><div class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; tmp)</div><div class="line">            j--;</div><div class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</div><div class="line">            arr[i] = arr[j];</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; tmp)</div><div class="line">            i++;</div><div class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</div><div class="line">            arr[j] = arr[i];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    arr[i] = tmp;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(left &gt; right)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> j = partition(arr, left, right);</div><div class="line">    quick_sort(arr, left, j - <span class="number">1</span>);</div><div class="line">    quick_sort(arr, j + <span class="number">1</span>, right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然用Haskell写是最简单的了:)</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">qs</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</div><div class="line"><span class="title">qs</span> [] = []</div><div class="line"><span class="title">qs</span> (x:xs) =</div><div class="line">    <span class="keyword">let</span> s = qs $ filter (&lt;= x) xs</div><div class="line">        l = qs $ filter (&gt; x)  xs</div><div class="line">    <span class="keyword">in</span> s ++ [x] ++ l</div></pre></td></tr></table></figure>
<p>另一种实现划分的思路是先从左到右扫描一个比基准数大的元素，再从右到左扫描一个比基准数小的元素（左右两个指针i、j滑动），然后交换这两个元素，重复操作直到两指针相遇，然后将基准元素arr[left]与左子序列最后的元素arr[j]进行交换即可，用代码描述为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = left, j = right + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> temp = arr[left];</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (arr[i] &lt; temp &amp;&amp; i &lt; right) &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (arr[j] &gt; temp &amp;&amp; j &lt; left) &#123;</div><div class="line">            j++</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &gt;= j)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        swap(arr[i], arr[j]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    swap(arr[left], arr[j]);</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>快速排序算法的平均时间复杂度为 $O(NlogN)$。快排的最差情况为序列完全有序，此时快排退化为冒泡排序，时间复杂度为 $O(n^2)$ 。</p>
<h1 id="快速排序的改进和优化">快速排序的改进和优化</h1><p>快速排序也有不足之处，比如<strong>对于元素较少或接近有序的数组来说，快速排序平均性能比插入排序差</strong>。这是因为小数组信息熵相对来说比较小（特别是经过一系列的快速排序调用以后），而插入排序在数据接近有序的情况下时间复杂度接近 $O(N)$，再加上快速排序递归调用也会有一些性能损耗。因此，针对小数组，我们可以加个判断，<strong>对小数组使用插入排序</strong>。Java标准库自带的排序<code>DualPivotQuicksort</code>就是这么干的，<code>INSERTION_SORT_THRESHOLD</code> = 47。</p>
<p>另外一个改进快速排序性能的方法就是使用<strong>双枢轴</strong>，即将数组三切分(大于枢轴，等于枢轴，小于枢轴），可以证明这样是熵最优的并且更高效。为什么这样划分呢？因为统计表明对大规模数组进行排序时，数据重复的情况比较多，因此使用双枢轴可以有效避免相等元素之间的比较。以Java标准库为例，JDK 1.8中的<code>DualPivotQuicksort</code>实现了一种 <strong>快速三向切分</strong> 的快速排序，它通过将相等元素聚集起来的方式使熵最优（原理：<strong>将相等元素聚集起来</strong>，不必再切分这些元素）。</p>
<p><img src="http://img.blog.csdn.net/20160220202246946" alt="快速三向切分"></p>
<p>还有一个优化的杀手锏就是 <strong>改进划分的策略</strong>，这里<code>DualPivotQuicksort</code>使用了一种称为 <strong>五取样划分</strong> 的策略对数组进行划分，类似于<a href="https://en.wikipedia.org/wiki/Median_of_medians" target="_blank" rel="external">BFPRT算法</a>。</p>
<p>总结一下，快排的改进主要有三种方法：小数组使用插入排序、双枢轴（快速三向切分）、划分策略优化（五取样划分）。经过优化后的快速排序算法时间复杂度可以介于 $O(N)$ 到 $O(NlogN)$ 之间，性能更优。具体实现可以看<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/e2117e30fb39/src/share/classes/java/util/DualPivotQuicksort.java" target="_blank" rel="external">DualPivotQuicksort的源码</a>，实现的很复杂，非常奇妙。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sort/">Sort</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-network-io-model" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Network/network-io-model/" class="article-date">
      <time datetime="2016-02-15T16:00:00.000Z" itemprop="datePublished">2016-02-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Network/network-io-model/">POSIX I/O模型之阻塞、非阻塞、同步、异步浅析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>服务端编程常需要接触I/O。最近对I/O模型有了进一步的认识，这里就总结一下POSIX I/O模型，并简略总结一下Java中的Network I/O模型。常见的POSIX I/O模型有四种：</p>
<ul>
<li>同步阻塞I/O（Synchrohous, blocking I/O）</li>
<li>同步非阻塞I/O（Synchrohous, non-blocking I/O）</li>
<li>I/O多路复用（I/O Multiplexing），较为典型的有<code>select</code>和<code>epoll</code>模型</li>
<li>异步I/O（Asynchronous I/O）</li>
</ul>
<h1 id="通俗解释">通俗解释</h1><p>在详细解释各个I/O模型之前，我们先来通俗地解释一下各个I/O模型，便于理解。</p>
<ul>
<li>同步阻塞I/O：去餐厅吃饭，等餐的时候需要在取餐处一直等着，不能干其他事情。</li>
<li>同步非阻塞I/O：去餐厅吃饭，等餐的时候可以干别的事，但需要不断去窗口询问饭是否准备好了（轮询）。</li>
<li>异步I/O：去餐厅吃饭，等餐的时候只需要坐着等人送来即可。</li>
</ul>
<p>下面我们来详细解释一下各个I/O模型，为了简单起见这里采用UDP协议作为示例。</p>
<h1 id="Blocking_I/O">Blocking I/O</h1><p>首先对于一个从socket读取数据的操作，通常将其分为两个阶段：</p>
<ol>
<li>等待远程数据就绪。网卡会将数据报文传给协议栈，封装处理之后拷贝到内核缓冲区中</li>
<li>将数据从内核缓冲区拷贝到进程中</li>
</ol>
<p>最简单的模型就是blocking I/O模型了。进行<code>recvfrom</code>系统调用（读取数据）以后，调用者进程会被阻塞，直到内核接收到数据并拷贝到进程中才返回。进行<code>recvfrom</code>系统调用后，内核首先会等待数据就绪，这通常需要一段时间。当数据就绪并到达内核缓冲区后，内核就会将数据拷贝至用户内存空间，并且返回结果，此时调用者进程才会解除阻塞状态，恢复执行。Blocking I/O不会浪费CPU时间片，但是只能处理一个连接，对于多个连接的情况就需要用到下面要提到的的I/O多路复用了。</p>
<p>可以看出，blocking I/O会阻塞上面两个阶段：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-blocking-io.png" alt="Synchrohous, blocking IO"></p>
<h1 id="Non-blocking_I/O">Non-blocking I/O</h1><p>与blocking I/O不同，non-blocking I/O的意思是在读取数据(<code>recvfrom</code>)时，如果数据没有就绪则立刻返回一个错误，而不会被阻塞住，这样我们还可以继续进行其它的操作。为了读取到数据，我们需要不断调用<code>recvfrom</code>进行轮询操作，一旦数据准备好了，内核就会将数据拷贝至用户内存空间，并且返回读取成功的结果。这种模型的弊端就是轮询操作会占用时间片，浪费CPU资源。可以看出，non-blocking I/O会阻塞上面的阶段(2)：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-non-blocking-io.png" alt="Non-blocking IO"></p>
<h1 id="I/O_multiplexing">I/O multiplexing</h1><p>I/O多路复用(multiplexing)是网络编程中最常用的模型，像我们最常用的<code>select</code>、<code>epoll</code>都属于这种模型。以<code>select</code>为例：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-io-multiplexing.png" alt="IO Multiplexing"></p>
<p>看起来它与blocking I/O很相似，两个阶段都阻塞。但它与blocking I/O的一个重要区别就是它可以等待多个文件描述符就绪，即可以处理多个连接。这里的<code>select</code>相当于一个“代理”，调用<code>select</code>以后进程会被<code>select</code>阻塞，这时候在内核空间内<code>select</code>会监听指定的的多个文件描述符(如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于<code>select</code>可以监听多个socket，我们可以用它来处理多个连接。</p>
<p>在<code>select</code>模型中每个socket一般都设置成non-blocking，虽然阶段(1)仍然是阻塞状态，但是它是被<code>select</code>调用阻塞的，而不是直接被I/O阻塞的。<code>select</code>底层通过轮询机制来判断每个socket读写是否就绪。</p>
<p>当然<code>select</code>也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了<code>epoll</code>作为<code>select</code>的改进版本，具体的区别和改进后面会另开一篇总结。</p>
<h1 id="Asynchronous_I/O">Asynchronous I/O</h1><p>Asynchronous I/O的过程：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-asynchronous-io.png" alt="Asynchronous IO"></p>
<p>这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(<code>aio_read</code>)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p>
<p>异步I/O在网络编程中几乎用不到，在File I/O中可能会用到。</p>
<h1 id="Java中的Network_I/O模型">Java中的Network I/O模型</h1><p>Java原生的Network I/O模型分为以下几种：</p>
<ul>
<li>BIO(如<code>ServerSocket</code>)</li>
<li>NIO(JDK 1.4引入，如<code>ServerSocketChannel</code>)</li>
<li>NIO.2(AIO, JDK 1.7引入，如<code>AsynchronousServerSocketChannel</code>)</li>
</ul>
<p>其中BIO对应传统的同步阻塞I/O，而NIO对应I/O多路复用(<code>select</code>模型，Reactor模式)，NIO.2则对应异步IO模型（依然是基于I/O多路复用，和POSIX的asynchronous I/O模型不同）。在Linux下，NIO和NIO.2底层都是通过<code>epoll</code>实现的。</p>
<p>Netty的I/O模型也类似，分为OIO和NIO两种。</p>
<h1 id="总结">总结</h1><p>我们来总结一下阻塞、非阻塞，同步和异步这两组概念。</p>
<p>先来说阻塞和非阻塞。阻塞调用会一直等待远程数据就绪再返回，即上面的阶段(1)会阻塞调用者，直到读取结束。而非阻塞无论在什么情况下都会立即返回。</p>
<p>接下来是同步和异步。POSIX标准里是这样定义同步和异步的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked.</li>
</ul>
<p>同步方法会一直阻塞进程，直到I/O操作结束，注意这里相当于上面的(1)(2)两个阶段都会阻塞调用者。而异步方法不会阻塞调用者进程，即使是从内核空间的缓冲区将数据拷贝到进程中这一操作也不会阻塞进程，拷贝完毕后内核会通知进程数据拷贝结束。</p>
<p>下面的这张图很好地总结了之前讲的这几种POSIX I/O模型（来自<em>Unix Network Programming</em>）：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-io-model-comparison.png" alt="IO模型比较"></p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>UNIX Network Programming (3rd edition), Volume 1</em></li>
<li><a href="https://segmentfault.com/a/1190000003063859?_ea=292572" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/">IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-tcp-series" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Network/tcp-series/" class="article-date">
      <time datetime="2016-02-04T16:00:00.000Z" itemprop="datePublished">2016-02-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Network/tcp-series/">TCP 相关知识总结目录</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>寒假翻了翻 TCP/IP Illustrated, Volume 1 的第二版，将里面的一些新知识与上个暑假总结的第一版的相关知识结合起来，针对TCP部分重新做了个总结~目前已经大体总结完毕，这里列个目录方便查阅：</p>
<ul>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-connection/">TCP连接的建立和终止</a></li>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-retransmission/">TCP 超时与重传机制</a></li>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-flow-control/">TCP 流量控制 &amp;&amp; 滑动窗口机制</a></li>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-congestion-control/">TCP 拥塞控制</a></li>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-keepalive-heartbeat/">TCP Keepalive机制 &amp;&amp; 心跳检测</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2018 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30 <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 7;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>