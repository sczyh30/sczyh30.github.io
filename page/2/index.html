<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>「千载弦歌，芳华如梦」 - sczyh30&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--<meta name="keywords" content="sczyh30, blog"/>-->
  <meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/page/2/index.html">
<meta property="og:site_name" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">
  
    <link rel="alternative" href="/atom.xml" title="「千载弦歌，芳华如梦」 - sczyh30&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/AIO/" style="font-size: 10px;">AIO</a> <a href="/tags/AMQP/" style="font-size: 10px;">AMQP</a> <a href="/tags/APT/" style="font-size: 10px;">APT</a> <a href="/tags/Akka-Actor/" style="font-size: 10px;">Akka Actor</a> <a href="/tags/Algorithm/" style="font-size: 12.73px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 14.55px;">Android</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 16.36px;">C++</a> <a href="/tags/C-11/" style="font-size: 10px;">C++ 11</a> <a href="/tags/CE3/" style="font-size: 10px;">CE3</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Category-Theory/" style="font-size: 10px;">Category Theory</a> <a href="/tags/Chemistry/" style="font-size: 10.91px;">Chemistry</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Docker/" style="font-size: 10.91px;">Docker</a> <a href="/tags/Engine/" style="font-size: 10px;">Engine</a> <a href="/tags/Euterpea/" style="font-size: 10px;">Euterpea</a> <a href="/tags/FRP/" style="font-size: 10px;">FRP</a> <a href="/tags/Functional-Programming/" style="font-size: 18.18px;">Functional Programming</a> <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/GC/" style="font-size: 12.73px;">GC</a> <a href="/tags/GDB/" style="font-size: 10px;">GDB</a> <a href="/tags/Game/" style="font-size: 10.91px;">Game</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/HashMap/" style="font-size: 10.91px;">HashMap</a> <a href="/tags/Haskell/" style="font-size: 13.64px;">Haskell</a> <a href="/tags/HotSpot/" style="font-size: 11.82px;">HotSpot</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 19.09px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Klass-oop/" style="font-size: 10px;">Klass-oop</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Linux/" style="font-size: 11.82px;">Linux</a> <a href="/tags/MIDI/" style="font-size: 10px;">MIDI</a> <a href="/tags/Mathematical-Logic/" style="font-size: 10px;">Mathematical Logic</a> <a href="/tags/Metaspace/" style="font-size: 10px;">Metaspace</a> <a href="/tags/Netflix-Hystrix/" style="font-size: 10px;">Netflix Hystrix</a> <a href="/tags/Network/" style="font-size: 16.36px;">Network</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Object-Model/" style="font-size: 11.82px;">Object Model</a> <a href="/tags/Play-Framework/" style="font-size: 10.91px;">Play Framework</a> <a href="/tags/Quorum/" style="font-size: 10px;">Quorum</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Reflection/" style="font-size: 10.91px;">Reflection</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/STL/" style="font-size: 10.91px;">STL</a> <a href="/tags/Scala/" style="font-size: 19.09px;">Scala</a> <a href="/tags/Slick/" style="font-size: 10.91px;">Slick</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Struct/" style="font-size: 10px;">Struct</a> <a href="/tags/Summary/" style="font-size: 11.82px;">Summary</a> <a href="/tags/TCP/" style="font-size: 14.55px;">TCP</a> <a href="/tags/Type-Lambda/" style="font-size: 10px;">Type Lambda</a> <a href="/tags/Type-System/" style="font-size: 10px;">Type System</a> <a href="/tags/Type-Theory/" style="font-size: 11.82px;">Type Theory</a> <a href="/tags/UE4/" style="font-size: 10px;">UE4</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/Vert-x/" style="font-size: 15.45px;">Vert.x</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Web/" style="font-size: 11.82px;">Web</a> <a href="/tags/Web开发/" style="font-size: 11.82px;">Web开发</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/functional/" style="font-size: 10px;">functional</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/事务/" style="font-size: 10px;">事务</a> <a href="/tags/云服务/" style="font-size: 11.82px;">云服务</a> <a href="/tags/内存区域/" style="font-size: 10px;">内存区域</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/分布式系统/" style="font-size: 11.82px;">分布式系统</a> <a href="/tags/前端/" style="font-size: 11.82px;">前端</a> <a href="/tags/基础/" style="font-size: 10px;">基础</a> <a href="/tags/多线程/" style="font-size: 10.91px;">多线程</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/并发/" style="font-size: 12.73px;">并发</a> <a href="/tags/开发/" style="font-size: 17.27px;">开发</a> <a href="/tags/异步/" style="font-size: 12.73px;">异步</a> <a href="/tags/异步编程/" style="font-size: 14.55px;">异步编程</a> <a href="/tags/微服务/" style="font-size: 12.73px;">微服务</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 10.91px;">数据库</a> <a href="/tags/架构/" style="font-size: 10.91px;">架构</a> <a href="/tags/消息系统/" style="font-size: 10px;">消息系统</a> <a href="/tags/源码分析/" style="font-size: 10px;">源码分析</a> <a href="/tags/生活/" style="font-size: 10px;">生活</a> <a href="/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Fighting</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-gradle-annotation-processing-vertx-codegen" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Develop/gradle-annotation-processing-vertx-codegen/" class="article-date">
      <time datetime="2016-05-17T16:00:00.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Develop/gradle-annotation-processing-vertx-codegen/">在Gradle中使用Annotation Processing Tool | Vert.x Codegen 示例</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在Maven中，我们可以很方便地利用 <em>Annotation Processing Tool(APT)</em> 来生成代码，配置简洁明了。比如在Maven中配置<a href="https://github.com/vert-x3/vertx-codegen" target="_blank" rel="external">Vert.x Codegen</a>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Configure the execution of the compiler to execute the codegen processor --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="title">encoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">id</span>&gt;</span>default-compile<span class="tag">&lt;/<span class="title">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">annotationProcessors</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">annotationProcessor</span>&gt;</span>io.vertx.codegen.CodeGenProcessor<span class="tag">&lt;/<span class="title">annotationProcessor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">annotationProcessors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">compilerArgs</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">arg</span>&gt;</span>-AoutputDirectory=$&#123;project.basedir&#125;/src/main<span class="tag">&lt;/<span class="title">arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">compilerArgs</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">pluginManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而Gradle就不是那么方便了，官方文档里没有讲，各种插件又不太好使，因此自己摸索了摸索。其实，我们只要搞明白<code>APT</code>的处理过程，一切问题就迎刃而解了。在编译阶段，我们可以通过<code>-processor</code>来配置对应的注解处理器，并将注解处理器的包文件加到<code>CLASSPATH</code>中。因此，我们可以在Gradle中写一个task来处理注解：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</span><br><span class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</span><br><span class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span></span><br><span class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</span><br><span class="line">  <span class="keyword">options</span>.compilerArgs = [</span><br><span class="line">    <span class="string">"-proc:only"</span>,</span><br><span class="line">    <span class="string">"-processor"</span>, <span class="string">"xxx.yyy.zzzProcessor"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>source</code>代表源代码目录，<code>classpath</code>设为所有的依赖，<code>destinationDir</code>代表输出路径，<code>options.compilerArgs</code>代表<code>javac</code>的配置项。</p>
<p>下面我们来看一个例子：如何在Gradle中使用Vert.x Codegen。首先先写处理注解的task：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</span><br><span class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</span><br><span class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span></span><br><span class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</span><br><span class="line">  <span class="keyword">options</span>.compilerArgs = [</span><br><span class="line">    <span class="string">"-proc:only"</span>,</span><br><span class="line">    <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</span><br><span class="line">    <span class="string">"-AoutputDirectory=$&#123;destinationDir.absolutePath&#125;"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意Vert.x Codegen要设定<code>outputDirectory</code>项（输出路径）方可生成代码。</p>
<p>下面我们在 <code>compileJava</code> 中引用 <code>annotationProcessing</code> ：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compileJava &#123;</span><br><span class="line">  <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></span><br><span class="line">  <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">  dependsOn annotationProcessing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在进行构建的时候，Gradle就可以利用APT来处理注解，生成代码了。如果要引用这些生成的代码，还要把它们加到源码路径中：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sourceSets</span> &#123;</span><br><span class="line">  main &#123;</span><br><span class="line">    java &#123;</span><br><span class="line">      srcDirs += <span class="string">'src/main/generated'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APT/">APT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-circuit-breaker-pattern" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Microservice/circuit-breaker-pattern/" class="article-date">
      <time datetime="2016-05-05T16:00:00.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Microservice/circuit-breaker-pattern/">微服务设计模式 | Circuit Breaker Pattern</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在分布式环境中，我们的应用可能会面临着各种各样的可恢复的异常（比如超时，网络环境异常），此时我们可以利用不断重试的方式来从异常中恢复(Retry Pattern)，使整个集群正常运行。</p>
<p>然而，也有一些异常比较顽固，突然发生，无法预测，而且很难恢复，并且还会导致级联失败（举个例子，假设一个服务集群的负载非常高，如果这时候集群的一部分挂掉了，还占了很大一部分资源，整个集群都有可能遭殃）。如果我们这时还是不断进行重试的话，结果大多都是失败的。因此，此时我们的应用需要立即进入失败状态(fast-fail)，并采取合适的方法进行恢复。</p>
<p><strong>Circuit Breaker Pattern</strong>（熔断器模式）就是这样的一种设计思想。它可以防止一个应用不断地去尝试一个很可能失败的操作。一个Circuit Breaker相当于一个代理，用于监测某个操作对应的失败比率(<code>fail / fail + success</code>)。它会根据得到的数据来决定是否允许执行此操作，或者是立即抛出异常。</p>
<h1 id="Circuit_Breaker原理">Circuit Breaker原理</h1><p>我们可以用状态机来实现Circuit Breaker，它有以下三种状态：</p>
<ul>
<li>关闭(<strong>Closed</strong>)：默认情况下Circuit Breaker是关闭的，此时允许操作执行。Circuit Breaker内部记录着最近失败的次数，如果对应的操作执行失败，次数就会续一次。如果在某个时间段内，失败次数（或者失败比率）达到阈值，Circuit Breaker会转换到开启(<strong>Open</strong>)状态。在开启状态中，Circuit Breaker会启用一个超时计时器，设这个计时器的目的是给集群相应的时间来恢复故障。当计时器时间到的时候，Circuit Breaker会转换到半开启(<strong>Half-Open</strong>)状态。</li>
<li>开启(<strong>Open</strong>)：在此状态下，执行对应的操作将会立即失败并且立即抛出异常。</li>
<li>半开启(<strong>Half-Open</strong>)：在此状态下，Circuit Breaker会允许执行一定数量的操作。如果所有操作全部成功，Circuit Breaker就会假定故障已经恢复，它就会转换到关闭状态，并且重置失败次数。如果其中 <strong>任意一次</strong> 操作失败了，Circuit Breaker就会认为故障仍然存在，所以它会转换到开启状态并再次开启计时器（再给系统一些时间使其从失败中恢复）。</li>
</ul>
<p>Circuit Breaker的状态图：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/circuit-breaker-states.png" alt="Circuit Breaker Pattern States"></p>
<h1 id="简单实现">简单实现</h1><p><em>TODO</em></p>
<hr>
<h1 id="Reference">Reference</h1><ul>
<li><em>Cloud Design Patterns</em>, Microsoft</li>
<li><a href="http://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="external">CircuitBreaker | Martin Fowler</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Microservice/">Microservice</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/云服务/">云服务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-type-system-existential-types-scala-java" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Functional-Programming/type-system-existential-types-scala-java/" class="article-date">
      <time datetime="2016-04-25T16:00:00.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Functional-Programming/type-system-existential-types-scala-java/">类型系统 | Existential Type | Scala ++ Java ++ Haskell</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>Existential type</strong>(存在类型)提供了一种在类型系统上抽象的方式，其中<strong>existential type</strong>这个名称源于<strong>existential quantification</strong>(全称量词，数学符号<code>∃</code>)。可以这样理解：某种形式的类型存在，但是在上下文中不知道它的具体类型。比如我们定义一种类型<code>type T = ∃x {a: x; f: (x =&gt; Int);}</code>，它可以表示这种类型有一个类型为<code>x</code>的成员变量a，一个类型为<code>x =&gt; Int</code>的成员函数f，而类型<code>x</code>是任意的。</p>
<p>这篇文章我们来探讨一下existential type在Java、Scala和Haskell中的运用。</p>
<h1 id="Existential_type_in_Java">Existential type in Java</h1><p>Existential Type在Java如此烂的类型系统中发挥着重要的作用。Java泛型中的<strong>Wildcards</strong>(占位符)其实就是一种existential type，比如<code>java.util.List&lt;?&gt;</code>。</p>
<p>由于JVM在编译时会对type parameters进行类型擦除，让它们回归为raw types，因此很多人认为existential type就相当于raw types，比如<code>List =:= List&lt;?&gt;</code>，这是不正确的。它们两种类型最大的区别就是existential type是type safe的，而raw types则不是。在将一个具化的泛型扒掉所有的type parameters的时候，后者是不安全的。我们测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Existential</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"Java"</span>, <span class="string">"sucks"</span>));</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List a = list;</span><br><span class="line">		a.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;?&gt; b = list;</span><br><span class="line">		b.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		t1();</span><br><span class="line">		t2();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译一下，编译器会提示t1方法不安全，而t2则无警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">λ javac ./Existential.java -Xlint:unchecked</span><br><span class="line">./Existential.java:<span class="number">11</span>: 警告: [unchecked] 对作为原始类型Iterable的成员的forEach(Consumer&lt;? <span class="keyword">super</span> T&gt;)的调用未经过检查</span><br><span class="line">                a.forEach(System.out::println);</span><br><span class="line">                         ^</span><br><span class="line">  其中, T是类型变量:</span><br><span class="line">    T扩展已在接口 Iterable中声明的Object</span><br><span class="line"><span class="number">1</span> 个警告</span><br></pre></td></tr></table></figure>
<p>因此我们要避免使用原始类型。(貌似越写越偏了。。那就顺便总结一下Java的Bounded Wildcards吧:)</p>
<p>Java通过 <strong>Bounded Wildcards</strong>（限定通配符）来实现有限的可变性(variance)，比如</p>
<ul>
<li><code>List&lt;? extends Object&gt;</code>（协变, covariance）</li>
<li><code>List&lt;? super User&gt;</code>（逆变, contravariance）</li>
<li><code>List&lt;?&gt;</code>（不可变, invariance）</li>
</ul>
<p>注意我们无法给限定通配符的List添加任何对象，因为它的类型参数无法确定（这即是existential的含义）。我们可以在方法参数中使用Bounded Wildcards来达到协变和逆变的效果，使用时遵循 <strong>PECS原则</strong> (Producer Extends, Consumer Super)。</p>
<p>注：这里的variance其实是一种<strong>use-site variance</strong>，后边有时间探究一下它与<strong>declaration-site variance</strong>的区别。</p>
<h1 id="Existential_type_in_Scala">Existential type in Scala</h1><p>Scala同样兼容Java的这种use-site variance，语法有两种。一种和Java类似，一种是完整表示方法（<code>forSome</code>关键字）。举个例子：</p>
<table>
<thead>
<tr>
<th>简单表示</th>
<th>完整表示</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Seq[_]</code></td>
<td><code>Seq[T] forSome {type T}</code></td>
<td>T可以是Any类型的任意子类</td>
</tr>
<tr>
<td><code>Seq[_ &lt;: A]</code></td>
<td><code>Seq[T] forSome {type T &lt;: A}</code></td>
<td>T可以是A类型的任意子类</td>
</tr>
<tr>
<td><code>Seq[_ &gt;: Z &lt;: A]</code></td>
<td><code>Seq[T] forSome {type T &gt;: Z &lt;: A}</code></td>
<td>T可以是A类型的任意子类，同时需要是Z类型的父类</td>
</tr>
</tbody>
</table>
<h1 id="Existential_type_in_Haskell">Existential type in Haskell</h1><p>在GHC中使用Existential Types需要开启扩展(<code>-XExistentialQuantification</code>)。Haskell中的Existential Type通过<code>forall</code>关键字来实现。但是，<code>forall</code>代表全称量词<code>∀</code>，这似乎和existential type的含义是对立的，是不是很神奇呢？我们将在稍后解释。这里我们先来看一下我们最熟悉的<code>map</code>函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br></pre></td></tr></table></figure>
<p>我们还可以通过全称量化的方法构造map：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: <span class="keyword">forall</span> a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span><br></pre></td></tr></table></figure></p>
<p>这两个map的定义是等价的。其实在Haskell中，很多类型的定义都是隐式地使用了<code>forall</code>。</p>
<p>再比如下边的例子定义了可以show的existential type：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="pragma">&#123;-# LANGUAGE ExistentialQuantification #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">ShowObj</span> = forall a. <span class="type">Show</span> a =&gt; <span class="type">S</span> a</span></span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">ShowObj</span> <span class="keyword">where</span></span></span><br><span class="line">	show (<span class="type">S</span> a) = show a</span><br><span class="line"></span><br><span class="line"><span class="title">li</span> :: [<span class="type">ShowObj</span>]</span><br><span class="line"><span class="title">li</span>  = [<span class="type">S</span> <span class="number">1</span>, <span class="type">S</span> <span class="string">"Java"</span>, <span class="type">S</span> <span class="string">"sucks"</span>, <span class="type">S</span> <span class="type">True</span>, <span class="type">S</span> ()]</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: [<span class="type">ShowObj</span>] -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">f</span> xs = mapM_ print xs</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = f li</span><br></pre></td></tr></table></figure>
<p>下面我们来探究一下<code>existential</code>和<code>forall</code>的真正含义。我们可以将类型看作是某些值的集合，比如<code>Bool</code>类型对应集合<code>{True, False, ⊥}</code>，<code>Integer</code>对应数的集合。注意bottom(<code>⊥</code>)属于每一个类型。</p>
<p><code>forall</code>代表这些集合的交集。我们举一些例子：</p>
<ul>
<li><code>forall a. a</code>是所有类型的交集，也就是<code>{⊥}</code></li>
<li><code>[forall a. Show a =&gt; a]</code>代表一种所含元素均为<code>forall a. Show a =&gt; a</code>类型的列表类型，<code>Show</code> Typeclass限定了只能在<code>Show</code>的instance里取交集</li>
</ul>
<p>我们随便定义一个existential datatype(下面我们用<code>∀</code>代替forall，用<code>∃</code>代替exists)：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">T</span> = ∀ a. <span class="type">MkT</span> a</span></span><br></pre></td></tr></table></figure></p>
<p>其中MkT的含义是产生一个T类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MkT</span> :: <span class="keyword">forall</span> a. a -&gt; <span class="type">T</span></span><br><span class="line"><span class="type">MkT</span> :: a -&gt; <span class="type">T</span> <span class="comment">&#123;- 等价 -&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>那么当我们对MkT进行解构的时候又会发生什么呢？比如进行模式匹配的时候：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> (<span class="type">MkT</span> x) = ...</span><br></pre></td></tr></table></figure></p>
<p>此时<code>x</code>的类型可以是任意的，也就是说我们可以用存在量词来表示x：<code>x :: ∃ a. a</code>。我们知道存在这种类型x，但不清楚x的真正类型。这样的定义<strong>同构</strong>于上边我们用全称量词的定义，即这两种定义等价：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">T</span> = ∀ a. <span class="type">MkT</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">T</span> = <span class="type">MkT</span> <span class="container">(∃ <span class="title">a</span>. <span class="title">a</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>而Haskell选择了前者的表达方式(<code>forall</code>)，即在Haskell中existential type通过<code>forall</code>关键字来实现。（为何不用<code>exists</code>？我也不清楚。。）</p>
<p>所以现在再回头来看我们之前定义的<code>ShowObj</code>类型，我们可以把它转化为用存在量词表达的existential type:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">ShowObj</span> = forall a. <span class="type">Show</span> a =&gt; <span class="type">S</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">ShowObj'</span> = <span class="type">S'</span> <span class="container">(<span class="title">exists</span> <span class="title">a</span>. <span class="type">Show</span> <span class="title">a</span> =&gt; <span class="title">a</span>)</span> <span class="container">&#123;- <span class="type">Haskell</span>里不能这么写 -&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>在Haskell各种类库中existential type用的非常多，例如<code>Control.Monad.ST</code>中的<code>runST</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">runST</span> :: <span class="keyword">forall</span> α. (<span class="keyword">forall</span> s. <span class="type">ST</span> s α) -&gt; α</span><br></pre></td></tr></table></figure></p>
<p>这里先不展开写了，后边有时间多实践实践再说。。。</p>
<h1 id="Heterogeneous_List">Heterogeneous List</h1><p><strong>待填坑</strong>。。Miles Sabin大神的Shapeless库中的 <strong>Heterogeneous List(HList)</strong> 值得一读。。</p>
<h1 id="Reference">Reference</h1><ul>
<li><em>Scala Language Specification</em>, 3.2.10</li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types" target="_blank" rel="external">Haskell/Existentially quantified types</a></li>
<li><a href="http://typelevel.org/blog/2015/02/26/rawtypes.html" target="_blank" rel="external">Existential types are not raw types</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Functional-Programming/">Functional Programming</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Type-System/">Type System</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-vertx-instance-internal-and-create" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-instance-internal-and-create/" class="article-date">
      <time datetime="2016-04-20T16:00:00.000Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Asynchronous/vertx-instance-internal-and-create/">Vert.x 异步编程 | Vertx实例的创建流程及内部实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在Vert.x中，<code>Vertx</code>接口是最为重要的一个接口，vertx-core的基础功能都在此接口中提供。这篇文章中我们就来分析一下<code>Vertx</code>接口体系的内部实现以及创建流程。本文对应Vert.x的版本为 <strong>3.2.1</strong>。</p>
<h1 id="Vertx接口体系">Vertx接口体系</h1><p>我们来看一下<code>Vertx</code>接口的UML关系：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertximpl-class-hc.png" alt=""></p>
<p>可以看到有<code>VertxImpl &lt;:&lt; VertxInternal &lt;:&lt; Vertx</code>这个继承链。这里我们先不研究<code>Measured</code>和<code>MetricsProvider</code>这两个接口。我们先来看一下<code>VertxInternal</code>的结构：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertxInternal-structure.png" alt=""></p>
<p>可以看到里边包含了各种操作多线程、执行回调等等的方法。<code>VertxInternal</code>接口仅供vertx-core内部调用。</p>
<p><code>VertxImpl</code>类是对<code>VertxInternal</code>和<code>Vertx</code>接口的实现。我们创建的Vertx实例都是<code>VertxImpl</code>。</p>
<h1 id="Vertx创建流程以及内部实现">Vertx创建流程以及内部实现</h1><p>通常，我们都会通过<code>Vertx</code>接口中的静态方法<code>vertx</code>创建Vertx实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vertx vertx = Vertx.vertx();</span><br></pre></td></tr></table></figure></p>
<p><code>vertx</code>方法底层通过工厂模式创建VertxImpl实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Vertx <span class="title">vertx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> factory.vertx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VertxFactoryImpl</span> <span class="keyword">implements</span> <span class="title">VertxFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Vertx <span class="title">vertx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VertxImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来探究一下<code>VertxImpl</code>类的创建流程和内部实现。我们首先来看一下<code>VertxImpl</code>类的实例成员：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileSystem fileSystem = getFileSystem();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SharedData sharedData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> VertxMetrics metrics;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Long, InternalTimerHandler&gt; timeouts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong timeoutCounter = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClusterManager clusterManager;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DeploymentManager deploymentManager;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileResolver fileResolver;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ServerID, HttpServerImpl&gt; sharedHttpServers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ServerID, NetServerImpl&gt; sharedNetServers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService workerPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService internalBlockingPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OrderedExecutorFactory workerOrderedFact;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OrderedExecutorFactory internalOrderedFact;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory eventLoopThreadFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NioEventLoopGroup eventLoopGroup;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NioEventLoopGroup acceptorEventLoopGroup;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockedThreadChecker checker;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> haEnabled;</span><br><span class="line"><span class="keyword">private</span> EventBus eventBus;</span><br><span class="line"><span class="keyword">private</span> HAManager haManager;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br></pre></td></tr></table></figure></p>
<p>这里面包含了一系列重要的类。我们将在初始化部分来分析这些成员的作用。下面我们来看一下构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VertxImpl() &#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> VertxOptions());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VertxImpl(VertxOptions options) &#123;</span><br><span class="line">  <span class="keyword">this</span>(options, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VertxImpl(VertxOptions options, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终都会调用到<code>VertxImpl(VertxOptions options, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler)</code>这个构造函数，下面我们就来分析一下。</p>
<p>首先，Vertx会检查当前是否有Vertx实例运行（通过<code>factory.context()</code>方法）。如果有实例运行的话就会给出警告。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sanity check</span></span><br><span class="line"><span class="keyword">if</span> (Vertx.currentContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">  log.warn(<span class="string">"You're already on a Vert.x context, are you sure you want to create a new Vertx instance?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着Vertx会初始化<code>checker</code>成员，它是一个<code>BlockedThreadChecker</code>，作用是检查vertx context中是否有阻塞的线程，如果有线程阻塞则给出警告。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checker = <span class="keyword">new</span> BlockedThreadChecker(options.getBlockedThreadCheckInterval(), options.getMaxEventLoopExecuteTime(),</span><br><span class="line">                                   options.getMaxWorkerExecuteTime(), options.getWarningExceptionTime());</span><br></pre></td></tr></table></figure></p>
<p>接下来，Vertx会初始化EventLoop线程工厂<code>eventLoopThreadFactory</code>，它用于产生EventLoop线程。然后初始化<code>eventLoopGroup</code>并进行配置。<code>NioEventLoopGroup</code>是Netty里的概念，将在稍后进行介绍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eventLoopThreadFactory = <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-eventloop-thread-"</span>, checker, <span class="keyword">false</span>);</span><br><span class="line">eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(options.getEventLoopPoolSize(), eventLoopThreadFactory);</span><br><span class="line">eventLoopGroup.setIoRatio(NETTY_IO_RATIO);</span><br></pre></td></tr></table></figure></p>
<p>接下来，Vertx会初始化Acceptor EventLoop线程工厂，并对其进行配置。然后对<code>workerPool</code>和<code>internalBlockingPool</code>这两个线程池进行初始化。其中<code>workerPool</code>用于执行worker线程，<code>internalBlockingPool</code>用于执行阻塞操作线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory acceptorEventLoopThreadFactory = <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-acceptor-thread-"</span>, checker, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// The acceptor event loop thread needs to be from a different pool otherwise can get lags in accepted connections</span></span><br><span class="line"><span class="comment">// under a lot of load</span></span><br><span class="line">acceptorEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, acceptorEventLoopThreadFactory);</span><br><span class="line">acceptorEventLoopGroup.setIoRatio(<span class="number">100</span>);</span><br><span class="line">workerPool = Executors.newFixedThreadPool(options.getWorkerPoolSize(),</span><br><span class="line">                                          <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-worker-thread-"</span>, checker, <span class="keyword">true</span>));</span><br><span class="line">internalBlockingPool = Executors.newFixedThreadPool(options.getInternalBlockingPoolSize(),</span><br><span class="line">                                                    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-internal-blocking-"</span>, checker, <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure></p>
<p>然后，Vertx会初始化两个线程池工厂<code>workerOrderedFact</code>和<code>internalOrderedFact</code>，它们的类型是<code>OrderedExecutorFactory</code>，里边包含一种能够按照次序执行线程的线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workerOrderedFact = <span class="keyword">new</span> OrderedExecutorFactory(workerPool);</span><br><span class="line">internalOrderedFact = <span class="keyword">new</span> OrderedExecutorFactory(internalBlockingPool);</span><br></pre></td></tr></table></figure></p>
<p>接下来，Vertx会依次对文件解析器<code>fileResolver</code>、部署管理器<code>deploymentManager</code>、SPI管理器<code>metrics</code>进行初始化，并且根据配置来决定是否初始化集群管理器<code>clusterManager</code>和高可用管理器<code>haManager</code>。然后Vertx会调用<code>createAndStartEventBus(options, resultHandler)</code>方法，创建并启动EventBus。最后对共享数据成员<code>sharedData</code>进行初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.fileResolver = <span class="keyword">new</span> FileResolver(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.deploymentManager = <span class="keyword">new</span> DeploymentManager(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.metrics = initialiseMetrics(options);</span><br><span class="line"><span class="keyword">this</span>.haEnabled = options.isClustered() &amp;&amp; options.isHAEnabled();</span><br><span class="line"><span class="keyword">if</span> (options.isClustered()) &#123;</span><br><span class="line">  <span class="keyword">this</span>.clusterManager = getClusterManager(options);</span><br><span class="line">  <span class="keyword">this</span>.clusterManager.setVertx(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.clusterManager.join(ar -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ar.failed()) &#123;</span><br><span class="line">      log.error(<span class="string">"Failed to join cluster"</span>, ar.cause());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Provide a memory barrier as we are setting from a different thread</span></span><br><span class="line">      <span class="keyword">synchronized</span> (VertxImpl.<span class="keyword">this</span>) &#123;</span><br><span class="line">        haManager = <span class="keyword">new</span> HAManager(<span class="keyword">this</span>, deploymentManager, clusterManager, options.getQuorumSize(),</span><br><span class="line">                                  options.getHAGroup(), haEnabled);</span><br><span class="line">        createAndStartEventBus(options, resultHandler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.clusterManager = <span class="keyword">null</span>;</span><br><span class="line">  createAndStartEventBus(options, resultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.sharedData = <span class="keyword">new</span> SharedDataImpl(<span class="keyword">this</span>, clusterManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过一系列的构造后，<code>VertxImpl</code>创建完成。</p>
<p>未完待续！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-play-framework-2-5-summary-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/play-framework-2-5-summary-1/" class="article-date">
      <time datetime="2016-04-16T16:00:00.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/play-framework-2-5-summary-1/">Play Framework 2.5 | Web开发总结(1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Samsara Aquarius已完成，是时候总结一下Play Framework的一些有用的东西和一些坑了～这里对应的Play版本为 <strong>2.5.2</strong>。</p>
<h1 id="Action,_Controller_和_Result">Action, Controller 和 Result</h1><p>在Play的Web开发中，<strong>Action</strong>, <strong>Controller</strong> 和 <strong>Result</strong> 这三个东西最为重要了。我们一个一个来解释：</p>
<h2 id="Result">Result</h2><p><code>Result</code>代表HTTP请求的结果，它包含header和body两部分。Play内部封装了常见的HTTP response状态，可以在这些Status的基础上生成Result，比如<code>200 OK</code>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Generates a ‘200 OK’ result. */</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">Ok</span> =</span> <span class="keyword">new</span> <span class="type">Status</span>(<span class="type">OK</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Action">Action</h2><p>每个Action相当于一个<code>Request =&gt; Result</code>类型（处理请求并返回结果）的函数，即每个Action都接受一个<code>Request</code>对象（代表HTTP请求），并产生<code>Result</code>对象（代表HTTP回应）。</p>
<p>关于Action的详细实现，后边我还会专门写一篇文章分析，这里先粗略总结一下。</p>
<h2 id="Controller">Controller</h2><p>在Play中，Controller里的函数用于生成Action。其实Action就相当于处理请求的函数，只不过将普通的函数包装了一层而已（继承关系：<code>Action &lt;:&lt; EssentialAction &lt;:&lt; (RequestHeader =&gt; Accumulator[ByteString, Result])</code>），因此调用这些函数其实就是在调用Action中包装的函数。</p>
<h1 id="Session、Cookie与Flash">Session、Cookie与Flash</h1><p>Play中处理Session、Cookie的语法都比较简洁。比如Cookie的添加与删除：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">res1</span> =</span> <span class="type">Ok</span>(<span class="string">"Good Scala"</span>) withCookies <span class="type">Cookie</span>(<span class="string">"fuck"</span>, <span class="string">"shit"</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">res2</span> =</span> res1.discardingCookies(<span class="type">DiscardingCookie</span>(<span class="string">"fuck"</span>))</span><br></pre></td></tr></table></figure>
<p>Session的使用也类似：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">res2</span> =</span> <span class="type">Ok</span>(<span class="string">"Good Scala"</span>) withSession <span class="type">Session</span>(<span class="string">"fuck"</span>, <span class="string">"shit"</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">res_rm</span> =</span> res2 withNewSession <span class="comment">// clear session</span></span><br></pre></td></tr></table></figure>
<p>但是Play里的session有个坑，它没实现expiration的功能，因此需要我们自己在session中加个时间戳，然后自己实现expiration的逻辑。</p>
<p>另外还有个<strong>大坑</strong>！如果需要添加session的话，需要这样：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ok</span>(<span class="string">"Good Scala"</span>) withSession (request.session + <span class="type">Session</span>(<span class="string">"fuck"</span>, <span class="string">"shit"</span>))</span><br></pre></td></tr></table></figure></p>
<p>因为<code>withSession(s)</code>方法会将<code>s</code>设为当前的session，原先的session将会被抹掉。<br>。所以一定要把原先的session加上，要不然原先的session会丢失。</p>
<p>Flash和Session类似，但Flash只在一个request内有效，多用于request之间数据的传递：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ok</span>(<span class="string">"Good Scala"</span>) flashing <span class="string">"fuck"</span> -&gt; <span class="string">"shit"</span></span><br></pre></td></tr></table></figure></p>
<h1 id="自定义Action">自定义Action</h1><p>比如有一些逻辑中，我们需要验证用户是否登录，如果没有登录就自动跳转到登录界面。如果在每个Action中都写上登录验证逻辑的话会非常不优美，因此我们可以自定义一个<code>AuthenticatedAction</code>，里面包装了权限验证的逻辑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AuthenticatedAction</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ActionBuilder</span>[</span><span class="type">Request</span>] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span>[</span><span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>],</span><br><span class="line">                              block: (<span class="type">Request</span>[<span class="type">A</span>]) =&gt; <span class="type">Future</span>[<span class="type">Result</span>]): <span class="type">Future</span>[<span class="type">Result</span>] = &#123;</span><br><span class="line">    utils.<span class="type">DateUtils</span>.ensureSession(request)</span><br><span class="line">    request.session.get(<span class="string">"user_token"</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(u) =&gt;</span><br><span class="line">        block(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        <span class="type">Future</span>.successful(<span class="type">Redirect</span>(routes.<span class="type">UserController</span>.loginIndex()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们自定义的Action需要实现<code>ActionBuilder[Request]</code>接口，并重写<code>invokeBlock</code>函数。</p>
<h1 id="拦截器">拦截器</h1><p>在Play中使用Filter也非常方便。比如我们想给应用添加安全拦截器，我们可以写一个Filter：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filters</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.<span class="type">Inject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> play.api.http.<span class="type">HttpFilters</span></span><br><span class="line"><span class="keyword">import</span> play.filters.headers.<span class="type">SecurityHeadersFilter</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filters</span> <span class="title">@Inject</span>(</span>) (security: <span class="type">SecurityHeadersFilter</span>) <span class="keyword">extends</span> <span class="type">HttpFilters</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">filters</span> =</span> <span class="type">Seq</span>(security)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中我们通过依赖注入获取安全拦截器<code>SecurityHeadersFilter</code>实例。然后，我们在<code>application.conf</code>中配置拦截器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play.http.filters=filters.<span class="type">Filters</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>未完待续，还会不断补充。。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Play-Framework/">Play Framework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web开发/">Web开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-type-system-refinement-types" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Functional-Programming/type-system-refinement-types/" class="article-date">
      <time datetime="2016-04-16T16:00:00.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Functional-Programming/type-system-refinement-types/">类型系统 | Refinement Type</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近在看某个Slide的时候里了解到了Refinement type这个玩意儿，今天拿来总结总结。</p>
<h1 id="何为Refinement_Type">何为Refinement Type</h1><p>言简意赅的讲：</p>
<blockquote>
<p>Refinement Types = Types + Logical Predicates</p>
</blockquote>
<p>即Refinement Type是由类型和谓词逻辑组合而成的，其中谓词逻辑可以对类型的值域进行约束。也就是说，我们可以在原有类型的基础上给它加个值的限定，并且可以在编译时检测是否符合谓词逻辑限定。</p>
<p>下面我们来玩一下Haskell和Scala中典型的Refinement Type库。</p>
<h1 id="LiquidHaskell">LiquidHaskell</h1><p><a href="https://github.com/ucsd-progsys/liquidhaskell" target="_blank" rel="external">LiquidHaskell</a>是Haskell上一个基于Liquid Types的静态分析器，可以通过Refinement Type进行静态检查。安装的时候注意需要系统环境中有logic solvers(比如<code>z3</code>)。</p>
<p>下边我们来看看如何使用LiquidHaskell：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="module"><span class="keyword">module</span> RfT <span class="keyword">where</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-@ zero'' :: &#123;v: Int | v &gt;= 0 &amp;&amp; v &lt; 24 &#125; @-&#125;</span></span><br><span class="line"><span class="title">zero'</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">zero'</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-@ zero'' :: &#123;v: Int | v &gt; 5 &#125; @-&#125;</span></span><br><span class="line"><span class="title">zero''</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">zero''</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>我们定义了两个函数<code>zero&#39;</code>和<code>zero&#39;&#39;</code>，这两个函数的值都是0。我们在每个函数的声明前都加了一行谓词逻辑的限定，语法类似于：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-@ f :: &#123;x: T | predicate &#125; @-&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>比如<code>{-@ zero&#39;&#39; :: {v: Int | v &gt; 5 } @-}</code>代表<code>zero&#39;&#39;</code>函数有一个类型为Int的参数，而且接受的值必须大于5，这就是谓词逻辑限定。我们运行一下看看结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ liquid --diff rft1.hs</span><br></pre></td></tr></table></figure></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LiquidHaskell</span> <span class="type">Copyright</span> <span class="number">2009</span>-<span class="number">15</span> <span class="type">Regents</span> <span class="keyword">of</span> the <span class="type">University</span> <span class="keyword">of</span> <span class="type">California</span>. <span class="type">All</span> <span class="type">Rights</span> <span class="type">Reserved</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**** <span class="type">DONE</span>:  <span class="type">Parsed</span> <span class="type">All</span> <span class="type">Specifications</span> ******************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**** <span class="type">DONE</span>:  <span class="type">Loaded</span> <span class="type">Targets</span> *****************************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**** <span class="type">DONE</span>:  <span class="type">Extracted</span> <span class="type">Core</span> using <span class="type">GHC</span> *******************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**** <span class="type">DONE</span>:  generateConstraints ************************************************</span><br><span class="line"></span><br><span class="line"><span class="type">Done</span> solving.</span><br><span class="line"><span class="type">Safe</span></span><br><span class="line"></span><br><span class="line">**** <span class="type">DONE</span>:  solve **************************************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**** <span class="type">DONE</span>:  annotate ***********************************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**** <span class="type">Checked</span> <span class="type">Binders</span>: <span class="type">None</span> *****************************************************</span><br><span class="line"></span><br><span class="line">**** <span class="type">RESULT</span>: <span class="type">UNSAFE</span> ************************************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> rft1.hs:<span class="number">10</span>:<span class="number">1</span>-<span class="number">6</span>: <span class="type">Error</span>: <span class="type">Liquid</span> <span class="type">Type</span> <span class="type">Mismatch</span></span><br><span class="line">  <span class="type">Inferred</span> <span class="typedef"><span class="keyword">type</span></span></span><br><span class="line">    <span class="type">VV</span> : &#123;<span class="type">VV</span> : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | <span class="type">VV</span> == (<span class="number">0</span> : int)&#125;</span><br><span class="line"></span><br><span class="line">  not a subtype <span class="keyword">of</span> <span class="type">Required</span> <span class="typedef"><span class="keyword">type</span></span></span><br><span class="line">    <span class="type">VV</span> : &#123;<span class="type">VV</span> : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | <span class="type">VV</span> &gt; <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">In</span> <span class="type">Context</span></span><br></pre></td></tr></table></figure>
<p>LiquidHaskell成功地检测出了错误 —— <code>zero&#39;&#39;</code>函数不符合谓词逻辑限定。</p>
<p>下边再举个对函数参数和返回值进行refine的例子：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;- Preconditions -&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-@ divide :: Int -&gt; &#123;v: Int | v != 0 &#125; -&gt; Int @-&#125;</span></span><br><span class="line"><span class="title">divide</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">divide</span> n d = n `div` d</span><br><span class="line"></span><br><span class="line"><span class="title">f1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">f1</span> = divide <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title">f2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">f2</span> = divide <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;- Postconditions -&#125;</span></span><br><span class="line"><span class="comment">&#123;-@ abs' :: Int -&gt; &#123;v: Int | v &gt;= 0 &#125; @-&#125;</span></span><br><span class="line"><span class="title">abs'</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">abs'</span> n | n &gt; <span class="number">0</span> 	   = n</span><br><span class="line">	   | otherwise = <span class="number">0</span> - n</span><br></pre></td></tr></table></figure></p>
<p>验证结果符合我们的期望：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rft1</span>.hs:<span class="number">19</span>:<span class="number">6</span>-<span class="number">15</span>: <span class="type">Error</span>: <span class="type">Liquid</span> <span class="type">Type</span> <span class="type">Mismatch</span></span><br><span class="line"></span><br><span class="line"><span class="number">19</span> | f1 = divide <span class="number">1</span> <span class="number">0</span></span><br><span class="line">          ^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">  <span class="type">Inferred</span> <span class="typedef"><span class="keyword">type</span></span></span><br><span class="line">    <span class="type">VV</span> : &#123;<span class="type">VV</span> : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | <span class="type">VV</span> == ?a&#125;</span><br><span class="line"></span><br><span class="line">  not a subtype <span class="keyword">of</span> <span class="type">Required</span> <span class="typedef"><span class="keyword">type</span></span></span><br><span class="line">    <span class="type">VV</span> : &#123;<span class="type">VV</span> : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | <span class="type">VV</span> /= <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">In</span> <span class="type">Context</span></span><br><span class="line">    ?a := &#123;?a : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | ?a == (<span class="number">0</span> : int)&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到LiquidHaskell可以验证函数的先验条件和后验条件。</p>
<p>至于其中的实现原理，可以参考这篇论文：<a href="http://goto.ucsd.edu/~rjhala/liquid/liquid_types.pdf" target="_blank" rel="external">Liquid Types</a>（数学推导太多，没看懂&gt;_&lt;）</p>
<h1 id="refined(Scala)">refined(Scala)</h1><p><a href="https://github.com/fthomas/refined" target="_blank" rel="external">refined</a>是Scala中一个Refinement Type的实现（貌似也是借鉴的Haskell的库，连名字都抄过来了）。我们在REPL里玩玩，首先导入相关的包：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eu.timepit.refined._</span><br><span class="line"><span class="keyword">import</span> eu.timepit.refined.api.<span class="type">Refined</span></span><br><span class="line"><span class="keyword">import</span> eu.timepit.refined.auto._</span><br><span class="line"><span class="keyword">import</span> eu.timepit.refined.numeric._</span><br><span class="line"><span class="keyword">import</span> eu.timepit.refined.boolean._</span><br><span class="line"><span class="keyword">import</span> eu.timepit.refined.char._</span><br><span class="line"><span class="keyword">import</span> eu.timepit.refined.collection._</span><br><span class="line"><span class="keyword">import</span> eu.timepit.refined.generic._</span><br><span class="line"><span class="keyword">import</span> eu.timepit.refined.string._</span><br><span class="line"><span class="keyword">import</span> shapeless.&#123; ::, <span class="type">HNil</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>refined这个库直接在类型系统上进行限定，通过一个<code>Refined[T, P]</code>类型(aka <code>T Refined P</code>, T - 类型， P - 谓词逻辑)来表示，比如正整数可以表示为<code>Int Refined Positive</code>，非空字符串可以表示为<code>String Refined NonEmpty</code>。几个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">i1</span>:</span> <span class="type">Int</span> <span class="type">Refined</span> <span class="type">Positive</span> = <span class="number">5</span></span><br><span class="line">i1: eu.timepit.refined.api.<span class="type">Refined</span>[<span class="type">Int</span>,eu.timepit.refined.numeric.<span class="type">Positive</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">i2</span>:</span> <span class="type">Int</span> <span class="type">Refined</span> <span class="type">Positive</span> = -<span class="number">5</span></span><br><span class="line">&lt;console&gt;:<span class="number">21</span>: error: <span class="type">Predicate</span> failed: (-<span class="number">5</span> &gt; <span class="number">0</span>).</span><br><span class="line">       <span class="function"><span class="keyword">val</span> <span class="title">i2</span>:</span> <span class="type">Int</span> <span class="type">Refined</span> <span class="type">Positive</span> = -<span class="number">5</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">i3</span>:</span> <span class="type">String</span> <span class="type">Refined</span> <span class="type">NonEmpty</span> = <span class="string">""</span></span><br><span class="line">&lt;console&gt;:<span class="number">37</span>: error: <span class="type">Predicate</span> isEmpty() did not fail.</span><br><span class="line">       <span class="function"><span class="keyword">val</span> <span class="title">i3</span>:</span> <span class="type">String</span> <span class="type">Refined</span> <span class="type">NonEmpty</span> = <span class="string">""</span></span><br><span class="line">                                         ^</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">u1</span>:</span> <span class="type">String</span> <span class="type">Refined</span> <span class="type">Url</span> = <span class="string">"htp://example.com"</span></span><br><span class="line">&lt;console&gt;:<span class="number">37</span>: error: <span class="type">Url</span> predicate failed: unknown protocol: htp</span><br><span class="line">       <span class="function"><span class="keyword">val</span> <span class="title">u1</span>:</span> <span class="type">String</span> <span class="type">Refined</span> <span class="type">Url</span> = <span class="string">"htp://example.com"</span></span><br><span class="line">                                    ^</span><br></pre></td></tr></table></figure></p>
<p>可以看到refined内置不少Predicate，也可以自己自定义Predicate。</p>
<h1 id="Reference">Reference</h1><ul>
<li><a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs" target="_blank" rel="external">Refinement Types 101 - LiquidHaskell</a></li>
<li><a href="http://refined.timepit.eu" target="_blank" rel="external">refined: simple refinement types for Scala</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Functional-Programming/">Functional Programming</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Type-Theory/">Type Theory</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-scala-type-lambda" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Functional-Programming/scala-type-lambda/" class="article-date">
      <time datetime="2016-04-12T16:00:00.000Z" itemprop="datePublished">2016-04-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Functional-Programming/scala-type-lambda/">Scala | 神奇的Type Lambda</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这里来总结一下Scala类型系统中的Type Lambda，这是一个神奇的Trick，可以在类型上做有限的类似于Lambda Calculus的运算。</p>
<h1 id="Type_Lambda">Type Lambda</h1><p>为了便于理解，这里就以熟悉的Monad开始。首先定义我们的Monad Typeclass:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[</span><span class="type">M</span>[_]] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span>[</span><span class="type">A</span>](a: <span class="type">A</span>): <span class="type">M</span>[<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;=</span>[</span><span class="type">A</span>, <span class="type">B</span>](m: <span class="type">M</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">M</span>[<span class="type">B</span>]): <span class="type">M</span>[<span class="type">B</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出Monad的kind为<code>(* -&gt; *) -&gt; *</code>。</p>
<p>假如我们想为<code>Either[+A, +B]</code>类型的右投影(Right Projection)实现对应的Monad，这里就会出现一个问题：<code>Either[+A, +B]</code>类型的kind为<code>* -&gt; * -&gt; *</code>，而Monad最多接受kind为<code>* -&gt; *</code>的type constructor，因此如果我们想把Either塞进Monad里，就必须将其kind化为<code>* -&gt; *</code>。是不是很像在类型系统上进行Currying(柯里化)呢？这就是<strong>type lambda</strong>的作用。我们可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">EitherMonad</span>[</span><span class="type">A</span>] <span class="keyword">extends</span> <span class="type">Monad</span>[(&#123;<span class="class"><span class="keyword">type</span> <span class="title">λ</span>[</span>α] = <span class="type">Either</span>[<span class="type">A</span>, α]&#125;)#λ] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span>[</span><span class="type">B</span>](a: <span class="type">B</span>): <span class="type">Either</span>[<span class="type">A</span>, <span class="type">B</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;=</span>[</span><span class="type">B</span>, <span class="type">C</span>](m: <span class="type">Either</span>[<span class="type">A</span>, <span class="type">B</span>])(f: <span class="type">B</span> =&gt; <span class="type">Either</span>[<span class="type">A</span>, <span class="type">C</span>]): <span class="type">Either</span>[<span class="type">A</span>, <span class="type">C</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来分析一下此Monad对应的type parameter是什么玩意儿。首先，<code>{type λ[α] = Either[A, α]}</code>这一块是一个<strong>structural type</strong>，在其内部定义了一个类型λ，接受一个类型参数α，此类型与<code>Either[A, α]</code>类型相对应。也就是说这个类型相当于<code>Either[A, _]</code>这个type constructor，它再接受一个类型参数从而构造出完整的Either[A, B]类型(kind为<code>*</code>)。接着我们通过类型投影（<code>#</code>操作符）得到这个λ类型（通过反射），它的kind为<code>* -&gt; *</code>，从而符合Monad类型参数的要求。</p>
<p>这样的trick就是<strong>Type Lambda</strong>，它相当于在类型系统上(对type constructor)进行Currying。我们可以看到它的实现非常巧妙，巧妙地利用了structural type和type projection。</p>
<p>我们类比一下Currying。比如有函数（为了表示方便，这里用Haskell函数表示）：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: (<span class="type">Int</span> a) =&gt; a -&gt; b -&gt; c</span><br></pre></td></tr></table></figure></p>
<p>我们可以对其进行Currying：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: (<span class="type">Int</span> a) =&gt; a -&gt; (b -&gt; c)</span><br><span class="line"></span><br><span class="line"><span class="title">g</span> :: b -&gt; c</span><br><span class="line"><span class="title">g</span> = f <span class="number">0</span> <span class="comment">&#123;- eta reduction -&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>同样，在类型系统上我们也可以这么干，比如我们要将kind为<code>* -&gt; * -&gt; *</code>的<code>Either[A, B]</code>化为kind为<code>* -&gt; *</code>的<code>Either[A, _]</code>，这时候我们就可以利用type lambda来进行转化。</p>
<p><strong>题外话（关于Haskell）</strong>：这样的操作其实属于类型组合(type composition)。Haskell中的<code>Control.Compose</code>模块提供了一系列的用于类型组合的玩意，有兴趣的可以看看Hackage中的<a href="http://hackage.haskell.org/package/TypeCompose-0.6.3/docs/Control-Compose.html" target="_blank" rel="external">文档</a>玩一玩～</p>
<hr>
<h1 id="Reference">Reference</h1><ul>
<li><a href="http://stackoverflow.com/questions/8736164/what-are-type-lambdas-in-scala-and-what-are-their-benefits" target="_blank" rel="external">What are type lambdas in Scala and what are their benefits?</a></li>
<li><a href="https://wiki.haskell.org/TypeCompose" target="_blank" rel="external">TypeCompose</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Functional-Programming/">Functional Programming</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Type-Lambda/">Type Lambda</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-akka-actor-sender-enclosing" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/akka-actor-sender-enclosing/" class="article-date">
      <time datetime="2016-04-10T16:00:00.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/akka-actor-sender-enclosing/">Akka Actor | 注意sender的闭包范围</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Akka Actor里都有一个sender方法返回此消息的发送方Actor，进行消息回复非常方便。但是在使用sender时，需要注意一点： <strong>不要在可能运行于其它线程的闭包中调用sender方法，也就是说一定要在当前Actor范围内调用sender方法</strong>，否则会出现各种问题。正好写Aquarius的时候用到了Actor，就用它演示一下。假设我们收到请求收藏的消息，并调用相关业务逻辑进行异步操作，并向sender返回操作结果。假如我们这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span>:</span> <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> go @ <span class="type">FavoriteOn</span>(a, u) =&gt;</span><br><span class="line">      service ❤ go onComplete &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt;</span><br><span class="line">          sender ! <span class="type">FAVORITE_PROCESS_SUCCESS</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Failure</span>(ex) =&gt;</span><br><span class="line">          sender ! <span class="type">FAVORITE_PROCESS_FAIL</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 其他代码略</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这是对应的请求逻辑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">val</span> <span class="title">timeout</span> =</span> <span class="type">Timeout</span>(<span class="number">5</span> seconds)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">like</span>(</span>aid: <span class="type">Int</span>, uid: <span class="type">Int</span>) = <span class="type">Action</span>.async &#123; <span class="keyword">implicit</span> request =&gt;</span><br><span class="line">    <span class="comment">// 省略其它逻辑</span></span><br><span class="line">    (alActor ? <span class="type">FavoriteOn</span>(aid, uid.toInt)).mapTo[<span class="type">ProcessResult</span>] map &#123; reply =&gt;</span><br><span class="line">      <span class="type">Ok</span>(<span class="type">Json</span>.toJson(reply))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们会发现，发出请求5s后抛出<code>AskTimeoutException</code>异常，表明Actor没有发送回reply：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">play.api.http.<span class="type">HttpErrorHandlerExceptions</span>$$anon$<span class="number">1</span>: <span class="type">Execution</span> exception[[<span class="type">AskTimeoutException</span>: <span class="type">Ask</span> timed out on [<span class="type">Actor</span>[akka:<span class="comment">//application/user/article-favorite-actor#377237056]] after [5000 ms]. Sender[null] sent message of type "message.FavoriteMessageActor$FavoriteOn".]]</span></span><br><span class="line">	at play.api.http.<span class="type">HttpErrorHandlerExceptions</span>$.throwableToUsefulException(<span class="type">HttpErrorHandler</span>.scala:<span class="number">269</span>)</span><br><span class="line">	at play.api.http.<span class="type">DefaultHttpErrorHandler</span>.onServerError(<span class="type">HttpErrorHandler</span>.scala:<span class="number">195</span>)</span><br><span class="line">	at play.core.server.netty.<span class="type">PlayRequestHandler</span>$$anonfun$<span class="number">2</span>$$anonfun$apply$<span class="number">1.</span>applyOrElse(<span class="type">PlayRequestHandler</span>.scala:<span class="number">99</span>)</span><br><span class="line">	at play.core.server.netty.<span class="type">PlayRequestHandler</span>$$anonfun$<span class="number">2</span>$$anonfun$apply$<span class="number">1.</span>applyOrElse(<span class="type">PlayRequestHandler</span>.scala:<span class="number">98</span>)</span><br><span class="line">	...</span><br><span class="line"><span class="type">Caused</span> by: akka.pattern.<span class="type">AskTimeoutException</span>: <span class="type">Ask</span> timed out on [<span class="type">Actor</span>[akka:<span class="comment">//application/user/article-favorite-actor#377237056]] after [5000 ms]. Sender[null] sent message of type "message.FavoriteMessageActor$FavoriteOn".</span></span><br><span class="line">	at akka.pattern.<span class="type">PromiseActorRef</span>$$anonfun$<span class="number">1.</span>apply$mcV$sp(<span class="type">AskSupport</span>.scala:<span class="number">604</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在对应Actor中检测sender的path，结果为<code>deadLetters</code>，表明我们此处获得的sender并不是消息发送方。这是因为上面的代码在Future的<code>onComplete</code>闭包中调用了sender方法，而<code>onComplete</code>闭包代码会异步执行（在另一个线程内），从而获得的sender并不是消息接收时对应的sender，行为是未定义，线程不安全的（可能会导致资源争用）。因此我们需要在Actor作用域内获取sender actor：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span>:</span> <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">sender</span> =</span> <span class="keyword">super</span>.sender()</span><br><span class="line">    <span class="keyword">case</span> go @ <span class="type">FavoriteOn</span>(a, u) =&gt;</span><br><span class="line">      service ❤ go onComplete &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt;</span><br><span class="line">          sender ! <span class="type">FAVORITE_PROCESS_SUCCESS</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Failure</span>(ex) =&gt;</span><br><span class="line">          sender ! <span class="type">FAVORITE_PROCESS_FAIL</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 其他代码略</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这样就确保sender是消息接收时对应的发送方Actor，从而可以正常的发送reply。</p>
<p>总结几种典型情况及解决方法：</p>
<ul>
<li>可变状态，如以下代码会导致未定义行为（由于资源争用），因此在Actor中不要使用共享的可变状态（一切都val！），或使用<code>DynamicVariable</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> &#123;</span></span><br><span class="line">    <span class="keyword">var</span> state = <span class="type">State</span>()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        <span class="type">Future</span> &#123; state = newState &#125;</span><br><span class="line">        otherActor ? message onSuccess &#123; r =&gt; state = r &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Future的<code>onComplete</code>、<code>onSuccess</code>和<code>onFailure</code>。在这些回调中必须正确地引用sender（在Actor作用域内获取或通过<code>self</code>）</li>
</ul>
<p>目前来说，编译器不能在编译期检查出sender的问题，因此写代码的时候一定要头脑清醒，注意sender的闭包范围。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Akka-Actor/">Akka Actor</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步/">异步</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-play-music-on-linux" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Miscellaneous/play-music-on-linux/" class="article-date">
      <time datetime="2016-04-07T16:00:00.000Z" itemprop="datePublished">2016-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Miscellaneous/play-music-on-linux/">在Linux环境下玩转MIDI</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>今天在Ubuntu下搭了各种MIDI环境，为后边玩 <em>Haskell School of Music</em> 中讲的Euterpea音乐库做准备。</p>
<h1 id="ASLA">ASLA</h1><p>首先介绍一下ASLA(Advanced Linux Sound Architecture)，它为Linux提供了MIDI和音频功能，相当于Linux下音频的基础。Ubuntu应该自带ALSA。</p>
<p><img src="http://tedfelix.com/linux/linux-midi.png" alt=""></p>
<p>查看一下当前系统的内核：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sczyh3<span class="number">0</span><span class="variable">@sczyh30</span>-<span class="symbol">workshop:</span>~<span class="variable">$ </span> uname -a</span><br><span class="line"><span class="constant">Linux </span>sczyh3<span class="number">0</span>-workshop <span class="number">3.19</span>.<span class="number">0</span>-<span class="number">49</span>-generic <span class="comment">#55-Ubuntu SMP Fri Jan 22 02:10:24 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure></p>
<p>由于玩MIDI对时间要求严格，不能卡顿，因此推荐用低延时的内核(Low Latency Kernel)，可以通过<code>sudo apt-get install linux-lowlatency</code>安装然后调整<code>CONFIG_HZ</code>参数。</p>
<p>然后我们来查看一下ALSA设备：<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sczyh30@sczyh30-workshop:~$  cat /<span class="keyword">proc</span>/asound/cards</span><br><span class="line"> 0 [HDMI           ]:<span class="symbol"> HDA-Intel</span> -<span class="symbol"> HDA</span> Intel<span class="symbol"> HDMI</span></span><br><span class="line"><span class="symbol">                      HDA</span> Intel<span class="symbol"> HDMI</span> at 0xf7b14000<span class="symbol"> irq</span> 34</span><br><span class="line"> 1 [PCH            ]:<span class="symbol"> HDA-Intel</span> -<span class="symbol"> HDA</span> Intel<span class="symbol"> PCH</span></span><br><span class="line"><span class="symbol">                      HDA</span> Intel<span class="symbol"> PCH</span> at 0xf7b10000<span class="symbol"> irq</span> 33</span><br></pre></td></tr></table></figure></p>
<p>从出现的列表看不出哪个是声卡设备，因此再用<code>aplay</code>命令看一下详细信息：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sczyh30<span class="comment">@sczyh30-workshop:~$  aplay -l</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> PLAYBACK 硬體裝置清單 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">card 0: HDMI [HDA Intel HDMI], device 3: HDMI 0 [HDMI 0]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br><span class="line">card 0: HDMI [HDA Intel HDMI], device 7: HDMI 1 [HDMI 1]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br><span class="line">card 0: HDMI [HDA Intel HDMI], device 8: HDMI 2 [HDMI 2]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br><span class="line">card 1: PCH [HDA Intel PCH], device 0: ALC892 Analog [ALC892 Analog]</span><br><span class="line">  子设备: 0/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br><span class="line">card 1: PCH [HDA Intel PCH], device 1: ALC892 Digital [ALC892 Digital]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 <span class="comment">#0: subdevice #0</span></span><br></pre></td></tr></table></figure>
<p>可以看到card 1位置为声卡，在ALSA设备里表示为<code>hw:1</code>，当然card 1处有两个子设备，可以分别用<code>hw:1,0</code>和<code>hw:1,1</code>表示。在下边调用ALSA设备的时候都会用到<code>hw:1</code>。</p>
<p>下面来测试一下ALSA音频功能。首先通过<code>sox</code>命令生成一段音频，然后用<code>aplay</code>播放：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sox -b <span class="number">16</span> -n test.wav rate <span class="number">44100</span> channels <span class="number">2</span> synth <span class="number">1</span> sine <span class="number">440</span></span><br><span class="line">aplay -D hw:<span class="number">1</span> test.wav</span><br></pre></td></tr></table></figure></p>
<p>正常情况下会听到”滴”的一声，代表设备正常，否则就是设备设置的不对。如果提示设备忙，那么可能是其它程序（比如pulseaudio）占用了。</p>
<h1 id="FluidSynth">FluidSynth</h1><p>下面来玩一下 <strong>FluidSynth</strong> ，它是一个音频合成器。它可以将MIDI数据通过<code>soundfont</code>转化为音频。先安装：<code>sudo apt-get install fluidsynth</code>。</p>
<p>fluidsynth可以用来播放MIDI文件，命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fluidsynth --audio-driver=alsa -o audio.alsa.device=hw:<span class="number">1</span> /usr/share/sounds/sf2/FluidR3_GM.sf2 song.mid</span><br></pre></td></tr></table></figure></p>
<p>当然fluidsynth也可以接受其它程序传输的MIDI数据并转化为音频。这时候fluidsynth将作为一个“音频服务器”。它会等待其它程序与它建立连接，并发送MIDI数据。命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fluidsynth --server --audio-driver=alsa -o audio.alsa.device=hw:<span class="number">1</span> /usr/share/sounds/sf2/FluidR3_GM.sf2</span><br></pre></td></tr></table></figure>
<p>此时fluidsynth已开始运行，用<code>aplaymidi -l</code>命令可以看到fluidsynth正在监听的端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sczyh30@sczyh30-workshop:~$ aplaymidi <span class="operator">-l</span></span><br><span class="line"> Port    Client name                      Port name</span><br><span class="line"> <span class="number">14</span>:<span class="number">0</span>    Midi Through                     Midi Through Port-<span class="number">0</span></span><br><span class="line"><span class="number">128</span>:<span class="number">0</span>    FLUID Synth (<span class="number">26298</span>)              Synth input port (<span class="number">26298</span>:<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后就可以往这个端口传输MIDI数据，比如MIDI文件：<code>aplaymidi -p 128:0 song.mid</code>。</p>
<p>再来玩一下VMPK(Virtual MIDI Pinao Keyboard)，它是个MIDI Piano，产生MIDI数据。首先先安装：<code>sudo apt-get install vmpk</code>，然后启动。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/linux-piano-1.png" alt=""></p>
<p>这时候由于没有与音频设备建立连接，按琴键的时候不会有声音。我们需要通过<code>aconnect</code>命令与fluidsynth建立连接。首先查看一下当前的Audio IO：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/linux-vmpk-config-bash.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sczyh30@sczyh30-workshop:~$ aconnect -i</span><br><span class="line">client <span class="number">0</span>: <span class="string">'System'</span> [<span class="built_in">type</span>=内核]</span><br><span class="line">    <span class="number">0</span> <span class="string">'Timer           '</span></span><br><span class="line">    <span class="number">1</span> <span class="string">'Announce        '</span></span><br><span class="line">client <span class="number">14</span>: <span class="string">'Midi Through'</span> [<span class="built_in">type</span>=内核]</span><br><span class="line">    <span class="number">0</span> <span class="string">'Midi Through Port-0'</span></span><br><span class="line">client <span class="number">129</span>: <span class="string">'VMPK Output'</span> [<span class="built_in">type</span>=用户]</span><br><span class="line">    <span class="number">0</span> <span class="string">'VMPK Output     '</span></span><br><span class="line">sczyh30@sczyh30-workshop:~$ aconnect -o</span><br><span class="line">client <span class="number">14</span>: <span class="string">'Midi Through'</span> [<span class="built_in">type</span>=内核]</span><br><span class="line">    <span class="number">0</span> <span class="string">'Midi Through Port-0'</span></span><br><span class="line">client <span class="number">128</span>: <span class="string">'FLUID Synth (26298)'</span> [<span class="built_in">type</span>=用户]</span><br><span class="line">    <span class="number">0</span> <span class="string">'Synth input port (26298:0)'</span></span><br><span class="line">client <span class="number">130</span>: <span class="string">'VMPK Input'</span> [<span class="built_in">type</span>=用户]</span><br><span class="line">    <span class="number">0</span> <span class="string">'VMPK Input      '</span></span><br></pre></td></tr></table></figure>
<p>我们需要将MIDI转化为Audio，即从<code>VMPK</code>到<code>FLUID Synth</code>。建立连接：<code>aconnect 129:0 128:0</code>，然后再测试一下VMPK，有声音输出了。</p>
<p>FluidSynth也有GUI版本<code>Qsynth</code>，可以很方便地合成声音。</p>
<h1 id="Euterpea依赖">Euterpea依赖</h1><p>Euterpea需要asound：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libasound2-dev jackd2</span><br></pre></td></tr></table></figure></p>
<p>然而现在配置好Euterpea后，无论如何play它都不发声音。。。官网说这玩意只在某些特定的Haskell版本上正常运行，也是醉了。。待调试好后再来补充。。</p>
<p>【补充】Windows下不用配置就可以很愉快的玩Euterpea了。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Miscellaneous/">Miscellaneous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Euterpea/">Euterpea</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MIDI/">MIDI</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-slick-3-type-system-query-prolouge" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Scala/slick-3-type-system-query-prolouge/" class="article-date">
      <time datetime="2016-04-06T16:00:00.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Scala/slick-3-type-system-query-prolouge/">探索万恶的Slick 3 类型系统 | Prologue</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这两天在给Samsara Aquarius的各个Service写分页的时候，设计了一个抽象层，想把一些公共的分页逻辑放在这个trait中，但是被Slick的类型系统折磨了一点时间。。今天粗略看了一下相关的源码，结合这几天遇到的问题，总结一下。因此就把这篇文章作为Prologue吧。。。（Slick的版本为3.1.1）</p>
<h1 id="蛋疼的类型参数">蛋疼的类型参数</h1><p>在Slick里面，分页可以通过<code>drop</code>和<code>take</code>函数实现。<code>query.drop(offset).take(n)</code>对应的SQL为<code>LIMIT n, offset</code>。因此在一开始，我设计了一个trait作为分页逻辑的抽象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PageDao</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">page</span>(</span>): <span class="type">Future</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>(</span>offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[_]]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>page</code>函数用于获取总页数，<code>fetchWithPage</code>函数实现分页查询逻辑。</p>
<p>在Slick里，db操作通过<code>db.run(DBIOAction)</code>进行，而每个<code>Query</code>可以通过<code>result</code>函数隐式转换成<code>DBIOAction</code>，因此我们需要给参数中加上Query，以便我们的Service层可以传递不同的Query：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PageDao</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">page</span>(</span>query: slick.lifted.<span class="type">Query</span>[_, _, <span class="type">Seq</span>]): <span class="type">Future</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>(</span>query: slick.lifted.<span class="type">Query</span>[_, _, <span class="type">Seq</span>], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[_]]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Query[+E, U, C[_]]</code>是一个接受3个类型参数的type constructor，这为后边的蛋疼埋下伏笔。。</p>
<p>好了，接下来，由于我们需要在抽象层进行db操作，因此必须获取db对象，这里我选择继承<code>HasDatabaseConfigProvider[JdbcProfile]</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">WithPageProvider</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HasDatabaseConfigProvider</span>[</span><span class="type">JdbcProfile</span>] <span class="keyword">with</span> <span class="type">PageDao</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> driver.api._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">withQueryByPage</span> =</span></span><br><span class="line">    (query: slick.lifted.<span class="type">Query</span>[_, _, _], offset: <span class="type">Int</span>) =&gt;</span><br><span class="line">      query.drop(offset).take(<span class="type">LIMIT_PAGE</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">page</span>(</span>query: slick.lifted.<span class="type">Query</span>[_, _, _]): <span class="type">Future</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    db.run(query.length.result) map &#123; all =&gt;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">p</span> =</span> all % <span class="type">LIMIT_PAGE</span> == <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (p) all / <span class="type">LIMIT_PAGE</span></span><br><span class="line">      <span class="keyword">else</span> (all / <span class="type">LIMIT_PAGE</span>) + <span class="number">1</span></span><br><span class="line">    &#125; recover &#123;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">Exception</span> =&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>(</span>query: slick.lifted.<span class="type">Query</span>[_, _, _], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[_]] = &#123;</span><br><span class="line">    db.run(withQueryByPage(query, offset).result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯。。逻辑很快写好了，一切似乎都是OK的，下面在业务层中调用一下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>(</span>offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[(<span class="type">Category</span>, <span class="type">Int</span>)]] =</span><br><span class="line">    <span class="keyword">super</span>.fetchWithPage(categoriesCompiled, offset)</span><br></pre></td></tr></table></figure>
<p>很快，远方就传来了IDE提示GG的声音。。。提示：<code>Expression of type Future[Seq[_]] doesn&#39;t conform to expected type Future[Seq[(Category, Int)]]</code>。</p>
<p>嗯。。。看来是必须具化Seq的type parameter了。。那么就给trait里的<code>fetchWithPage</code>加个type parameter吧。。下面就陷入了苦逼的Slick类型系统初探过程——Slick在<code>run</code>、<code>result</code>的过程中，如何从一个原始的<code>Query[+E, U, C[_]]</code>转化为最终的<code>Future[Seq[R]]</code>？也就是说Query的这几个type parameters该取什么类型？想解决这个问题，只能看Slick的源码了。。首先从<code>run</code>函数出发，看看Future是怎么产生的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Run an Action asynchronously and return the result as a Future. */</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>[</span><span class="type">R</span>](a: <span class="type">DBIOAction</span>[<span class="type">R</span>, <span class="type">NoStream</span>, <span class="type">Nothing</span>]): <span class="type">Future</span>[<span class="type">R</span>] = runInternal(a, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，最后返回Future的类型参数是<code>DBIOAction[R, NoStream, Nothing]</code>的第一个类型参数R。接着我们看一下<code>DBIOAction</code>的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">DBIOAction</span>[</span>+<span class="type">R</span>, +<span class="type">S</span> &lt;: <span class="type">NoStream</span>, -<span class="type">E</span> &lt;: <span class="type">Effect</span>] <span class="keyword">extends</span> <span class="type">Dumpable</span></span><br></pre></td></tr></table></figure>
<p>嗯，看到这里，似乎明白了什么。。然后再看一下<code>Query</code>的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">QueryBase</span>[</span><span class="type">T</span>] <span class="keyword">extends</span> <span class="type">Rep</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>[</span>+<span class="type">E</span>, <span class="type">U</span>, <span class="type">C</span>[_]] <span class="keyword">extends</span> <span class="type">QueryBase</span>[<span class="type">C</span>[<span class="type">U</span>]]</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Query[+E, U, C[_]]</code>继承了<code>QueryBase[C[U]]</code>，然而注释里完全没有这三个type parameters的含义，所以就瞎猜。。注释里提到计算结果代表一个集合类型，如<code>Rep[Seq[T]]</code>，而<code>QueryBase[T]</code>又继承了<code>Rep[T]</code>，所以很容易想到<code>Query</code>第三个类型参数为<code>Seq</code>。然而一开始没有看到后边的<code>[C[U]]</code>，又因为DBIOAction中返回类型为第一个类型参数R，因此就错误地把这里的返回类型想成了第一个类型参数E（还是协变的，很迷惑人）。于是把<code>fetchWithPage</code>改成了这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>[</span><span class="type">R</span>](query: slick.lifted.<span class="type">Query</span>[<span class="type">R</span>, _, <span class="type">Seq</span>], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">R</span>]]</span><br></pre></td></tr></table></figure>
<p>仍然在报错，这次成了<code>Expression of type Future[Seq[Any]] doesn&#39;t conform to expected type Future[Seq[R]]</code>。</p>
<p>这时候提示就比较明显了，既然第一个类型参数已经限定为<code>R</code>，而返回值还为<code>Future[Seq[Any]]</code>，那么很容易就会联想到当前为<code>_</code>的类型参数有猫腻，即<code>Query[+E, U, C[_]]</code>中的<code>U</code>。这时候再看到后边继承的<code>QueryBase[C[U]]</code>，一切都一目了然了。这里的<code>QueryBase[C[U]]</code>是一个higher-kinded type，既然我们将<code>C</code>设为<code>Seq</code>，那么很容易想到<code>C[U]</code>其实就是对应着<code>Seq[Result]</code>，那么我们的R参数应该放在<code>Query</code>的第二个类型参数U上。改一下发现，一切都正常了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span>[</span><span class="type">R</span>](query: slick.lifted.<span class="type">Query</span>[_, <span class="type">R</span>, <span class="type">Seq</span>], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">R</span>]] = &#123;</span><br><span class="line">    db.run(withQueryByPage(query, offset).result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="寻根溯源">寻根溯源</h1><p>问题解决了，但<code>Query[+E, U, C[_]]</code>里那个<code>+E</code>实在是很迷惑人，于是就继续探究了探究它到底是什么玩意。注释里没写，那就从<code>Query</code>的实现中找吧。。在<code>TableQuery</code>的定义中有：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableQuery</span>[</span><span class="type">E</span> &lt;: <span class="type">AbstractTable</span>[_]](cons: <span class="type">Tag</span> =&gt; <span class="type">E</span>) <span class="keyword">extends</span> <span class="type">Query</span>[<span class="type">E</span>, <span class="type">E</span>#<span class="type">TableElementType</span>, <span class="type">Seq</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The driver-independent superclass of all table row objects.*/</span></span><br><span class="line"><span class="comment">// @tparam T Row type for this table.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTable</span>[</span><span class="type">T</span>](<span class="function"><span class="keyword">val</span> <span class="title">tableTag</span>:</span> <span class="type">Tag</span>, <span class="function"><span class="keyword">val</span> <span class="title">schemaName</span>:</span> <span class="type">Option</span>[<span class="type">String</span>], <span class="function"><span class="keyword">val</span> <span class="title">tableName</span>:</span> <span class="type">String</span>) <span class="keyword">extends</span> <span class="type">Rep</span>[<span class="type">T</span>] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">TableElementType</span></span><br><span class="line"></span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>E需要是<code>AbstractTable[_]</code>的子类，而我们在定义表的映射的时候都是继承了<code>Table[_]</code>类，因此可以确定E就是查询的类型所对应的Table类（比如ArticleTable）。</p>
<p>另外一个值的探究的地方就是那个<code>result</code>函数是如何将一个<code>Query</code>转化为<code>DBIOAction</code>的。蛋疼的地方在于这个转换是隐式的（相当于实现了Typeclass Pattern），因此追踪如何转换的比较困难。好在写代码的时候发现，如果不导入<code>driver.api._</code>的话，就会找不到<code>result</code>函数，因此可以从这里入手。跳转到<code>api</code>的源码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">api</span>:</span> <span class="type">API</span> = <span class="keyword">new</span> <span class="type">API</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>那么秘密应该就藏在<code>JdbcProfile#API</code>类里了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">API</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">LowPriorityAPI</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">super</span>.<span class="title">API</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ImplicitColumnTypes</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">FastPath</span>[</span><span class="type">T</span>] = <span class="type">JdbcFastPath</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">SimpleDBIO</span>[</span>+<span class="type">R</span>] = <span class="type">SimpleJdbcAction</span>[<span class="type">R</span>]</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">SimpleDBIO</span> =</span> <span class="type">SimpleJdbcAction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">jdbcFastPathExtensionMethods</span>[</span><span class="type">T</span>, <span class="type">P</span>](mp: <span class="type">MappedProjection</span>[<span class="type">T</span>, <span class="type">P</span>]) = <span class="keyword">new</span> <span class="type">JdbcFastPathExtensionMethods</span>[<span class="type">T</span>, <span class="type">P</span>](mp)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">queryDeleteActionExtensionMethods</span>[</span><span class="type">C</span>[_]](q: <span class="type">Query</span>[_ &lt;: <span class="type">RelationalProfile</span>#<span class="type">Table</span>[_], _, <span class="type">C</span>]): <span class="type">DeleteActionExtensionMethods</span> =</span><br><span class="line">    createDeleteActionExtensionMethods(deleteCompiler.run(q.toNode).tree, ())</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">runnableCompiledDeleteActionExtensionMethods</span>[</span><span class="type">RU</span>, <span class="type">C</span>[_]](c: <span class="type">RunnableCompiled</span>[_ &lt;: <span class="type">Query</span>[_, _, <span class="type">C</span>], <span class="type">C</span>[<span class="type">RU</span>]]): <span class="type">DeleteActionExtensionMethods</span> =</span><br><span class="line">    createDeleteActionExtensionMethods(c.compiledDelete, c.param)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">runnableCompiledUpdateActionExtensionMethods</span>[</span><span class="type">RU</span>, <span class="type">C</span>[_]](c: <span class="type">RunnableCompiled</span>[_ &lt;: <span class="type">Query</span>[_, _, <span class="type">C</span>], <span class="type">C</span>[<span class="type">RU</span>]]): <span class="type">UpdateActionExtensionMethods</span>[<span class="type">RU</span>] =</span><br><span class="line">    createUpdateActionExtensionMethods(c.compiledUpdate, c.param)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">jdbcActionExtensionMethods</span>[</span><span class="type">E</span> &lt;: <span class="type">Effect</span>, <span class="type">R</span>, <span class="type">S</span> &lt;: <span class="type">NoStream</span>](a: <span class="type">DBIOAction</span>[<span class="type">R</span>, <span class="type">S</span>, <span class="type">E</span>]): <span class="type">JdbcActionExtensionMethods</span>[<span class="type">E</span>, <span class="type">R</span>, <span class="type">S</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">JdbcActionExtensionMethods</span>[<span class="type">E</span>, <span class="type">R</span>, <span class="type">S</span>](a)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">actionBasedSQLInterpolation</span>(</span>s: <span class="type">StringContext</span>) = <span class="keyword">new</span> <span class="type">ActionBasedSQLInterpolation</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面存在这样的继承关系（简化过后的）：<code>JdbcProfile#API &lt;:&lt; RelationalProfile#API &lt;:&lt; BasicProfile#API</code>。</p>
<p>再看RelationalProfile中的API类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">API</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">super</span>.<span class="title">API</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ImplicitColumnTypes</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Table</span>[</span><span class="type">T</span>] = driver.<span class="type">Table</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Sequence</span>[</span><span class="type">T</span>] = driver.<span class="type">Sequence</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">Sequence</span> =</span> driver.<span class="type">Sequence</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">ColumnType</span>[</span><span class="type">T</span>] = driver.<span class="type">ColumnType</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">BaseColumnType</span>[</span><span class="type">T</span>] = driver.<span class="type">BaseColumnType</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">MappedColumnType</span> =</span> driver.<span class="type">MappedColumnType</span></span><br><span class="line"></span><br><span class="line">  <span class="annotation">@deprecated</span>(<span class="string">"Use an explicit conversion to an Option column with `.?`"</span>, <span class="string">"3.0"</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">columnToOptionColumn</span>[</span><span class="type">T</span> : <span class="type">BaseTypedType</span>](c: <span class="type">Rep</span>[<span class="type">T</span>]): <span class="type">Rep</span>[<span class="type">Option</span>[<span class="type">T</span>]] = c.?</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">valueToConstColumn</span>[</span><span class="type">T</span> : <span class="type">TypedType</span>](v: <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">LiteralColumn</span>[<span class="type">T</span>](v)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">columnToOrdered</span>[</span><span class="type">T</span> : <span class="type">TypedType</span>](c: <span class="type">Rep</span>[<span class="type">T</span>]): <span class="type">ColumnOrdered</span>[<span class="type">T</span>] = <span class="type">ColumnOrdered</span>[<span class="type">T</span>](c, <span class="type">Ordering</span>())</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">tableQueryToTableQueryExtensionMethods</span>[</span><span class="type">T</span> &lt;: <span class="type">RelationalProfile</span>#<span class="type">Table</span>[_], <span class="type">U</span>](q: <span class="type">Query</span>[<span class="type">T</span>, <span class="type">U</span>, <span class="type">Seq</span>] <span class="keyword">with</span> <span class="type">TableQuery</span>[<span class="type">T</span>]) =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">TableQueryExtensionMethods</span>[<span class="type">T</span>, <span class="type">U</span>](q)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableCompiledInsertActionExtensionMethods</span>[</span><span class="type">EU</span>](c: <span class="type">StreamableCompiled</span>[_, _, <span class="type">EU</span>]): <span class="type">InsertActionExtensionMethods</span>[<span class="type">EU</span>] = createInsertActionExtensionMethods[<span class="type">EU</span>](c.compiledInsert.asInstanceOf[<span class="type">CompiledInsert</span>])</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">queryInsertActionExtensionMethods</span>[</span><span class="type">U</span>, <span class="type">C</span>[_]](q: <span class="type">Query</span>[_, <span class="type">U</span>, <span class="type">C</span>]) = createInsertActionExtensionMethods[<span class="type">U</span>](compileInsert(q.toNode))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">schemaActionExtensionMethods</span>(</span>sd: <span class="type">SchemaDescription</span>): <span class="type">SchemaActionExtensionMethods</span> = createSchemaActionExtensionMethods(sd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看BasicProfile中的API类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">API</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Aliases</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ExtensionMethodConversions</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Database</span> =</span> <span class="type">Backend</span>#<span class="type">Database</span></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">Database</span> =</span> backend.<span class="type">Database</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Session</span> =</span> <span class="type">Backend</span>#<span class="type">Session</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">SlickException</span> =</span> slick.<span class="type">SlickException</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">val</span> <span class="title">slickDriver</span>:</span> driver.<span class="keyword">type</span> = driver</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Work-around for SI-3346</span></span><br><span class="line">  <span class="annotation">@inline</span> <span class="keyword">implicit</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">anyToToShapedValue</span>[</span><span class="type">T</span>](value: <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">ToShapedValue</span>[<span class="type">T</span>](value)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">repQueryActionExtensionMethods</span>[</span><span class="type">U</span>](rep: <span class="type">Rep</span>[<span class="type">U</span>]): <span class="type">QueryActionExtensionMethods</span>[<span class="type">U</span>, <span class="type">NoStream</span>] =</span><br><span class="line">    createQueryActionExtensionMethods[<span class="type">U</span>, <span class="type">NoStream</span>](queryCompiler.run(rep.toNode).tree, ())</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableQueryActionExtensionMethods</span>[</span><span class="type">U</span>, <span class="type">C</span>[_]](q: <span class="type">Query</span>[_,<span class="type">U</span>, <span class="type">C</span>]): <span class="type">StreamingQueryActionExtensionMethods</span>[<span class="type">C</span>[<span class="type">U</span>], <span class="type">U</span>] =</span><br><span class="line">    createStreamingQueryActionExtensionMethods[<span class="type">C</span>[<span class="type">U</span>], <span class="type">U</span>](queryCompiler.run(q.toNode).tree, ())</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">runnableCompiledQueryActionExtensionMethods</span>[</span><span class="type">RU</span>](c: <span class="type">RunnableCompiled</span>[_, <span class="type">RU</span>]): <span class="type">QueryActionExtensionMethods</span>[<span class="type">RU</span>, <span class="type">NoStream</span>] =</span><br><span class="line">    createQueryActionExtensionMethods[<span class="type">RU</span>, <span class="type">NoStream</span>](c.compiledQuery, c.param)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableCompiledQueryActionExtensionMethods</span>[</span><span class="type">RU</span>, <span class="type">EU</span>](c: <span class="type">StreamableCompiled</span>[_, <span class="type">RU</span>, <span class="type">EU</span>]): <span class="type">StreamingQueryActionExtensionMethods</span>[<span class="type">RU</span>, <span class="type">EU</span>] =</span><br><span class="line">    createStreamingQueryActionExtensionMethods[<span class="type">RU</span>, <span class="type">EU</span>](c.compiledQuery, c.param)</span><br><span class="line">  <span class="comment">// Applying a CompiledFunction always results in only a RunnableCompiled, not a StreamableCompiled, so we need this:</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableAppliedCompiledFunctionActionExtensionMethods</span>[</span><span class="type">R</span>, <span class="type">RU</span>, <span class="type">EU</span>, <span class="type">C</span>[_]](c: <span class="type">AppliedCompiledFunction</span>[_, <span class="type">Query</span>[<span class="type">R</span>, <span class="type">EU</span>, <span class="type">C</span>], <span class="type">RU</span>]): <span class="type">StreamingQueryActionExtensionMethods</span>[<span class="type">RU</span>, <span class="type">EU</span>] =</span><br><span class="line">    createStreamingQueryActionExtensionMethods[<span class="type">RU</span>, <span class="type">EU</span>](c.compiledQuery, c.param)</span><br><span class="line">  <span class="comment">// This only works on Scala 2.11 due to SI-3346:</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">recordQueryActionExtensionMethods</span>[</span><span class="type">M</span>, <span class="type">R</span>](q: <span class="type">M</span>)(<span class="keyword">implicit</span> shape: <span class="type">Shape</span>[_ &lt;: <span class="type">FlatShapeLevel</span>, <span class="type">M</span>, <span class="type">R</span>, _]): <span class="type">QueryActionExtensionMethods</span>[<span class="type">R</span>, <span class="type">NoStream</span>] =</span><br><span class="line">    createQueryActionExtensionMethods[<span class="type">R</span>, <span class="type">NoStream</span>](queryCompiler.run(shape.toNode(q)).tree, ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此多的implicit转换，可以将Query和CompiledQuery转换成各种QueryActionExtensionMethods。那么我们再来看<code>result</code>的源码，看看它是不是在某个QueryActionExtensionMethods类里：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamingQueryActionExtensionMethodsImpl</span>[</span><span class="type">R</span>, <span class="type">T</span>](tree: <span class="type">Node</span>, param: <span class="type">Any</span>) <span class="keyword">extends</span> <span class="type">QueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">Streaming</span>[<span class="type">T</span>]](tree, param) <span class="keyword">with</span> <span class="keyword">super</span>.<span class="type">StreamingQueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">result</span>:</span> <span class="type">StreamingDriverAction</span>[<span class="type">R</span>, <span class="type">T</span>, <span class="type">Effect</span>.<span class="type">Read</span>] = <span class="keyword">super</span>.result.asInstanceOf[<span class="type">StreamingDriverAction</span>[<span class="type">R</span>, <span class="type">T</span>, <span class="type">Effect</span>.<span class="type">Read</span>]]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然！<code>result</code>方法存在于这个QueryActionExtensionMethods类里，而且Query可以通过上述API隐式转换为QueryActionExtensionMethods。这个类好混乱，继承了两个trait，还没注释（这一点最蛋疼了，直接看源码估计无解）。再往它的父类找：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">QueryActionExtensionMethodsImpl</span>[</span><span class="type">R</span>, <span class="type">S</span> &lt;: <span class="type">NoStream</span>] &#123;</span><br><span class="line">    <span class="comment">/** An Action that runs this query. */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span>:</span> <span class="type">DriverAction</span>[<span class="type">R</span>, <span class="type">S</span>, <span class="type">Effect</span>.<span class="type">Read</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">StreamingQueryActionExtensionMethodsImpl</span>[</span><span class="type">R</span>, <span class="type">T</span>] <span class="keyword">extends</span> <span class="type">QueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">Streaming</span>[<span class="type">T</span>]] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span>:</span> <span class="type">StreamingDriverAction</span>[<span class="type">R</span>, <span class="type">T</span>, <span class="type">Effect</span>.<span class="type">Read</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>它们是最基本的<code>QueryActionExtensionMethods</code>，即查询操作。</p>
<p>到此为止，我们终于搞明白了一个数据库查询过程中从<code>Query</code>经过implicit的<code>result</code>转换成<code>DBIOAction</code>，再进行<code>db.run</code>得到Future异步结果的类型转换的过程。我做了一张图来总结这个过程：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/slick-db-type-convert-query-sczyh30-fixed.png" alt="Slick Query Type Process"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Slick/">Slick</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2016 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30.
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>