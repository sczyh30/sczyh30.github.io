<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="sczyh30" />


    
    


<meta name="description" content="sczyh30&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="「浮生若梦」 - sczyh30's blog">
<meta property="og:url" content="http://www.sczyh30.com/page/2/index.html">
<meta property="og:site_name" content="「浮生若梦」 - sczyh30's blog">
<meta property="og:description" content="sczyh30&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「浮生若梦」 - sczyh30's blog">
<meta name="twitter:description" content="sczyh30&apos;s blog">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="「浮生若梦」 - sczyh30&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>「浮生若梦」 - sczyh30&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="http://7xkkgd.com1.z0.glb.clouddn.com/blog-default-lambda-avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMQP/">AMQP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/APT/">APT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Akka/">Akka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-14/">C++ 14</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/">CAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CE3/">CE3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPS/">CPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/">Cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Category-Theory/">Category Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Continuation/">Continuation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DI/">DI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Engine/">Engine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Euterpea/">Euterpea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Loop/">Event Loop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GDB/">GDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game/">Game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC/">JUC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Klass-oop/">Klass-oop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda-Calculus/">Lambda Calculus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIDI/">MIDI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mathematical-Logic/">Mathematical Logic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metaspace/">Metaspace</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netflix-Hystrix/">Netflix Hystrix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-Model/">Object Model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PLT/">PLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Play-Framework/">Play Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quorum/">Quorum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reflection/">Reflection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheme/">Scheme</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slick/">Slick</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sort/">Sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Summary/">Summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Class/">Type Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Lambda/">Type Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-System/">Type System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Theory/">Type Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UE4/">UE4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中间件/">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云服务/">云服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存区域/">内存区域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式计算/">分布式计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息系统/">消息系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程安全/">线程安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a></li></ul>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Distributed System/Deep Learning/PLT</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="http://7xkkgd.com1.z0.glb.clouddn.com/blog-default-lambda-avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-vertx-blueprint-3-micro-shop-microservice" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/" class="article-date">
      <time datetime="2016-08-29T10:00:00.000Z" itemprop="datePublished">2016-08-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务实战</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Vert.x 蓝图项目已经发布至Vert.x官方网站：<a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x Blueprint Tutorials</a></p>
<hr>
<p><strong>Vert.x 蓝图系列</strong> 的第三篇教程出炉咯！这篇教程是微服务实战相关的主题。篇幅较长，team给了模板用于渲染对应的文档，因此这里就直接放链接了：</p>
<ul>
<li><a href="http://sczyh30.github.io/vertx-blueprint-microservice/cn/index.html" target="_blank" rel="external">Vert.x 蓝图 - Micro Shop 微服务实战 (开发篇)</a></li>
<li><a href="http://sczyh30.github.io/vertx-blueprint-microservice/cn/api-gateway.html" target="_blank" rel="external">Vert.x 蓝图 - Micro Shop 微服务实战 (API Gateway)</a></li>
</ul>
<p>对应的GitHub Repository:  <a href="https://github.com/sczyh30/vertx-blueprint-microservice" target="_blank" rel="external">sczyh30/vertx-blueprint-microservice</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vertx-blueprint-2-vertx-kue-http-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/" class="article-date">
      <time datetime="2016-07-24T07:00:00.000Z" itemprop="datePublished">2016-07-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/">Vert.x Blueprint 系列教程(二) | Vert.x Kue 教程（Web部分）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">上部分蓝图教程</a>中我们一起探索了如何用Vert.x开发一个基于消息的应用。在这部分教程中，我们将粗略地探索一下<code>kue-http</code>模块的实现。</p>
<h1 id="Vert-x_Kue_REST_API">Vert.x Kue REST API</h1><p><code>kue-http</code>模块中只有一个类<code>KueHttpVerticle</code>，作为整个REST API以及UI服务的实现。对REST API部分来说，如果看过我们之前的 <a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x 蓝图 | 待办事项服务开发教程</a> 的话，你应该对这一部分非常熟悉了，因此这里我们就不详细解释了。有关使用Vert.x Web实现REST API的教程可参考 <a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x 蓝图 | 待办事项服务开发教程</a>。</p>
<h1 id="将Kue_UI与Vert-x_Web进行适配">将Kue UI与Vert.x Web进行适配</h1><p>除了REST API之外，我们还给Vert.x Kue提供了一个用户界面。我们复用了Automattic/Kue的用户界面所以我们就不用写前端代码了（部分API有变动的地方我已进行了修改）。我们只需要将前端代码与Vert.x Web适配即可。</p>
<p>首先，前端的代码都属于静态资源，因此我们需要配置路由来允许访问静态资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">router.route().handler(StaticHandler.create(root));</div></pre></td></tr></table></figure>
<p>这样我们就可以直接访问静态资源咯～</p>
<p>注意到Kue UI使用了<strong>Jade</strong>（最近貌似改名叫Pug了）作为模板引擎，因此我们需要一个Jade模板解析器。好在Vert.x Web提供了一个Jade模板解析的实现: <code>io.vertx:vertx-web-templ-jade</code>，所以我们可以利用这个实现来渲染UI。首先在类中定义一个<code>JadeTemplateEngine</code>并在<code>start</code>方法中初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">engine = JadeTemplateEngine.create();</div></pre></td></tr></table></figure>
<p>然后我们就可以写一个处理器方法来根据不同的任务状态来渲染UI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(RoutingContext context, String state)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String uiPath = <span class="string">"webroot/views/job/list.jade"</span>; <span class="comment">// (1)</span></div><div class="line">  String title = config().getString(<span class="string">"kue.ui.title"</span>, <span class="string">"Vert.x Kue"</span>);</div><div class="line">  kue.getAllTypes()</div><div class="line">    .setHandler(resultHandler(context, r -&gt; &#123;</div><div class="line">      context.put(<span class="string">"state"</span>, state) <span class="comment">// (2)</span></div><div class="line">        .put(<span class="string">"types"</span>, r)</div><div class="line">        .put(<span class="string">"title"</span>, title);</div><div class="line">      engine.render(context, uiPath, res -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">        <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">          context.response()</div><div class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>) <span class="comment">// (4)</span></div><div class="line">            .end(res.result());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          context.fail(res.cause());</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们需要给渲染引擎指定我们前端代码的地址 (1)。然后我们从Redis中获取其中所有的任务类型，然后向解析器context中添加任务状态、网页标题、任务类型等信息供渲染器渲染使用 (2)。接着我们就可以调用<code>engine.render(context, path, handler)</code>方法进行渲染 (3)。如果渲染成功，我们将页面写入HTTP Response (4)。</p>
<p>现在我们可以利用<code>render</code>方法去实现其它的路由函数了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUIActive</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  render(context, <span class="string">"active"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们给它绑个路由就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">router.route(KUE_UI_ACTIVE).handler(<span class="keyword">this</span>::handleUIActive);</div></pre></td></tr></table></figure>
<p>是不是非常方便呢？不仅如此，Vert.x Web还提供了其它各种模板引擎的支持，比如 <em>FreeMaker</em>, <em>Pebble</em> 以及 <em>Thymeleaf 3</em>。如果感兴趣的话，你可以查阅<a href="http://vertx.io/docs/vertx-web/java/#_templates" target="_blank" rel="external">官方文档</a>来获取详细的使用指南。</p>
<h1 id="展示时间！">展示时间！</h1><p>是不是等不及要看UI长啥样了？现在我们就来展示一下！首先构建项目：</p>
<pre><code><span class="title">gradle</span> build
</code></pre><p><code>kue-http</code>需要<code>kue-core</code>运行着（因为<code>kue-core</code>里注册了Event Bus服务），因此我们先运行<code>kue-core</code>，再运行<code>kue-http</code>。不要忘记运行Redis:</p>
<pre><code>redis-server
java -jar kue-core/build/libs/vertx-blueprint-kue-core<span class="class">.jar</span> -cluster -ha -conf config/config<span class="class">.json</span>
java -jar kue-http/build/libs/vertx-blueprint-kue-http<span class="class">.jar</span> -cluster -ha -conf config/config.json
</code></pre><p>为了更好地观察任务处理的流程，我们再运行一个示例：</p>
<pre><code>java -jar kue-example<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-example.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>好啦！现在在浏览器中访问<code>http://localhost:8080</code>，我们的Kue UI就呈现在我们眼前啦！</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/vertx_kue_ui_1.png" alt="Vert.x Kue UI"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vertx-blueprint-2-vertx-kue-core-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/" class="article-date">
      <time datetime="2016-07-24T06:00:00.000Z" itemprop="datePublished">2016-07-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本文章是 <strong>Vert.x 蓝图系列</strong> 的第二篇教程。全系列：</p>
<ul>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</a></li>
<li>Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程</li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践</a></li>
</ul>
<h1 id="前言">前言</h1><p>欢迎回到Vert.x 蓝图系列～在本教程中，我们将利用Vert.x开发一个基于消息的应用 - Vert.x Kue，它是一个使用Vert.x开发的优先级工作队列，数据存储使用的是 <em>Redis</em> 。Vert.x Kue是<a href="https://github.com/Automattic/kue" target="_blank" rel="external">Automattic/kue</a>的Vert.x实现版本。我们可以使用Vert.x Kue来处理各种各样的任务，比如文件转换、订单处理等等。</p>
<p>通过本教程，你将会学习到以下内容：</p>
<ul>
<li>消息、消息系统以及事件驱动的运用</li>
<li>Vert.x <strong>Event Bus</strong> 的几种事件机制（发布/订阅、点对点模式）</li>
<li>设计 <strong>分布式</strong> 的Vert.x应用</li>
<li>工作队列的设计</li>
<li><strong>Vert.x Service Proxy</strong>（服务代理）的运用</li>
<li>更深层次的Redis运用</li>
</ul>
<p>本教程是 <a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x 蓝图系列</a> 的第二篇教程，对应的Vert.x版本为 <strong>3.3.3</strong> 。本教程中的完整代码已托管至<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/tree/master" target="_blank" rel="external">GitHub</a>。</p>
<h1 id="Vert-x的消息系统">Vert.x的消息系统</h1><p>既然我们要用Vert.x开发一个基于消息的应用，那么我们先来瞅一瞅Vert.x的消息系统吧～在Vert.x中，我们可以通过 <strong>Event Bus</strong> 来发送和接收各种各样的消息，这些消息可以来自不同的<code>Vertx</code>实例。怎么样，很酷吧？我们都将消息发送至Event Bus上的某个<strong>地址</strong>上，这个地址可以是任意的字符串。</p>
<p>Event Bus支持三种消息机制：<strong>发布/订阅</strong>(Publish/Subscribe)、<strong>点对点</strong>(Point to point)以及<strong>请求/回应</strong>(Request-Response)模式。下面我们就来看一看这几种机制。</p>
<h2 id="发布/订阅模式">发布/订阅模式</h2><p>在<strong>发布/订阅模式</strong>中，消息被发布到Event Bus的某一个地址上，所有订阅此地址的<code>Handler</code>都会接收到该消息并且调用相应的处理逻辑。我们来看一看示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">EventBus eventBus = vertx.eventBus();</div><div class="line"></div><div class="line">eventBus.consumer(<span class="string">"foo.bar.baz"</span>, r -&gt; &#123; <span class="comment">// subscribe to `foo.bar.baz` address</span></div><div class="line">  System.out.println(<span class="string">"1: "</span> + r.body());</div><div class="line">&#125;);</div><div class="line">eventBus.consumer(<span class="string">"foo.bar.baz"</span>, r -&gt; &#123; <span class="comment">// subscribe to `foo.bar.baz` address</span></div><div class="line">  System.out.println(<span class="string">"2: "</span> + r.body());</div><div class="line">&#125;);</div><div class="line"></div><div class="line">eventBus.publish(<span class="string">"foo.bar.baz"</span>, <span class="string">"+1s"</span>); <span class="comment">// 向此地址发送消息</span></div></pre></td></tr></table></figure>
<p>我们可以通过<code>vertx.eventBus()</code>方法获取<code>EventBus</code>的引用，然后我们就可以通过<code>consume</code>方法订阅某个地址的消息并且绑定一个<code>Handler</code>。接着我们通过<code>publish</code>向此地址发送消息。如果运行上面的例子，我们会得到一下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2: +1s</div><div class="line">1: +1s</div></pre></td></tr></table></figure>
<h2 id="点对点模式">点对点模式</h2><p>如果我们把上面的示例中的<code>publish</code>方法替代成<code>send</code>方法，上面的实例就变成<strong>点对点模式</strong>了。在点对点模式中，消息被发布到Event Bus的某一个地址上。Vert.x会将此消息传递给其中监听此地址的<code>Handler</code>之一。如果有多个<code>Handler</code>绑定到此地址，那么就使用轮询算法随机挑一个<code>Handler</code>传递消息。比如在此示例中，程序只会打印<code>2: +1s</code>或者<code>1: +1s</code>之中的一个。</p>
<h2 id="请求/回应模式">请求/回应模式</h2><p>当我们绑定的<code>Handler</code>接收到消息的时候，我们可不可以给消息的发送者回复呢？当然了！当我们通过<code>send</code>方法发送消息的时候，我们可以同时指定一个回复处理函数(reply handler)。然后当某个消息的订阅者接收到消息的时候，它就可以给发送者回复消息；如果发送者接收到了回复，发送者绑定的回复处理函数就会被调用。这就是<strong>请求/回应模式</strong>。</p>
<p>好啦，现在我们已经粗略了解了Vert.x中的消息系统 - Event Bus的基本使用，下面我们就看看Vert.x Kue的基本设计。有关更多关于Event Bus的信息请参考<a href="http://vertx.io/docs/vertx-core/java/#event_bus" target="_blank" rel="external">Vert.x Core Manual - Event Bus</a>。</p>
<h1 id="Vert-x_Kue_架构设计">Vert.x Kue 架构设计</h1><h2 id="Vert-x_Kue_组件划分">Vert.x Kue 组件划分</h2><p>在我们的项目中，我们将Vert.x Kue划分为两个模块：</p>
<ul>
<li><code>kue-core</code>: 核心组件，提供优先级队列的功能</li>
<li><code>kue-http</code>: Web组件，提供Web UI以及REST API</li>
</ul>
<p>另外我们还提供一个示例模块<code>kue-example</code>用于演示以及阐述如何使用Vert.x Kue。</p>
<p>既然我们的项目有两个模块，那么你一定会好奇：两个模块之间是如何进行通信的？并且如果我们写自己的Kue应用的话，我们该怎样去调用Kue Core中的服务呢？不要着急，谜底将在后边的章节中揭晓:-)</p>
<h2 id="Vert-x_Kue_核心模块">Vert.x Kue 核心模块</h2><p>回顾一下Vert.x Kue的作用 - 优先级工作队列，所以在Vert.x Kue的核心模块中我们设计了以下的类：</p>
<ul>
<li><code>Job</code> - 任务（作业）数据实体</li>
<li><code>JobService</code> - 异步服务接口，提供操作任务以及获取数据的相关逻辑</li>
<li><code>KueWorker</code> - 用于处理任务的Verticle</li>
<li><code>Kue</code> - 工作队列</li>
</ul>
<p>前边我们提到过，我们的两个组件之间需要一种通信机制可以互相通信 - 这里我们使用Vert.x的<strong>集群模式</strong>，即以clustered的模式来部署Verticle。这样的环境下的Event Bus同样也是集群模式的，因此各个组件可以通过集群模式下的Event Bus进行通信。很不错吧？在Vert.x的集群模式下，我们需要指定一个集群管理器<code>ClusterManager</code>。这里我们使用默认的<code>HazelcastClusterManager</code>，使用<strong>Hazelcast</strong>作为集群管理。</p>
<p>在Vert.x Kue中，我们将<code>JobService</code>服务发布至分布式的Event Bus上，这样其它的组件就可以通过Event Bus调用该服务了。我们设计了一个<code>KueVerticle</code>用于注册服务。Vert.x提供了Vert.x Service Proxy（服务代理组件），可以很方便地将服务注册至Event Bus上，然后在其它地方获取此服务的代理并调用。我们将在下面的章节中详细介绍<strong>Vert.x Service Proxy</strong>。</p>
<h2 id="基于Future的异步模式">基于Future的异步模式</h2><p>在我们的Vert.x Kue中，大多数的异步方法都是基于<code>Future</code>的。如果您看过蓝图系列的第一篇文章的话，您一定不会对这种模式很陌生。在Vert.x 3.3.2中，我们的<code>Future</code>支持基本的响应式的操作，比如<code>map</code>和<code>compose</code>。它们用起来非常方便，因为我们可以将多个<code>Future</code>以响应式的方式组合起来而不用担心陷入回调地狱中。</p>
<h2 id="Vert-x_Kue中的事件">Vert.x Kue中的事件</h2><p>正如我们在<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">Vert.x Kue 特性介绍</a>中提到的那样，Vert.x Kue支持两种级别的事件：<strong>任务事件(job events)</strong> 以及 <strong>队列事件(queue events)</strong>。在Vert.x Kue中，我们设计了三种事件地址：</p>
<ul>
<li><code>vertx.kue.handler.job.{handlerType}.{addressId}.{jobType}</code>: 某个特定任务的任务事件地址</li>
<li><code>vertx.kue.handler.workers.{eventType}</code>: （全局）队列事件地址</li>
<li><code>vertx.kue.handler.workers.{eventType}.{addressId}</code>: 某个特定任务的内部事件地址</li>
</ul>
<p>在<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">特性介绍文档</a>中，我们提到了以下几种任务事件：</p>
<ul>
<li><code>start</code> 开始处理一个任务 (<code>onStart</code>)</li>
<li><code>promotion</code> 一个延期的任务时间已到，提升至工作队列中 (<code>onPromotion</code>)</li>
<li><code>progress</code> 任务的进度变化 (<code>onProgress</code>)</li>
<li><code>failed_attempt</code> 任务处理失败，但是还可以重试 (<code>onFailureAttempt</code>)</li>
<li><code>failed</code> 任务处理失败并且不能重试 (<code>onFailure</code>)</li>
<li><code>complete</code> 任务完成 (<code>onComplete</code>)</li>
<li><code>remove</code> 任务从后端存储中移除 (<code>onRemove</code>)</li>
</ul>
<p>队列事件也相似，只不过需要加前缀<code>job_</code>。这些事件都会通过<code>send</code>方法发送至Event Bus上。每一个任务都有对应的任务事件地址，因此它们能够正确地接收到对应的事件并进行相应的处理逻辑。</p>
<p>特别地，我们还有两个内部事件：<code>done</code>和<code>done_fail</code>。<code>done</code>事件对应一个任务在底层的处理已经完成，而<code>done_fail</code>事件对应一个任务在底层的处理失败。这两个事件使用第三种地址进行传递。</p>
<h2 id="任务状态">任务状态</h2><p>在Vert.x Kue中，任务共有五种状态：</p>
<ul>
<li><code>INACTIVE</code>: 任务还未开始处理，在工作队列中等待处理</li>
<li><code>ACTIVE</code>: 任务正在处理中</li>
<li><code>COMPLETE</code>: 任务处理完成</li>
<li><code>FAILED</code>: 任务处理失败</li>
<li><code>DELAYED</code>: 任务延时处理，正在等待计时器时间到并提升至工作队列中</li>
</ul>
<p>我们使用状态图来描述任务状态的变化：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/job_state_machine.png" alt="Job State Machine"></p>
<p>以及任务状态的变化伴随的事件：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/event_emit_state_machine.png" alt="Events with state change"></p>
<h2 id="整体设计">整体设计</h2><p>为了让大家对Vert.x Kue的架构有大致的了解，我用一幅图来简略描述整个Vert.x Kue的设计：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_diagram.png" alt="Diagram - How Vert.x Kue works"></p>
<p>现在我们对Vert.x Kue的设计有了大致的了解了，下面我们就来看一看Vert.x Kue的代码实现了～</p>
<h1 id="项目结构">项目结构</h1><p>我们来开始探索Vert.x Kue的旅程吧！首先我们先从GitHub上clone源代码：</p>
<pre><code>git clone <span class="string">https:</span><span class="comment">//github.com/sczyh30/vertx-blueprint-job-queue.git</span>
</code></pre><p>然后你可以把项目作为Gradle项目导入你的IDE中。（如何导入请参考相关IDE帮助文档）</p>
<p>正如我们之前所提到的，我们的Vert.x Kue中有两个功能模块和一个实例模块，因此我们需要在Gradle工程文件中定义三个子工程。我们来看一下本项目中的<code>build.gradle</code>文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">configure(<span class="keyword">allprojects</span>) &#123; <span class="keyword">project</span> -&gt;</div><div class="line"></div><div class="line">  ext &#123;</div><div class="line">    vertxVersion = <span class="string">"3.3.2"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  apply plugin: <span class="string">'java'</span></div><div class="line"></div><div class="line">  <span class="keyword">repositories</span> &#123;</div><div class="line">    jcenter()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-core:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-codegen:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-rx-java:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-hazelcast:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-lang-ruby:$&#123;vertxVersion&#125;"</span>)</div><div class="line"></div><div class="line">    testCompile(<span class="string">"io.vertx:vertx-unit:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    testCompile <span class="keyword">group</span>: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.12'</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">sourceSets</span> &#123;</div><div class="line">    main &#123;</div><div class="line">      java &#123;</div><div class="line">        srcDirs += <span class="string">'src/main/generated'</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  compileJava &#123;</div><div class="line">    <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">    <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">project</span>(<span class="string">"kue-core"</span>) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-redis-client:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-service-proxy:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jar &#123;</div><div class="line">    archiveName = <span class="string">'vertx-blueprint-kue-core.jar'</span></div><div class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">    manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.queue.KueVerticle'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123; <span class="comment">// codegen</span></div><div class="line">    <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">    <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span></div><div class="line">    <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">    <span class="keyword">options</span>.compilerArgs = [</div><div class="line">      <span class="string">"-proc:only"</span>,</div><div class="line">      <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</div><div class="line">      <span class="string">"-AoutputDirectory=$&#123;project.projectDir&#125;/src/main"</span></div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  compileJava &#123;</div><div class="line">    <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">    <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line"></div><div class="line">    dependsOn annotationProcessing</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">project</span>(<span class="string">"kue-http"</span>) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web-templ-jade:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jar &#123;</div><div class="line">    archiveName = <span class="string">'vertx-blueprint-kue-http.jar'</span></div><div class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">    manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.http.KueHttpVerticle'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">project</span>(<span class="string">"kue-example"</span>) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jar &#123;</div><div class="line">    archiveName = <span class="string">'vertx-blueprint-kue-example.jar'</span></div><div class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">    manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.example.LearningVertxVerticle'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">task</span> wrapper(type: Wrapper) &#123;</div><div class="line">  gradleVersion = <span class="string">'2.12'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(⊙o⊙)…比之前的待办事项服务项目中的长不少诶。。。我们来解释一下：</p>
<ul>
<li>在<code>configure(allprojects)</code>作用域中，我们配置了一些全局信息（对所有子工程都适用）。</li>
<li>我们定义了三个子工程：<code>kue-core</code>、<code>kue-http</code>以及<code>kue-example</code>。这里我们来解释一下里面用到的依赖。在<code>kue-core</code>中，<code>vertx-redis-client</code>用于Redis通信，<code>vertx-service-proxy</code>用于Event Bus上的服务代理。在<code>kue-http</code>中，我们将<code>kue-core</code>子工程作为它的一个依赖。<code>vertx-web</code>和<code>vertx-web-templ-jade</code>用于Kue Web端的开发。</li>
<li>任务<code>annotationProcessing</code>用于注解处理（Vert.x Codegen）。我们已经在上一篇教程中介绍过了，这里就不展开讲了。</li>
</ul>
<p>我们还需要在 <code>settings.gradle</code> 中配置工程：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rootProject.name = <span class="string">'vertx-blueprint-job-queue'</span></div><div class="line"></div><div class="line"><span class="keyword">include</span> <span class="string">"kue-core"</span></div><div class="line"><span class="keyword">include</span> <span class="string">"kue-http"</span></div><div class="line"><span class="keyword">include</span> <span class="string">"kue-example"</span></div></pre></td></tr></table></figure>
<p>看完了配置文件以后，我们再来浏览一下我们的项目目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── build.gradle</div><div class="line">├── kue-core</div><div class="line">│   └── src</div><div class="line">│       ├── main</div><div class="line">│       │   ├── java</div><div class="line">│       │   └── resources</div><div class="line">│       └── test</div><div class="line">│           ├── java</div><div class="line">│           └── resources</div><div class="line">├── kue-example</div><div class="line">│   └── src</div><div class="line">│       ├── main</div><div class="line">│       │   ├── java</div><div class="line">│       │   └── resources</div><div class="line">│       └── test</div><div class="line">│           ├── java</div><div class="line">│           └── resources</div><div class="line">├── kue-http</div><div class="line">│   └── src</div><div class="line">│       ├── main</div><div class="line">│       │   ├── java</div><div class="line">│       │   └── resources</div><div class="line">│       └── test</div><div class="line">│           ├── java</div><div class="line">│           └── resources</div><div class="line">└── settings.gradle</div></pre></td></tr></table></figure>
<p>在Gradle中，项目的源码都位于<code>{projectName}/src/main/java</code>目录内。这篇教程是围绕Vert.x Kue Core的，所以我们的代码都在<code>kue-core</code>目录中。</p>
<p>好啦！现在我们已经对Vert.x Kue项目的整体结构有了大致的了解了，下面我们开始源码探索之旅！</p>
<h1 id="任务实体_-_不仅仅是一个数据对象">任务实体 - 不仅仅是一个数据对象</h1><p>Vert.x Kue是用来处理任务的，因此我们先来看一下代表任务实体的<code>Job</code>类。<code>Job</code>类位于<code>io.vertx.blueprint.kue.queue</code>包下。代码可能有点长，不要担心，我们把它分成几部分，分别来解析。</p>
<h2 id="任务成员属性">任务成员属性</h2><p>我们先来看一下<code>Job</code>类中的成员属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@DataObject</span>(generateConverter = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    <span class="comment">// job properties</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address_id;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> String zid;</div><div class="line">    <span class="keyword">private</span> String type;</div><div class="line">    <span class="keyword">private</span> JsonObject data;</div><div class="line">    <span class="keyword">private</span> Priority priority = Priority.NORMAL;</div><div class="line">    <span class="keyword">private</span> JobState state = JobState.INACTIVE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delay = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max_attempts = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> removeOnComplete = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ttl = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> JsonObject backoff;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> attempts = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> progress = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> JsonObject result;</div><div class="line"></div><div class="line">    <span class="comment">// job metrics</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> created_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> promote_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> updated_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> failed_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> started_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> duration;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我去。。。好多属性！我们一个一个地解释：</p>
<ul>
<li><code>address_id</code>: 一个UUID序列，作为Event Bus的地址</li>
<li><code>id</code>: 任务的编号(id)</li>
<li><code>type</code>: 任务的类型</li>
<li><code>data</code>: 任务携带的数据，以 <code>JsonObject</code> 类型表示</li>
<li><code>priority</code>: 任务优先级，以 <code>Priority</code> 枚举类型表示。默认优先级为正常(<code>NORMAL</code>)</li>
<li><code>delay</code>: 任务的延迟时间，默认是 <strong>0</strong></li>
<li><code>state</code>: 任务状态，以 <code>JobState</code> 枚举类型表示。默认状态为等待(<code>INACTIVE</code>)</li>
<li><code>attempts</code>: 任务已经尝试执行的次数</li>
<li><code>max_attempts</code>: 任务尝试执行次数的最大阈值</li>
<li><code>removeOnComplete</code>: 代表任务完成时是否自动从后台移除</li>
<li><code>zid</code>: <code>zset</code>操作对应的编号(zid)，保持先进先出顺序</li>
<li><code>ttl</code>: TTL(Time to live)</li>
<li><code>backoff</code>: 任务重试配置，以 <code>JsonObject</code> 类型表示</li>
<li><code>progress</code>: 任务执行的进度</li>
<li><code>result</code>: 任务执行的结果，以 <code>JsonObject</code> 类型表示</li>
</ul>
<p>还有这些统计数据：</p>
<ul>
<li><code>created_at</code>: 代表此任务创建的时间</li>
<li><code>promote_at</code>: 代表此任务从延时状态被提升至等待状态时的时间</li>
<li><code>updated_at</code>: 代表任务更新的时间</li>
<li><code>failed_at</code>: 代表任务失败的时间</li>
<li><code>started_at</code>: 代表任务开始的时间</li>
<li><code>duration</code>: 代表处理任务花费的时间，单位为毫秒(<code>ms</code>)</li>
</ul>
<p>你可能注意到在 <code>Job</code> 类中还存在着几个静态成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Job.class);</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vertx vertx;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisClient client;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> EventBus eventBus;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setVertx</span><span class="params">(Vertx v, RedisClient redisClient)</span> </span>&#123;</div><div class="line">  vertx = v;</div><div class="line">  client = redisClient;</div><div class="line">  eventBus = vertx.eventBus();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 <code>logger</code> 对象，我想大家应该都很熟悉，它代表一个Vert.x Logger实例用于日志记录。但是你一定想问为什么 <code>Job</code> 类中存在着一个<code>Vertx</code>类型的静态成员。<code>Job</code>类不应该是一个数据对象吗？当然咯！<code>Job</code>类代表一个数据对象，但<strong>不仅仅</strong>是一个数据对象。这里我模仿了一些Automattic/kue的风格，把一些任务相关逻辑方法放到了<code>Job</code>类里，它们大多都是基于<code>Future</code>的异步方法，因此可以很方便地去调用以及进行组合变换。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">job.save()</div><div class="line">    .compose(Job::updateNow)</div><div class="line">    .compose(j -&gt; j.log(<span class="string">"good!"</span>));</div></pre></td></tr></table></figure>
<p>由于我们不能在<code>Job</code>类被JVM加载的时候就获取<code>Vertx</code>实例，我们必须手动给<code>Job</code>类中的静态<code>Vertx</code>成员赋值。这里我们是在<code>Kue</code>类中对其进行赋值的。当我们创建一个工作队列的时候，<code>Job</code>类中的静态成员变量会被初始化。同时为了保证程序的正确性，我们需要一个方法来检测静态成员变量是否初始化。当我们在创建一个任务的时候，如果静态成员此时未被初始化，那么日志会给出警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">_checkStatic</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (vertx == <span class="keyword">null</span>) &#123;</div><div class="line">    logger.warn(<span class="string">"static Vertx instance in Job class is not initialized!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还注意到 <code>Job</code> 类也是由<code>@DataObject</code>注解修饰的。Vert.x Codegen可以处理含有<code>@DataObject</code>注解的类并生成对应的JSON转换器，并且Vert.x Service Proxy也需要数据对象。</p>
<p>在<code>Job</code>类中我们有四个构造函数。其中<code>address_id</code>成员必须在一个任务被创建时就被赋值，默认情况下此地址用一个唯一的UUID字符串表示。每一个构造函数中我们都要调用<code>_checkStatic</code>函数来检测静态成员变量是否被初始化。</p>
<h2 id="任务事件辅助函数">任务事件辅助函数</h2><p>正如我们之前所提到的那样，我们通过一个特定的地址<code>vertx.kue.handler.job.{handlerType}.{addressId}.{jobType}</code>在分布式的Event Bus上发送和接收任务事件(job events)。所以我们提供了两个用于发送和接收事件的辅助函数<code>emit</code>和<code>on</code>(类似于Node.js中的<code>EventEmitter</code>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Job <span class="title">on</span><span class="params">(String event, Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</div><div class="line">  logger.debug(<span class="string">"[LOG] On: "</span> + Kue.getCertainJobAddress(event, <span class="keyword">this</span>));</div><div class="line">  eventBus.consumer(Kue.getCertainJobAddress(event, <span class="keyword">this</span>), handler);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">emit</span><span class="params">(String event, Object msg)</span> </span>&#123;</div><div class="line">  logger.debug(<span class="string">"[LOG] Emit: "</span> + Kue.getCertainJobAddress(event, <span class="keyword">this</span>));</div><div class="line">  eventBus.send(Kue.getCertainJobAddress(event, <span class="keyword">this</span>), msg);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在后面的代码中，我们将频繁使用这两个辅助函数。</p>
<h2 id="Redis中的存储形式">Redis中的存储形式</h2><p>在我们探索相关的逻辑函数之前，我们先来描述一下Vert.x Kue的数据在Redis中是以什么样的形式存储的：</p>
<ul>
<li>所有的key都在<code>vertx_kue</code>命名空间下(以<code>vertx_kue:</code>作为前缀)</li>
<li><code>vertx:kue:job:{id}</code>: 存储任务实体的map</li>
<li><code>vertx:kue:ids</code>: 计数器，指示当前最大的任务ID</li>
<li><code>vertx:kue:job:types</code>: 存储所有任务类型的列表</li>
<li><code>vertx:kue:{type}:jobs</code>: 指示所有等待状态下的某种类型任务的列表</li>
<li><code>vertx_kue:jobs</code>: 存储所有任务<code>zid</code>的有序集合</li>
<li><code>vertx_kue:job:{state}</code>: 存储所有指定状态的任务<code>zid</code>的有序集合</li>
<li><code>vertx_kue:jobs:{type}:{state}</code>: 存储所有指定状态和类型的任务<code>zid</code>的有序集合</li>
<li><code>vertx:kue:job:{id}:log</code>: 存储指定<code>id</code>的任务对应日志的列表</li>
</ul>
<p>OK，下面我们就来看看<code>Job</code>类中重要的逻辑函数。</p>
<h2 id="改变任务状态">改变任务状态</h2><p>我们之前提到过，Vert.x Kue中的任务一共有五种状态。所有的任务相关的操作都伴随着任务状态的变换，因此我们先来看一下<code>state</code>方法的实现，它用于改变任务的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">state</span><span class="params">(JobState newState)</span> </span>&#123;</div><div class="line">  Future&lt;Job&gt; future = Future.future();</div><div class="line">  RedisClient client = RedisHelper.client(vertx, <span class="keyword">new</span> JsonObject()); <span class="comment">// use a new client to keep transaction</span></div><div class="line">  JobState oldState = <span class="keyword">this</span>.state;</div><div class="line">  client.transaction().multi(r0 -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (r0.succeeded()) &#123;</div><div class="line">      <span class="keyword">if</span> (oldState != <span class="keyword">null</span> &amp;&amp; !oldState.equals(newState)) &#123; <span class="comment">// (2)</span></div><div class="line">        client.transaction().zrem(RedisHelper.getStateKey(oldState), <span class="keyword">this</span>.zid, _failure())</div><div class="line">          .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + oldState.name()), <span class="keyword">this</span>.zid, _failure());</div><div class="line">      &#125;</div><div class="line">      client.transaction().hset(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), <span class="string">"state"</span>, newState.name(), _failure()) <span class="comment">// (3)</span></div><div class="line">        .zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure())</div><div class="line">        .zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + newState.name()), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure());</div><div class="line"></div><div class="line">      <span class="keyword">switch</span> (newState) &#123; <span class="comment">// dispatch different state</span></div><div class="line">        <span class="keyword">case</span> ACTIVE: <span class="comment">// (4)</span></div><div class="line">          client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</div><div class="line">            <span class="keyword">this</span>.priority.getValue() &lt; <span class="number">0</span> ? <span class="keyword">this</span>.priority.getValue() : -<span class="keyword">this</span>.priority.getValue(),</div><div class="line">            <span class="keyword">this</span>.zid, _failure());</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> DELAYED: <span class="comment">// (5)</span></div><div class="line">          client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</div><div class="line">            <span class="keyword">this</span>.promote_at, <span class="keyword">this</span>.zid, _failure());</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> INACTIVE: <span class="comment">// (6)</span></div><div class="line">          client.transaction().lpush(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="string">"1"</span>, _failure());</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.state = newState;</div><div class="line"></div><div class="line">      client.transaction().exec(r -&gt; &#123; <span class="comment">// (7)</span></div><div class="line">        <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">          future.complete(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          future.fail(r.cause());</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      future.fail(r0.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> future.compose(Job::updateNow);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们先创建了一个<code>Future</code>对象。然后我们调用了 <code>client.transaction().multi(handler)</code> 函数开始一次Redis事务 (1)。在Vert.x 3.3.2中，所有的Redis事务操作都移至<code>RedisTransaction</code>类中，所以我们需要先调用<code>client.transaction()</code>方法去获取一个事务实例，然后调用<code>multi</code>代表事务块的开始。</p>
<p>在<code>multi</code>函数传入的<code>Handler</code>中，我们先判定当前的任务状态。如果当前任务状态不为空并且不等于新的任务状态，我们就将Redis中存储的旧的状态信息移除 (2)。为了方便起见，我们提供了一个<code>RedisHelper</code>辅助类，里面提供了一些生成特定地址以及编码解码<code>zid</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.util;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.JobState;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Vertx;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisOptions;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisHelper</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERTX_KUE_REDIS_PREFIX = <span class="string">"vertx_kue"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">RedisHelper</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisClient <span class="title">client</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> RedisClient.create(vertx, options(config));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisOptions <span class="title">options</span><span class="params">(JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisOptions()</div><div class="line">      .setHost(config.getString(<span class="string">"redis.host"</span>, <span class="string">"127.0.0.1"</span>))</div><div class="line">      .setPort(config.getInteger(<span class="string">"redis.port"</span>, <span class="number">6379</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> VERTX_KUE_REDIS_PREFIX + <span class="string">":"</span> + key;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStateKey</span><span class="params">(JobState state)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> VERTX_KUE_REDIS_PREFIX + <span class="string">":jobs:"</span> + state.name();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createFIFO</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">    String idLen = <span class="string">""</span> + (<span class="string">""</span> + id).length();</div><div class="line">    <span class="keyword">int</span> len = <span class="number">2</span> - idLen.length();</div><div class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>)</div><div class="line">      idLen = <span class="string">"0"</span> + idLen;</div><div class="line">    <span class="keyword">return</span> idLen + <span class="string">"|"</span> + id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stripFIFO</span><span class="params">(String zid)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> zid.substring(zid.indexOf(<span class="string">'|'</span>) + <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">numStripFIFO</span><span class="params">(String zid)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Long.parseLong(zid.substring(zid.indexOf(<span class="string">'|'</span>) + <span class="number">1</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的key都必须在<code>vertx_kue</code>命名空间下，因此我们封装了一个<code>getKey</code>方法。我们还实现了<code>createFIFO</code>和<code>stripFIFO</code>方法用于生成<code>zid</code>以及解码<code>zid</code>。<code>zid</code>的格式使用了Automattic/Kue中的格式。</p>
<p>回到<code>state</code>方法来。我们使用<code>zrem(String key, String member, Handler&lt;AsyncResult&lt;String&gt;&gt; handler)</code>方法将特定的数据从有序集合中移除。两个key分别是<code>vertx_kue:job:{state}</code> 以及 <code>vertx_kue:jobs:{type}:{state}</code>；<code>member</code>对应着任务的<code>zid</code>。</p>
<p>接下来我们使用<code>hset</code>方法来变更新的状态 (3)，然后用<code>zadd</code>方法往<code>vertx_kue:job:{state}</code> 和 <code>vertx_kue:jobs:{type}:{state}</code>两个有序集合中添加此任务的<code>zid</code>，同时传递一个<strong>权重</strong>(score)。这个非常重要，我们就是通过这个实现<strong>优先级</strong>队列的。我们直接使用<code>priority</code>对应的值作为<code>score</code>。这样，当我们需要从Redis中获取任务的时候，我们就可以通过<code>zpop</code>方法获取优先级最高的任务。我们会在后面详细讲述。</p>
<p>不同的新状态需要不同的操作。对于<code>ACTIVE</code>状态，我们通过<code>zadd</code>命令将<code>zid</code>添加至<code>vertx_kue:jobs:ACTIVE</code>有序集合中并赋予优先级权值 (4)。对于<code>DELAYED</code>状态，我们通过<code>zadd</code>命令将<code>zid</code>添加至<code>vertx_kue:jobs:DELAYED</code>有序集合中并赋予提升时间(<code>promote_at</code>)权值 (5)。对于<code>INACTIVE</code>状态，我们向<code>vertx:kue:{type}:jobs</code>列表中添加一个元素 (6)。这些操作都是在Redis事务块内完成的。最后我们通过<code>exec</code>方法一并执行这些事务操作 (7)。如果执行成功，我们给<code>future</code>赋值（当前任务）。最后我们返回<code>future</code>并且与<code>updateNow</code>方法相组合。</p>
<p><code>updateNow</code>方法非常简单，就是把<code>updated_at</code>的值设为当前时间，然后存到Redis中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">Future&lt;Job&gt; <span class="title">updateNow</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.updated_at = System.currentTimeMillis();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.set(<span class="string">"updated_at"</span>, String.valueOf(updated_at));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="保存任务">保存任务</h2><p>这里我们来看一下整个<code>Job</code>类中最重要的方法之一 - <code>save</code>方法，它的作用是保存任务至Redis中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">save</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// check</span></div><div class="line">  Objects.requireNonNull(<span class="keyword">this</span>.type, <span class="string">"Job type cannot be null"</span>); <span class="comment">// (1)</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> update(); <span class="comment">// (2)</span></div><div class="line"></div><div class="line">  Future&lt;Job&gt; future = Future.future();</div><div class="line"></div><div class="line">  <span class="comment">// 生成id</span></div><div class="line">  client.incr(RedisHelper.getKey(<span class="string">"ids"</span>), res -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      <span class="keyword">this</span>.id = res.result();</div><div class="line">      <span class="keyword">this</span>.zid = RedisHelper.createFIFO(id); <span class="comment">// (4)</span></div><div class="line">      String key = RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.delay &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.state = JobState.DELAYED;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      client.sadd(RedisHelper.getKey(<span class="string">"job:types"</span>), <span class="keyword">this</span>.type, _failure()); <span class="comment">// (5)</span></div><div class="line">       <span class="keyword">this</span>.created_at = System.currentTimeMillis();</div><div class="line">       <span class="keyword">this</span>.promote_at = <span class="keyword">this</span>.created_at + <span class="keyword">this</span>.delay;</div><div class="line">       <span class="comment">// 保存任务</span></div><div class="line">       client.hmset(key, <span class="keyword">this</span>.toJson(), _completer(future, <span class="keyword">this</span>)); <span class="comment">// (6)</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      future.fail(res.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> future.compose(Job::update); <span class="comment">// (7)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，任务类型不能为空所以我们要检查<code>type</code>是否为空 (1)。接着，如果当前任务的id大于0，则代表此任务已经存储过（因为id是存储时分配），此时只需执行更新操作(<code>update</code>)即可 (2)。然后我们创建一个<code>Future</code>对象，然后使用<code>incr</code>方法从<code>vertx_kue:ids</code>字段获取一个新的<code>id</code> (3)。同时我们使用<code>RedisHelper.createFIFO(id)</code>方法来生成新的<code>zid</code> (4)。接着我们来判断任务延时是否大于0，若大于0则将当前任务状态设置为<code>DELAYED</code>。然后我们通过<code>sadd</code>方法将当前任务类型添加至<code>vertx:kue:job:types</code>列表中 (5) 并且保存任务创建时间(<code>created_at</code>)以及任务提升时间(<code>promote_at</code>)。经过这一系列的操作后，所有的属性都已准备好，所以我们可以利用<code>hmset</code>方法将此任务实体存储至<code>vertx:kue:job:{id}</code>哈希表中 (6)。如果存储操作成功，那么将当前任务实体赋给<code>future</code>，否则记录错误。最后我们返回此<code>future</code>并且将其与<code>update</code>方法进行组合。</p>
<p><code>update</code>方法进行一些更新操作，它的逻辑比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">Future&lt;Job&gt; <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">  Future&lt;Job&gt; future = Future.future();</div><div class="line">  <span class="keyword">this</span>.updated_at = System.currentTimeMillis();</div><div class="line"></div><div class="line">  client.transaction().multi(_failure())</div><div class="line">    .hset(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), <span class="string">"updated_at"</span>, String.valueOf(<span class="keyword">this</span>.updated_at), _failure())</div><div class="line">    .zadd(RedisHelper.getKey(<span class="string">"jobs"</span>), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure())</div><div class="line">    .exec(_completer(future, <span class="keyword">this</span>));</div><div class="line"></div><div class="line">  <span class="keyword">return</span> future.compose(r -&gt;</div><div class="line">    <span class="keyword">this</span>.state(<span class="keyword">this</span>.state));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>update</code>方法只做了三件微小的工作：存储任务更新时间、存储<code>zid</code>以及更改当前任务状态（组合<code>state</code>方法）。</p>
<p>最后总结一下将一个任务存储到Redis中经过的步骤：<code>save -&gt; update -&gt; state</code> :-)</p>
<h2 id="移除任务">移除任务</h2><p>移除任务非常简单，借助<code>zrem</code>和<code>del</code>方法即可。我们来看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Void&gt; <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">  Future&lt;Void&gt; future = Future.future();</div><div class="line">  client.transaction().multi(_failure())</div><div class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.stateName()), <span class="keyword">this</span>.zid, _failure())</div><div class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + <span class="keyword">this</span>.stateName()), <span class="keyword">this</span>.zid, _failure())</div><div class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs"</span>), <span class="keyword">this</span>.zid, _failure())</div><div class="line">    .del(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id + <span class="string">":log"</span>), _failure())</div><div class="line">    .del(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), _failure())</div><div class="line">    .exec(r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">"remove"</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"id"</span>, <span class="keyword">this</span>.id));</div><div class="line">        future.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        future.fail(r.cause());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  <span class="keyword">return</span> future;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到成功移除任务时，我们会向Event Bus上的特定地址发送<code>remove</code>任务事件。此事件包含着被移除任务的<code>id</code>。</p>
<h2 id="监听任务事件">监听任务事件</h2><p>我们可以通过几种 <code>onXXX</code> 方法来监听任务事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onComplete</span><span class="params">(Handler&lt;Job&gt; completeHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"complete"</span>, message -&gt; &#123;</div><div class="line">    completeHandler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onFailure</span><span class="params">(Handler&lt;JsonObject&gt; failureHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"failed"</span>, message -&gt; &#123;</div><div class="line">    failureHandler.handle((JsonObject) message.body());</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onFailureAttempt</span><span class="params">(Handler&lt;JsonObject&gt; failureHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"failed_attempt"</span>, message -&gt; &#123;</div><div class="line">    failureHandler.handle((JsonObject) message.body());</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onPromotion</span><span class="params">(Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"promotion"</span>, message -&gt; &#123;</div><div class="line">    handler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onStart</span><span class="params">(Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"start"</span>, message -&gt; &#123;</div><div class="line">    handler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onRemove</span><span class="params">(Handler&lt;JsonObject&gt; removeHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"start"</span>, message -&gt; &#123;</div><div class="line">    removeHandler.handle((JsonObject) message.body());</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onProgress</span><span class="params">(Handler&lt;Integer&gt; progressHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"progress"</span>, message -&gt; &#123;</div><div class="line">    progressHandler.handle((Integer) message.body());</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到不同的事件，对应接收的数据类型也有差异。我们来说明一下：</p>
<ul>
<li><code>onComplete</code>、<code>onPromotion</code> 以及 <code>onStart</code>: 发送的数据是对应的<code>Job</code>对象</li>
<li><code>onFailure</code> and <code>onFailureAttempt</code>: 发送的数据是<code>JsonObject</code>类型的，其格式类似于：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"job"</span>: &#123;&#125;,</div><div class="line">    <span class="attr">"extra"</span>: &#123;</div><div class="line">        <span class="attr">"message"</span>: <span class="string">"some_error"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>onProgress</code>: 发送的数据是当前任务进度</li>
<li><code>onRemove</code>: 发送的数据是<code>JsonObject</code>类型的，其中<code>id</code>代表被移除任务的编号</li>
</ul>
<h2 id="更新任务进度">更新任务进度</h2><p>我们可以通过<code>progress</code>方法来更新任务进度。看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">progress</span><span class="params">(<span class="keyword">int</span> complete, <span class="keyword">int</span> total)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> n = Math.min(<span class="number">100</span>, complete * <span class="number">100</span> / total); <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">this</span>.emit(<span class="string">"progress"</span>, n); <span class="comment">// (2)</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.setProgress(n) <span class="comment">// (3)</span></div><div class="line">    .set(<span class="string">"progress"</span>, String.valueOf(n))</div><div class="line">    .compose(Job::updateNow);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>progress</code>方法接受两个参数：第一个是当前完成的进度值，第二个是完成状态需要的进度值。我们首先计算出当前的进度 (1)，然后向特定地址发送<code>progress</code>事件 (2)。最后我们将进度存储至Redis中并更新时间，返回<code>Future</code> (3)。</p>
<h2 id="任务失败以及重试机制">任务失败以及重试机制</h2><p>当一个任务处理失败时，如果它有剩余的重试次数，Vert.x Kue会自动调用<code>failAttempt</code>方法进行重试。我们来看一下<code>failAttempt</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">Future&lt;Job&gt; <span class="title">failedAttempt</span><span class="params">(Throwable err)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.error(err)</div><div class="line">    .compose(Job::failed)</div><div class="line">    .compose(Job::attemptInternal);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(⊙o⊙)非常简短吧～实际上，<code>failAttempt</code>方法是三个异步方法的组合：<code>error</code>、<code>failed</code>以及<code>attemptInternal</code>。当一个任务需要进行重试的时候，我们首先向Event Bus发布 <code>error</code> 队列事件并且在Redis中记录日志，然后将当前的任务状态置为<code>FAILED</code>，最后重新处理此任务。</p>
<p>我们先来看一下<code>error</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">error</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.emitError(ex)</div><div class="line">    .set(<span class="string">"error"</span>, ex.getMessage())</div><div class="line">    .compose(j -&gt; j.log(<span class="string">"error | "</span> + ex.getMessage()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的逻辑很简单：首先我们向Event Bus发布 <strong>错误</strong> 事件，然后记录错误日志即可。这里我们封装了一个发布错误的函数<code>emitError</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">emitError</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">  JsonObject errorMessage = <span class="keyword">new</span> JsonObject().put(<span class="string">"id"</span>, <span class="keyword">this</span>.id)</div><div class="line">    .put(<span class="string">"message"</span>, ex.getMessage());</div><div class="line">  eventBus.publish(Kue.workerAddress(<span class="string">"error"</span>), errorMessage);</div><div class="line">  eventBus.send(Kue.getCertainJobAddress(<span class="string">"error"</span>, <span class="keyword">this</span>), errorMessage);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中发送的错误信息格式类似于下面的样子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"id"</span>: <span class="number">2052</span>,</div><div class="line">    <span class="attr">"message"</span>: <span class="string">"some error"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们再来看一下<code>failed</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">failed</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.failed_at = System.currentTimeMillis();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.updateNow()</div><div class="line">    .compose(j -&gt; j.set(<span class="string">"failed_at"</span>, String.valueOf(j.failed_at)))</div><div class="line">    .compose(j -&gt; j.state(JobState.FAILED));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简单，首先我们更新任务的更新时间和失败时间，然后通过<code>state</code>方法将当前任务状态置为<code>FAILED</code>即可。</p>
<p>任务重试的核心逻辑在<code>attemptInternal</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;Job&gt; <span class="title">attemptInternal</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> remaining = <span class="keyword">this</span>.max_attempts - <span class="keyword">this</span>.attempts; <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">if</span> (remaining &gt; <span class="number">0</span>) &#123; <span class="comment">// 还有重试次数</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.attemptAdd() <span class="comment">// (2)</span></div><div class="line">      .compose(Job::reattempt) <span class="comment">// (3)</span></div><div class="line">      .setHandler(r -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">          <span class="keyword">this</span>.emitError(r.cause()); <span class="comment">// (4)</span></div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123; <span class="comment">// (5)</span></div><div class="line">    <span class="keyword">return</span> Future.failedFuture(<span class="string">"No more attempts"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// (6)</span></div><div class="line">    <span class="keyword">return</span> Future.failedFuture(<span class="keyword">new</span> IllegalStateException(<span class="string">"Attempts Exceeded"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我们的<code>Job</code>数据对象中，我们存储了最大重试次数<code>max_attempts</code>以及已经重试的次数<code>attempts</code>，所以我们首先根据这两个数据计算剩余的重试次数<code>remaining</code> (1)。如果还有剩余次数的话，我们就先调用<code>attemptAdd</code>方法增加一次已重试次数并 (2)，然后我们调用<code>reattempt</code>方法执行真正的任务重试逻辑 (3)。最后返回这两个异步方法组合的<code>Future</code>。如果其中一个过程出现错误，我们就发布<code>error</code>事件 (4)。如果没有剩余次数了或者超出剩余次数了，我们直接返回错误。</p>
<p>在我们解析<code>reattempt</code>方法之前，我们先来回顾一下Vert.x Kue中的任务失败恢复机制。Vert.x Kue支持延时重试机制(retry backoff)，并且支持不同的策略（如 <strong>fixed</strong> 以及 <strong>exponential</strong>）。之前我们提到<code>Job</code>类中有一个<code>backoff</code>成员变量，它用于配置延时重试的策略。它的格式类似于这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"type"</span>: <span class="string">"fixed"</span>,</div><div class="line">    <span class="attr">"delay"</span>: <span class="number">5000</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>延时重试机制的实现在<code>getBackoffImpl</code>方法中，它返回一个<code>Function&lt;Integer, Long&gt;</code>对象，代表一个接受<code>Integer</code>类型（即<code>attempts</code>），返回<code>Long</code>类型（代表计算出的延时值）的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Function&lt;Integer, Long&gt; <span class="title">getBackoffImpl</span><span class="params">()</span> </span>&#123;</div><div class="line">  String type = <span class="keyword">this</span>.backoff.getString(<span class="string">"type"</span>, <span class="string">"fixed"</span>); <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">long</span> _delay = <span class="keyword">this</span>.backoff.getLong(<span class="string">"delay"</span>, <span class="keyword">this</span>.delay); <span class="comment">// (2)</span></div><div class="line">  <span class="keyword">switch</span> (type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"exponential"</span>: <span class="comment">// (3)</span></div><div class="line">      <span class="keyword">return</span> attempts -&gt; Math.round(_delay * <span class="number">0.5</span> * (Math.pow(<span class="number">2</span>, attempts) - <span class="number">1</span>));</div><div class="line">    <span class="keyword">case</span> <span class="string">"fixed"</span>:</div><div class="line">    <span class="keyword">default</span>: <span class="comment">// (4)</span></div><div class="line">      <span class="keyword">return</span> attempts -&gt; _delay;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们从<code>backoff</code>配置中获取延迟重试策略。目前Vert.x Kue支持两种策略：<code>fixed</code> 和 <code>exponential</code>。前者采用固定延迟时间，而后者采用指数增长型延迟时间。默认情况下Vert.x Kue会采用<code>fixed</code>策略 (1)。接下来我们从<code>backoff</code>配置中获取延迟时间，如果配置中没有指定，那么就使用任务对象中的延迟时间<code>delay</code> (2)。接下来就是根据具体的策略进行计算了。对于指数型延迟，我们计算<code>[delay * 0.5 * 2^attempts]</code>作为延迟时间 (3)；对于固定型延迟策略，我们直接使用获取到的延迟时间 (4)。</p>
<p>好啦，现在回到“真正的重试”方法 —— <code>reattempt</code>方法来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;Job&gt; <span class="title">reattempt</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.backoff != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">long</span> delay = <span class="keyword">this</span>.getBackoffImpl().apply(attempts); <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.setDelay(delay)</div><div class="line">      .setPromote_at(System.currentTimeMillis() + delay)</div><div class="line">      .update() <span class="comment">// (2)</span></div><div class="line">      .compose(Job::delayed); <span class="comment">// (3)</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.inactive(); <span class="comment">// (4)</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们先检查<code>backoff</code>配置是否存在，若存在则计算出对应的延时时间 (1) 并且设定<code>delay</code>和<code>promote_at</code>属性的值然后保存至Redis中 (2)。接着我们通过<code>delayed</code>方法将任务的状态设为延时(<code>DELAYED</code>) (3)。如果延时重试配置不存在，我们就通过<code>inactive</code>方法直接将此任务置入工作队列中 (4)。</p>
<p>这就是整个任务重试功能的实现，也不是很复杂蛤？观察上面的代码，我们可以发现<code>Future</code>组合无处不在。这种响应式的组合非常方便。想一想如果我们用回调的异步方式来写代码的话，我们很容易陷入回调地狱中(⊙o⊙)。。。几个回调嵌套起来总显得不是那么优美和简洁，而用响应式的、可组合的<code>Future</code>就可以有效地避免这个问题。</p>
<p>不错！到现在为止我们已经探索完<code>Job</code>类的源码了～下面我们来看一下<code>JobService</code>类。</p>
<h1 id="Event_Bus_服务_-_JobService">Event Bus 服务 - JobService</h1><p>在本章节中我们来探索一下<code>JobService</code>接口及其实现 —— 它包含着各种普通的操作和统计<code>Job</code>的逻辑。</p>
<h2 id="异步RPC">异步RPC</h2><p>我们的<code>JobService</code>是一个通用逻辑接口，因此我们希望应用中的每一个组件都能访问此服务，即进行RPC。在Vert.x中，我们可以将服务注册至Event Bus上，然后其它组件就可以通过Event Bus来远程调用注册的服务了。</p>
<p>传统的RPC有一个缺点：消费者需要阻塞等待生产者的回应。你可能想说：这是一种阻塞模型，和Vert.x推崇的异步开发模式不相符。没错！而且，传统的RPC不是真正<strong>面向失败设计</strong>的。</p>
<p>还好，Vert.x提供了一种高效的、响应式的RPC —— 异步RPC。我们不需要等待生产者的回应，而只需要传递一个<code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code>参数给异步方法。这样当收到生产者结果时，对应的<code>Handler</code>就会被调用，非常方便，这与Vert.x的异步开发模式相符。并且，<code>AsyncResult</code>也是面向失败设计的。</p>
<p>所以讲到这里，你可能想问：到底怎么在Event Bus上注册服务呢？我们是不是需要写一大堆的逻辑去包装和发送信息，然后在另一端解码信息并进行调用呢？不，这太麻烦了！有了Vert.x 服务代理，我们不需要这么做！Vert.x提供了一个组件 <strong>Vert.x Service Proxy</strong> 来自动生成服务代理。有了它的帮助，我们就只需要按照规范设计我们的异步服务接口，然后用<code>@ProxyGen</code>注解修饰即可。</p>
<p>[NOTE <code>@ProxyGen</code>注解的限制 | <code>@ProxyGen</code>注解的使用有诸多限制。比如，所有的异步方法都必须是基于回调的，也就是说每个方法都要接受一个<code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code>类型的参数。并且，类型<code>R</code>也是有限制的 —— 只允许基本类型以及数据对象类型。详情请参考<a href="http://vertx.io/docs/vertx-service-proxy/" target="_blank" rel="external">官方文档</a>。 ]</p>
<h2 id="异步服务接口">异步服务接口</h2><p>我们来看一下<code>JobService</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ProxyGen</span></div><div class="line"><span class="meta">@VertxGen</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> JobService <span class="title">create</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JobServiceImpl(vertx, config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> JobService <span class="title">createProxy</span><span class="params">(Vertx vertx, String address)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ProxyHelper.createProxy(JobService.class, vertx, address);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取任务，按照优先级顺序</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> id      job id</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Job&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 删除任务</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> id      job id</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">removeJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Void&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 判断任务是否存在</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> id      job id</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">existsJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Boolean&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取任务日志</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> id      job id</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getJobLog</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;JsonArray&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取某一范围内某个指定状态下的任务列表</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> state   expected job state</div><div class="line">   * <span class="doctag">@param</span> from    from</div><div class="line">   * <span class="doctag">@param</span> to      to</div><div class="line">   * <span class="doctag">@param</span> order   range order</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">jobRangeByState</span><span class="params">(String state, <span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取某一范围内某个指定状态和类型下的任务列表</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type    expected job type</div><div class="line">   * <span class="doctag">@param</span> state   expected job state</div><div class="line">   * <span class="doctag">@param</span> from    from</div><div class="line">   * <span class="doctag">@param</span> to      to</div><div class="line">   * <span class="doctag">@param</span> order   range order</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">jobRangeByType</span><span class="params">(String type, String state, <span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取某一范围内的任务列表（按照顺序或倒序）</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> from    from</div><div class="line">   * <span class="doctag">@param</span> to      to</div><div class="line">   * <span class="doctag">@param</span> order   range order</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">jobRange</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// 统计函数</span></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取指定状态和类型下的任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type    job type</div><div class="line">   * <span class="doctag">@param</span> state   job state</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">cardByType</span><span class="params">(String type, JobState state, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取某个状态下的任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> state   job state</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">card</span><span class="params">(JobState state, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取COMPLETE状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type    job type; if null, then return global metrics</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">completeCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取FAILED状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">failedCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取INACTIVE状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">inactiveCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取ACTIVE状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">activeCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取DELAYED状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">delayedCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取当前存在的所有任务类型</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getAllTypes</span><span class="params">(Handler&lt;AsyncResult&lt;List&lt;String&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取指定状态下的所有任务的ID</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> state   job state</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getIdsByState</span><span class="params">(JobState state, Handler&lt;AsyncResult&lt;List&lt;Long&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 工作队列运行时间（ms）</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getWorkTime</span><span class="params">(Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到我们还为<code>JobService</code>接口添加了<code>@VertxGen</code>注解，Vert.x Codegen可以处理此注解生成多种语言版本的服务。</p>
<p>在<code>JobService</code>接口中我们还定义了两个静态方法：<code>create</code>用于创建一个任务服务实例，<code>createProxy</code>用于创建一个服务代理。</p>
<p><code>JobService</code>接口中包含一些任务操作和统计的相关逻辑，每个方法的功能都已经在注释中阐述了，因此我们就直接来看它的实现吧～</p>
<h2 id="任务服务的实现">任务服务的实现</h2><p><code>JobService</code>接口的实现位于<code>JobServiceImpl</code>类中，代码非常长，因此这里就不贴代码了。。。大家可以对照<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/kue-core/src/main/java/io/vertx/blueprint/kue/service/impl/JobServiceImpl.java" target="_blank" rel="external">GitHub中的代码</a>读下面的内容。</p>
<ul>
<li><code>getJob</code>: 获取任务的方法非常简单。直接利用<code>hgetall</code>命令从Redis中取出对应的任务即可。</li>
<li><code>removeJob</code>: 我们可以将此方法看作是<code>getJob</code>和<code>Job#remove</code>两个方法的组合。</li>
<li><code>existsJob</code>: 使用<code>exists</code>命令判断对应<code>id</code>的任务是否存在。</li>
<li><code>getJobLog</code>: 使用<code>lrange</code>命令从<code>vertx_kue:job:{id}:log</code>列表中取出日志。</li>
<li><code>rangeGeneral</code>: 使用<code>zrange</code>命令获取一定范围内的任务，这是一个通用方法。</li>
</ul>
<p>[NOTE <code>zrange</code> 操作 | <code>zrange</code> 返回某一有序集合中某个特定范围内的元素。详情请见<a href="http://redis.io/commands/zrange" target="_blank" rel="external">ZRANGE - Redis</a>。 ]</p>
<p>以下三个方法复用了<code>rangeGeneral</code>方法：</p>
<ul>
<li><code>jobRangeByState</code>: 指定状态，对应的key为<code>vertx_kue:jobs:{state}</code>。</li>
<li><code>jobRangeByType</code>: 指定状态和类型，对应的key为<code>vertx_kue:jobs:{type}:{state}</code>。</li>
<li><code>jobRange</code>: 对应的key为<code>vertx_kue:jobs</code>。</li>
</ul>
<p>这两个通用方法用于任务数量的统计：</p>
<ul>
<li><code>cardByType</code>: 利用<code>zcard</code>命令获取某一指定状态和类型下任务的数量。</li>
<li><code>card</code>: 利用<code>zcard</code>命令获取某一指定状态下任务的数量。</li>
</ul>
<p>下面五个辅助统计方法复用了上面两个通用方法：</p>
<ul>
<li><code>completeCount</code></li>
<li><code>failedCount</code></li>
<li><code>delayedCount</code></li>
<li><code>inactiveCount</code></li>
<li><code>activeCount</code></li>
</ul>
<p>接着看：</p>
<ul>
<li><code>getAllTypes</code>: 利用<code>smembers</code>命令获取<code>vertx_kue:job:types</code>集合中存储的所有的任务类型。</li>
<li><code>getIdsByState</code>: 使用<code>zrange</code>获取某一指定状态下所有任务的ID。</li>
<li><code>getWorkTime</code>: 使用<code>get</code>命令从<code>vertx_kue:stats:work-time</code>中获取Vert.x Kue的工作时间。</li>
</ul>
<h2 id="注册任务服务">注册任务服务</h2><p>既然完成了<code>JobService</code>的实现，接下来我们来看一下如何利用Service Proxy将服务注册至Event Bus上。这里我们还需要一个<code>KueVerticle</code>来创建要注册的服务实例，并且将其注册至Event Bus上。</p>
<p>打开<code>io.vertx.blueprint.kue.queue.KueVerticle</code>类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.queue;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.service.JobService;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.util.RedisHelper;</div><div class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"><span class="keyword">import</span> io.vertx.core.logging.Logger;</div><div class="line"><span class="keyword">import</span> io.vertx.core.logging.LoggerFactory;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</div><div class="line"><span class="keyword">import</span> io.vertx.serviceproxy.ProxyHelper;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KueVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Job.class);</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EB_JOB_SERVICE_ADDRESS = <span class="string">"vertx.kue.service.job.internal"</span>; <span class="comment">// (1)</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> JsonObject config;</div><div class="line">  <span class="keyword">private</span> JobService jobService;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">this</span>.config = config();</div><div class="line">    <span class="keyword">this</span>.jobService = JobService.create(vertx, config); <span class="comment">// (2)</span></div><div class="line">    <span class="comment">// create redis client</span></div><div class="line">    RedisClient redisClient = RedisHelper.client(vertx, config);</div><div class="line">    redisClient.ping(pr -&gt; &#123; <span class="comment">// (3) test connection</span></div><div class="line">      <span class="keyword">if</span> (pr.succeeded()) &#123;</div><div class="line">        logger.info(<span class="string">"Kue Verticle is running..."</span>);</div><div class="line"></div><div class="line">        <span class="comment">// (4) register job service</span></div><div class="line">        ProxyHelper.registerService(JobService.class, vertx, jobService, EB_JOB_SERVICE_ADDRESS);</div><div class="line"></div><div class="line">        future.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        logger.error(<span class="string">"oops!"</span>, pr.cause());</div><div class="line">        future.fail(pr.cause());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们需要定义一个地址用于服务注册 (1)。在<code>start</code>方法中，我们创建了一个任务服务实例 (2)，然后通过<code>ping</code>命令测试Redis连接 (3)。如果连接正常，那么我们就可以通过<code>ProxyHelper</code>类中的<code>registerService</code>辅助方法来将服务实例注册至Event Bus上 (4)。</p>
<p>这样，一旦我们在集群模式下部署<code>KueVerticle</code>，服务就会被发布至Event Bus上，然后我们就可以在其他组件中去远程调用此服务了。很奇妙吧！</p>
<h1 id="Kue_-_工作队列">Kue - 工作队列</h1><p><code>Kue</code>类代表着工作队列。我们来看一下<code>Kue</code>类的实现。首先先看一下其构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Kue</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.vertx = vertx;</div><div class="line">  <span class="keyword">this</span>.config = config;</div><div class="line">  <span class="keyword">this</span>.jobService = JobService.createProxy(vertx, EB_JOB_SERVICE_ADDRESS);</div><div class="line">  <span class="keyword">this</span>.client = RedisHelper.client(vertx, config);</div><div class="line">  Job.setVertx(vertx, RedisHelper.client(vertx, config)); <span class="comment">// init static vertx instance inner job</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们需要注意两点：第一点，我们通过<code>createProxy</code>方法来创建一个<code>JobService</code>的服务代理；第二点，之前提到过，我们需要在这里初始化<code>Job</code>类中的静态成员变量。</p>
<h2 id="基于Future的封装">基于Future的封装</h2><p>我们的<code>JobService</code>是基于回调的，这是服务代理组件所要求的。为了让Vert.x Kue更加响应式，使用起来更加方便，我们在<code>Kue</code>类中以基于Future的异步模式封装了<code>JobService</code>中的所有异步方法。这很简单，比如这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function">JobService <span class="title">getJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Job&gt;&gt; handler)</span></span>;</div></pre></td></tr></table></figure>
<p>可以这么封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Future&lt;Optional&lt;Job&gt;&gt; getJob(<span class="keyword">long</span> id) &#123;</div><div class="line">  Future&lt;Optional&lt;Job&gt;&gt; future = Future.future();</div><div class="line">  jobService.getJob(id, r -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">      future.complete(Optional.ofNullable(r.result()));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      future.fail(r.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> future;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是加一层<code>Future</code>。其它的封装过程也类似所以我们就不细说了。</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_future_based_methods.png" alt=""></p>
<h2 id="process和processBlocking方法">process和processBlocking方法</h2><p><code>process</code>和<code>processBlocking</code>方法用于处理任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">process</span><span class="params">(String type, <span class="keyword">int</span> n, Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The process times must be positive"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</div><div class="line">    processInternal(type, handler, <span class="keyword">false</span>);</div><div class="line">  &#125;<span class="function">f</span></div><div class="line">  <span class="title">setupTimers</span><span class="params">()</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">process</span><span class="params">(String type, Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  processInternal(type, handler, <span class="keyword">false</span>);</div><div class="line">  setupTimers();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">processBlocking</span><span class="params">(String type, <span class="keyword">int</span> n, Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The process times must be positive"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</div><div class="line">    processInternal(type, handler, <span class="keyword">true</span>);</div><div class="line">  &#125;</div><div class="line">  setupTimers();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个<code>process</code>方法都类似 —— 它们都是使用<strong>Event Loop</strong>线程处理任务的，其中第一个方法还可以指定同时处理任务数量的阈值。我们来回顾一下使用<strong>Event Loop</strong>线程的注意事项 —— 我们不能阻塞Event Loop线程。因此如果我们需要在处理任务时做一些耗时的操作，我们可以使用<code>processBlocking</code>方法。这几个方法的代码看起来都差不多，那么区别在哪呢？之前我们提到过，我们设计了一种Verticle - <code>KueWorker</code>，用于处理任务。因此对于<code>process</code>方法来说，<code>KueWorker</code>就是一种普通的Verticle；而对于<code>processBlocking</code>方法来说，<code>KueWorker</code>是一种<strong>Worker Verticle</strong>。这两种Verticle有什么不同呢？区别在于，Worker Verticle会使用<strong>Worker线程</strong>，因此即使我们执行一些耗时的操作，Event Loop线程也不会被阻塞。</p>
<p>创建及部署<code>KueWorker</code>的逻辑在<code>processInternal</code>方法中，这三个方法都使用了<code>processInternal</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processInternal</span><span class="params">(String type, Handler&lt;Job&gt; handler, <span class="keyword">boolean</span> isWorker)</span> </span>&#123;</div><div class="line">  KueWorker worker = <span class="keyword">new</span> KueWorker(type, handler, <span class="keyword">this</span>); <span class="comment">// (1)</span></div><div class="line">  vertx.deployVerticle(worker, <span class="keyword">new</span> DeploymentOptions().setWorker(isWorker), r0 -&gt; &#123; <span class="comment">// (2)</span></div><div class="line">    <span class="keyword">if</span> (r0.succeeded()) &#123;</div><div class="line">      <span class="keyword">this</span>.on(<span class="string">"job_complete"</span>, msg -&gt; &#123;</div><div class="line">        <span class="keyword">long</span> dur = <span class="keyword">new</span> Job(((JsonObject) msg.body()).getJsonObject(<span class="string">"job"</span>)).getDuration();</div><div class="line">        client.incrby(RedisHelper.getKey(<span class="string">"stats:work-time"</span>), dur, r1 -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">          <span class="keyword">if</span> (r1.failed())</div><div class="line">            r1.cause().printStackTrace();</div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们创建一个<code>KueWorker</code>实例 (1)。我们将在稍后详细介绍<code>KueWorker</code>的实现。然后我们根据提供的配置来部署此<code>KueWorker</code> (2)。<code>processInternal</code>方法的第三个参数代表此<code>KueWorker</code>是否为worker verticle。如果部署成功，我们就监听<code>complete</code>事件。每当接收到<code>complete</code>事件的时候，我们获取收到的信息（处理任务消耗的时间），然后用<code>incrby</code>增加对应的工作时间 (3)。</p>
<p>再回到前面三个处理方法中。除了部署<code>KueWorker</code>以外，我们还调用了<code>setupTimers</code>方法，用于设定定时器以监测延时任务以及监测活动任务TTL。</p>
<h2 id="监测延时任务">监测延时任务</h2><p>Vert.x Kue支持延时任务，因此我们需要在任务延时时间到达时将任务“提升”至工作队列中等待处理。这个工作是在<code>checkJobPromotion</code>方法中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkJobPromotion</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> timeout = config.getInteger(<span class="string">"job.promotion.interval"</span>, <span class="number">1000</span>); <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">int</span> limit = config.getInteger(<span class="string">"job.promotion.limit"</span>, <span class="number">1000</span>); <span class="comment">// (2)</span></div><div class="line">  vertx.setPeriodic(timeout, l -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">    client.zrangebyscore(RedisHelper.getKey(<span class="string">"jobs:DELAYED"</span>), String.valueOf(<span class="number">0</span>), String.valueOf(System.currentTimeMillis()),</div><div class="line">      <span class="keyword">new</span> RangeLimitOptions(<span class="keyword">new</span> JsonObject().put(<span class="string">"offset"</span>, <span class="number">0</span>).put(<span class="string">"count"</span>, limit)), r -&gt; &#123;  <span class="comment">// (4)</span></div><div class="line">        <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">          r.result().forEach(r1 -&gt; &#123;</div><div class="line">            <span class="keyword">long</span> id = Long.parseLong(RedisHelper.stripFIFO((String) r1));</div><div class="line">            <span class="keyword">this</span>.getJob(id).compose(jr -&gt; jr.get().inactive())  <span class="comment">// (5)</span></div><div class="line">              .setHandler(jr -&gt; &#123;</div><div class="line">                <span class="keyword">if</span> (jr.succeeded()) &#123;</div><div class="line">                  jr.result().emit(<span class="string">"promotion"</span>, jr.result().getId()); <span class="comment">// (6)</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  jr.cause().printStackTrace();</div><div class="line">                &#125;</div><div class="line">              &#125;);</div><div class="line">          &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          r.cause().printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们从配置中获取监测延时任务的间隔(<code>job.promotion.interval</code>，默认1000ms)以及提升数量阈值(<code>job.promotion.limit</code>，默认1000)。然后我们使用<code>vertx.setPeriodic</code>方法设一个周期性的定时器 (3)，每隔一段时间就从Redis中获取需要被提升的任务 (4)。这里我们通过<code>zrangebyscore</code>获取每个需要被提升任务的<code>id</code>。我们来看一下<code>zrangebyscore</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">RedisClient <span class="title">zrangebyscore</span><span class="params">(String key, String min, String max, RangeLimitOptions options, Handler&lt;AsyncResult&lt;JsonArray&gt;&gt; handler)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><code>key</code>: 某个有序集合的key，即<code>vertx_kue:jobs:DELAYED</code></li>
<li><code>min</code> and <code>max</code>: 最小值以及最大值（按照某种模式）。这里<code>min</code>是<strong>0</strong>，而<code>max</code>是当前时间戳</li>
</ul>
<p>我们来回顾一下<code>Job</code>类中的<code>state</code>方法。当我们要把任务状态设为<code>DELAYED</code>的时候，我们将score设为<code>promote_at</code>时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> DELAYED:</div><div class="line">  client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</div><div class="line">    <span class="keyword">this</span>.promote_at, <span class="keyword">this</span>.zid, _failure());</div></pre></td></tr></table></figure>
<p>因此我们将<code>max</code>设为当前时间(<code>System.currentTimeMillis()</code>)，只要当前时间超过需要提升的时间，这就说明此任务可以被提升了。</p>
<ul>
<li><code>options</code>: range和limit配置。这里我们需要指定<code>LIMIT</code>值所以我们用<code>new RangeLimitOptions(new JsonObject().put(&quot;offset&quot;, 0).put(&quot;count&quot;, limit)</code>创建了一个配置</li>
</ul>
<p><code>zrangebyscore</code>的结果是一个<code>JsonArray</code>，里面包含着所有等待提升任务的<code>zid</code>。获得结果后我们就将每个<code>zid</code>转换为<code>id</code>，然后分别获取对应的任务实体，最后对每个任务调用<code>inactive</code>方法来将任务状态设为<code>INACTIVE</code> (5)。如果任务成功提升至工作队列，我们就发送<code>promotion</code>事件 (6)。</p>
<h2 id="CallbackKue_-_提供多语言支持">CallbackKue - 提供多语言支持</h2><p>我们知道，Vert.x支持多种语言(如JS，Ruby)，因此如果能让我们的Vert.x Kue支持多种语言那当然是极好的！这没有问题～Vert.x Codegen可以处理含<code>@VertxGen</code>注解的异步接口，生成多语言版本。<code>@VertxGen</code>注解同样限制异步方法 —— 需要基于回调，因此我们设计了一个<code>CallbackKue</code>接口用于提供多语言支持。<code>CallbackKue</code>的设计非常简单，其实现复用了<code>Kue</code>和<code>jobService</code>的代码。大家可以直接看源码，一目了然，这里就不细说了。</p>
<p>注意要生成多语言版本的代码，需要添加相应的依赖。比如要生成Ruby版本的代码就要向<code>build.gradle</code>中添加<code>compile(&quot;io.vertx:vertx-lang-ruby:${vertxVersion}&quot;)</code>。</p>
<h1 id="KueWorker_-_任务在此处理">KueWorker - 任务在此处理</h1><p>好啦，我们已经对Vert.x Kue Core的几个核心部分有了大致的了解了，现在是时候探索一下任务处理的本源 - <code>KueWorker</code>了～</p>
<p>每一个worker都对应一个特定的任务类型，并且绑定着特定的处理函数(<code>Handler</code>)，所以我们需要在创建的时候指定它们。</p>
<h2 id="prepareAndStart方法">prepareAndStart方法</h2><p>在<code>KueWorker</code>中，我们使用<code>prepareAndStart</code>方法来准备要处理的任务并且开始处理任务的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAndStart</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.getJobFromBackend().setHandler(jr -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (jr.succeeded()) &#123;</div><div class="line">      <span class="keyword">if</span> (jr.result().isPresent()) &#123;</div><div class="line">        <span class="keyword">this</span>.job = jr.result().get(); <span class="comment">// (2)</span></div><div class="line">        process(); <span class="comment">// (3)</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, <span class="string">"job_not_exist"</span>));</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"job not exist"</span>);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, jr.cause().getMessage()));</div><div class="line">        jr.cause().printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码比较直观。首先我们通过<code>getJobFromBackend</code>方法从Redis中按照优先级顺序获取任务 (1)。如果成功获取任务，我们就把获取到的任务保存起来 (2) 然后通过<code>process</code>方法处理任务 (3)。如果中间出现错误，我们需要发送<code>error</code>错误事件，其中携带错误信息。</p>
<h2 id="使用zpop按照优先级顺序获取任务">使用zpop按照优先级顺序获取任务</h2><p>我们来看一下我们是如何从Redis中按照优先级顺序获取任务实体的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Future&lt;Optional&lt;Job&gt;&gt; getJobFromBackend() &#123;</div><div class="line">  Future&lt;Optional&lt;Job&gt;&gt; future = Future.future();</div><div class="line">  client.blpop(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="number">0</span>, r1 -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (r1.failed()) &#123;</div><div class="line">      client.lpush(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="string">"1"</span>, r2 -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (r2.failed())</div><div class="line">          future.fail(r2.cause());</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.zpop(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":INACTIVE"</span>)) <span class="comment">// (2)</span></div><div class="line">        .compose(kue::getJob) <span class="comment">// (3)</span></div><div class="line">        .setHandler(r -&gt; &#123;</div><div class="line">          <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">            future.complete(r.result());</div><div class="line">          &#125; <span class="keyword">else</span></div><div class="line">            future.fail(r.cause());</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> future;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前我们已经了解到，每当我们保存一个任务的时候，我们都会向<code>vertx_kue:{type}:jobs</code>列表中插入一个新元素表示新的任务可供处理。因此这里我们通过<code>blpop</code>命令来等待可用的任务 (1)。一旦有任务可供处理，我们就利用<code>zpop</code>方法取出高优先级的任务的<code>zid</code> (2)。<code>zpop</code>命令是一个原子操作，用于从有序集合中弹出最小score值的元素。注意Redis没有实现<code>zpop</code>命令，因此我们需要自己实现。</p>
<p><a href="http://redis.io/topics/transactions#using-a-hrefcommandswatchwatcha-to-implement-zpop" target="_blank" rel="external">Redis官方文档</a>介绍了一种实现<code>zpop</code>命令的简单方法 - 利用 <code>WATCH</code>。这里我们利用另外一种思路实现<code>zpop</code>命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;Long&gt; <span class="title">zpop</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">  Future&lt;Long&gt; future = Future.future();</div><div class="line">  client.transaction()</div><div class="line">    .multi(_failure())</div><div class="line">    .zrange(key, <span class="number">0</span>, <span class="number">0</span>, _failure())</div><div class="line">    .zremrangebyrank(key, <span class="number">0</span>, <span class="number">0</span>, _failure())</div><div class="line">    .exec(r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">        JsonArray res = r.result();</div><div class="line">        <span class="keyword">if</span> (res.getJsonArray(<span class="number">0</span>).size() == <span class="number">0</span>) <span class="comment">// empty set</span></div><div class="line">          future.fail(<span class="keyword">new</span> IllegalStateException(<span class="string">"Empty zpop set"</span>));</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            future.complete(Long.parseLong(RedisHelper.stripFIFO(</div><div class="line">              res.getJsonArray(<span class="number">0</span>).getString(<span class="number">0</span>))));</div><div class="line">          &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">            future.fail(ex);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        future.fail(r.cause());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  <span class="keyword">return</span> future;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我们的<code>zpop</code>的实现中，我们首先开始了一个事务块，然后依次执行<code>zrange</code>和<code>zremrangebyrank</code>命令。有关这些命令的详情我们就不细说了，可以参考<a href="http://redis.io/commands" target="_blank" rel="external">Redis官方文档</a>。然后我们提交事务，如果提交成功，我们会获得一个<code>JsonArray</code>类型的结果。正常情况下我们都可以通过<code>res.getJsonArray(0).getString(0)</code>获取到对应的<code>zid</code>值。获取到<code>zid</code>值以后我们就可以将其转换为任务的<code>id</code>了，最后我们将<code>id</code>置于<code>Future</code>内（因为<code>zpop</code>也是一个异步方法）。</p>
<p>接着回到<code>getJobFromBackend</code>方法中。获取到对应的<code>id</code>之后，我们就可以通过<code>Kue</code>的<code>getJob</code>函数获取任务实体了 (3)。由于<code>getJobFromBackend</code>也是一个异步方法，因此我们同样将结果置于<code>Future</code>中。</p>
<h2 id="真正的“处理”逻辑">真正的“处理”逻辑</h2><p>前边讲了那么多，都是在为处理任务做准备。。。不要着急，现在终于到了真正的“处理”逻辑咯！我们看一下<code>process</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">long</span> curTime = System.currentTimeMillis();</div><div class="line">  <span class="keyword">this</span>.job.setStarted_at(curTime)</div><div class="line">    .set(<span class="string">"started_at"</span>, String.valueOf(curTime)) <span class="comment">// (1) set start time</span></div><div class="line">    .compose(Job::active) <span class="comment">// (2) set the job state to ACTIVE</span></div><div class="line">    .setHandler(r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">        Job j = r.result();</div><div class="line">        <span class="comment">// emit start event</span></div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"start"</span>, j, <span class="keyword">null</span>);  <span class="comment">// (3) emit job `start` event</span></div><div class="line">        <span class="comment">// (4) process logic invocation</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          jobHandler.handle(j);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">          j.done(ex);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// (5) consume the job done event</span></div><div class="line"></div><div class="line">        eventBus.consumer(Kue.workerAddress(<span class="string">"done"</span>, j), msg -&gt; &#123;</div><div class="line">          createDoneCallback(j).handle(Future.succeededFuture(</div><div class="line">            ((JsonObject) msg.body()).getJsonObject(<span class="string">"result"</span>)));</div><div class="line">        &#125;);</div><div class="line">        eventBus.consumer(Kue.workerAddress(<span class="string">"done_fail"</span>, j), msg -&gt; &#123;</div><div class="line">          createDoneCallback(j).handle(Future.failedFuture(</div><div class="line">            (String) msg.body()));</div><div class="line">        &#125;);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">this</span>.job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, r.cause().getMessage()));</div><div class="line">          r.cause().printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到了最核心的函数了！首先我们先给开始时间赋值 (1) 然后将任务状态置为<code>ACTIVE</code> (2)。如果这两个操作成功的话，我们就向Event Bus发送任务开始(<code>start</code>)事件 (3)。接下来我们调用真正的处理逻辑 - 之前绑定的<code>jobHandler</code> (4)。如果处理过程中抛出异常的话，Vert.x Kue就会调用<code>job.done(ex)</code>方法发送<code>done_fail</code>内部事件来通知worker任务处理失败。但是似乎没有看到在哪里接收并处理<code>done</code>和<code>done_fail</code>事件呢？就在这 (5)！一旦Vert.x Kue接收到这两个事件，它就会调用对应的<code>handler</code>去进行任务完成或失败的相应操作。这里的<code>handler</code>是由<code>createDoneCallback</code>方法生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; createDoneCallback(Job job) &#123;</div><div class="line">  <span class="keyword">return</span> r0 -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (job == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (r0.failed()) &#123;</div><div class="line">      <span class="keyword">this</span>.fail(r0.cause()); <span class="comment">// (1)</span></div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> dur = System.currentTimeMillis() - job.getStarted_at();</div><div class="line">    job.setDuration(dur)</div><div class="line">      .set(<span class="string">"duration"</span>, String.valueOf(dur)); <span class="comment">// (2)</span></div><div class="line">    JsonObject result = r0.result();</div><div class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">      job.setResult(result)</div><div class="line">        .set(<span class="string">"result"</span>, result.encodePrettily()); <span class="comment">// (3)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    job.complete().setHandler(r -&gt; &#123; <span class="comment">// (4)</span></div><div class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">        Job j = r.result();</div><div class="line">        <span class="keyword">if</span> (j.isRemoveOnComplete()) &#123; <span class="comment">// (5)</span></div><div class="line">          j.remove();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"complete"</span>, j, <span class="keyword">null</span>); <span class="comment">// (6)</span></div><div class="line"></div><div class="line">        <span class="keyword">this</span>.prepareAndStart(); <span class="comment">// (7) 准备处理下一个任务</span></div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任务处理有两种情况：完成和失败，因此我们先来看任务成功处理的情况。我们首先给任务的用时(<code>duration</code>)赋值 (2)，并且如果任务产生了结果，也给结果(<code>result</code>)赋值 (3)。然后我们调用<code>job.complete</code>方法将状态设置为<code>COMPLETE</code> (4)。如果成功的话，我们就检查<code>removeOnComplete</code>标志位 (5) 并决定是否将任务从Redis中移除。然后我们向Event Bus发送任务完成事件(<code>complete</code>)以及队列事件<code>job_complete</code> (6)。现在这个任务的处理过程已经结束了，worker需要准备处理下一个任务了，因此最后我们调用<code>prepareAndStart</code>方法准备处理下一个<code>Job</code>。</p>
<h2 id="处理失败了怎么办？">处理失败了怎么办？</h2><p>人生不如意事十之八九，任务处理过程中很可能会遇见各种各样的问题而失败。当任务处理失败时，我们调用<code>KueWorker</code>中的<code>fail</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">  job.failedAttempt(ex).setHandler(r -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">      <span class="keyword">this</span>.error(r.cause(), job); <span class="comment">// (2)</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      Job res = r.result();</div><div class="line">      <span class="keyword">if</span> (res.hasAttempts()) &#123; <span class="comment">// (3)</span></div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"failed_attempt"</span>, job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, ex.getMessage()));</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"failed"</span>, job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, ex.getMessage())); <span class="comment">// (4)</span></div><div class="line">      &#125;</div><div class="line">      prepareAndStart(); <span class="comment">// (5)</span></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>面对失败时，我们首先通过<code>failedAttempt</code>方法尝试从错误中恢复 (1)。如果恢复失败（比如没有重试次数了）就向Event Bus发送<code>error</code>队列事件 (2)。如果恢复成功，我们就根据是否还有剩余重试次数来发送对应的事件(<code>failed</code>或者<code>failed_attempt</code>)。搞定错误以后，worker同样需要准备处理下一个任务了，因此最后我们调用<code>prepareAndStart</code>方法准备处理下一个<code>Job</code> (5)。</p>
<p>这就是<code>KueWorker</code>的全部实现，是不是很有趣呢？看了这么久的代码也有些累了，下面是时候来写个Kue应用跑一下咯～</p>
<h1 id="展示时间！">展示时间！</h1><p>在<code>io.vertx.blueprint.kue.example</code>包下(<code>kue-example</code>子工程)创建一个<code>LearningVertxVerticle</code>类，然后编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.example;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.Kue;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.Job;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.Priority;</div><div class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearningVertxVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 创建工作队列</span></div><div class="line">    Kue kue = Kue.createQueue(vertx, config());</div><div class="line"></div><div class="line">    <span class="comment">// 监听全局错误事件</span></div><div class="line">    kue.on(<span class="string">"error"</span>, message -&gt;</div><div class="line">      System.out.println(<span class="string">"[Global Error] "</span> + message.body()));</div><div class="line"></div><div class="line">    JsonObject data = <span class="keyword">new</span> JsonObject()</div><div class="line">      .put(<span class="string">"title"</span>, <span class="string">"Learning Vert.x"</span>)</div><div class="line">      .put(<span class="string">"content"</span>, <span class="string">"core"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 准备学习Vert.x，爽！</span></div><div class="line">    Job j = kue.createJob(<span class="string">"learn vertx"</span>, data)</div><div class="line">      .priority(Priority.HIGH)</div><div class="line">      .onComplete(r -&gt; &#123; <span class="comment">// 完成任务事件监听</span></div><div class="line">        System.out.println(<span class="string">"Feeling: "</span> + r.getResult().getString(<span class="string">"feeling"</span>, <span class="string">"none"</span>));</div><div class="line">    &#125;).onFailure(r -&gt; &#123; <span class="comment">// 任务失败事件监听</span></div><div class="line">        System.out.println(<span class="string">"eee...so difficult..."</span>);</div><div class="line">    &#125;).onProgress(r -&gt; &#123; <span class="comment">// 任务进度变更事件监听</span></div><div class="line">        System.out.println(<span class="string">"I love this! My progress =&gt; "</span> + r);</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 保存任务</span></div><div class="line">    j.save().setHandler(r0 -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r0.succeeded()) &#123;</div><div class="line">        <span class="comment">// 开始学习！</span></div><div class="line">        kue.processBlocking(<span class="string">"learn vertx"</span>, <span class="number">1</span>, job -&gt; &#123;</div><div class="line">          job.progress(<span class="number">10</span>, <span class="number">100</span>);</div><div class="line">          <span class="comment">// 3秒速成</span></div><div class="line">          vertx.setTimer(<span class="number">3000</span>, r1 -&gt; &#123;</div><div class="line">            job.setResult(<span class="keyword">new</span> JsonObject().put(<span class="string">"feeling"</span>, <span class="string">"amazing and wonderful!"</span>)) <span class="comment">// 结果</span></div><div class="line">              .done(); <span class="comment">// 完成啦！</span></div><div class="line">          &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.err.println(<span class="string">"Wow, something happened: "</span> + r0.cause().getMessage());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常情况下，一个Vert.x Kue应用可以分为几部分：创建工作队列、创建任务、保存任务以及处理任务。我们推荐开发者把应用写成<code>Verticle</code>的形式。</p>
<p>在这个例子中，我们要模拟一个学习Vert.x的任务！首先我们通过<code>Kue.createQueue</code>方法创建一个工作队列并且通过<code>on(error, handler)</code>方法监听全局错误(<code>error</code>)事件。接着我们通过<code>kue.createJob</code>方法创建学习任务，将优先级设定为<code>HIGH</code>，并且监听<code>complete</code>、<code>failed</code>以及<code>progress</code>事件。然后我们需要保存任务，保存完毕以后我们就可以通过<code>processBlocking</code>方法来执行耗时任务了。在处理逻辑中，我们首先通过<code>job.progress</code>方法将进度设为<code>10</code>，然后使用<code>vertx.setTimer</code>方法设一个3秒的定时器，定时器时间到以后赋予结果并完成任务。</p>
<p>像往常一样，我们还需要在<code>build.gradle</code>中配置一下。我们需要将<code>kue-example</code>子工程中的<code>Main-Verticle</code>属性设为刚才写的<code>io.vertx.blueprint.kue.example.LearningVertxVerticle</code>：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">project</span>(<span class="string">"kue-example"</span>) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jar &#123;</div><div class="line">    archiveName = <span class="string">'vertx-blueprint-kue-example.jar'</span></div><div class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">    manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.example.LearningVertxVerticle'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，到了展示时间了！打开终端，构建项目：</p>
<pre><code><span class="title">gradle</span> build
</code></pre><p>当然不要忘记运行Redis：</p>
<pre><code>redis-<span class="keyword">server</span>
</code></pre><p>然后我们先运行Vert.x Kue Core部分：</p>
<pre><code>java -jar kue-core<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-core.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>然后再运行我们的实例：</p>
<pre><code>java -jar kue-example<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-example.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>这时终端应该会依次显示输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">INFO: Kue Verticle is running...</div><div class="line">I love this! My progress =&gt; 10</div><div class="line">Feeling: amazing and wonderful!</div></pre></td></tr></table></figure>
<p>当然你也可以在Vert.x Kue的Web端查看任务情况。</p>
<h1 id="完成我们的探索之旅！">完成我们的探索之旅！</h1><p>棒极了！我们终于结束了我们的Vert.x Kue核心部分探索之旅～～！从这篇超长的教程中，你学到了如何利用Vert.x去开发一个基于消息的应用！太酷了！</p>
<p>如果想了解<code>kue-http</code>的实现，请移步<a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/">Vert.x 蓝图 | Vert.x Kue 教程（Web部分）</a>。如果想了解更多的关于Vert.x Kue的特性，请移步<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">Vert.x Kue 特性介绍</a>。</p>
<p>Vert.x能做的不仅仅是这些。想要了解更多的关于Vert.x的知识，请参考<a href="http://vertx.io/docs/" target="_blank" rel="external">Vert.x 官方文档</a> —— 这永远是资料最齐全的地方。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/消息系统/">消息系统</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vertx-blueprint-1-todo-backend-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/" class="article-date">
      <time datetime="2016-06-15T16:00:00.000Z" itemprop="datePublished">2016-06-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本文章是 <a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x 蓝图系列</a> 的第一篇教程。全系列：</p>
<ul>
<li>Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程</a></li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践</a></li>
</ul>
<h1 id="前言">前言</h1><p>在本教程中，我们会使用Vert.x来一步一步地开发一个REST风格的Web服务 - Todo Backend，你可以把它看作是一个简单的待办事项服务，我们可以自由添加或者取消各种待办事项。</p>
<p>通过本教程，你将会学习到以下的内容：</p>
<ul>
<li><strong>Vert.x</strong> 是什么，以及其基本设计思想</li>
<li><code>Verticle</code>是什么，以及如何使用<code>Verticle</code></li>
<li>如何用 <strong>Vert.x Web</strong> 来开发REST风格的Web服务</li>
<li><strong>异步编程风格</strong> 的应用</li>
<li>如何通过 Vert.x 的各种组件来进行数据的存储操作（如 <em>Redis</em> 和 <em>MySQL</em>）</li>
</ul>
<p>本教程是 <strong>Vert.x 蓝图系列</strong> 的第一篇教程，对应的Vert.x版本为<strong>3.3.3</strong>。本教程中的完整代码已托管至<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/tree/master" target="_blank" rel="external">GitHub</a>。</p>
<h1 id="踏入Vert-x之门">踏入Vert.x之门</h1><p>朋友，欢迎来到Vert.x的世界！初次听说Vert.x，你一定会非常好奇：这是啥？让我们来看一下Vert.x的官方解释：</p>
<blockquote>
<p>Vert.x is a tool-kit for building reactive applications on the JVM.</p>
</blockquote>
<p>(⊙o⊙)哦哦。。。翻译一下，Vert.x是一个在JVM上构建 <strong>响应式</strong> 应用的 <strong>工具集</strong> 。这个定义比较模糊，我们来简单解释一下：<strong>工具集</strong> 意味着Vert.x非常轻量，可以嵌入到你当前的应用中而不需要改变现有的结构；另一个重要的描述是 <strong>响应式</strong> —— Vert.x就是为构建响应式应用（系统）而设计的。响应式系统这个概念在 <a href="http://reactivemanifesto.org/" target="_blank" rel="external">Reactive Manifesto</a> 中有详细的定义。我们在这里总结4个要点：</p>
<ul>
<li>响应式的(Responsive)：一个响应式系统需要在 <em>合理</em> 的时间内处理请求。</li>
<li>弹性的(Resilient)：一个响应式系统必须在遇到 <em>异常</em> （崩溃，超时， <code>500</code> 错误等等）的时候保持响应的能力，所以它必须要为 <em>异常处理</em> 而设计。</li>
<li>可伸缩的(Elastic)：一个响应式系统必须在不同的负载情况下都要保持响应能力，所以它必须能伸能缩，并且可以利用最少的资源来处理负载。</li>
<li>消息驱动：一个响应式系统的各个组件之间通过 <strong>异步消息传递</strong> 来进行交互。</li>
</ul>
<p>Vert.x是 <strong>事件驱动的</strong>，同时也是非阻塞的。首先，我们来介绍 <strong>Event Loop</strong> 的概念。Event Loop是一组负责分发和处理事件的线程。注意，我们绝对不能去阻塞Event Loop线程，否则事件的处理过程会被阻塞，我们的应用就失去了响应能力。因此当我们在写Vert.x应用的时候，我们要时刻谨记 <strong>异步非阻塞开发模式</strong> 而不是传统的阻塞开发模式。我们将会在下面详细讲解异步非阻塞开发模式。</p>
<h1 id="我们的应用_-_待办事项服务">我们的应用 - 待办事项服务</h1><p>我们的应用是一个REST风格的待办事项服务，它非常简单，整个API其实就围绕着 <em>增删改查</em> 四种操作。所以我们可以设计以下的路由：</p>
<ul>
<li>添加待办事项: <code>POST /todos</code></li>
<li>获取某一待办事项: <code>GET /todos/:todoId</code></li>
<li>获取所有待办事项: <code>GET /todos</code></li>
<li>更新待办事项: <code>PATCH /todos/:todoId</code></li>
<li>删除某一待办事项: <code>DELETE /todos/:todoId</code></li>
<li>删除所有待办事项: <code>DELETE /todos</code></li>
</ul>
<p>注意我们这里不讨论REST风格API的设计规范（仁者见仁,智者见智），因此你也可以用你喜欢的方式去定义路由。</p>
<p>下面我们开始开发我们的项目！High起来～～～</p>
<h1 id="说干就干！">说干就干！</h1><p>Vert.x Core提供了一些较为底层的处理HTTP请求的功能，这对于Web开发来说不是很方便，因为我们通常不需要这么底层的功能，因此<a href="http://vertx.io/docs/vertx-web/java" target="_blank" rel="external">Vert.x Web</a>应运而生。Vert.x Web基于Vert.x Core，并且提供一组更易于创建Web应用的上层功能（如路由）。</p>
<h2 id="Gradle配置文件">Gradle配置文件</h2><p>首先我们先来创建我们的项目。在本教程中我们使用<strong>Gradle</strong>作为构建工具，当然你也可以使用其它诸如Maven之类的构建工具。我们的项目目录里需要有：</p>
<ol>
<li><code>src/main/java</code> 文件夹（源码目录）</li>
<li><code>src/test/java</code> 文件夹（测试目录）</li>
<li><code>build.gradle</code> 文件（Gradle配置文件）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── build.gradle</div><div class="line">├── settings.gradle</div><div class="line">├── src</div><div class="line">│   ├── main</div><div class="line">│   │   └── java</div><div class="line">│   └── test</div><div class="line">│       └── java</div></pre></td></tr></table></figure>
<p>我们首先来创建 <code>build.gradle</code> 文件，这是Gradle对应的配置文件：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></div><div class="line"></div><div class="line">targetCompatibility = <span class="number">1.8</span></div><div class="line">sourceCompatibility = <span class="number">1.8</span></div><div class="line"></div><div class="line">repositories &#123;</div><div class="line">  jcenter()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line"></div><div class="line">  compile <span class="string">"io.vertx:vertx-core:3.3.3"</span></div><div class="line">  compile <span class="string">'io.vertx:vertx-web:3.3.3'</span></div><div class="line"></div><div class="line">  testCompile <span class="string">'io.vertx:vertx-unit:3.3.3'</span></div><div class="line">  testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能不是很熟悉Gradle，这不要紧。我们来解释一下：</p>
<ul>
<li>我们将 <code>targetCompatibility</code> 和 <code>sourceCompatibility</code> 这两个值都设为<strong>1.8</strong>，代表目标Java版本是Java 8。这非常重要，因为Vert.x就是基于Java 8构建的。</li>
<li>在<code>dependencies</code>中，我们声明了我们需要的依赖。<code>vertx-core</code> 和 <code>vert-web</code> 用于开发REST API。</li>
</ul>
<p>搞定<code>build.gradle</code>以后，我们开始写代码！</p>
<h2 id="待办事项对象">待办事项对象</h2><p>首先我们需要创建我们的数据实体对象 - <code>Todo</code> 实体。在<code>io.vertx.blueprint.todolist.entity</code>包下创建<code>Todo</code>类，并且编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.entity;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.codegen.annotations.DataObject;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@DataObject</span>(generateConverter = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger acc = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">// counter</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">  <span class="keyword">private</span> String title;</div><div class="line">  <span class="keyword">private</span> Boolean completed;</div><div class="line">  <span class="keyword">private</span> Integer order;</div><div class="line">  <span class="keyword">private</span> String url;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(Todo other)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = other.id;</div><div class="line">    <span class="keyword">this</span>.title = other.title;</div><div class="line">    <span class="keyword">this</span>.completed = other.completed;</div><div class="line">    <span class="keyword">this</span>.order = other.order;</div><div class="line">    <span class="keyword">this</span>.url = other.url;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(JsonObject obj)</span> </span>&#123;</div><div class="line">    TodoConverter.fromJson(obj, <span class="keyword">this</span>); <span class="comment">// 还未生成Converter的时候需要先注释掉，生成过后再取消注释</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(String jsonStr)</span> </span>&#123;</div><div class="line">    TodoConverter.fromJson(<span class="keyword">new</span> JsonObject(jsonStr), <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(<span class="keyword">int</span> id, String title, Boolean completed, Integer order, String url)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">    <span class="keyword">this</span>.completed = completed;</div><div class="line">    <span class="keyword">this</span>.order = order;</div><div class="line">    <span class="keyword">this</span>.url = url;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> JsonObject <span class="title">toJson</span><span class="params">()</span> </span>&#123;</div><div class="line">    JsonObject json = <span class="keyword">new</span> JsonObject();</div><div class="line">    TodoConverter.toJson(<span class="keyword">this</span>, json);</div><div class="line">    <span class="keyword">return</span> json;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIncId</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = acc.incrementAndGet();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIncId</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> acc.get();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setIncIdWith</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    acc.set(n);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> title;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">isCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getOrElse(completed, <span class="keyword">false</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompleted</span><span class="params">(Boolean completed)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.completed = completed;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getOrElse(order, <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(Integer order)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.order = order;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> url;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.url = url;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    Todo todo = (Todo) o;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (id != todo.id) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (!title.equals(todo.title)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (completed != <span class="keyword">null</span> ? !completed.equals(todo.completed) : todo.completed != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">return</span> order != <span class="keyword">null</span> ? order.equals(todo.order) : todo.order == <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = id;</div><div class="line">    result = <span class="number">31</span> * result + title.hashCode();</div><div class="line">    result = <span class="number">31</span> * result + (completed != <span class="keyword">null</span> ? completed.hashCode() : <span class="number">0</span>);</div><div class="line">    result = <span class="number">31</span> * result + (order != <span class="keyword">null</span> ? order.hashCode() : <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Todo -&gt; &#123;"</span> +</div><div class="line">      <span class="string">"id="</span> + id +</div><div class="line">      <span class="string">", title='"</span> + title + <span class="string">'\''</span> +</div><div class="line">      <span class="string">", completed="</span> + completed +</div><div class="line">      <span class="string">", order="</span> + order +</div><div class="line">      <span class="string">", url='"</span> + url + <span class="string">'\''</span> +</div><div class="line">      <span class="string">'&#125;'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getOrElse</span><span class="params">(T value, T defaultValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? defaultValue : value;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Todo <span class="title">merge</span><span class="params">(Todo todo)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Todo(id,</div><div class="line">      getOrElse(todo.title, title),</div><div class="line">      getOrElse(todo.completed, completed),</div><div class="line">      getOrElse(todo.order, order),</div><div class="line">      url);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的 <code>Todo</code> 实体对象由序号<code>id</code>、标题<code>title</code>、次序<code>order</code>、地址<code>url</code>以及代表待办事项是否完成的一个标识<code>complete</code>组成。我们可以把它看作是一个简单的Java Bean。它可以被编码成JSON格式的数据，我们在后边会大量使用JSON（事实上，在Vert.x中JSON非常普遍）。同时注意到我们给<code>Todo</code>类加上了一个注解：<code>@DataObject</code>，这是用于生成JSON转换类的注解。</p>
<blockquote>
<p><code>@DataObject</code> 注解</p>
<p>被 <code>@DataObject</code> 注解的实体类需要满足以下条件：拥有一个拷贝构造函数以及一个接受一个 <code>JsonObject</code> 对象的构造函数。</p>
</blockquote>
<p>我们利用Vert.x Codegen来自动生成JSON转换类。我们需要在<code>build.gradle</code>中添加依赖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compileOnly <span class="string">'io.vertx:vertx-codegen:3.3.3'</span></div></pre></td></tr></table></figure>
<p>由于Vert.x Codegen仅在编译期生成代码，因此我们这里使用了<code>compileOnly</code>(相当于Maven中的<code>provided</code>。需要Gradle 2.12及以上版本)。同时，我们需要在<code>io.vertx.blueprint.todolist.entity</code>包中添加<code>package-info.java</code>文件来指引Vert.x Codegen生成代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Indicates that this module contains classes that need to be generated / processed.</div><div class="line"> */</div><div class="line"><span class="meta">@ModuleGen</span>(name = <span class="string">"vertx-blueprint-todo-entity"</span>, groupPackage = <span class="string">"io.vertx.blueprint.todolist.entity"</span>)</div><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.entity;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.codegen.annotations.ModuleGen;</div></pre></td></tr></table></figure>
<p>Vert.x Codegen本质上是一个注解处理器(annotation processing tool)，因此我们还需要在<code>build.gradle</code>中配置apt。往里面添加以下代码：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</div><div class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</div><div class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">  <span class="keyword">options</span>.compilerArgs = [</div><div class="line">    <span class="string">"-proc:only"</span>,</div><div class="line">    <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</div><div class="line">    <span class="string">"-AoutputDirectory=$&#123;destinationDir.absolutePath&#125;"</span></div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">sourceSets</span> &#123;</div><div class="line">  main &#123;</div><div class="line">    java &#123;</div><div class="line">      srcDirs += <span class="string">'src/main/generated'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">compileJava &#123;</div><div class="line">  <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">  <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line"></div><div class="line">  dependsOn annotationProcessing</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，每次我们在编译项目的时候，Vert.x Codegen都会自动检测含有 <code>@DataObject</code> 注解的类并且根据配置生成JSON转换类。在本例中，我们应该会得到一个 <code>TodoConverter</code> 类，然后我们可以在<code>Todo</code>类中使用它。</p>
<h2 id="Verticle">Verticle</h2><p>下面我们来写我们的应用组件。在<code>io.vertx.blueprint.todolist.verticles</code>包中创建<code>SingleApplicationVerticle</code>类，并编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.verticles;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisOptions;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleApplicationVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_HOST = <span class="string">"0.0.0.0"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_HOST = <span class="string">"127.0.0.1"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_PORT = <span class="number">8082</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REDIS_PORT = <span class="number">6379</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> RedisClient redis;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      <span class="comment">// TODO with start...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的<code>SingleApplicationVerticle</code>类继承了<code>AbstractVerticle</code>抽象类。那么什么是 <code>Verticle</code> 呢？在Vert.x中，一个<code>Verticle</code>代表应用的某一组件。我们可以通过部署<code>Verticle</code>来运行这些组件。如果你了解 <strong>Actor</strong> 模型的话，你会发现它和Actor非常类似。</p>
<p>当<code>Verticle</code>被部署的时候，其<code>start</code>方法会被调用。我们注意到这里的<code>start</code>方法接受一个类型为<code>Future&lt;Void&gt;</code>的参数，这代表了这是一个异步的初始化方法。这里的<code>Future</code>代表着<code>Verticle</code>的初始化过程是否完成。你可以通过调用Future的<code>complete</code>方法来代表初始化过程完成，或者<code>fail</code>方法代表初始化过程失败。</p>
<p>现在我们<code>Verticle</code>的轮廓已经搞好了，那么下一步也就很明了了 - 创建HTTP Client并且配置路由，处理HTTP请求。</p>
<h1 id="Vert-x_Web与REST_API">Vert.x Web与REST API</h1><h2 id="创建HTTP服务端并配置路由">创建HTTP服务端并配置路由</h2><p>我们来给<code>start</code>方法加点东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  initData();</div><div class="line">  Router router = Router.router(vertx); <span class="comment">// &lt;1&gt;</span></div><div class="line">  <span class="comment">// CORS support</span></div><div class="line">  Set&lt;String&gt; allowHeaders = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">  allowHeaders.add(<span class="string">"x-requested-with"</span>);</div><div class="line">  allowHeaders.add(<span class="string">"Access-Control-Allow-Origin"</span>);</div><div class="line">  allowHeaders.add(<span class="string">"origin"</span>);</div><div class="line">  allowHeaders.add(<span class="string">"Content-Type"</span>);</div><div class="line">  allowHeaders.add(<span class="string">"accept"</span>);</div><div class="line">  Set&lt;HttpMethod&gt; allowMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">  allowMethods.add(HttpMethod.GET);</div><div class="line">  allowMethods.add(HttpMethod.POST);</div><div class="line">  allowMethods.add(HttpMethod.DELETE);</div><div class="line">  allowMethods.add(HttpMethod.PATCH);</div><div class="line"></div><div class="line">  router.route().handler(CorsHandler.create(<span class="string">"*"</span>) <span class="comment">// &lt;2&gt;</span></div><div class="line">    .allowedHeaders(allowHeaders)</div><div class="line">    .allowedMethods(allowMethods));</div><div class="line">  router.route().handler(BodyHandler.create()); <span class="comment">// &lt;3&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">// <span class="doctag">TODO:</span>routes</span></div><div class="line"></div><div class="line">  vertx.createHttpServer() <span class="comment">// &lt;4&gt;</span></div><div class="line">    .requestHandler(router::accept)</div><div class="line">    .listen(PORT, HOST, result -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (result.succeeded())</div><div class="line">          future.complete();</div><div class="line">        <span class="keyword">else</span></div><div class="line">          future.fail(result.cause());</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(⊙o⊙)…一长串代码诶。。是不是看着很晕呢？我们来详细解释一下。</p>
<p>首先我们创建了一个 <code>Router</code> 实例 （1）。这里的<code>Router</code>代表路由器，相信做过Web开发的开发者们一定不会陌生。路由器负责将对应的HTTP请求分发至对应的处理逻辑（Handler）中。每个<code>Handler</code>负责处理请求并且写入回应结果。当HTTP请求到达时，对应的<code>Handler</code>会被调用。</p>
<p>然后我们创建了两个<code>Set</code>：<code>allowHeaders</code>和<code>allowMethods</code>，并且我们向里面添加了一些HTTP Header以及HTTP Method，然后我们给路由器绑定了一个<code>CorsHandler</code> （2）。<code>route()</code>方法（无参数）代表此路由匹配所有请求。这两个<code>Set</code>的作用是支持 <em>CORS</em>，因为我们的API需要开启CORS以便配合前端正常工作。有关CORS的详细内容我们就不在这里细说了，详情可以参考<a href="http://enable-cors.org/server.html" target="_blank" rel="external">这里</a>。我们这里只需要知道如何开启CORS支持即可。</p>
<p>接下来我们给路由器绑定了一个全局的<code>BodyHandler</code> （3），它的作用是处理HTTP请求正文并获取其中的数据。比如，在实现添加待办事项逻辑的时候，我们需要读取请求正文中的JSON数据，这时候我们就可以用<code>BodyHandler</code>。</p>
<p>最后，我们通过<code>vertx.createHttpServer()</code>方法来创建一个HTTP服务端 （4）。注意这个功能是Vert.x Core提供的底层功能之一。然后我们将我们的路由处理器绑定到服务端上，这也是Vert.x Web的核心。你可能不熟悉<code>router::accept</code>这样的表示，这是Java 8中的 <em>方法引用</em>，它相当于一个分发路由的<code>Handler</code>。当有请求到达时，Vert.x会调用<code>accept</code>方法。然后我们通过<code>listen</code>方法监听8082端口。因为创建服务端的过程可能失败，因此我们还需要给<code>listen</code>方法传递一个<code>Handler</code>来检查服务端是否创建成功。正如我们前面所提到的，我们可以使用<code>future.complete</code>来表示过程成功，或者用<code>future.fail</code>来表示过程失败。</p>
<p>到现在为止，我们已经创建好HTTP服务端了，但我们还没有见到任何的路由呢！不要着急，是时候去声明路由了！</p>
<h2 id="配置路由">配置路由</h2><p>下面我们来声明路由。正如我们之前提到的，我们的路由可以设计成这样：</p>
<ul>
<li>添加待办事项: <code>POST /todos</code></li>
<li>获取某一待办事项: <code>GET /todos/:todoId</code></li>
<li>获取所有待办事项: <code>GET /todos</code></li>
<li>更新待办事项: <code>PATCH /todos/:todoId</code></li>
<li>删除某一待办事项: <code>DELETE /todos/:todoId</code></li>
<li>删除所有待办事项: <code>DELETE /todos</code></li>
</ul>
<blockquote>
<p>路径参数</p>
<p>在URL中，我们可以通过<code>:name</code>的形式定义路径参数。当处理请求的时候，Vert.x会自动获取这些路径参数并允许我们访问它们。拿我们的路由举个例子，<code>/todos/19</code> 将 <code>todoId</code> 映射为 <code>19</code>。</p>
</blockquote>
<p>首先我们先在 <code>io.vertx.blueprint.todolist</code> 包下创建一个<code>Constants</code>类用于存储各种全局常量（当然也可以放到其对应的类中）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Constants</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">/** API Route */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_GET = <span class="string">"/todos/:todoId"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_LIST_ALL = <span class="string">"/todos"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_CREATE = <span class="string">"/todos"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_UPDATE = <span class="string">"/todos/:todoId"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_DELETE = <span class="string">"/todos/:todoId"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_DELETE_ALL = <span class="string">"/todos"</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们将<code>start</code>方法中的<code>TODO</code>标识处替换为以下的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// routes</span></div><div class="line">router.get(Constants.API_GET).handler(<span class="keyword">this</span>::handleGetTodo);</div><div class="line">router.get(Constants.API_LIST_ALL).handler(<span class="keyword">this</span>::handleGetAll);</div><div class="line">router.post(Constants.API_CREATE).handler(<span class="keyword">this</span>::handleCreateTodo);</div><div class="line">router.patch(Constants.API_UPDATE).handler(<span class="keyword">this</span>::handleUpdateTodo);</div><div class="line">router.delete(Constants.API_DELETE).handler(<span class="keyword">this</span>::handleDeleteOne);</div><div class="line">router.delete(Constants.API_DELETE_ALL).handler(<span class="keyword">this</span>::handleDeleteAll);</div></pre></td></tr></table></figure>
<p>代码很直观、明了。我们用对应的方法（如<code>get</code>,<code>post</code>,<code>patch</code>等等）将路由路径与路由器绑定，并且我们调用<code>handler</code>方法给每个路由绑定上对应的<code>Handler</code>，接受的<code>Handler</code>类型为<code>Handler&lt;RoutingContext&gt;</code>。这里我们分别绑定了六个方法引用，它们的形式都类似于这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将在稍后实现这六个方法，这也是我们待办事项服务逻辑的核心。</p>
<h2 id="异步方法模式">异步方法模式</h2><p>我们之前提到过，Vert.x是 <strong>异步、非阻塞的</strong> 。每一个异步的方法总会接受一个 <code>Handler</code> 参数作为回调函数，当对应的操作完成时会调用接受的<code>Handler</code>，这是异步方法的一种实现。还有一种等价的实现是返回<code>Future</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAsync</span><span class="params">(A a, B b, Handler&lt;R&gt; handler)</span></span>;</div><div class="line"><span class="comment">// 这两种实现等价</span></div><div class="line"><span class="function">Future&lt;R&gt; <span class="title">doAsync</span><span class="params">(A a, B b)</span></span>;</div></pre></td></tr></table></figure>
<p>其中，<code>Future</code> 对象代表着一个操作的结果，这个操作可能还没有进行，可能正在进行，可能成功也可能失败。当操作完成时，<code>Future</code>对象会得到对应的结果。我们也可以通过<code>setHandler</code>方法给<code>Future</code>绑定一个<code>Handler</code>，当<code>Future</code>被赋予结果的时候，此<code>Handler</code>会被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Future&lt;R&gt; future = doAsync(A a, B b);</div><div class="line">future.setHandler(r -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">        <span class="comment">// 处理失败</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 操作结果</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Vert.x中大多数异步方法都是基于Handler的。而在本教程中，这两种异步模式我们都会接触到。</p>
<h2 id="待办事项逻辑实现">待办事项逻辑实现</h2><p>现在是时候来实现我们的待办事项业务逻辑了！这里我们使用 Redis 作为数据持久化存储。有关Redis的详细介绍请参照<a href="http://redis.io/" target="_blank" rel="external">Redis 官方网站</a>。Vert.x给我们提供了一个组件—— Vert.x-redis，允许我们以异步的形式操作Redis数据。</p>
<blockquote>
<p>如何安装Redis？</p>
<p>请参照Redis官方网站上详细的<a href="http://redis.io/download#installation" target="_blank" rel="external">安装指南</a>。</p>
</blockquote>
<h3 id="Vert-x_Redis">Vert.x Redis</h3><p>Vert.x Redis允许我们以异步的形式操作Redis数据。我们首先需要在<code>build.gradle</code>中添加以下依赖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> <span class="string">'io.vertx:vertx-redis-client:3.3.3'</span></div></pre></td></tr></table></figure>
<p>我们通过<code>RedisClient</code>对象来操作Redis中的数据，因此我们定义了一个类成员<code>redis</code>。在使用<code>RedisClient</code>之前，我们首先需要与Redis建立连接，并且需要配置（以<code>RedisOptions</code>的形式），后边我们再讲需要配置哪些东西。</p>
<p>我们来实现 <code>initData</code> 方法用于初始化 <code>RedisClient</code> 并且测试连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">  RedisOptions config = <span class="keyword">new</span> RedisOptions()</div><div class="line">      .setHost(config().getString(<span class="string">"redis.host"</span>, REDIS_HOST)) <span class="comment">// redis host</span></div><div class="line">      .setPort(config().getInteger(<span class="string">"redis.port"</span>, REDIS_PORT)); <span class="comment">// redis port</span></div><div class="line"></div><div class="line">  <span class="keyword">this</span>.redis = RedisClient.create(vertx, config); <span class="comment">// create redis client</span></div><div class="line"></div><div class="line">  redis.hset(Constants.REDIS_TODO_KEY, <span class="string">"24"</span>, Json.encodePrettily( <span class="comment">// test connection</span></div><div class="line">    <span class="keyword">new</span> Todo(<span class="number">24</span>, <span class="string">"Something to do..."</span>, <span class="keyword">false</span>, <span class="number">1</span>, <span class="string">"todo/ex"</span>)), res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.failed()) &#123;</div><div class="line">      LOGGER.error(<span class="string">"Redis service is not running!"</span>);</div><div class="line">      res.cause().printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们在加载Verticle的时候，我们会首先调用<code>initData</code>方法，这样可以保证<code>RedisClient</code>可以被正常创建。</p>
<h3 id="存储格式">存储格式</h3><p>我们知道，Redis支持各种格式的数据，并且支持多种方式存储（如<code>list</code>、<code>hash map</code>等）。这里我们将我们的待办事项存储在 <em>哈希表(map)</em> 中。我们使用待办事项的<code>id</code>作为key，JSON格式的待办事项数据作为value。同时，我们的哈希表本身也要有个key，我们把它命名为 <em>VERT_TODO</em>，并且存储到<code>Constants</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_TODO_KEY = <span class="string">"VERT_TODO"</span>;</div></pre></td></tr></table></figure>
<p>正如我们之前提到的，我们利用了生成的JSON数据转换类来实现<code>Todo</code>实体与JSON数据之间的转换（通过几个构造函数），在后面实现待办事项服务的时候可以广泛利用。</p>
<h3 id="获取/获取所有待办事项">获取/获取所有待办事项</h3><p>我们首先来实现获取待办事项的逻辑。正如我们之前所提到的，我们的处理逻辑方法需要接受一个<code>RoutingContext</code>类型的参数。我们看一下获取某一待办事项的逻辑方法(<code>handleGetTodo</code>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>); <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">if</span> (todoID == <span class="keyword">null</span>)</div><div class="line">    sendError(<span class="number">400</span>, context.response()); <span class="comment">// (2)</span></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    redis.hget(Constants.REDIS_TODO_KEY, todoID, x -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">      <span class="keyword">if</span> (x.succeeded()) &#123;</div><div class="line">        String result = x.result();</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</div><div class="line">          sendError(<span class="number">404</span>, context.response());</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          context.response()</div><div class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">            .end(result); <span class="comment">// (4)</span></div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span></div><div class="line">        sendError(<span class="number">503</span>, context.response());</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们先通过<code>getParam</code>方法获取路径参数<code>todoId</code> (1)。我们需要检测路径参数获取是否成功，如果不成功就返回 <code>400 Bad Request</code> 错误 (2)。这里我们写一个函数封装返回错误response的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> statusCode, HttpServerResponse response)</span> </span>&#123;</div><div class="line">  response.setStatusCode(statusCode).end();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面，<code>end</code>方法是非常重要的。只有我们调用<code>end</code>方法时，对应的HTTP Response才能被发送回客户端。</p>
<p>再回到<code>handleGetTodo</code>方法中。如果我们成功获取到了<code>todoId</code>，我们可以通过<code>hget</code>操作从Redis中获取对应的待办事项 (3)。<code>hget</code>代表通过key从对应的哈希表中获取对应的value，我们来看一下<code>hget</code>函数的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">RedisClient <span class="title">hget</span><span class="params">(String key, String field, Handler&lt;AsyncResult&lt;String&gt;&gt; handler)</span></span>;</div></pre></td></tr></table></figure>
<p>第一个参数<code>key</code>对应哈希表的key，第二个参数<code>field</code>代表待办事项的key，第三个参数代表当获取操作成功时对应的回调。在<code>Handler</code>中，我们首先检查操作是否成功，如果不成功就返回<code>503</code>错误。如果成功了，我们就可以获取操作的结果了。结果是<code>null</code>的话，说明Redis中没有对应的待办事项，因此我们返回<code>404 Not Found</code>代表不存在。如果结果存在，那么我们就可以通过<code>end</code>方法将其写入response中 (4)。注意到我们所有的RESTful API都返回JSON格式的数据，所以我们将<code>content-type</code>头设为<code>JSON</code>。</p>
<p>获取所有待办事项的逻辑<code>handleGetAll</code>与<code>handleGetTodo</code>大体上类似，但实现上有些许不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  redis.hvals(Constants.REDIS_TODO_KEY, res -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      String encoded = Json.encodePrettily(res.result().stream() <span class="comment">// (2)</span></div><div class="line">        .map(x -&gt; <span class="keyword">new</span> Todo((String) x))</div><div class="line">        .collect(Collectors.toList()));</div><div class="line">      context.response()</div><div class="line">        .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">        .end(encoded); <span class="comment">// (3)</span></div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">      sendError(<span class="number">503</span>, context.response());</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们通过<code>hvals</code>操作 (1) 来获取某个哈希表中的所有数据（以JSON数组的形式返回，即<code>JsonArray</code>对象）。在Handler中我们还是像之前那样先检查操作是否成功。如果成功的话我们就可以将结果写入response了。注意这里我们不能直接将返回的<code>JsonArray</code>写入response。想象一下返回的<code>JsonArray</code>包括着待办事项的key以及对应的JSON数据（字符串形式），因此此时每个待办事项对应的JSON数据都被转义了，所以我们需要先把这些转义过的JSON数据转换成实体对象，再重新编码。</p>
<p>我们这里采用了一种响应式编程思想的方法。首先我们了解到<code>JsonArray</code>类继承了<code>Iterable&lt;Object&gt;</code>接口（是不是感觉它很像<code>List</code>呢？），因此我们可以通过<code>stream</code>方法将其转化为<code>Stream</code>对象。注意这里的<code>Stream</code>可不是传统意义上讲的输入输出流(I/O stream)，而是数据流(data flow)。我们需要对数据流进行一系列的变换处理操作，这就是响应式编程的思想（也有点函数式编程的思想）。我们将数据流中的每个字符串数据转换为<code>Todo</code>实体对象，这个过程是通过<code>map</code>算子实现的。我们这里就不深入讨论<code>map</code>算子了，但它在函数式编程中非常重要。在<code>map</code>过后，我们通过<code>collect</code>方法将数据流“归约”成<code>List&lt;Todo&gt;</code>。现在我们就可以通过<code>Json.encodePrettily</code>方法对得到的list进行编码了，转换成JSON格式的数据。最后我们将转换后的结果写入到response中 (3)。</p>
<h3 id="创建待办事项">创建待办事项</h3><p>经过了上面两个业务逻辑实现的过程，你应该开始熟悉Vert.x了～现在我们来实现创建待办事项的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">final</span> Todo todo = wrapObject(<span class="keyword">new</span> Todo(context.getBodyAsString()), context);</div><div class="line">    <span class="keyword">final</span> String encoded = Json.encodePrettily(todo);</div><div class="line">    redis.hset(Constants.REDIS_TODO_KEY, String.valueOf(todo.getId()),</div><div class="line">      encoded, res -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (res.succeeded())</div><div class="line">          context.response()</div><div class="line">            .setStatusCode(<span class="number">201</span>)</div><div class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">            .end(encoded);</div><div class="line">        <span class="keyword">else</span></div><div class="line">          sendError(<span class="number">503</span>, context.response());</div><div class="line">      &#125;);</div><div class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</div><div class="line">    sendError(<span class="number">400</span>, context.response());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们通过<code>context.getBodyAsString()</code>方法来从请求正文中获取JSON数据并转换成<code>Todo</code>实体对象 (1)。这里我们包装了一个处理<code>Todo</code>实例的方法，用于给其添加必要的信息（如URL）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Todo <span class="title">wrapObject</span><span class="params">(Todo todo, RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> id = todo.getId();</div><div class="line">  <span class="keyword">if</span> (id &gt; Todo.getIncId()) &#123;</div><div class="line">    Todo.setIncIdWith(id);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)</div><div class="line">    todo.setIncId();</div><div class="line">  todo.setUrl(context.request().absoluteURI() + <span class="string">"/"</span> + todo.getId());</div><div class="line">  <span class="keyword">return</span> todo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于没有ID（或者为默认ID）的待办事项，我们会给它分配一个ID。这里我们采用了自增ID的策略，通过<code>AtomicInteger</code>来实现。</p>
<p>然后我们通过<code>Json.encodePrettily</code>方法将我们的<code>Todo</code>实例再次编码成JSON格式的数据 (2)。接下来我们利用<code>hset</code>函数将待办事项实例插入到对应的哈希表中 (3)。如果插入成功，返回 <code>201</code> 状态码 (4)。</p>
<p>[NOTE 201 状态码? | 正如你所看到的那样，我们将状态码设为<code>201</code>，这代表<code>CREATED</code>（已创建）。另外，如果不指定状态码的话，Vert.x Web默认将状态码设为 <code>200 OK</code>。]</p>
<p>同时，我们接收到的HTTP请求首部可能格式不正确，因此我们需要在方法中捕获<code>DecodeException</code>异常。这样一旦捕获到<code>DecodeException</code>异常，我们就返回<code>400 Bad Request</code>状态码。</p>
<h3 id="更新待办事项">更新待办事项</h3><p>如果你想改变你的计划，你就需要更新你的待办事项。我们来实现更新待办事项的逻辑，它有点小复杂（或者说是，繁琐？）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PATCH /todos/:todoId</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUpdateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    String todoID = context.request().getParam(<span class="string">"todoId"</span>); <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">final</span> Todo newTodo = <span class="keyword">new</span> Todo(context.getBodyAsString()); <span class="comment">// (2)</span></div><div class="line">    <span class="comment">// handle error</span></div><div class="line">    <span class="keyword">if</span> (todoID == <span class="keyword">null</span> || newTodo == <span class="keyword">null</span>) &#123;</div><div class="line">      sendError(<span class="number">400</span>, context.response());</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    redis.hget(Constants.REDIS_TODO_KEY, todoID, x -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">      <span class="keyword">if</span> (x.succeeded()) &#123;</div><div class="line">        String result = x.result();</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</div><div class="line">          sendError(<span class="number">404</span>, context.response()); <span class="comment">// (4)</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          Todo oldTodo = <span class="keyword">new</span> Todo(result);</div><div class="line">          String response = Json.encodePrettily(oldTodo.merge(newTodo)); <span class="comment">// (5)</span></div><div class="line">          redis.hset(Constants.REDIS_TODO_KEY, todoID, response, res -&gt; &#123; <span class="comment">// (6)</span></div><div class="line">            <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">              context.response()</div><div class="line">                .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">                .end(response); <span class="comment">// (7)</span></div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span></div><div class="line">        sendError(<span class="number">503</span>, context.response());</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</div><div class="line">    sendError(<span class="number">400</span>, context.response());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唔。。。一大长串代码诶。。。我们来看一下。首先我们从 <code>RoutingContext</code> 中获取路径参数 <code>todoId</code> (1)，这是我们想要更改待办事项对应的id。然后我们从请求正文中获取新的待办事项数据 (2)。这一步也有可能抛出 <code>DecodeException</code> 异常因此我们也需要去捕获它。要更新待办事项，我们需要先通过<code>hget</code>函数获取之前的待办事项 (3)，检查其是否存在。获取旧的待办事项之后，我们调用之前在<code>Todo</code>类中实现的<code>merge</code>方法将旧待办事项与新待办事项整合到一起 (5)，然后编码成JSON格式的数据。然后我们通过<code>hset</code>函数更新对应的待办事项 (6)（<code>hset</code>表示如果不存在就插入，存在就更新）。操作成功的话，返回 <code>200 OK</code> 状态。</p>
<p>这就是更新待办事项的逻辑～要有耐心哟，我们马上就要见到胜利的曙光了～下面我们来实现删除待办事项的逻辑。</p>
<h3 id="删除/删除全部待办事项">删除/删除全部待办事项</h3><p>删除待办事项的逻辑非常简单。我们利用<code>hdel</code>函数来删除某一待办事项，用<code>del</code>函数删掉所有待办事项（实际上是直接把那个哈希表给删了）。如果删除操作成功，返回<code>204 No Content</code> 状态。</p>
<p>这里直接给出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteOne</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">  redis.hdel(Constants.REDIS_TODO_KEY, todoID, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded())</div><div class="line">      context.response().setStatusCode(<span class="number">204</span>).end();</div><div class="line">    <span class="keyword">else</span></div><div class="line">      sendError(<span class="number">503</span>, context.response());</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  redis.del(Constants.REDIS_TODO_KEY, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded())</div><div class="line">      context.response().setStatusCode(<span class="number">204</span>).end();</div><div class="line">    <span class="keyword">else</span></div><div class="line">      sendError(<span class="number">503</span>, context.response());</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>啊哈！我们实现待办事项服务的Verticle已经完成咯～一颗赛艇！但是我们该如何去运行我们的<code>Verticle</code>呢？答案是，我们需要 <em>部署并运行</em> 我们的Verticle。还好Vert.x提供了一个运行Verticle的辅助工具：Vert.x Launcher，让我们来看看如何利用它。</p>
<h2 id="将应用与Vert-x_Launcher一起打包">将应用与Vert.x Launcher一起打包</h2><p>要通过Vert.x Launcher来运行Verticle，我们需要在<code>build.gradle</code>中配置一下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jar &#123;</div><div class="line">  <span class="comment">// by default fat jar</span></div><div class="line">  archiveName = <span class="string">'vertx-blueprint-todo-backend-fat.jar'</span></div><div class="line">  <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">  manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.todolist.verticles.SingleApplicationVerticle'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在<code>jar</code>区块中，我们配置Gradle使其生成 <strong>fat-jar</strong>，并指定启动类。<em>fat-jar</em> 是一个给Vert.x应用打包的简便方法，它直接将我们的应用连同所有的依赖都给打包到jar包中去了，这样我们可以直接通过jar包运行我们的应用而不必再指定依赖的 <code>CLASSPATH</code></li>
<li>我们将<code>Main-Class</code>属性设为<code>io.vertx.core.Launcher</code>，这样就可以通过Vert.x Launcher来启动对应的Verticle了。另外我们需要将<code>Main-Verticle</code>属性设为我们想要部署的Verticle的类名（全名）。</li>
</ul>
<p>配置好了以后，我们就可以打包了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle build</div></pre></td></tr></table></figure>
<h2 id="运行我们的服务">运行我们的服务</h2><p>万事俱备，只欠东风。是时候运行我们的待办事项服务了！首先我们先启动Redis服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server</div></pre></td></tr></table></figure>
<p>然后运行服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar build/libs/vertx-blueprint-todo-backend-fat.jar</div></pre></td></tr></table></figure>
<p>如果没问题的话，你将会在终端中看到 <code>Succeeded in deploying verticle</code> 的字样。下面我们可以自由测试我们的API了，其中最简便的方法是借助 <a href="https://github.com/TodoBackend/todo-backend-js-spec" target="_blank" rel="external">todo-backend-js-spec</a> 来测试。</p>
<p>键入 <code>http://127.0.0.1:8082/todos</code>：</p>
<p><img src="https://github.com/sczyh30/vertx-blueprint-todo-backend/raw/master/docs/img/todo-test-input.png" alt=""></p>
<p>测试结果：</p>
<p><img src="https://github.com/sczyh30/vertx-blueprint-todo-backend/raw/master/docs/img/todo-test-result.png" alt=""></p>
<p>当然，我们也可以用其它工具，比如 <code>curl</code> ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">sczyh30@sczyh30-workshop:~$ curl http://127.0.0.1:8082/todos</div><div class="line">[ &#123;</div><div class="line">  "id" : 20578623,</div><div class="line">  "title" : "blah",</div><div class="line">  "completed" : false,</div><div class="line">  "order" : 95,</div><div class="line">  "url" : "http://127.0.0.1:8082/todos/20578623"</div><div class="line">&#125;, &#123;</div><div class="line">  "id" : 1744802607,</div><div class="line">  "title" : "blah",</div><div class="line">  "completed" : false,</div><div class="line">  "order" : 523,</div><div class="line">  "url" : "http://127.0.0.1:8082/todos/1744802607"</div><div class="line">&#125;, &#123;</div><div class="line">  "id" : 981337975,</div><div class="line">  "title" : "blah",</div><div class="line">  "completed" : false,</div><div class="line">  "order" : 95,</div><div class="line">  "url" : "http://127.0.0.1:8082/todos/981337975"</div><div class="line">&#125; ]</div></pre></td></tr></table></figure>
<h1 id="将服务与控制器分离">将服务与控制器分离</h1><p>啊哈～我们的待办事项服务已经可以正常运行了，但是回头再来看看 <code>SingleApplicationVerticle</code> 类的代码，你会发现它非常混乱，待办事项业务逻辑与控制器混杂在一起，让这个类非常的庞大，并且这也不利于我们服务的扩展。根据面向对象解耦的思想，我们需要将控制器部分与业务逻辑部分分离。</p>
<h2 id="用Future实现异步服务">用Future实现异步服务</h2><p>下面我们来设计我们的业务逻辑层。就像我们之前提到的那样，我们的服务需要是异步的，因此这些服务的方法要么需要接受一个<code>Handler</code>参数作为回调，要么需要返回一个<code>Future</code>对象。但是想象一下很多个<code>Handler</code>混杂在一起嵌套的情况，你会陷入 <em>回调地狱</em>，这是非常糟糕的。因此，这里我们用<code>Future</code>实现我们的待办事项服务。</p>
<p>在 <code>io.vertx.blueprint.todolist.service</code> 包下创建 <code>TodoService</code> 接口并且编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.entity.Todo;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Optional;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TodoService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">initData</span><span class="params">()</span></span>; <span class="comment">// 初始化数据（或数据库）</span></div><div class="line"></div><div class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">insert</span><span class="params">(Todo todo)</span></span>;</div><div class="line"></div><div class="line">  Future&lt;List&lt;Todo&gt;&gt; getAll();</div><div class="line"></div><div class="line">  Future&lt;Optional&lt;Todo&gt;&gt; getCertain(String todoID);</div><div class="line"></div><div class="line">  <span class="function">Future&lt;Todo&gt; <span class="title">update</span><span class="params">(String todoId, Todo newTodo)</span></span>;</div><div class="line"></div><div class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">delete</span><span class="params">(String todoId)</span></span>;</div><div class="line"></div><div class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">deleteAll</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到<code>getCertain</code>方法返回一个<code>Future&lt;Optional&lt;Todo&gt;&gt;</code>对象。那么<code>Optional</code>是啥呢？它封装了一个可能为空的对象。因为数据库里面可能没有与我们给定的<code>todoId</code>相对应的待办事项，查询的结果可能为空，因此我们给它包装上 <code>Optional</code>。<code>Optional</code> 可以避免万恶的 <code>NullPointerException</code>，并且它在函数式编程中用途特别广泛（在Haskell中对应 <strong>Maybe Monad</strong>）。</p>
<p>既然我们已经设计好我们的异步服务接口了，让我们来重构原先的Verticle吧！</p>
<h2 id="开始重构！">开始重构！</h2><p>我们创建一个新的Verticle。在 <code>io.vertx.blueprint.todolist.verticles</code> 包中创建 <code>TodoVerticle</code> 类，并编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.verticles;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.Constants;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.entity.Todo;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.service.TodoService;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</div><div class="line"><span class="keyword">import</span> io.vertx.core.AsyncResult;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Handler;</div><div class="line"><span class="keyword">import</span> io.vertx.core.http.HttpMethod;</div><div class="line"><span class="keyword">import</span> io.vertx.core.http.HttpServerResponse;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.DecodeException;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.Json;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.web.Router;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.web.RoutingContext;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.web.handler.BodyHandler;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.web.handler.CorsHandler;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"><span class="keyword">import</span> java.util.function.Consumer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"0.0.0.0"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8082</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> TodoService service;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Router router = Router.router(vertx);</div><div class="line">    <span class="comment">// CORS support</span></div><div class="line">    Set&lt;String&gt; allowHeaders = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    allowHeaders.add(<span class="string">"x-requested-with"</span>);</div><div class="line">    allowHeaders.add(<span class="string">"Access-Control-Allow-Origin"</span>);</div><div class="line">    allowHeaders.add(<span class="string">"origin"</span>);</div><div class="line">    allowHeaders.add(<span class="string">"Content-Type"</span>);</div><div class="line">    allowHeaders.add(<span class="string">"accept"</span>);</div><div class="line">    Set&lt;HttpMethod&gt; allowMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    allowMethods.add(HttpMethod.GET);</div><div class="line">    allowMethods.add(HttpMethod.POST);</div><div class="line">    allowMethods.add(HttpMethod.DELETE);</div><div class="line">    allowMethods.add(HttpMethod.PATCH);</div><div class="line"></div><div class="line">    router.route().handler(BodyHandler.create());</div><div class="line">    router.route().handler(CorsHandler.create(<span class="string">"*"</span>)</div><div class="line">      .allowedHeaders(allowHeaders)</div><div class="line">      .allowedMethods(allowMethods));</div><div class="line"></div><div class="line">    <span class="comment">// routes</span></div><div class="line">    router.get(Constants.API_GET).handler(<span class="keyword">this</span>::handleGetTodo);</div><div class="line">    router.get(Constants.API_LIST_ALL).handler(<span class="keyword">this</span>::handleGetAll);</div><div class="line">    router.post(Constants.API_CREATE).handler(<span class="keyword">this</span>::handleCreateTodo);</div><div class="line">    router.patch(Constants.API_UPDATE).handler(<span class="keyword">this</span>::handleUpdateTodo);</div><div class="line">    router.delete(Constants.API_DELETE).handler(<span class="keyword">this</span>::handleDeleteOne);</div><div class="line">    router.delete(Constants.API_DELETE_ALL).handler(<span class="keyword">this</span>::handleDeleteAll);</div><div class="line"></div><div class="line">    vertx.createHttpServer()</div><div class="line">      .requestHandler(router::accept)</div><div class="line">      .listen(PORT, HOST, result -&gt; &#123;</div><div class="line">          <span class="keyword">if</span> (result.succeeded())</div><div class="line">            future.complete();</div><div class="line">          <span class="keyword">else</span></div><div class="line">            future.fail(result.cause());</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    initData();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUpdateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteOne</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">     <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> statusCode, HttpServerResponse response)</span> </span>&#123;</div><div class="line">    response.setStatusCode(statusCode).end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">badRequest</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    context.response().setStatusCode(<span class="number">400</span>).end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notFound</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    context.response().setStatusCode(<span class="number">404</span>).end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceUnavailable</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    context.response().setStatusCode(<span class="number">503</span>).end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Todo <span class="title">wrapObject</span><span class="params">(Todo todo, RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> id = todo.getId();</div><div class="line">    <span class="keyword">if</span> (id &gt; Todo.getIncId()) &#123;</div><div class="line">      Todo.setIncIdWith(id);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)</div><div class="line">      todo.setIncId();</div><div class="line">    todo.setUrl(context.request().absoluteURI() + <span class="string">"/"</span> + todo.getId());</div><div class="line">    <span class="keyword">return</span> todo;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很熟悉吧？这个<code>Verticle</code>的结构与我们之前的Verticle相类似，这里就不多说了。下面我们来利用我们之前编写的服务接口实现每一个控制器方法。</p>
<p>首先先实现 <code>initData</code> 方法，此方法用于初始化存储结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String serviceType = config().getString(<span class="string">"service.type"</span>, <span class="string">"redis"</span>);</div><div class="line">  LOGGER.info(<span class="string">"Service Type: "</span> + serviceType);</div><div class="line">  <span class="keyword">switch</span> (serviceType) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"jdbc"</span>:</div><div class="line">      service = <span class="keyword">new</span> JdbcTodoService(vertx, config());</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"redis"</span>:</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      RedisOptions config = <span class="keyword">new</span> RedisOptions()</div><div class="line">        .setHost(config().getString(<span class="string">"redis.host"</span>, <span class="string">"127.0.0.1"</span>))</div><div class="line">        .setPort(config().getInteger(<span class="string">"redis.port"</span>, <span class="number">6379</span>));</div><div class="line">      service = <span class="keyword">new</span> RedisTodoService(vertx, config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  service.initData().setHandler(res -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (res.failed()) &#123;</div><div class="line">        LOGGER.error(<span class="string">"Persistence service is not running!"</span>);</div><div class="line">        res.cause().printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们从配置中获取服务的类型，这里我们有两种类型的服务：<code>redis</code>和<code>jdbc</code>，默认是<code>redis</code>。接着我们会根据服务的类型以及对应的配置来创建服务。在这里，我们的配置都是从JSON格式的配置文件中读取，并通过Vert.x Launcher的<code>-conf</code>项加载。后面我们再讲要配置哪些东西。</p>
<p>接着我们给<code>service.initData()</code>方法返回的<code>Future</code>对象绑定了一个<code>Handler</code>，这个<code>Handler</code>将会在<code>Future</code>得到结果的时候被调用。一旦初始化过程失败，错误信息将会显示到终端上。</p>
<p>其它的方法实现也类似，这里就不详细解释了，直接放上代码，非常简洁明了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Wrap the result handler with failure handler (503 Service Unavailable)</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> &lt;T&gt; Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler(RoutingContext context, Consumer&lt;T&gt; consumer) &#123;</div><div class="line">  <span class="keyword">return</span> res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      consumer.accept(res.result());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      serviceUnavailable(context);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">final</span> Todo todo = wrapObject(<span class="keyword">new</span> Todo(context.getBodyAsString()), context);</div><div class="line">    <span class="keyword">final</span> String encoded = Json.encodePrettily(todo);</div><div class="line"></div><div class="line">    service.insert(todo).setHandler(resultHandler(context, res -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (res) &#123;</div><div class="line">        context.response()</div><div class="line">          .setStatusCode(<span class="number">201</span>)</div><div class="line">          .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">          .end(encoded);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serviceUnavailable(context);</div><div class="line">      &#125;</div><div class="line">    &#125;));</div><div class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</div><div class="line">    sendError(<span class="number">400</span>, context.response());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">  <span class="keyword">if</span> (todoID == <span class="keyword">null</span>) &#123;</div><div class="line">    sendError(<span class="number">400</span>, context.response());</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  service.getCertain(todoID).setHandler(resultHandler(context, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (!res.isPresent())</div><div class="line">      notFound(context);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">final</span> String encoded = Json.encodePrettily(res.get());</div><div class="line">      context.response()</div><div class="line">        .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">        .end(encoded);</div><div class="line">    &#125;</div><div class="line">  &#125;));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  service.getAll().setHandler(resultHandler(context, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</div><div class="line">      serviceUnavailable(context);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">final</span> String encoded = Json.encodePrettily(res);</div><div class="line">      context.response()</div><div class="line">        .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">        .end(encoded);</div><div class="line">    &#125;</div><div class="line">  &#125;));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUpdateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    String todoID = context.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">    <span class="keyword">final</span> Todo newTodo = <span class="keyword">new</span> Todo(context.getBodyAsString());</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">    <span class="keyword">if</span> (todoID == <span class="keyword">null</span>) &#123;</div><div class="line">      sendError(<span class="number">400</span>, context.response());</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    service.update(todoID, newTodo)</div><div class="line">      .setHandler(resultHandler(context, res -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>)</div><div class="line">          notFound(context);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">final</span> String encoded = Json.encodePrettily(res);</div><div class="line">          context.response()</div><div class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">            .end(encoded);</div><div class="line">        &#125;</div><div class="line">      &#125;));</div><div class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</div><div class="line">    badRequest(context);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;Boolean&gt;&gt; deleteResultHandler(RoutingContext context) &#123;</div><div class="line">  <span class="keyword">return</span> res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      <span class="keyword">if</span> (res.result()) &#123;</div><div class="line">        context.response().setStatusCode(<span class="number">204</span>).end();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serviceUnavailable(context);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      serviceUnavailable(context);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteOne</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">  service.delete(todoID)</div><div class="line">    .setHandler(deleteResultHandler(context));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  service.deleteAll()</div><div class="line">    .setHandler(deleteResultHandler(context));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是和之前的Verticle很相似呢？这里我们还封装了两个<code>Handler</code>生成器：<code>resultHandler</code> 和 <code>deleteResultHandler</code>。这两个生成器封装了一些重复的代码，可以减少代码量。</p>
<p>嗯。。。我们的新Verticle写好了，那么是时候去实现具体的业务逻辑了。这里我们会实现两个版本的业务逻辑，分别对应两种存储：<strong>Redis</strong> 和 <strong>MySQL</strong>。</p>
<h2 id="Vert-x-Redis版本的待办事项服务">Vert.x-Redis版本的待办事项服务</h2><p>之前我们已经实现过一遍Redis版本的服务了，因此你应该对其非常熟悉了。这里我们仅仅解释一个 <code>update</code> 方法，其它的实现都非常类似，代码可以在<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/blob/master/src/main/java/io/vertx/blueprint/todolist/service/RedisTodoService.java" target="_blank" rel="external">GitHub</a>上浏览。</p>
<h3 id="Monadic_Future">Monadic Future</h3><p>回想一下我们之前写的更新待办事项的逻辑，我们会发现它其实是由两个独立的操作组成 - <code>get</code> 和 <code>insert</code>（对于Redis来说）。所以呢，我们可不可以复用 <code>getCertain</code> 和 <code>insert</code> 这两个方法？当然了！因为<code>Future</code>是可组合的，因此我们可以将这两个方法返回的<code>Future</code>组合到一起。是不是非常方便呢？我们来编写此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Todo&gt; <span class="title">update</span><span class="params">(String todoId, Todo newTodo)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.getCertain(todoId).compose(old -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (old.isPresent()) &#123;</div><div class="line">      Todo fnTodo = old.get().merge(newTodo);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.insert(fnTodo)</div><div class="line">        .map(r -&gt; r ? fnTodo : <span class="keyword">null</span>); <span class="comment">// (2)</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> Future.succeededFuture(); <span class="comment">// (3)</span></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们调用了<code>getCertain</code>方法，此方法返回一个<code>Future&lt;Optional&lt;Todo&gt;&gt;</code>对象。同时我们使用<code>compose</code>函数将此方法返回的<code>Future</code>与另一个<code>Future</code>进行组合（1），其中<code>compose</code>函数接受一个<code>T =&gt; Future&lt;U&gt;</code>类型的lambda。然后我们接着检查旧的待办事项是否存在，如果存在的话，我们将新的待办事项与旧的待办事项相融合，然后更新待办事项。注意到<code>insert</code>方法返回<code>Future&lt;Boolean&gt;</code>类型的<code>Future</code>，因此我们还需要对此Future的结果做变换，这个变换的过程是通过<code>map</code>函数实现的（2）。<code>map</code>函数接受一个<code>T =&gt; U</code>类型的lambda。如果旧的待办事项不存在，我们返回一个包含null的<code>Future</code>（3）。最后我们返回组合后的<code>Future</code>对象。</p>
<blockquote>
<p><code>Future</code> 的本质</p>
<p>在函数式编程中，<code>Future</code> 实际上是一种 <code>Monad</code>。有关<code>Monad</code>的理论较为复杂，这里就不进行阐述了。你可以简单地把它看作是一个可以进行变换(<code>map</code>)和组合(<code>compose</code>)的包装对象。我们把这种特性叫做 <strong>monadic</strong>。</p>
</blockquote>
<p>下面来实现MySQL版本的待办事项服务。</p>
<h2 id="Vert-x-JDBC版本的待办事项服务">Vert.x-JDBC版本的待办事项服务</h2><h3 id="JDBC_++_异步">JDBC ++ 异步</h3><p>我们使用Vert.x-JDBC和MySQL来实现JDBC版本的待办事项服务。我们知道，数据库操作都是阻塞操作，很可能会占用不少时间。而Vert.x-JDBC提供了一种异步操作数据库的模式，很神奇吧？所以，在传统JDBC代码下我们要执行SQL语句需要这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String SQL = <span class="string">"SELECT * FROM todo"</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line">ResultSet rs = pstmt.executeQuery(SQL);</div></pre></td></tr></table></figure>
<p>而在Vert.x JDBC中，我们可以利用回调获取数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">connection.query(SQL, result -&gt; &#123;</div><div class="line">    <span class="comment">// do something with result...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种异步操作可以有效避免对数据的等待。当数据获取成功时会自动调用回调函数来执行处理数据的逻辑。</p>
<h3 id="添加依赖">添加依赖</h3><p>首先我们需要向<code>build.gradle</code>文件中添加依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'io.vertx:vertx-jdbc-client:3.3.3'</span></div><div class="line">compile <span class="string">'mysql:mysql-connector-java:6.0.2'</span></div></pre></td></tr></table></figure>
<p>其中第二个依赖是MySQL的驱动，如果你想使用其他的数据库，你需要自行替换掉这个依赖。</p>
<h3 id="初始化JDBCClient">初始化JDBCClient</h3><p>在Vert.x JDBC中，我们需要从一个<code>JDBCClient</code>对象中获取数据库连接，因此我们来看一下如何创建<code>JDBCClient</code>实例。在<code>io.vertx.blueprint.todolist.service</code>包下创建<code>JdbcTodoService</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.entity.Todo;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Vertx;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonArray;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.jdbc.JDBCClient;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.sql.SQLConnection;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Optional;</div><div class="line"><span class="keyword">import</span> java.util.stream.Collectors;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTodoService</span> <span class="keyword">implements</span> <span class="title">TodoService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vertx vertx;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> JsonObject config;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> JDBCClient client;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JdbcTodoService</span><span class="params">(JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(Vertx.vertx(), config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JdbcTodoService</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.vertx = vertx;</div><div class="line">    <span class="keyword">this</span>.config = config;</div><div class="line">    <span class="keyword">this</span>.client = JDBCClient.createShared(vertx, config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用<code>JDBCClient.createShared(vertx, config)</code>方法来创建一个<code>JDBCClient</code>实例，其中我们传入一个<code>JsonObject</code>对象作为配置。一般来说，我们需要配置以下的内容：</p>
<ul>
<li><em>url</em> - JDBC URL，比如 <code>jdbc:mysql://localhost/vertx_blueprint</code></li>
<li><em>driver_class</em> - JDBC驱动名称，比如 <code>com.mysql.cj.jdbc.Driver</code></li>
<li><em>user</em> - 数据库用户</li>
<li><em>password</em> - 数据库密码</li>
</ul>
<p>我们将会通过Vert.x Launcher从配置文件中读取此<code>JsonObject</code>。</p>
<p>现在我们已经创建了<code>JDBCClient</code>实例了，下面我们需要在MySQL中建这样一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`todo`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  <span class="string">`title`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`completed`</span> TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`order`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`url`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>我们把要用到的数据库语句都存到服务类中（这里我们就不讨论如何设计表以及写SQL了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_CREATE = <span class="string">"CREATE TABLE IF NOT EXISTS `todo` (\n"</span> +</div><div class="line">  <span class="string">"  `id` int(11) NOT NULL AUTO_INCREMENT,\n"</span> +</div><div class="line">  <span class="string">"  `title` varchar(255) DEFAULT NULL,\n"</span> +</div><div class="line">  <span class="string">"  `completed` tinyint(1) DEFAULT NULL,\n"</span> +</div><div class="line">  <span class="string">"  `order` int(11) DEFAULT NULL,\n"</span> +</div><div class="line">  <span class="string">"  `url` varchar(255) DEFAULT NULL,\n"</span> +</div><div class="line">  <span class="string">"  PRIMARY KEY (`id`) )"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_INSERT = <span class="string">"INSERT INTO `todo` "</span> +</div><div class="line">  <span class="string">"(`id`, `title`, `completed`, `order`, `url`) VALUES (?, ?, ?, ?, ?)"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_QUERY = <span class="string">"SELECT * FROM todo WHERE id = ?"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_QUERY_ALL = <span class="string">"SELECT * FROM todo"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_UPDATE = <span class="string">"UPDATE `todo`\n"</span> +</div><div class="line">  <span class="string">"SET `id` = ?,\n"</span> +</div><div class="line">  <span class="string">"`title` = ?,\n"</span> +</div><div class="line">  <span class="string">"`completed` = ?,\n"</span> +</div><div class="line">  <span class="string">"`order` = ?,\n"</span> +</div><div class="line">  <span class="string">"`url` = ?\n"</span> +</div><div class="line">  <span class="string">"WHERE `id` = ?;"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_DELETE = <span class="string">"DELETE FROM `todo` WHERE `id` = ?"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_DELETE_ALL = <span class="string">"DELETE FROM `todo`"</span>;</div></pre></td></tr></table></figure>
<p>OK！一切工作准备就绪，下面我们来实现我们的JDBC版本的服务～</p>
<h3 id="实现JDBC版本的服务">实现JDBC版本的服务</h3><p>所有的获取连接、获取执行数据的操作都要在<code>Handler</code>中完成。比如我们可以这样获取数据库连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">client.getConnection(conn -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (conn.succeeded()) &#123;</div><div class="line">        <span class="keyword">final</span> SQLConnection connection = conn.result();</div><div class="line">        <span class="comment">// do something...</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// handle failure</span></div><div class="line">      &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>由于每一个数据库操作都需要获取数据库连接，因此我们来包装一个返回<code>Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt;</code>的方法，在此回调中可以直接使用数据库连接，可以减少一些代码量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt; connHandler(Future future, Handler&lt;SQLConnection&gt; handler) &#123;</div><div class="line">  <span class="keyword">return</span> conn -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (conn.succeeded()) &#123;</div><div class="line">      <span class="keyword">final</span> SQLConnection connection = conn.result();</div><div class="line">      handler.handle(connection);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      future.fail(conn.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取数据库连接以后，我们就可以对数据库进行各种操作了：</p>
<ul>
<li><code>query</code> : 执行查询（raw SQL）</li>
<li><code>queryWithParams</code> : 执行预编译查询（prepared statement）</li>
<li><code>updateWithParams</code> : 执行预编译DDL语句（prepared statement）</li>
<li><code>execute</code>: 执行任意SQL语句</li>
</ul>
<p>所有的方法都是异步的所以每个方法最后都接受一个<code>Handler</code>参数，我们可以在此<code>Handler</code>中获取结果并执行相应逻辑。</p>
<p>现在我们来编写初始化数据库表的<code>initData</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">  Future&lt;Boolean&gt; result = Future.future();</div><div class="line">  client.getConnection(connHandler(result, connection -&gt;</div><div class="line">    connection.execute(SQL_CREATE, create -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (create.succeeded()) &#123;</div><div class="line">        result.complete(<span class="keyword">true</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        result.fail(create.cause());</div><div class="line">      &#125;</div><div class="line">      connection.close();</div><div class="line">    &#125;)));</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此方法仅会在Verticle初始化时被调用，如果<code>todo</code>表不存在的话就创建一下。注意，<strong>最后一定要关闭数据库连接</strong>。</p>
<p>下面我们来实现插入逻辑方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title">insert</span><span class="params">(Todo todo)</span> </span>&#123;</div><div class="line">  Future&lt;Boolean&gt; result = Future.future();</div><div class="line">  client.getConnection(connHandler(result, connection -&gt; &#123;</div><div class="line">    connection.updateWithParams(SQL_INSERT, <span class="keyword">new</span> JsonArray().add(todo.getId())</div><div class="line">      .add(todo.getTitle())</div><div class="line">      .add(todo.isCompleted())</div><div class="line">      .add(todo.getOrder())</div><div class="line">      .add(todo.getUrl()), r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">        result.fail(r.cause());</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        result.complete(<span class="keyword">true</span>);</div><div class="line">      &#125;</div><div class="line">      connection.close();</div><div class="line">    &#125;);</div><div class="line">  &#125;));</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用<code>updateWithParams</code>方法执行插入逻辑，并且传递了一个<code>JsonArray</code>变量作为预编译参数。这一点很重要，使用预编译语句可以有效防止SQL注入。</p>
<p>我们再来实现<code>getCertain</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Future&lt;Optional&lt;Todo&gt;&gt; getCertain(String todoID) &#123;</div><div class="line">  Future&lt;Optional&lt;Todo&gt;&gt; result = Future.future();</div><div class="line">  client.getConnection(connHandler(result, connection -&gt; &#123;</div><div class="line">    connection.queryWithParams(SQL_QUERY, <span class="keyword">new</span> JsonArray().add(todoID), r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">        result.fail(r.cause());</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        List&lt;JsonObject&gt; list = r.result().getRows();</div><div class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span> || list.isEmpty()) &#123;</div><div class="line">          result.complete(Optional.empty());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          result.complete(Optional.of(<span class="keyword">new</span> Todo(list.get(<span class="number">0</span>))));</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      connection.close();</div><div class="line">    &#125;);</div><div class="line">  &#125;));</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法里，当我们的查询语句执行以后，我们获得到了<code>ResultSet</code>实例作为查询的结果集。我们可以通过<code>getColumnNames</code>方法获取字段名称，通过<code>getResults</code>方法获取结果。这里我们通过<code>getRows</code>方法来获取结果集，结果集的类型为<code>List&lt;JsonObject&gt;</code>。</p>
<p>其余的几个方法：<code>getAll</code>, <code>update</code>, <code>delete</code> 以及 <code>deleteAll</code>都遵循上面的模式，这里就不多说了。你可以在<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/blob/master/src/main/java/io/vertx/blueprint/todolist/service/JdbcTodoService.java" target="_blank" rel="external">GitHub</a>上浏览完整的源代码。</p>
<p>重构完毕，我们来写待办事项服务对应的配置，然后再来运行！</p>
<h2 id="再来运行！">再来运行！</h2><p>首先我们在项目的根目录下创建一个 <code>config</code> 文件夹作为配置文件夹。我们在其中创建一个<code>config_jdbc.json</code>文件作为 <code>jdbc</code> 类型服务的配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"service.type"</span>: <span class="string">"jdbc"</span>,</div><div class="line">  <span class="attr">"url"</span>: <span class="string">"jdbc:mysql://localhost/vertx_blueprint?characterEncoding=UTF-8&amp;useSSL=false"</span>,</div><div class="line">  <span class="attr">"driver_class"</span>: <span class="string">"com.mysql.cj.jdbc.Driver"</span>,</div><div class="line">  <span class="attr">"user"</span>: <span class="string">"vbpdb1"</span>,</div><div class="line">  <span class="attr">"password"</span>: <span class="string">"666666*"</span>,</div><div class="line">  <span class="attr">"max_pool_size"</span>: <span class="number">30</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你需要根据自己的情况替换掉上述配置文件中相应的内容(如 <em>JDBC URL</em>，<em>JDBC 驱动</em> 等)。</p>
<p>再建一个<code>config.json</code>文件作为<code>redis</code>类型服务的配置（其它的项就用默认配置好啦）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"service.type"</span>: <span class="string">"redis"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的构建文件也需要更新咯～这里直接给出最终的<code>build.gradle</code>文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">plugins &#123;</div><div class="line">  id <span class="string">'java'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">version <span class="string">'1.0'</span></div><div class="line"></div><div class="line">ext &#123;</div><div class="line">  vertxVersion = <span class="string">"3.3.3"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">jar &#123;</div><div class="line">  <span class="comment">// by default fat jar</span></div><div class="line">  archiveName = <span class="string">'vertx-blueprint-todo-backend-fat.jar'</span></div><div class="line">  <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">  manifest &#123;</div><div class="line">    attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">    attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.todolist.verticles.TodoVerticle'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">repositories</span> &#123;</div><div class="line">  jcenter()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// compileOnly requires Gradle 2.12+</span></div><div class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</div><div class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</div><div class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">  <span class="keyword">options</span>.compilerArgs = [</div><div class="line">    <span class="string">"-proc:only"</span>,</div><div class="line">    <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</div><div class="line">    <span class="string">"-AoutputDirectory=$&#123;destinationDir.absolutePath&#125;"</span></div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">sourceSets</span> &#123;</div><div class="line">  main &#123;</div><div class="line">    java &#123;</div><div class="line">      srcDirs += <span class="string">'src/main/generated'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">compileJava &#123;</div><div class="line">  <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">  <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line"></div><div class="line">  dependsOn annotationProcessing</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-core:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-jdbc-client:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-redis-client:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  compileOnly(<span class="string">"io.vertx:vertx-codegen:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  <span class="keyword">compile</span> <span class="string">'mysql:mysql-connector-java:6.0.2'</span></div><div class="line"></div><div class="line">  testCompile(<span class="string">"io.vertx:vertx-unit:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  testCompile <span class="keyword">group</span>: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.12'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">task</span> wrapper(type: Wrapper) &#123;</div><div class="line">  gradleVersion = <span class="string">'3.0'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好啦好啦，迫不及待了吧？～打开终端，构建我们的应用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle build</div></pre></td></tr></table></figure>
<p>然后我们可以运行Redis版本的待办事项服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar build/libs/vertx-blueprint-todo-backend-fat.jar -conf config/config.json</div></pre></td></tr></table></figure>
<p>我们也可以运行JDBC版本的待办事项服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar build/libs/vertx-blueprint-todo-backend-fat.jar -conf config/config_jdbc.json</div></pre></td></tr></table></figure>
<p>同样地，我们也可以使用<a href="https://github.com/TodoBackend/todo-backend-js-spec" target="_blank" rel="external">todo-backend-js-spec</a>来测试我们的API。由于我们的API设计没有改变，因此测试结果应该不会有变化。</p>
<p>我们也提供了待办事项服务对应的Docker Compose镜像构建文件，可以直接通过Docker来运行我们的待办事项服务。你可以在仓库的根目录下看到<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/blob/master/docker-compose.yml" target="_blank" rel="external">相应的配置文件</a>，并通过 <code>docker-compose up -- build</code> 命令来构建并运行。</p>
<p><img src="https://github.com/sczyh30/vertx-blueprint-todo-backend/raw/master/docs/img/vbptds-docker-compose-running.png" alt="Docker Compose"></p>
<h1 id="哈哈，成功了！">哈哈，成功了！</h1><p>哈哈，恭喜你完成了整个待办事项服务，是不是很开心？～在整个教程中，你应该学到了很多关于 <code>Vert.x Web</code>、 <code>Vert.x Redis</code> 和 <code>Vert.x JDBC</code> 的开发知识。当然，最重要的是，你会对Vert.x的 <strong>异步开发模式</strong> 有了更深的理解和领悟。</p>
<p>另外，Vert.x 蓝图系列已经发布至Vert.x官网：<a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x Blueprint Tutorials</a>。其中<a href="http://sczyh30.github.io/vertx-blueprint-job-queue/cn/kue-core/index.html" target="_blank" rel="external">第二个Blueprint</a>是关于消息应用的，<a href="http://sczyh30.github.io/vertx-blueprint-microservice/cn/index.html" target="_blank" rel="external">第三个Blueprint</a>是关于微服务的，有兴趣的朋友可以参考后面几篇蓝图教程。</p>
<p>更多关于Vert.x的文章，请参考<a href="http://vertx.io/blog/archives/" target="_blank" rel="external">Blog on Vert.x Website</a>。官网的资料是最全面的 :-)</p>
<h1 id="来自其它框架？">来自其它框架？</h1><p>之前你可能用过其它的框架，比如Spring Boot。这一小节，我将会用类比的方式来介绍Vert.x Web的使用。</p>
<h2 id="来自Spring_Boot/Spring_MVC">来自Spring Boot/Spring MVC</h2><p>在Spring Boot中，我们通常在控制器(Controller)中来配置路由以及处理请求，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@ComponentScan</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> TodoService service;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping</span>(method = RequestMethod.GET, value = <span class="string">"/todos/&#123;id&#125;"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> Todo <span class="title">getCertain</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</div><div class="line">    <span class="keyword">return</span> service.fetch(id);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Spring Boot中，我们使用 <code>@RequestMapping</code> 注解来配置路由，而在Vert.x Web中，我们是通过 <code>Router</code> 对象来配置路由的。并且因为Vert.x Web是异步的，我们会给每个路由绑定一个处理器（<code>Handler</code>）来处理对应的请求。</p>
<p>另外，在Vert.x Web中，我们使用 <code>end</code> 方法来向客户端发送HTTP response。相对地，在Spring Boot中我们直接在每个方法中返回结果作为response。</p>
<h2 id="来自Play_Framework_2">来自Play Framework 2</h2><p>如果之前用过Play Framework 2的话，你一定会非常熟悉异步开发模式。在Play Framework 2中，我们在 <code>routes</code> 文件中定义路由，类似于这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">GET</span>     /todos/:todoId      controllers.<span class="type">TodoController</span>.handleGetCertain(todoId: <span class="type">Int</span>)</div></pre></td></tr></table></figure>
<p>而在Vert.x Web中，我们通过<code>Router</code>对象来配置路由：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">"/todos/:todoId"</span>).handler(<span class="keyword">this</span>::handleGetCertain);</div></pre></td></tr></table></figure>
<p><code>this::handleGetCertain</code>是处理对应请求的方法引用（在Scala里可以把它看作是一个函数）。</p>
<p>Play Framework 2中的异步开发模式是基于<code>Future</code>的。每一个路由处理函数都返回一个<code>Action</code>对象（实质上是一个类型为<code>Request[A] =&gt; Result</code>的函数），我们在<code>Action.apply</code>(或<code>Action.async</code>)闭包中编写我们的处理逻辑，类似于这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleGetCertain</span></span>(todoId: <span class="type">Int</span>): <span class="type">Action</span>[<span class="type">AnyContent</span>] = <span class="type">Action</span>.async &#123;</div><div class="line">    service.getCertain(todoId) map &#123; <span class="comment">// 服务返回的类型是 `Future[Option[Todo]]`</span></div><div class="line">        <span class="keyword">case</span> <span class="type">Some</span>(res) =&gt;</div><div class="line">            <span class="type">Ok</span>(<span class="type">Json</span>.toJson(res))</div><div class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">            <span class="type">NotFound</span>()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在Vert.x Web中，异步开发模式基本上都是基于回调的（当然也可以用Vert.x RxJava）。我们可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    String todoId = context.request().getParam(<span class="string">"todoId"</span>); <span class="comment">// 获取Path Variable</span></div><div class="line">    service.getCertain(todoId).setHandler(r -&gt; &#123; <span class="comment">// 服务返回的类型是 `Future&lt;Optional&lt;Todo&gt;&gt;`</span></div><div class="line">        <span class="keyword">if</span> (r.succeeded) &#123;</div><div class="line">            Optional&lt;Todo&gt; res = r.result;</div><div class="line">            <span class="keyword">if</span> (res.isPresent()) &#123;</div><div class="line">                context.response()</div><div class="line">                    .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">                    .end(Json.encodePrettily(res));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sendError(<span class="number">404</span>, context.response()); <span class="comment">// NotFound(404)</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sendError(<span class="number">503</span>, context.response());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="想要使用其它持久化存储框架？">想要使用其它持久化存储框架？</h2><p>你可能想在Vert.x中使用其它的持久化存储框架或库，比如MyBatis ORM或者Jedis，这当然可以啦！Vert.x允许开发者整合任何其它的框架和库，但是像MyBatis ORM这种框架都是阻塞型的，可能会阻塞Event Loop线程，因此我们需要利用<code>blockingHandler</code>方法去执行阻塞的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">"/todos/:todoId"</span>).blockingHandler(routingContext -&gt; &#123;</div><div class="line">            String todoID = routingContext.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">            Todo res = service.fetchBlocking(todoID); <span class="comment">// 阻塞型</span></div><div class="line"></div><div class="line">            <span class="comment">// 做一些微小的工作</span></div><div class="line"></div><div class="line">            routingContext.next();</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>Vert.x会使用Worker线程去执行<code>blockingHandler</code>方法(或者Worker Verticles)中的操作，因此不会阻塞Event Loop线程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-quorum-based-voting-for-replica-control" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Architecture/quorum-based-voting-for-replica-control/" class="article-date">
      <time datetime="2016-05-24T16:00:00.000Z" itemprop="datePublished">2016-05-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Architecture/quorum-based-voting-for-replica-control/">基于Quorum投票机制的Replica Control算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在分布式系统中，一份数据可能有多份副本（冗余数据）。为了保证数据读写的正确性，同一时刻一份数据的多份副本只能用于读或用于写，而不能同时被超过两个访问对象并发读写。Quorum机制就可以保证这一点，我们来看一下它的思想。</p>
<p>一个分布式系统中，我们给每个数据副本都赋予一票。假设一共有 <strong>V</strong> 个数据副本，那么总共就有 <strong>V</strong> 个票数。每个操作必须要获得读票数(完成读操作所需要读取的最小副本数，read quorum,  <strong>V(r)</strong> )或写票数(完成写操作所需要读取的最小副本数write quorum,  <strong>V(w)</strong> )才能够对数据进行读或写。票数需要遵循以下规则：</p>
<ol>
<li>$V_{r} + V_{w} &gt; V$</li>
<li>$V_{w} &gt; \frac{V}{2}$</li>
</ol>
<p>第一条规则有两个作用：第一个作用是保证了一个数据不会被同时读写。当请求一个写操作时，它需要的得到 <strong>V(w)</strong> 读票数，而剩下的票数为 <strong>V - V(w) &lt; V(r)</strong>，因此不再允许读操作。请求读操作时也是同理；第二个作用是保证了强一致性。根据 <strong>鸽巢原理</strong>，写数据操作与读新数据操作之间是有重叠的，这就确保至少有一个读操作是可以读到最新数据的。</p>
<p>第二条规则保证了数据的串行化修改，同一个数据不能同时被两个写操作并发修改。</p>
<p>Quorum投票机制非常有用。比如一份数据在5个结点上存有副本，进行一次写操作的时候，必须等待五个结点的写操作都完成，整个写操作才返回（因为可以从任意结点读取）。这样会导致写操作负载太高，而有了Quorum机制以后，我们可以让写操作在至少3个结点上完成就可以返回，另外的结点可以等待后台同步，而读操作V(r)也需要大于 <strong>V-V(w)</strong> 才能确保至少一个读操作可以读到最新数据。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>Weighted Voting for Replicated Data</em>, David K. Gifford, Stanford University and Xerox Palo Alto Research Center</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Architecture/">Architecture</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Quorum/">Quorum</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-netflix-hystrix-how-it-works-summary" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Microservice/netflix-hystrix-how-it-works-summary/" class="article-date">
      <time datetime="2016-05-23T16:00:00.000Z" itemprop="datePublished">2016-05-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Microservice/netflix-hystrix-how-it-works-summary/">Netflix Hystrix | 工作流程浅析 &amp;&amp; HystrixCircuitBreaker源码分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这篇文章里我们来总结一下Netflix Hystrix的工作流程。这是官方提供的流程图(来自GitHub)：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/hystrix-command-flow-chart.png" alt="Netflix Hystrix Flow Chart"></p>
<h1 id="工作流程">工作流程</h1><p>我们来根据流程图来分析一下工作流程。</p>
<p>首先我们需要创建一个 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code> 实例来代表向其它组件发出的操作请求（指令），然后通过相关的方法执行操作指令。这里有4个方法，前两个对应<code>HystrixCommand</code>，后两个对应<code>HystrixObservableCommand</code>：</p>
<ul>
<li><code>execute()</code>：阻塞型方法，返回单个结果（或者抛出异常）</li>
<li><code>queue()</code>：异步方法，返回一个<code>Future</code>对象，可以从中取出单个结果（或者抛出异常）</li>
<li><code>observe()</code>和<code>toObservable()</code>都返回对应的<code>Observable</code>对象，代表（多个）操作结果。注意<code>observe</code>方法在调用的时候就开始执行对应的指令，而<code>toObservable</code>方法相当于是<code>observe</code>方法的lazy版本，当我们去<code>subscribe</code>的时候，对应的指令才会被执行并产生结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">K             value   = command.execute();</div><div class="line">Future&lt;K&gt;     fValue  = command.queue();</div><div class="line">Observable&lt;K&gt; ohValue = command.observe();         <span class="comment">//hot observable</span></div><div class="line">Observable&lt;K&gt; ocValue = command.toObservable();    <span class="comment">//cold observable</span></div></pre></td></tr></table></figure>
<p>从底层实现来讲，<code>HystrixCommand</code>也是利用<code>Observable</code>实现的（看Hystrix源码的话可以发现里面大量使用了RxJava），尽管它只返回单个结果。<code>HystrixCommand</code>的<code>queue</code>方法实际上是调用了<code>toObservable().toBlocking().toFuture()</code>，而<code>execute</code>方法实际上是调用了<code>queue().get()</code>。</p>
<p>执行操作指令时，Hystrix首先会检查缓存内是否有对应指令的结果，如果有的话，将缓存的结果直接以<code>Observable</code>对象的形式返回。如果没有对应的缓存，Hystrix会检查Circuit Breaker的状态。如果Circuit Breaker的状态为开启状态，Hystrix将不会执行对应指令，而是直接进入失败处理状态（图中8 Fallback）。如果Circuit Breaker的状态为关闭状态，Hystrix会继续进行线程池、任务队列、信号量的检查（图中5），确认是否有足够的资源执行操作指令。如果资源满，Hystrix同样将不会执行对应指令并且直接进入失败处理状态。</p>
<p>如果资源充足，Hystrix将会执行操作指令。操作指令的调用最终都会到这两个方法：</p>
<ul>
<li><code>HystrixCommand.run()</code></li>
<li><code>HystrixObservableCommand.construct()</code></li>
</ul>
<p>如果执行指令的时间超时，执行线程会抛出<code>TimeoutException</code>异常。Hystrix会抛弃结果并直接进入失败处理状态。如果执行指令成功，Hystrix会进行一系列的数据记录，然后返回执行的结果。</p>
<p>同时，Hystrix会根据记录的数据来计算失败比率，一旦失败比率达到某一阈值将自动开启Circuit Breaker。</p>
<p>最后我们再来看一下Hystrix是如何处理失败的。如果我们在Command中实现了<code>HystrixCommand.getFallback()</code>方法（或<code>HystrixObservableCommand.resumeWithFallback()</code>方法，Hystrix会返回对应方法的结果。如果没有实现这些方法的话，从底层看Hystrix将会返回一个空的<code>Observable</code>对象，并且可以通过<code>onError</code>来终止并处理错误。从上层看：</p>
<ul>
<li><code>execute</code>方法将会抛出异常</li>
<li><code>queue</code>方法将会返回一个失败状态的<code>Future</code>对象</li>
<li><code>observe()</code>和<code>toObservable()</code>方法都会返回上述的<code>Observable</code>对象</li>
</ul>
<h1 id="HystrixCircuitBreaker源码分析">HystrixCircuitBreaker源码分析</h1><p>Hystrix中的Circuit Breaker的实现比较明了。整个<code>HystrixCircuitBreaker</code>接口一共有三个方法和三个静态类：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/hystrix-circuit-breaker-class-structure.png" alt="Class Hierarchy of HystrixCircuitBreaker"></p>
<p>其中<code>allowRequest()</code>方法表示是否允许指令执行，<code>isOpen()</code>方法表示断路器是否为开启状态，<code>markSuccess()</code>用于将断路器关闭。</p>
<p><code>Factory</code>静态类相当于Circuit Breaker Factory，用于获取相应的<code>HystrixCircuitBreaker</code>。我们来看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="comment">// String is HystrixCommandKey.name() (we can't use HystrixCommandKey directly as we can't guarantee it implements hashcode/equals correctly)</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, HystrixCircuitBreaker&gt; circuitBreakersByCommand = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HystrixCircuitBreaker&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixCircuitBreaker <span class="title">getInstance</span><span class="params">(HystrixCommandKey key, HystrixCommandGroupKey group, HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</div><div class="line">        <span class="comment">// this should find it for all but the first time</span></div><div class="line">        HystrixCircuitBreaker previouslyCached = circuitBreakersByCommand.get(key.name());</div><div class="line">        <span class="keyword">if</span> (previouslyCached != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> previouslyCached;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// if we get here this is the first time so we need to initialize</span></div><div class="line"></div><div class="line">        <span class="comment">// Create and add to the map ... use putIfAbsent to atomically handle the possible race-condition of</span></div><div class="line">        <span class="comment">// 2 threads hitting this point at the same time and let ConcurrentHashMap provide us our thread-safety</span></div><div class="line">        <span class="comment">// If 2 threads hit here only one will get added and the other will get a non-null response instead.</span></div><div class="line">        HystrixCircuitBreaker cbForCommand = circuitBreakersByCommand.putIfAbsent(key.name(), <span class="keyword">new</span> HystrixCircuitBreakerImpl(key, group, properties, metrics));</div><div class="line">        <span class="keyword">if</span> (cbForCommand == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// this means the putIfAbsent step just created a new one so let's retrieve and return it</span></div><div class="line">            <span class="keyword">return</span> circuitBreakersByCommand.get(key.name());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// this means a race occurred and while attempting to 'put' another one got there before</span></div><div class="line">            <span class="comment">// and we instead retrieved it and will now return it</span></div><div class="line">            <span class="keyword">return</span> cbForCommand;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixCircuitBreaker <span class="title">getInstance</span><span class="params">(HystrixCommandKey key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> circuitBreakersByCommand.get(key.name());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* package */</span><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">        circuitBreakersByCommand.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hystrix在<code>Factory</code>类中维护了一个<code>ConcurrentHashMap</code>用于存储与每一个<code>HystrixCommandKey</code>相对应的<code>HystrixCircuitBreaker</code>。每当我们通过<code>getInstance</code>方法从中获取<code>HystrixCircuitBreaker</code>的时候，Hystrix首先会检查<code>ConcurrentHashMap</code>中有没有对应的缓存的断路器，如果有的话直接返回。如果没有的话就会新创建一个<code>HystrixCircuitBreaker</code>实例，将其添加到缓存中并且返回。</p>
<p><code>HystrixCircuitBreakerImpl</code>静态类是<code>HystrixCircuitBreaker</code>接口的实现。我们可以看到<code>HystrixCircuitBreakerImpl</code>类中有四个成员变量。其中<code>properties</code>是对应<code>HystrixCommand</code>的属性类，<code>metrics</code>是对应<code>HystrixCommand</code>的度量数据类。由于会工作在并发环境下，我们用一个<code>AtomicBoolean</code>类型的变量<code>circuitOpen</code>来代表断路器的状态（默认是<code>false</code>代表关闭，这里没有特意实现Half-Open这个状态），并用一个<code>AtomicLong</code>类型的变量<code>circuitOpenedOrLastTestedTime</code>记录着断路恢复计时器的初始时间，用于Open状态向Close状态的转换。</p>
<p>我们首先来看一下<code>isOpen</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (circuitOpen.get()) &#123;</div><div class="line">        <span class="comment">// if we're open we immediately return true and don't bother attempting to 'close' ourself as that is left to allowSingleTest and a subsequent successful test to close</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// we're closed, so let's see if errors have made us so we should trip the circuit open</span></div><div class="line">    HealthCounts health = metrics.getHealthCounts();</div><div class="line"></div><div class="line">    <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></div><div class="line">    <span class="keyword">if</span> (health.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</div><div class="line">        <span class="comment">// we are not past the minimum volume threshold for the statisticalWindow so we'll return false immediately and not calculate anything</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (health.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// our failure rate is too high, trip the circuit</span></div><div class="line">        <span class="keyword">if</span> (circuitOpen.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">            <span class="comment">// if the previousValue was false then we want to set the currentTime</span></div><div class="line">            circuitOpenedOrLastTestedTime.set(System.currentTimeMillis());</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// How could previousValue be true? If another thread was going through this code at the same time a race-condition could have</span></div><div class="line">            <span class="comment">// caused another thread to set it to true already even though we were in the process of doing the same</span></div><div class="line">            <span class="comment">// In this case, we know the circuit is open, so let the other thread set the currentTime and report back that the circuit is open</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过<code>circuitOpen.get()</code>获取断路器的状态，如果是开启状态(<code>true</code>)则返回<code>true</code>。否则，Hystrix会从Metrics数据中获取<code>HealthCounts</code>对象，然后检查对应的请求总数(<code>totalCount</code>)是否小于属性中的请求容量阈值(<code>circuitBreakerRequestVolumeThreshold</code>)，如果是的话表示断路器可以保持关闭状态，返回<code>false</code>。如果不满足请求总数条件，就再检查错误比率(<code>errorPercentage</code>)是否小于属性中的错误百分比阈值(<code>circuitBreakerErrorThresholdPercentage</code>，默认 <strong>50</strong>)，如果是的话表示断路器可以保持关闭状态，返回 <code>false</code>；如果超过阈值，Hystrix会判定服务的某些地方出现了问题，因此通过CAS操作将断路器设为开启状态，并记录此时的系统时间作为定时器初始时间，最后返回 <code>true</code>。</p>
<p>我们再来看一下判断Open状态下计时器的实现方法<code>allowSingleTest</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowSingleTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> timeCircuitOpenedOrWasLastTested = circuitOpenedOrLastTestedTime.get();</div><div class="line">    <span class="comment">// 1) if the circuit is open</span></div><div class="line">    <span class="comment">// 2) and it's been longer than 'sleepWindow' since we opened the circuit</span></div><div class="line">    <span class="keyword">if</span> (circuitOpen.get() &amp;&amp; System.currentTimeMillis() &gt; timeCircuitOpenedOrWasLastTested + properties.circuitBreakerSleepWindowInMilliseconds().get()) &#123;</div><div class="line">        <span class="comment">// We push the 'circuitOpenedTime' ahead by 'sleepWindow' since we have allowed one request to try.</span></div><div class="line">        <span class="comment">// If it succeeds the circuit will be closed, otherwise another singleTest will be allowed at the end of the 'sleepWindow'.</span></div><div class="line">        <span class="keyword">if</span> (circuitOpenedOrLastTestedTime.compareAndSet(timeCircuitOpenedOrWasLastTested, System.currentTimeMillis())) &#123;</div><div class="line">            <span class="comment">// if this returns true that means we set the time so we'll return true to allow the singleTest</span></div><div class="line">            <span class="comment">// if it returned false it means another thread raced us and allowed the singleTest before we did</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取断路恢复计时器记录的初始时间<code>circuitOpenedOrLastTestedTime</code>，然后判断以下两个条件是否同时满足：</p>
<ul>
<li>断路器的状态为开启状态(<code>circuitOpen.get() == true</code>)</li>
<li>当前时间与计时器初始时间之差大于计时器阈值<code>circuitBreakerSleepWindowInMilliseconds</code>(默认为 <strong>5</strong> 秒)</li>
</ul>
<p>如果同时满足的话，表示可以从<code>Open</code>状态向<code>Close</code>状态转换。Hystrix会通过CAS操作将<code>circuitOpenedOrLastTestedTime</code>设为当前时间，并返回<code>true</code>。如果不同时满足，返回<code>false</code>，代表断路器关闭或者计时器时间未到。</p>
<p>有了这个函数以后，我们再来看一下<code>allowRequest</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceOpen().get()) &#123;</div><div class="line">        <span class="comment">// properties have asked us to force the circuit open so we will allow NO requests</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceClosed().get()) &#123;</div><div class="line">        <span class="comment">// we still want to allow isOpen() to perform it's calculations so we simulate normal behavior</span></div><div class="line">        isOpen();</div><div class="line">        <span class="comment">// properties have asked us to ignore errors so we will ignore the results of isOpen and just allow all traffic through</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> !isOpen() || allowSingleTest();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常直观。首先先读取属性中的强制设定值（可以强制设定状态），如果没有设定的话，就判断断路器是否关闭或者断路恢复计时器是否到达时间，只要满足其中一个条件就返回<code>true</code>，即允许执行操作指令。</p>
<p>最后就是<code>markSuccess</code>方法了，它用于关闭断路器并重置统计数据。代码非常直观，就不多说了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markSuccess</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (circuitOpen.get()) &#123;</div><div class="line">        <span class="keyword">if</span> (circuitOpen.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</div><div class="line">            metrics.resetStream();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hystrix的Circuit Breaker可以用以下的图来总结：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/hystrix-circuit-breaker-1280.png" alt="Hystrix Circuit Breaker"></p>
<p>至于Hystrix在底层执行Command时是如何利用<code>HystrixCircuitBreaker</code>的，可以看<code>AbstractCommand</code>类中<code>toObservable</code>方法和<code>getRunObservableDecoratedForMetricsAndErrorHandling</code>方法的源码，后边再总结。</p>
<hr>
<h1 id="Reference">Reference</h1><ul>
<li><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" target="_blank" rel="external">How it Works - Netflix/Hystrix - Wiki</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Microservice/">Microservice</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netflix-Hystrix/">Netflix Hystrix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/云服务/">云服务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-concurrency-treiber-stack" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Concurrency/concurrency-treiber-stack/" class="article-date">
      <time datetime="2016-05-21T16:00:00.000Z" itemprop="datePublished">2016-05-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Concurrency/concurrency-treiber-stack/">并发编程算法 | Treiber Stack实现lock-free stack</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>多线程环境下各种数据结构的实现有了很大的变化，每当我们更新某个数据的时候，我们都要考虑其它线程是否对其进行了修改。最简单的一种方法就是加锁，不过加锁会导致性能低下，而且可能阻塞其他线程。因此，我们引入了非阻塞(non-blocking)的算法 —— 通过CAS操作保证操作的原子性，同时我们还引入了 <em>lock-free</em> 的概念，它指的是一个线程出现问题（如阻塞，失败）但不影响其他线程（从总体看程序仍然是在运行的）。这里就来看一下Non-blocking stack的一个实现 —— <strong>Treiber Stack</strong>。</p>
<h1 id="Treiber_Stack">Treiber Stack</h1><p>这里给出的是Treiber Stack的一个简化版的Java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Concurrent stack implementation</div><div class="line"> * Treiber's Algorithm</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&lt;E&gt;&gt; top = <span class="keyword">new</span> AtomicReference&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E elem)</span> </span>&#123;</div><div class="line">        Node&lt;E&gt; newHead = <span class="keyword">new</span> Node&lt;&gt;(elem);</div><div class="line">        Node&lt;E&gt; oldHead;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            oldHead = top.get();</div><div class="line">            newHead.next = oldHead;</div><div class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldHead, newHead));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;E&gt; oldHead;</div><div class="line">        Node&lt;E&gt; newHead;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            oldHead = top.get();</div><div class="line">            <span class="keyword">if</span> (oldHead == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            newHead = oldHead.next;</div><div class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldHead, newHead));</div><div class="line">        <span class="keyword">return</span> oldHead.item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> E item;</div><div class="line">        <span class="keyword">public</span> Node&lt;E&gt; next;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.item = item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用了<code>AtomicReference</code>来实现Treiber Stack。每当我们<code>push</code>进去一个元素的时候，我们首先根据要添加的元素创建一个<code>Node</code>，然后获取原栈顶结点，并将新结点的下一个结点指向原栈顶结点。此时我们使用CAS操作来更改栈顶结点，如果此时的栈顶和之前的相同，代表CAS操作成功，那么就把新插入的元素设为栈顶；如果此时的栈顶和之前的不同（即其他线程改变了栈顶结点），CAS操作失败，那么需要重复上述操作（更新当前的栈顶元素并且重设next），直到成功。<code>pop</code>操作的原理也相似。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>Java Concurrency In Practice</em></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Concurrency/">Concurrency</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-distributed-system-base" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Distributed-System/distributed-system-base/" class="article-date">
      <time datetime="2016-05-21T16:00:00.000Z" itemprop="datePublished">2016-05-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Distributed-System/distributed-system-base/">分布式系统基础总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>从大一就一直在搞分布式系统，Hadoop, Spark, Kafka, ZooKeeper之类的都玩过，然而以前只是简单地用用各个开源组件实现，并没有系统地学习其中的原理和算法。最近在跟着MIT 6.824课程学习分布式系统的各种理论原理，这里就来简单总结下分布式系统中的一些基础内容吧~</p>
<h1 id="CAP_Theory">CAP Theory</h1><p>CAP Theory阐述了分布式系统中的一个事实：一致性(Consistency)、可用性(Availability)和分区容错性(Partition Tolerance)不能同时保证。三个只能选择两个</p>
<p><img src="http://book.mixu.net/distsys/images/CAP.png" alt="CAP Theory"></p>
<p>假设有两台机器A、B，两者之间互相同步保持数据的一致性。现在B由于网络原因不能与A通信(Network Partition)，假设某个client向A写入数据，现在有两种选择：</p>
<ul>
<li>A拒绝写入，这样能保证与B的一致性，但是牺牲了可用性</li>
<li>A允许写入，但是这样就不能保证与B的一致性了</li>
</ul>
<p>Network Partition是必然的，网络非常可能出现问题（断线、超时），因此CAP理论一般只能AP或CP，而CA一般较难实现。</p>
<ul>
<li>CP: 要实现一致性，则需要一定的一致性算法，一般是基于多数派表决的，如Paxos和Raft</li>
<li>AP: 要实现可用性，则要有一定的策略决议到底用哪个数据，并且数据一般要进行冗余备份(replication)</li>
</ul>
<p>当然，在上面的例子中，A可以先允许写入，等B的网络恢复以后再同步至B（根据CAP原理这样不能保证强一致性了，但是可以考虑实现最终一致性）。</p>
<h1 id="一致性哈希">一致性哈希</h1><p>分布式Key-Value Store中的key映射问题。</p>
<ul>
<li>传统<code>hash(x) % N</code>算法的弊端：不利于架构的伸缩性</li>
<li>一致性哈希将哈希值映射到一个哈希环上，然后将数据进行哈希处理后映射到哈希环上，再把节点进行哈希处理映射到哈希环上，数据将选择最近的节点存储</li>
<li>伸缩性：节点删除时，原有的数据将会就近迁移，其他数据不用迁移；节点增加时也相似</li>
<li>保证负载均衡：虚拟节点</li>
</ul>
<h1 id="拜占庭将军问题">拜占庭将军问题</h1><p>最复杂的情况：自己发的包被截；对方发的包自己收不到；内部有节点捣乱，造成不一致。</p>
<h1 id="FLP_Impossibility">FLP Impossibility</h1><p><em>Impossibility of Distributed Consensus with One Faulty Process</em> 这篇论文提到：</p>
<blockquote>
<p>No completely asynchronous consensus protocol can tolerate even a single unannounced process death.</p>
</blockquote>
<p>假设节点只有崩溃这一种异常行为，网络是可靠的，并且不考虑异步通信下的时序差异。FLP Impossibility指出在异步网络环境中只要有一个故障节点, 任何Consensus算法都无法保证行为正确。</p>
<h1 id="Lease机制">Lease机制</h1><p>Lease（租约）机制应用非常广泛：</p>
<ul>
<li>可用作授权来进行同步等操作(如Append)</li>
<li>可用作读锁/写锁（分布式锁）</li>
</ul>
<p>租约的一个关键点就是有效期，过了有效期可以续约。如果不可用就收回租约，给另一台服务器权限。</p>
<p>实际应用：</p>
<ul>
<li>GFS: Master grant to ChunckServer</li>
</ul>
<blockquote>
<p>思考：<strong>Lease == Lock?</strong></p>
</blockquote>
<h1 id="Quorum机制">Quorum机制</h1><p>多数表决机制在分布式系统中通常有两个应用场景：</p>
<ol>
<li>Leader Election</li>
<li>Replication (NWR机制)</li>
</ol>
<p>理论基础：鸽巢原理</p>
<h1 id="Consensus问题">Consensus问题</h1><h2 id="Consensus条件">Consensus条件</h2><ul>
<li>Termination: 最终必须决议出结果</li>
<li>Validity:</li>
<li>Integrity</li>
<li>Agreement</li>
</ul>
<h2 id="2PC/3PC">2PC/3PC</h2><p>2PC在proposer和某个voter都挂掉的时候会阻塞（原因：别的节点没有对应voter的消息，只能阻塞等待此voter恢复）</p>
<p>3PC添加了一个  <em>prepare-commit</em> 阶段用于准备提交工作，这里面可以实现事务的回滚。</p>
<p>缺点：效率貌似很低。。。分布式事务用2PC会特别蛋疼</p>
<h1 id="Paxos">Paxos</h1><p>推演：</p>
<ul>
<li>First Accept/Last Accept都不可以（结合时序图）</li>
<li>一个阶段不行，自然想到两个阶段：发起决议以及提交决议</li>
</ul>
<ul>
<li>One Proposer -&gt; One Acceptor 挂了就gg了</li>
<li>One Proposer -&gt; Many Acceptors （规则：先到先投）</li>
<li>Many Proposers -&gt; Many Acceptors (很容易乱。。。)</li>
</ul>
<p>Paxos引入了Log ID (num, value)，共有三个角色，两个阶段。</p>
<ul>
<li>Proposer: 决议发起者，需要等待多数派表决</li>
<li>Acceptor: 决议投票者，对收到的Propose进行表决并返回</li>
<li>Learner: 最水的角色，学习到投票的结果即可</li>
</ul>
<blockquote>
<p>分布式一致性算法(Paxos, Raft, Chubby, Zab)待详细总结。。。</p>
</blockquote>
<h1 id="时序问题">时序问题</h1><h2 id="Lamport_Timestamp">Lamport Timestamp</h2><p>一般我们不关心分布式系统中某个过程的绝对时间，而只关注两个事件之间的相对时间。<br>在一个系统的事件集合E上定义一种偏序关系<code>-&gt;</code>，满足：</p>
<ul>
<li>如果a与b发生在同一个进程中，且a先于b发生，则有<code>a -&gt; b</code></li>
<li>进程间通信，a代表进程Pi发出消息m，b代表另一个进程Pj接收消息m，则有<code>a -&gt; b</code></li>
<li>传递性：若<code>a -&gt; b, b -&gt; c</code>，则<code>a -&gt; c</code></li>
</ul>
<p>定义并发：<code>a -&gt; b</code>与<code>b -&gt; a</code>均不成立则为并发情况</p>
<p>引入Lamport逻辑时钟。一个时钟本质上是一个事件到实数的映射（假设时间是连续的）。对于每一个进程Pi，都有其对应的时钟Ci。</p>
<p>分布式系统中的全局信息实际上是对各个实体信息的叠加（Q：重合怎么办？）</p>
<p>可以看到Lamport Timestamp必须要求两个事件有先后顺序关系，因而在时序图上不好表示concurrent。由此引入Vector Clock。</p>
<h2 id="Vector_Clock">Vector Clock</h2><p>Vector Clock是对Lamport Timestamp的演进。它不仅保存了自身的timestamp，而且还保留了根节点的timestamp。</p>
<p>Vector Clock(Version Vector)只能用于发现数据冲突，但是想要解决数据冲突还要留给用户去定夺（就好比git commit出现conflicts，需要手工解决一样），当然也可以设置某种策略来直接解决冲突（保留最新或集群内多数表决）。</p>
<p>结合时序图理解会更好(图来自维基百科)：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Vector_Clock.svg/725px-Vector_Clock.svg.png" alt=""></p>
<p>可能出现的问题：Vector Clock过多。解决方案：剪枝（如果超过某个阈值就把最初的那个给扔掉；要是现在还依赖最初的那个clock的话可能就会造成一些问题（思考：如何解决？）</p>
<p>对应论文：<em>Dynamo: Amazon’s Highly Available Key-value Store, Section 4.4</em>.</p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://book.mixu.net/distsys/index.html" target="_blank" rel="external">Distributed systems for fun and profit</a></li>
<li><a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf" target="_blank" rel="external">Leslie Lamport. Time, Clocks and Ordering of Events in a Distributed System.</a></li>
<li><a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf" target="_blank" rel="external">Michael J. Fisher, et al. Impossibility of Distributed Consensus with One Faulty Process.</a></li>
<li><a href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">Giuseppe DeCandia, et al. Dynamo: Amazon’s Highly Available Key-value Store.</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CAP/">CAP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-service-with-docker-compose" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Architecture/service-with-docker-compose/" class="article-date">
      <time datetime="2016-05-19T16:00:00.000Z" itemprop="datePublished">2016-05-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Architecture/service-with-docker-compose/">使用 Docker Compose 编排容器集群</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="https://docs.docker.com/compose/" target="_blank" rel="external">Docker Compose</a>可以让我们方便、快速地编排容器集群，有利于分布式架构的实现。</p>
<p>假设我们有一个应用以MySQL作为数据存储，如果没有编排工具的话，我们在构建此应用的Docker镜像时必须将MySQL一同打包进镜像中，这样不仅会使镜像体积臃肿，而且不利于分布式架构的实现（假如要做读写分离、主从复制之类的）。而有了Docker Compose，我们就可以创建两个镜像：单独的应用镜像和MySQL镜像。在运行时，分别创建两个容器，并且将两个容器链接(link)在一起，使它们之间可以按照配置相互通信。这样就将我们的单体应用拆分成了多个组件构成的应用（其实这就是微服务的思想），从而更有利于服务间的解耦以及分布式架构的实现。</p>
<p>下面举一个例子，完整实现可见<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend" target="_blank" rel="external">vertx-blueprint-todo-backend | GitHub</a>。现有一服务<code>Vert.x Blueprint Todo Backend</code>已打包成jar包，该服务以Redis作为数据存储。该服务以及Redis监听的地址和端口通过JSON配置文件来提供。我们可以设计两个镜像：服务镜像（通过<code>Dockerfile</code>构建）以及官方Redis镜像，运行时分别创建一个容器实例，然后通过Docker Compose将两个容器组合起来。首先来看一下我们的<code>Dockerfile</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-jre</div><div class="line"></div><div class="line"><span class="keyword">ENV</span> VERTICLE_FILE build/libs/vertx-blueprint-todo-backend-fat.jar</div><div class="line"></div><div class="line"><span class="keyword">ENV</span> VERTICLE_HOME /usr/verticles</div><div class="line"></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">8082</span></div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$VERTICLE_FILE</span> <span class="variable">$VERTICLE_HOME</span>/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> config/config_docker.json <span class="variable">$VERTICLE_HOME</span>/</span></div><div class="line"></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$VERTICLE_HOME</span></span></div><div class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"sh"</span>, <span class="string">"-c"</span>]</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"java -jar vertx-blueprint-todo-backend-fat.jar -conf config_docker.json"</span>]</span></div></pre></td></tr></table></figure>
<p>服务容器运行时对外暴露8082端口。再看一下服务配置文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"service.type"</span>: <span class="string">"redis"</span>,</div><div class="line">  <span class="attr">"http.port"</span>: <span class="number">8082</span>,</div><div class="line">  <span class="attr">"http.address"</span>: <span class="string">"0.0.0.0"</span>,</div><div class="line">  <span class="attr">"redis.host"</span>: <span class="string">"redis"</span>,</div><div class="line">  <span class="attr">"redis.port"</span>: <span class="number">6379</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意我们将Redis的host设为<code>redis</code>，这个<code>redis</code>是对应的访问路径，后面会提到。下面来看Docker Compose的配置文件<code>docker-compose.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="string">"2"</span></div><div class="line"><span class="attr">services:</span></div><div class="line"><span class="attr">  redis:</span></div><div class="line"><span class="attr">    container_name:</span> vertx-todo-backend_redis</div><div class="line"><span class="attr">    image:</span> redis:latest</div><div class="line"><span class="attr">    expose:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"6379"</span></div><div class="line"></div><div class="line"><span class="attr">  vertx-todo-backend:</span></div><div class="line"><span class="attr">    depends_on:</span></div><div class="line"><span class="bullet">      -</span> redis</div><div class="line"><span class="attr">    container_name:</span> vertx-todo-backend_service</div><div class="line"><span class="attr">    build:</span> .</div><div class="line"><span class="attr">    links:</span></div><div class="line"><span class="bullet">      -</span> redis</div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"8082:8082"</span></div></pre></td></tr></table></figure>
<p>其中<code>version: &quot;2&quot;</code>代表对应镜像版本，最新的需要Docker 1.10.0支持。在<code>services</code>中，我们定义了两个<code>service</code>：<code>redis</code>和<code>vertx-todo-backend</code>。</p>
<p>先来看<code>redis</code>中的配置。<code>container_name</code>代表容器名称，<code>image</code>代表对应的镜像，<code>expose</code>代表在集群内暴露的端口号（不对外暴露）。其它容器通过服务名<code>redis</code>访问此镜像。</p>
<p>再来看<code>vertx-todo-backend</code>。我们的服务需要依赖Redis，因此容器的启动顺序应该是<code>redis -&gt; vertx-todo-backend</code>，因此我们配置了<code>depends_on</code>选项，此选项下的所有容器都将会在本容器启动之前启动（注意只是启动，并不是其它容器初始化完成后本容器才启动。如果需要等待其它容器初始化完毕，则需要另写脚本）。<code>build</code>对应着<code>Dockerfile</code>文件的路径，<code>links</code>代表链接的镜像，<code>ports</code>代表对外暴露的端口。</p>
<p>配置好以后，我们在目录下执行<code>docker-compose up --build</code>，一会就可以看到容器集群运行起来了，非常方便。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vbptds-docker-compose-running.png" alt="Docker Compose"></p>
<p>更多的有关Docker Compose的信息，参考<a href="https://docs.docker.com/compose/" target="_blank" rel="external">官方文档</a>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Architecture/">Architecture</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/容器/">容器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-gradle-annotation-processing-vertx-codegen" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Develop/gradle-annotation-processing-vertx-codegen/" class="article-date">
      <time datetime="2016-05-17T16:00:00.000Z" itemprop="datePublished">2016-05-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/Develop/gradle-annotation-processing-vertx-codegen/">在Gradle中使用Annotation Processing Tool | Vert.x Codegen 示例</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在Maven中，我们可以很方便地利用 <em>Annotation Processing Tool(APT)</em> 来生成代码，配置简洁明了。比如在Maven中配置<a href="https://github.com/vert-x3/vertx-codegen" target="_blank" rel="external">Vert.x Codegen</a>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Configure the execution of the compiler to execute the codegen processor --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-compile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">annotationProcessors</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">annotationProcessor</span>&gt;</span>io.vertx.codegen.CodeGenProcessor<span class="tag">&lt;/<span class="name">annotationProcessor</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">annotationProcessors</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">arg</span>&gt;</span>-AoutputDirectory=$&#123;project.basedir&#125;/src/main<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></div></pre></td></tr></table></figure>
<p>而Gradle就不是那么方便了，官方文档里没有讲，各种插件又不太好使，因此自己摸索了摸索。其实，我们只要搞明白<code>APT</code>的处理过程，一切问题就迎刃而解了。在编译阶段，我们可以通过<code>-processor</code>来配置对应的注解处理器，并将注解处理器的包文件加到<code>CLASSPATH</code>中。因此，我们可以在Gradle中写一个task来处理注解：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</div><div class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</div><div class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">  <span class="keyword">options</span>.compilerArgs = [</div><div class="line">    <span class="string">"-proc:only"</span>,</div><div class="line">    <span class="string">"-processor"</span>, <span class="string">"xxx.yyy.zzzProcessor"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>source</code>代表源代码目录，<code>classpath</code>设为所有的依赖，<code>destinationDir</code>代表输出路径，<code>options.compilerArgs</code>代表<code>javac</code>的配置项。注意编译期依赖可以用<code>compileOnly</code>表示（Gradle 2.12及以上版本支持）。</p>
<p>下面我们来看一个例子：如何在Gradle中使用Vert.x Codegen。首先先写处理注解的task：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</div><div class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</div><div class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">  <span class="keyword">options</span>.compilerArgs = [</div><div class="line">    <span class="string">"-proc:only"</span>,</div><div class="line">    <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</div><div class="line">    <span class="string">"-AoutputDirectory=$&#123;destinationDir.absolutePath&#125;"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意Vert.x Codegen要设定<code>outputDirectory</code>项（输出路径）方可生成代码。</p>
<p>下面我们在 <code>compileJava</code> 中引用 <code>annotationProcessing</code> ：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">compileJava &#123;</div><div class="line">  <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">  <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line"></div><div class="line">  dependsOn annotationProcessing</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在进行构建的时候，Gradle就可以利用APT来处理注解，生成代码了。如果要引用这些生成的代码，还要把它们加到源码路径中：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sourceSets</span> &#123;</div><div class="line">  main &#123;</div><div class="line">    java &#123;</div><div class="line">      srcDirs += <span class="string">'src/main/generated'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>题外话：安卓开发中也需要处理一些Android SDK中特定的注解，不过Jack发布后一般都有专门的插件，不需要自己写task。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APT/">APT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2017 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30 <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 7;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>