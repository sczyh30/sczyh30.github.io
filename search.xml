<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[call/cc总结 | Scheme]]></title>
      <url>http://www.sczyh30.com/posts/Functional-Programming/call-with-current-continuation/</url>
      <content type="html"><![CDATA[<h1 id="Continuation">Continuation</h1><p>Continuation也是一个老生常谈的东西了，我们来回顾一下。首先我们看一下 <em>TSPL4</em> 中定义的表达式求值需要做的事：</p>
<blockquote>
<p>During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value.</p>
</blockquote>
<p>Continuation即为其中的(2)，即表达式被求值以后，<strong>接下来要对表达式做的计算</strong>。<em>R5RS</em> 中continuation的定义为：</p>
<blockquote>
<p>The continuation represents an entire (default) future for the computation.</p>
</blockquote>
<p>比如 <code>(+ (* 2 3) (+ 1 7))</code> 表达式中，<code>(* 2 3)</code>的continuation为：保存<code>(* 2 3)</code>计算出的值<code>6</code>，然后计算<code>(+ 1 7)</code>的值，最后将两表达式的值相乘，结束；<code>(+ 1 7)</code>的continuation为：保存<code>(+ 1 7)</code>的值<code>8</code>，将其与前面计算出的<code>6</code>相乘，结束。</p>
<p>Scheme中的continuation是first-class的，也就是说它可以被当做参数进行传递和返回；并且Scheme中可以将continuation视为一个procedure，也就是说可以调用continuation执行后续的运算。</p>
<h1 id="call/cc">call/cc</h1><p>每个表达式在求值的时候，都会有一个对应的 <strong>current continuation</strong>，它在等着当前表达式求值完毕然后把值传递给它。那么如何捕捉current continuation呢？这就要用到Scheme中强大的<code>call/cc</code>了。<code>call/cc</code>的全名是<code>call-with-current-continuation</code>，它可以捕捉当前环境下的current continuation并利用它做各种各样的事情，如改变控制流，实现非本地退出(non-local exit)、协程(coroutine)、多任务(multi-tasking)等，非常方便。注意这里的continuation将当前context一并打包保存起来了，而不只是保存程序运行的位置。下面我们来举几个例子说明一下<code>call/cc</code>的用法。</p>
<h2 id="current_continuation">current continuation</h2><p>我们先来看个最简单的例子 —— 用它来捕捉current continuation并作为procedure调用。<code>call/cc</code>接受一个函数，该函数接受一个参数，此参数即为current continuation。以之前<code>(+ (* 2 3) (+ 1 7))</code> 表达式中 <code>(* 2 3)</code>的continuation为例：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> cc <span class="literal">#f</span>)</div><div class="line">(<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">call/cc</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (return)</div><div class="line">                (<span class="name"><span class="builtin-name">set!</span></span> cc return)</div><div class="line">                (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">3</span>)))</div><div class="line">   (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">7</span>))</div></pre></td></tr></table></figure>
<p>我们将<code>(* 2 3)</code>的current continuation(用<code>(+ ? (+ 1 7))</code>表示)绑定给<code>cc</code>变量。现在<code>cc</code>就对应了一个continuation，它相当于过程<code>(define (cc x) (+ (x) (+ 1 7)))</code>，等待一个值然后进行后续的运算：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; cc</div><div class="line">#&lt;continuation&gt;</div><div class="line">&gt; (cc 10)</div><div class="line">18</div><div class="line">&gt; (cc (* 2 3))</div><div class="line">14</div></pre></td></tr></table></figure>
<p>这个例子很好理解，我们下面引入<code>call/cc</code>的本质 —— 控制流变换。在Scheme中，假设<code>call/cc</code>捕捉到的current continuation为<code>cc</code>(位于<code>lambda</code>中)，如果<code>cc</code>作为过程<strong>直接或间接地被调用</strong>（即给它传值），<code>call/cc</code>会立即返回，返回值即为传入<code>cc</code>的值。即一旦current continuation被调用，控制流会跳到<code>call/cc</code>处。因此，利用<code>call/cc</code>，我们可以摆脱顺序执行的限制，在程序中跳来跳去，非常灵活。下面我们举几个non-local exit的例子来说明。</p>
<h2 id="Non-local_exit">Non-local exit</h2><p>Scheme中没有<code>break</code>和<code>return</code>关键字，因此在循环中如果想<code>break</code>并提前返回的话就得借助<code>call/cc</code>。比如下面的例子寻找传入的<code>list</code>中是否包含<code>5</code>：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">do-with</span> element return)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> element <span class="number">5</span>)</div><div class="line">      (<span class="name">return</span> <span class="symbol">'find-five</span>)</div><div class="line">      (<span class="name">void</span>)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">check-lst</span> lst)</div><div class="line">  (<span class="name"><span class="builtin-name">call/cc</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (return)</div><div class="line">             (<span class="name"><span class="builtin-name">for-each</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (element)</div><div class="line">                        (<span class="name">do-with</span> element return)</div><div class="line">                        (<span class="name">printf</span> <span class="string">"~a~%"</span> element))</div><div class="line">                      lst)</div><div class="line">             <span class="symbol">'not-found</span>)))</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; (check-lst '(0 2 4))</div><div class="line">0</div><div class="line">2</div><div class="line">4</div><div class="line">'not-found</div><div class="line">&gt; (check-lst '(0 3 5 1))</div><div class="line">0</div><div class="line">3</div><div class="line">'find-five</div></pre></td></tr></table></figure>
<p><code>check-lst</code>过程会遍历列表中的元素，每次都会将current continuation传给<code>do-with</code>过程并进行调用，一旦<code>do-with</code>遇到<code>5</code>，我们就将结果传给current continuation(即<code>return</code>)，此时控制流会马上跳回<code>check-lst</code>过程中的<code>call/cc</code>处，这时候就已经终止遍历了（跳出了循环）。<code>call/cc</code>的返回值为<code>&#39;find-five</code>，所以最后会在控制台上打印出<code>&#39;find-five</code>。</p>
<p>我们再来看一个经典的generator的例子，它非常像Python和ES6中的<code>yield</code>，每次调用的时候都会返回list中的一个元素：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">generate-one-element-at-a-time</span> lst)</div><div class="line"></div><div class="line">  <span class="comment">;; Hand the next item from a-list to "return" or an end-of-list marker</span></div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">control-state</span> return)</div><div class="line">    (<span class="name"><span class="builtin-name">for-each</span></span></div><div class="line">     (<span class="name"><span class="builtin-name">lambda</span></span> (element)</div><div class="line">               (<span class="name"><span class="builtin-name">set!</span></span> return (<span class="name"><span class="builtin-name">call/cc</span></span></div><div class="line">                              (<span class="name"><span class="builtin-name">lambda</span></span> (resume-here)</div><div class="line">                                <span class="comment">;; Grab the current continuation</span></div><div class="line">                               (<span class="name"><span class="builtin-name">set!</span></span> control-state resume-here)</div><div class="line">                               (<span class="name">return</span> element)))))</div><div class="line">     lst)</div><div class="line">    (<span class="name">return</span> <span class="symbol">'you-fell-off-the-end</span>))</div><div class="line"></div><div class="line">  <span class="comment">;; This is the actual generator, producing one item from a-list at a time</span></div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">generator</span>)</div><div class="line">    (<span class="name"><span class="builtin-name">call/cc</span></span> control-state))</div><div class="line"></div><div class="line">  <span class="comment">;; Return the generator</span></div><div class="line">  generator)</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> generate-digit</div><div class="line">  (<span class="name">generate-one-element-at-a-time</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>)))</div></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; (generate-digit)</div><div class="line">0</div><div class="line">&gt; (generate-digit)</div><div class="line">1</div><div class="line">&gt; (generate-digit)</div><div class="line">2</div><div class="line">&gt; (generate-digit)</div><div class="line">'you-fell-off-the-end</div></pre></td></tr></table></figure>
<p>注意到这个例子里有两个<code>call/cc</code>，大家刚看到的时候可能会有点晕，其实这两个<code>call/cc</code>各司其职，互不干扰。第一个<code>call/cc</code>负责保存遍历的状态（从此处恢复），而<code>generator</code>中的<code>call/cc</code>才是真正生成值的地方（非本地退出）。其中一个需要注意的地方就是<code>control-state</code>，它在第一次调用的时候还是个procedure，在第一次调用的过程中它就被重新绑定成一个<code>continuation</code>，之后再调用<code>generator</code>生成器的时候，控制流就可以跳到之前遍历的位置继续执行下面的过程，从而达到生成器的效果。</p>
<h1 id="阴阳谜题">阴阳谜题</h1><p>continuation环境嵌套。后面有时间专开一篇分析～</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">let*</span></span> ((<span class="name">yin</span></div><div class="line">         ((<span class="name"><span class="builtin-name">lambda</span></span> (cc) (<span class="name"><span class="builtin-name">display</span></span> <span class="literal">#\@</span>) cc) (<span class="name"><span class="builtin-name">call-with-current-continuation</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (c) c))))</div><div class="line">       (<span class="name">yang</span></div><div class="line">         ((<span class="name"><span class="builtin-name">lambda</span></span> (cc) (<span class="name"><span class="builtin-name">display</span></span> <span class="literal">#\*</span>) cc) (<span class="name"><span class="builtin-name">call-with-current-continuation</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (c) c)))))</div><div class="line">    (<span class="name">yin</span> yang))</div></pre></td></tr></table></figure>
<h1 id="call/cc与数理逻辑">call/cc与数理逻辑</h1><p>这里简单提一下<code>call/cc</code>与类型系统和数理逻辑的联系。<code>call/cc</code>的类型是<code>((P → Q) → P) → P</code>，通过Curry-Howard 同构，它可以对应到经典逻辑中的<strong>Peirce’s law</strong>：</p>
<p>$$((P \to Q) \to P) \to P$$</p>
<p>Peirce’s law代表排中律 $P \land \lnot P$，这条逻辑无法在Lambda演算所对应的直觉逻辑中表示（直觉逻辑中双重否定不成立），因此<code>call/cc</code>无法用Lambda表达式定义。通常我们用扩展后的 $\lambda \mu \ calculus$ 来定义<code>call/cc</code>，$\lambda \mu \ calculus$  经Curry-Howard 同构可以得到经典逻辑。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://www.scheme.com/tspl4/" target="_blank" rel="external">The Scheme Programming Language, 4th Edition</a></li>
<li><a href="http://community.schemewiki.org/?call-with-current-continuation" target="_blank" rel="external">Short introduction to call-with-current-continuation</a></li>
<li><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/" target="_blank" rel="external">The Revised Revised Revised Revised Revised Report on the Algorithmic Language Scheme (R5RS)</a></li>
<li><a href="https://docs.racket-lang.org/guide/conts.html" target="_blank" rel="external">The Racket Guide, 10.3 Continuations</a></li>
<li><a href="https://en.wikipedia.org/wiki/Call-with-current-continuation" target="_blank" rel="external">Call-with-current-continuation, Wikipedia</a></li>
<li><a href="https://golem.ph.utexas.edu/category/2008/01/the_continuation_passing_trans.html#c044523" target="_blank" rel="external">The Continuation Passing Transform and the Yoneda Embedding</a></li>
<li><a href="https://www.quora.com/What-is-continuation-passing-style-in-functional-programming" target="_blank" rel="external">What is continuation-passing style in functional programming? - Quora</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分布式计算系统中的GC问题 | Yak(OSDI 2016) 学习笔记]]></title>
      <url>http://www.sczyh30.com/posts/Distributed-System/distributed-computing-system-gc-osdi16-yak/</url>
      <content type="html"><![CDATA[<p>最近一直在关注OSDI 2016，发现了这篇关于分布式计算系统内存管理的论文：<a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-nguyen.pdf" target="_blank" rel="external">Yak: A High-Performance Big-Data-Friendly. Garbage Collector</a>，感觉比较有趣，拿来总结总结~</p>
<p>Yak是一个JVM平台上的针对大数据场景（分布式计算框架）设计、优化的Garbage Collector。</p>
<h1 id="背景">背景</h1><p>在传统的基于分代模型的垃圾回收算法中，小对象首先被划分到Young Generation（新生代）；如果对象经历过一定阈值的GC还会存活后，它就会被晋升至Old Generation（老年代）；大对象可以直接进入老年代。</p>
<p>对于分布式计算框架而言，这样的模型有一定的弊端：没有考虑分布式计算情景下对象的生命周期。分布式计算中控制过程(Control Path)与数据处理过程(Data Path)界限明显，如果全都用统一的GC模型的话，会导致频繁请求GC数据，扫描全堆，最后实际回收的很少，导致Full GC(STW)。因此，像Apache Spark在1.5版本以后已经放弃使用JVM的GC进行内存管理，而是直接利用unsafe包进行内存管理。这样十分麻烦还容易出错。</p>
<p>Yak就是为了解决这样的问题而诞生的。既然分布式计算过程中控制过程与数据处理过程界限明显，Yak针对这两种过程中的数据划分了两种不同的空间(space):</p>
<ul>
<li>Control Space (CS)</li>
<li>Data Space (DS)</li>
</ul>
<p>对于控制过程（比如任务的调度、日志记录等），其内存布局与传统的一致，GC还是采用分代模型，分YoungGen/OldGen/Metaspace。控制过程产生的对象小、生命周期短暂，符合分代假设。</p>
<p>而对于数据处理过程，其中的对象通常都是很大的、在计算周期中一直需要访问的，因此Yak提出了Epoch Region，数据对象的生命周期依赖于每个epoch。每个epoch的start与end需要用户来设置（但是很简单）。</p>
<h1 id="时域抽象">时域抽象</h1><blockquote>
<p>Epoch hypothesis: many data-path objects have the same life span and can be reclaimed together at the end of an epoch.</p>
</blockquote>
<p>时域抽象(Epoch Region): 抽象成semilattice(半格)，用于描述nested epoches之间的偏序关系。见论文Figure 5。(Order Theory在这里非常有用)</p>
<p>如何正确地回收某个特定的Region</p>
<p>如果有的对象生命周期超出此epoch，如何将其迁移至“安全地带”？</p>
<ul>
<li>思考点1：标记escaping objects</li>
<li>思考点2：决定escaping objects的迁移终点并且执行复制</li>
</ul>
<p>对于标记的过程，可以以cross-region/space references为根节点来遍历对象图并且标记其中的escaping objects（传递闭包）</p>
<p>对于决定其destination的过程，需要计算出对象O的引用region的上确界(via semilattice)。</p>
<p>如果对应的region具有继承关系，则应选择最上面的（上确界）。如果是不同线程执行的，那么对应的上确界则为CS。</p>
<blockquote>
<p>TODO: 待详细总结</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Distributed System | Spark RDD 论文总结]]></title>
      <url>http://www.sczyh30.com/posts/Distributed-System/spark-rdd-paper-summary/</url>
      <content type="html"><![CDATA[<p>本篇文章是对Spark RDD论文的总结，中间会穿插一些Spark的内部实现总结，对应Spark版本为2.0。</p>
<h1 id="RDD">RDD</h1><h2 id="Motivation">Motivation</h2><p>传统的分布式计算框架(如MapReduce)在执行计算任务时，中间结果通常会存于磁盘中，这样带来的IO消耗是非常大的，尤其是对于各种机器学习算法，它们需要复用上次计算的结果进行迭代，如果每次结果都存到磁盘上再从磁盘读取，耗时会很大。因此Spark这篇论文提出了一种新的分布式数据抽象 —— <strong>RDD</strong>。</p>
<h2 id="设计思想及特点">设计思想及特点</h2><p><strong>Resilient Distributed Dataset</strong>(RDD)是Apache Spark中数据的核心抽象，它是一种只读的、分区的数据记录集合。</p>
<p>RDD的特点：</p>
<ul>
<li>Lazy evaluation，只在需要的时候才进行计算</li>
<li>RDD里面的数据是分区的，每一块数据都可能分布在集群内不同的节点上；支持并行计算</li>
<li>Resilient: 借助RDD lineage graph，Spark可以重新执行之前失败的计算任务而不用整体上重新计算，保证了容错性而且非常灵活，实现了fault-tolerance</li>
</ul>
<p>那么如何操作、处理数据呢？Spark提供了一组函数式编程风格的API，可以很方便地对RDD进行操作、变换，就像操作集合一样。比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> rdd = sc.parallelize(<span class="number">1</span> to <span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> result = rdd.map(_ + <span class="number">10</span>)</div><div class="line">  .filter(_ &gt; <span class="number">15</span>)</div><div class="line">  .map(x =&gt; (x, <span class="number">1</span>))</div><div class="line">  .reduceByKey(_+_)</div><div class="line">  .collect</div></pre></td></tr></table></figure>
<p>并且开发者可以根据需要自己编写相应的RDD以及RDD之间的操作，非常方便。可以这么理解，RDD就相当于抽象的数据表示，而operation就相当于一套DSL用于对RDD进行变换或者求值。</p>
<h2 id="RDD的表示">RDD的表示</h2><p>Spark中的RDD主要包含五部分信息：</p>
<ul>
<li><code>partitions()</code>: partition集合</li>
<li><code>dependencies()</code>: 当前RDD的dependency集合</li>
<li><code>iterator(split, context)</code>: 对每个partition进行计算或读取操作的函数</li>
<li><code>partitioner()</code>: 分区方式，如<code>HashPartitioner</code>和<code>RangePartitioner</code></li>
<li><code>preferredLocations(split)</code>: 访问某个partition最快的节点</li>
</ul>
<p>所有的RDD都继承抽象类<code>RDD</code>。几种常见的操作：</p>
<ul>
<li><code>sc#textFile</code>: 生成<code>HadoopRDD</code>，代表可以从HDFS中读取数据的RDD</li>
<li><code>sc#parallelize</code>: 生成<code>ParallelCollectionRDD</code>，代表从Scala集合中生成的RDD</li>
</ul>
<ul>
<li><code>map</code>, <code>flatMap</code>, <code>filter</code>: 生成<code>MapPartitionsRDD</code>，其partition与parent RDD一致，同时会对parent RDD中<code>iterator</code>函数返回的数据进行对应的操作(lazy)</li>
<li><code>union</code>: 生成<code>UnionRDD</code>或<code>PartitionerAwareUnionRDD</code></li>
<li><code>reduceByKey</code>, <code>groupByKey</code>: 生成<code>ShuffledRDD</code>，需要进行shuffle操作</li>
<li><code>cogroup</code>, <code>join</code>: 生成<code>CoGroupedRDD</code></li>
</ul>
<h1 id="Operations">Operations</h1><p>Spark里面对RDD的操作分为两种：<strong>transformation</strong> 和 <strong>action</strong>。</p>
<ul>
<li>transformation是lazy的，仅仅会保存计算步骤并返回一个新的RDD，而不会立刻执行计算操作</li>
<li>action会依次执行计算操作并且得到结果</li>
</ul>
<p>这些transformation和action在FP中应该是很常见的，如<code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>reduce</code>, <code>count</code>, <code>sum</code>。</p>
<p>对单个数据操作的transformation函数都在<code>RDD</code>抽象类内，而对tuple操作的transformation都在<code>PairRDDFunctions</code>包装类中。<code>RDD</code>可以通过implicit函数在符合类型要求的时候自动转换为<code>PairRDDFunctions</code>类，从而可以进行<code>reduceByKey</code>之类的操作。对应的implicit函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">rddToPairRDDFunctions</span></span>[<span class="type">K</span>, <span class="type">V</span>](rdd: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)])</div><div class="line">  (<span class="keyword">implicit</span> kt: <span class="type">ClassTag</span>[<span class="type">K</span>], vt: <span class="type">ClassTag</span>[<span class="type">V</span>], ord: <span class="type">Ordering</span>[<span class="type">K</span>] = <span class="literal">null</span>): <span class="type">PairRDDFunctions</span>[<span class="type">K</span>, <span class="type">V</span>] = &#123;</div><div class="line">  <span class="keyword">new</span> <span class="type">PairRDDFunctions</span>(rdd)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Dependency">Dependency</h1><p>上面我们提到，RDD只会在需要的时候计算结果，调用那些transformation方法以后，对应的transformation信息只是被简单地存储起来，直到调用某个action才会真正地去执行计算。Spark中RDD之间是有联系的，RDD之间会形成依赖关系，也就是形成lineage graph(依赖图)。Dependency大致分两种：narrow dependency和wide dependency。</p>
<ul>
<li>Narrow dependency(<code>NarrowDependency</code>): Parent RDD中的每个partition最多被child RDD中的一个partition使用，即一对一的关系。比如<code>map</code>, <code>flatMap</code>, <code>filter</code>等transformation都是narrow dependency</li>
<li>Wide dependency(<code>ShuffleDependency</code>)：Parent RDD中的每个partition会被child RDD中的多个partition使用，即一对多的关系。比如<code>join</code>生成的RDD一般是wide dependency(不同的partitioner)</li>
</ul>
<p>论文中的图例很直观地表示了RDD间的依赖关系：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-paper-dependency-image.png" alt="Spark RDD Dependency"></p>
<p>这样划分dependency的原因：</p>
<ol>
<li>Narrow dependency可以方便地以流水线的形式执行计算，即从头到尾一串chain下来。而wide dependency必须要等所有的parent RDD的结果都准备好以后再执行计算</li>
<li>Narrow dependency失败以后，Spark只需要重新计算失败的parent RDD即可；而对于wide dependency来说，一失败可能导致某些分区丢失，必须整体重新进行计算</li>
</ol>
<h1 id="Shuffle">Shuffle</h1><p>Spark中的shuffle操作与MapReduce中类似，在计算wide dependency对应的RDD的时候（即ShuffleMapStage）会触发。</p>
<p>首先来回顾一下为什么要进行shuffle操作。以<code>reduceByKey</code>操作为例，Spark要按照key把这些具有相同key的tuple聚集到一块然后进行计算操作。然而这些tuple可能在不同的partition中，甚至在不同的集群节点中，要想计算必须先把它们聚集起来。因此，Spark用一组map task来将每个分区写入到临时文件中，然后下一个stage端(reduce task)会根据编号获取临时文件，然后将partition中的tuple按照key聚集起来并且进行相应的操作。这里面还包括着排序操作（可能在map side也可能在reduce side进行）。</p>
<p>Shuffle是Spark的主要性能瓶颈之一（涉及磁盘IO,数据序列化和网络IO），其优化一直是个难题。</p>
<ul>
<li>Shuffle write(map task): <code>SortShuffleWriter#write</code></li>
<li>Shuffle read(reduce task): <code>ShuffleRDD#compute</code></li>
</ul>
<h1 id="Persistence">Persistence</h1><h2 id="Checkpointing">Checkpointing</h2><p>Checkpoint的目的是保存那些计算耗时较长的RDD数据(long lineage chains)，执行Checkpoint的时候会新提交一个Job，因此最好先<code>persist</code>后<code>checkpoint</code>。</p>
<h2 id="Cache/Persist">Cache/Persist</h2><p><code>cache</code>和<code>persist</code>用于缓存一些经常使用的RDD结果（但是不能太大）。</p>
<ul>
<li><code>persist</code>方法的主要作用是改变<code>StorageLevel</code>以在<code>compute</code>的时候通过<code>BlockManager</code>进行相应的持久化操作</li>
<li><code>cache</code>方法相当于设置存储级别为<code>MEMORY_ONLY</code></li>
</ul>
<h1 id="Job_Scheduling">Job Scheduling</h1><p>简单来说，Spark会将提交的计算划分为不同的stages，形成一个有向无环图(<strong>DAG</strong>)。Spark的调度器会按照DAG的次序依次进行计算每个stage，最终得到计算结果。执行计算的几个重要的类或接口如下：</p>
<ul>
<li><code>DAGScheduler</code></li>
<li><code>ActiveJob</code></li>
<li><code>Stage</code></li>
<li><code>Task</code></li>
<li><code>TaskScheduler</code></li>
<li><code>SchedulerBackend</code></li>
</ul>
<p>这里面最为重要的就是 <strong>DAGScheduler</strong> 了，它会将<strong>逻辑执行计划</strong>（即RDD lineage）转化为<strong>物理执行计划</strong>（stage/task）。之前我们提到过，当开发者对某个RDD执行action的时候，Spark才会执行真正的计算过程。当开发者执行action的时候，<code>SparkContext</code>会将当前的逻辑执行计划传给<code>DAGScheduler</code>，<code>DAGScheduler</code>会根据给定的逻辑执行计划生成一个Job(对应<code>ActiveJob</code>类)并提交。每执行一个acton都会生成一个<code>ActiveJob</code>。</p>
<p>提交Job的过程中，<code>DAGScheduler</code>会进行stage的划分。Spark里是按照<code>shuffle</code>操作来划分stage的，也就是说stage之间都是wide dependency，每个stage之内的dependency都是narrow dependency。这样划分的好处是尽可能地把多个narrow dependency的RDD放到同一个stage之内以便于进行pipeline计算，而wide dependency中child RDD必须等待所有的parent RDD计算完成并且<code>shuffle</code>以后才能接着计算，因此这样划分stage是最合适的。</p>
<p>划分好的stages会形成一个DAG，<code>DAGScheduler</code>会根据DAG中的顺序先提交parent stages（如果存在的话），再提交当前stage，以此类推，最先提交的是没有parent stage的stage。从执行角度来讲，一个stage的parent stages执行完以后，该stage才可以被执行。最后一个stage是产生最终结果的stage，对应<code>ResultStage</code>，而其余的stage都是<code>ShuffleMapStage</code>。下面是论文中stage划分的一个图例，非常直观：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-paper-stage-figure.png" alt="DAG of stages"></p>
<p>提交stage的时候，Spark会根据stage的类型生成一组对应类型的<code>Task</code>(<code>ResultTask</code>或<code>ShuffleMapTask</code>)，然后将这些<code>Task</code>包装成<code>TaskSet</code>提交到<code>TaskScheduler</code>中。一个<code>Task</code>对应某个RDD中的某一个partition，即一个<code>Task</code>只负责某个partition的计算：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> tasks: <span class="type">Seq</span>[<span class="type">Task</span>[_]] = <span class="keyword">try</span> &#123;</div><div class="line">  stage <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</div><div class="line">      partitionsToCompute.map &#123; id =&gt;</div><div class="line">        <span class="keyword">val</span> locs = taskIdToLocations(id)</div><div class="line">        <span class="keyword">val</span> part = stage.rdd.partitions(id)</div><div class="line">        <span class="keyword">new</span> <span class="type">ShuffleMapTask</span>(stage.id, stage.latestInfo.attemptId,</div><div class="line">          taskBinary, part, locs, stage.latestInfo.taskMetrics, properties)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</div><div class="line">      <span class="keyword">val</span> job = stage.activeJob.get</div><div class="line">      partitionsToCompute.map &#123; id =&gt;</div><div class="line">        <span class="keyword">val</span> p: <span class="type">Int</span> = stage.partitions(id)</div><div class="line">        <span class="keyword">val</span> part = stage.rdd.partitions(p)</div><div class="line">        <span class="keyword">val</span> locs = taskIdToLocations(id)</div><div class="line">        <span class="keyword">new</span> <span class="type">ResultTask</span>(stage.id, stage.latestInfo.attemptId,</div><div class="line">          taskBinary, part, locs, id, properties, stage.latestInfo.taskMetrics)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">  <span class="comment">// 此处代码略...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>TaskScheduler</code>会向执行任务的后端(<code>SchedulerBackend</code>，可以是Local, Mesos, Hadoop YARN或者其它集群管理组件)发送<code>ReviveOffers</code>消息，对应的执行后端接收到消息以后会将<code>Task</code>封装成<code>TaskRunner</code>(<code>Runnable</code>接口的实例)，然后提交到底层的<code>Executor</code>中，并行执行计算任务。</p>
<p><code>Executor</code>中的线程池定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> threadPool = <span class="type">ThreadUtils</span>.newDaemonCachedThreadPool(<span class="string">"Executor task launch worker"</span>)</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">newDaemonCachedThreadPool</span></span>(prefix: <span class="type">String</span>): <span class="type">ThreadPoolExecutor</span> = &#123;</div><div class="line">  <span class="keyword">val</span> threadFactory = namedThreadFactory(prefix)</div><div class="line">  <span class="type">Executors</span>.newCachedThreadPool(threadFactory).asInstanceOf[<span class="type">ThreadPoolExecutor</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到底层执行task的线程池实际上是JUC中的<code>CachedThreadPool</code>，按需创建新线程，同时会复用线程池中已经建好的线程。</p>
<p>最后用一幅图总结一下Job, Stage和Task的关系（图来自 <em>Mastering Apache Spark 2.0</em>）：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-stage-tasks-jobs.png" alt="Stage, Job and Task in Spark"></p>
<p>整个Spark Context执行task的步骤图：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-run-job-diagram.png" alt=""></p>
<h1 id="Memory_Management">Memory Management</h1><p>Spark中RDD的存储方式有两种：in memory和on disk，默认是in memory的。进行分布式计算的时候通常会读入大量的数据，并且通常还需要重用这些数据，如果简单地把内存管理交给GC的话，很容易导致回收失败从而cause full GC，影响性能。</p>
<p>Spark 1.5开始不再通过GC管理内存。Spark 1.5实现了一个内存管理器用于手动管理内存(Project Tungsten)，底层通过<code>Unsafe</code>类来直接分配和回收内存。</p>
<p>另外，分布式计算系统的GC方面还可以参考OSDI 2016的一篇论文: <em>Yak: A High-Performance Big-Data-Friendly Garbage Collector</em>。</p>
<h1 id="PageRank实例">PageRank实例</h1><p>下面在Spark中跑一个PageRank来观察一下生成的Stage DAG。PageRank的公式比较简单：</p>
<p>$$PageRank (p_i) = \frac{1-d}{N} + d \sum_{p_j \in M(p_i)} \frac{PageRank (p_j)}{L(p_j)} $$</p>
<p>这里我们选择damping factor=0.85，初始的rank值为1.0；PageRank算法可以用马尔科夫矩阵进行优化，但是这里迭代次数较小，可以直接进行迭代计算。对应代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> iters = <span class="number">10</span></div><div class="line"><span class="keyword">val</span> data = sc.textFile(<span class="string">"data.txt"</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> links = data.map &#123; s =&gt;</div><div class="line">  <span class="keyword">val</span> parts = s.split(<span class="string">"\\s+"</span>)</div><div class="line">  (parts(<span class="number">0</span>), parts(<span class="number">1</span>))</div><div class="line">&#125;.distinct().groupByKey().cache()</div><div class="line"><span class="keyword">var</span> ranks = links.mapValues(v =&gt; <span class="number">1.0</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to iters) &#123;</div><div class="line">  <span class="keyword">val</span> contribs = links.join(ranks).values.flatMap &#123; <span class="keyword">case</span> (urls, rank) =&gt;</div><div class="line">    <span class="keyword">val</span> size = urls.size</div><div class="line">    urls.map(url =&gt; (url, rank / size))</div><div class="line">  &#125;</div><div class="line">  ranks = contribs.reduceByKey(_ + _).mapValues(<span class="number">0.15</span> + <span class="number">0.85</span> * _)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> output = ranks.collect()</div></pre></td></tr></table></figure>
<p>对应的Stage DAG:</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-simple-rankpage-dag.png" alt="DAG of stages in PageRank Algorithm"></p>
<p>其中Stage 3中的RDD dependencies如下：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/spark-simple-rankpage-one-stage-dag.png" alt="One stage in PageRank Algorithm"></p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://people.csail.mit.edu/matei/papers/2012/nsdi_spark.pdf" target="_blank" rel="external">M. Zaharia, <em>et al</em>. <em>Resilient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing</em>.</a></li>
<li><a href="https://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="external">Jeffrey Dean, Sanjay Ghemawat. <em>MapReduce: Simplified Data Processing on Large Clusters</em>.</a></li>
<li><a href="https://www.gitbook.com/book/jaceklaskowski/mastering-apache-spark" target="_blank" rel="external">Mastering Apache Spark 2.0</a></li>
<li><a href="https://github.com/JerryLead/SparkInternals" target="_blank" rel="external">Spark Internals</a></li>
<li><a href="http://spark.apache.org/docs/latest/programming-guide.html" target="_blank" rel="external">Spark Programming Guide</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vert.x 技术内幕 | 解道Vert.x线程模型]]></title>
      <url>http://www.sczyh30.com/posts/Vert-x/vertx-advanced-demystifying-thread-model/</url>
      <content type="html"><![CDATA[<h1 id="线程模型概述">线程模型概述</h1><p>Vert.x的线程模型设计的非常巧妙。总的来说，Vert.x中主要有两种线程：<strong>Event Loop线程</strong> 和 <strong>Worker线程</strong>。其中，Event Loop线程结合了Netty的<code>EventLoop</code>，用于处理事件。每一个<code>EventLoop</code>都与唯一的线程相绑定，这个线程就叫Event Loop线程。Event Loop线程不能被阻塞，否则事件将无法被处理。</p>
<p>Worker线程用于执行阻塞任务，这样既可以执行阻塞任务而又不阻塞Event Loop线程。</p>
<p>如果像Node.js一样只有单个Event Loop的话就不能充分利用多核CPU的性能了。为了充分利用多核CPU的性能，Vert.x中提供了一组Event Loop线程。每个Event Loop线程都可以处理事件。为了保证线程安全，防止资源争用，Vert.x保证了某一个<code>Handler</code>总是被同一个Event Loop线程执行，这样不仅可以保证线程安全，而且还可以在底层对锁进行优化提升性能。所以，只要开发者遵循Vert.x的线程模型，开发者就不需要再担心线程安全的问题，这是非常方便的。</p>
<p>本篇文章将底层的角度来解析Vert.x的线程模型。对应的Vert.x版本为<strong>3.3.3</strong>。</p>
<h1 id="Event_Loop线程">Event Loop线程</h1><p>首先回顾一下Event Loop线程，它会不断地轮询获取事件，并将获取到的事件分发到对应的事件处理器中进行处理：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertx-event-loop-xx.png" alt="Vert.x Event Loop"></p>
<p>Vert.x线程模型中最重要的一点就是：<strong>永远不要阻塞Event Loop线程</strong>。因为一旦处理事件的线程被阻塞了，事件就会一直积压着不能被处理，整个应用也就不能正常工作了。</p>
<p>Vert.x中内置一种用于检测Event Loop是否阻塞的线程：<code>vertx-blocked-thread-checker</code>。一旦Event Loop处理某个事件的时间超过一定阈值（默认为2000ms）就会警告，如果阻塞的时间过长就会抛出异常。Block Checker的实现原理比较简单，底层借助了JUC的<code>TimerTask</code>，定时计算每个Event Loop线程的处理事件消耗的时间，如果超时就进行相应的警告。</p>
<h1 id="Vert-x_Thread">Vert.x Thread</h1><p>Vert.x中的Event Loop线程及Worker线程都用<code>VertxThread</code>类表示，并通过<code>VertxThreadFactory</code>线程工厂来创建。<code>VertxThreadFactory</code>创建Vert.x线程的过程非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">  VertxThread t = <span class="keyword">new</span> VertxThread(runnable, prefix + threadCount.getAndIncrement(), worker, maxExecTime);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (checker != <span class="keyword">null</span>) &#123;</div><div class="line">    checker.registerThread(t);</div><div class="line">  &#125;</div><div class="line">  addToMap(t);</div><div class="line"></div><div class="line">  t.setDaemon(<span class="keyword">false</span>);</div><div class="line">  <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了创建<code>VertxThread</code>线程之外，<code>VertxThreadFactory</code>还会将此线程注册至Block Checker线程中以监视线程的阻塞情况，并且将此线程添加至内部的<code>weakMap</code>中。这个<code>weakMap</code>作用只有一个，就是在注销对应的Verticle的时候可以将每个<code>VertxThread</code>中的<code>Context</code>实例清除(unset)。为了保证资源不被一直占用，这里使用了<code>WeakHashMap</code>来存储每一个<code>VertxThread</code>。当里面的<code>VertxThread</code>的引用不被其他实例持有的时候，它就会被标记为可清除的对象，等待GC。</p>
<p>至于<code>VertxThread</code>，它其实就是在普通线程的基础上存储了额外的数据（如对应的Vert.x Context，最大执行时长，当前执行时间，是否为Worker线程等），这里就不多讲了。</p>
<h1 id="Vert-x_Context">Vert.x Context</h1><p>Vert.x底层中一个重要的概念就是<code>Context</code>，每个<code>Context</code>都会绑定着一个Event Loop线程（而一个Event Loop线程可以对应多个<code>Context</code>）。我们可以把<code>Context</code>看作是控制一系列的<code>Handler</code>的执行作用域及顺序的上下文对象。</p>
<p>每当Vert.x底层将事件分发至<code>Handler</code>的时候，Vert.x都会给此<code>Handler</code>钦点一个<code>Context</code>用于处理任务：</p>
<ul>
<li>如果当前线程是Vert.x线程(<code>VertxThread</code>)，那么Vert.x就会复用此线程上绑定的<code>Context</code>；如果没有对应的<code>Context</code>就创建新的</li>
<li>如果当前线程是普通线程，就创建新的<code>Context</code></li>
</ul>
<p>Vert.x中存在三种<code>Context</code>，与之前的线程种类相对应：</p>
<ul>
<li><code>EventLoopContext</code></li>
<li><code>WorkerContext</code></li>
<li><code>MultiThreadedWorkerContext</code></li>
</ul>
<h2 id="Event_loop_context">Event loop context</h2><p>每个Event Loop Context都会对应着唯一的一个<code>EventLoop</code>，即一个Event Loop Context只会在同一个Event Loop线程上执行任务。在创建<code>Context</code>的时候，Vert.x会自动根据轮询策略选择对应的<code>EventLoop</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ContextImpl</span><span class="params">(VertxInternal vertx, WorkerPool internalBlockingPool, WorkerPool workerPool, String deploymentID, JsonObject config,</span></span></div><div class="line">                        ClassLoader tccl) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    EventLoopGroup group = vertx.getEventLoopGroup();</div><div class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.eventLoop = group.next();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.eventLoop = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>在Netty中，<code>EventLoopGroup</code>代表一组<code>EventLoop</code>，而从中获取<code>EventLoop</code>的方法则是<code>next</code>方法。<code>EventLoopGroup</code>中<code>EventLoop</code>的数量由CPU内核数目所确定。Vert.x这里使用了Netty NIO对应的<code>NioEventLoop</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(options.getEventLoopPoolSize(), eventLoopThreadFactory);</div><div class="line">eventLoopGroup.setIoRatio(NETTY_IO_RATIO);</div></pre></td></tr></table></figure>
<p>对应的轮询算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTowEventExecutorChooser(executors);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，正常情况下Netty会用轮询策略选择<code>EventLoop</code>。特别地，如果<code>EventLoop</code>的个数是2的倍数的话，选择的会快一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTowEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以在Embedded模式下测试一下Event Loop线程的分配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">System.out.println(Thread.currentThread());</div><div class="line">Vertx vertx = Vertx.vertx();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</div><div class="line">  <span class="keyword">int</span> index = i;</div><div class="line">  vertx.setTimer(<span class="number">1</span>, t -&gt; &#123;</div><div class="line">    System.out.println(index + <span class="string">":"</span> + Thread.currentThread());</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>运行结果（不同机器运行顺序、Event Loop线程数可能不同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Thread[main,<span class="number">5</span>,main]</div><div class="line"><span class="number">0</span>:Thread[vert.x-eventloop-thread-<span class="number">0</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">1</span>:Thread[vert.x-eventloop-thread-<span class="number">1</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">2</span>:Thread[vert.x-eventloop-thread-<span class="number">2</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">3</span>:Thread[vert.x-eventloop-thread-<span class="number">3</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">5</span>:Thread[vert.x-eventloop-thread-<span class="number">5</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">6</span>:Thread[vert.x-eventloop-thread-<span class="number">6</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">8</span>:Thread[vert.x-eventloop-thread-<span class="number">8</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">7</span>:Thread[vert.x-eventloop-thread-<span class="number">7</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">10</span>:Thread[vert.x-eventloop-thread-<span class="number">10</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">9</span>:Thread[vert.x-eventloop-thread-<span class="number">9</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">4</span>:Thread[vert.x-eventloop-thread-<span class="number">4</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">11</span>:Thread[vert.x-eventloop-thread-<span class="number">11</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">12</span>:Thread[vert.x-eventloop-thread-<span class="number">12</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">13</span>:Thread[vert.x-eventloop-thread-<span class="number">13</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">14</span>:Thread[vert.x-eventloop-thread-<span class="number">14</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">16</span>:Thread[vert.x-eventloop-thread-<span class="number">0</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">17</span>:Thread[vert.x-eventloop-thread-<span class="number">1</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">15</span>:Thread[vert.x-eventloop-thread-<span class="number">15</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">18</span>:Thread[vert.x-eventloop-thread-<span class="number">2</span>,<span class="number">5</span>,main]</div><div class="line"><span class="number">19</span>:Thread[vert.x-eventloop-thread-<span class="number">3</span>,<span class="number">5</span>,main]</div></pre></td></tr></table></figure>
<p>可以看到尽管每个<code>Context</code>对应唯一的Event Loop线程，而每个Event Loop线程却可能对应多个<code>Context</code>。</p>
<p>Event Loop Context会在对应的<code>EventLoop</code>中执行<code>Handler</code>进行事件的处理（IO事件，非阻塞）。Vert.x会保证同一个<code>Handler</code>会一直在同一个Event Loop线程中执行，这样可以简化线程模型，让开发者在写<code>Handler</code>的时候不需要考虑并发的问题，非常方便。</p>
<p>我们来粗略地看一下<code>Handler</code>是如何在<code>EventLoop</code>上执行的。<code>EventLoopContext</code>中实现了<code>executeAsync</code>方法用于包装<code>Handler</code>中事件处理的逻辑并将其提交至对应的<code>EventLoop</code>中进行执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</div><div class="line">  <span class="comment">// No metrics, we are on the event loop.</span></div><div class="line">  nettyEventLoop().execute(wrapTask(<span class="keyword">null</span>, task, <span class="keyword">true</span>, <span class="keyword">null</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里Vert.x使用了<code>wrapTask</code>方法将<code>Handler</code>封装成了一个<code>Runnable</code>用于向<code>EventLoop</code>中提交。代码比较直观，大致就是检查当前线程是否为Vert.x线程，然后记录事件处理开始的时间，给当前的Vert.x线程设置<code>Context</code>，并且调用<code>Handler</code>里面的事件处理方法。具体请参考源码，这里就不贴出来了。</p>
<p>那么把封装好的task提交到<code>EventLoop</code>以后，<code>EventLoop</code>是怎么处理的呢？这就需要更多的Netty相关的知识了。根据Netty的模型，Event Loop线程需要处理IO事件，普通事件（即我们的<code>Handler</code>）以及定时事件（比如Vert.x的<code>setTimer</code>）。Vert.x会提供一个<code>NETTY_IO_RATIO</code>给Netty代表<code>EventLoop</code>处理IO事件时间占用的百分比（默认为50，即IO事件时间占用:非IO事件时间占用=1:1）。当<code>EventLoop</code>启动的时候，它会不断轮询IO时间及其它事件并进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</div><div class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</div><div class="line">                    select(wakenUp.getAndSet(<span class="keyword">false</span>));</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</div><div class="line">                        selector.wakeup();</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="comment">// fallthrough</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            cancelledKeys = <span class="number">0</span>;</div><div class="line">            needsToSelectAgain = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</div><div class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</div><div class="line">                processSelectedKeys();</div><div class="line">                runAllTasks();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</div><div class="line"></div><div class="line">                processSelectedKeys();</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</div><div class="line">                runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</div><div class="line">                closeAll();</div><div class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="comment">// process the error</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面Netty会调用<code>processSelectedKeys</code>方法进行IO事件的处理，并且会计算出处理IO时间所用的事件然后计算出给非IO事件处理分配的时间，然后调用<code>runAllTasks</code>方法执行所有的非IO任务（这里面就有我们的各个<code>Handler</code>）。</p>
<p><code>runAllTasks</code>会按顺序从内部的任务队列中取出任务(<code>Runnable</code>)然后进行安全执行。而我们刚才调用的<code>NioEventLoop</code>的<code>execute</code>方法其实就是将包装好的<code>Handler</code>置入<code>NioEventLoop</code>内部的任务队列中等待执行。</p>
<h2 id="Worker_context">Worker context</h2><p>顾名思义，Worker Context用于跑阻塞任务。与Event Loop Context相似，每一个<code>Handler</code>都只会跑在固定的Worker线程下。</p>
<p>Vert.x还提供一种Multi-threaded worker context可以在多个Worker线程下并发执行任务，这样就会出现并发问题，需要开发者自行解决并发问题。因此一般情况下我们用不到Multi-threaded worker context。</p>
<h1 id="Verticle">Verticle</h1><p>我们再来讨论一下<code>Verticle</code>中的<code>Context</code>。在部署<code>Verticle</code>的时候，Vert.x会根据配置来创建<code>Context</code>并绑定到Verticle上，此后此Verticle上所有绑定的<code>Handler</code>都会在此<code>Context</code>上执行。相关实现位于<code>doDeploy</code>方法，这里摘取核心部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (Verticle verticle: verticles) &#123;</div><div class="line">  WorkerExecutorImpl workerExec = poolName != <span class="keyword">null</span> ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize()) : <span class="keyword">null</span>;</div><div class="line">  WorkerPool pool = workerExec != <span class="keyword">null</span> ? workerExec.getPool() : <span class="keyword">null</span>;</div><div class="line">  <span class="comment">// 根据配置创建Context</span></div><div class="line">  ContextImpl context = options.isWorker() ? vertx.createWorkerContext(options.isMultiThreaded(), deploymentID, pool, conf, tccl) :</div><div class="line">    vertx.createEventLoopContext(deploymentID, pool, conf, tccl);</div><div class="line">  <span class="keyword">if</span> (workerExec != <span class="keyword">null</span>) &#123;</div><div class="line">    context.addCloseHook(workerExec);</div><div class="line">  &#125;</div><div class="line">  context.setDeployment(deployment);</div><div class="line">  deployment.addVerticle(<span class="keyword">new</span> VerticleHolder(verticle, context));</div><div class="line">  <span class="comment">// 此Verticle上的Handler都会在创建的context作用域内执行</span></div><div class="line">  context.runOnContext(v -&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      verticle.init(vertx, context);</div><div class="line">      Future&lt;Void&gt; startFuture = Future.future();</div><div class="line">      <span class="comment">// 大家熟悉的start方法的执行点</span></div><div class="line">      verticle.start(startFuture);</div><div class="line">      startFuture.setHandler(ar -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (ar.succeeded()) &#123;</div><div class="line">          <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">            parent.addChild(deployment);</div><div class="line">            deployment.child = <span class="keyword">true</span>;</div><div class="line">          &#125;</div><div class="line">          vertx.metricsSPI().verticleDeployed(verticle);</div><div class="line">          deployments.put(deploymentID, deployment);</div><div class="line">          <span class="keyword">if</span> (deployCount.incrementAndGet() == verticles.length) &#123;</div><div class="line">            reportSuccess(deploymentID, callingContext, completionHandler);</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!failureReported.get()) &#123;</div><div class="line">          reportFailure(ar.cause(), callingContext, completionHandler);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">      reportFailure(t, callingContext, completionHandler);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这样一种方式，Vert.x保证了<code>Verticle</code>的线程安全 —— 即某个<code>Verticle</code>上的所有<code>Handler</code>都会在同一个Vert.x线程上执行，这样也保证了<code>Verticle</code>内部成员的安全（没有race condition问题）。比如下面Verticle中处理IO及事件的处理都一直是在同一个Vert.x线程下执行的，每次打印出的线程名称应该是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    vertx.createNetClient().connect(<span class="number">6666</span>, <span class="string">"localhost"</span>, ar -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (ar.succeeded()) &#123;</div><div class="line">        NetSocket socket = ar.result();</div><div class="line">        System.out.println(Thread.currentThread().getName());</div><div class="line">        socket.handler(buffer -&gt; &#123;</div><div class="line">          i++;</div><div class="line">          System.out.println(Thread.currentThread().getName());</div><div class="line">          System.out.println(<span class="string">"Net client receiving: "</span> + buffer.toString(<span class="string">"UTF-8"</span>));</div><div class="line">        &#125;);</div><div class="line">        socket.write(<span class="string">"+1s\n"</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ar.cause().printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="线程池">线程池</h1><h2 id="Event_Loop线程池">Event Loop线程池</h2><p>之前我们已经提到过，Event Loop线程池的类型为Netty中的<code>NioEventLoopGroup</code>，里面的线程通过Vert.x自己的线程工厂<code>VertxThreadFactory</code>进行创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eventLoopThreadFactory = <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-eventloop-thread-"</span>, checker, <span class="keyword">false</span>, options.getMaxEventLoopExecuteTime());</div><div class="line">eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(options.getEventLoopPoolSize(), eventLoopThreadFactory);</div><div class="line">eventLoopGroup.setIoRatio(NETTY_IO_RATIO);</div></pre></td></tr></table></figure>
<p>其中Event Loop线程的数目可以在配置中指定。</p>
<h2 id="Worker线程池">Worker线程池</h2><p>在之前讲<code>executeBlocking</code>底层实现的文章中我们已经提到过Worker线程池，它其实就是一种Fixed Thread Pool:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService workerExec = Executors.newFixedThreadPool(options.getWorkerPoolSize(),</div><div class="line">    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-worker-thread-"</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime()));</div><div class="line">PoolMetrics workerPoolMetrics = isMetricsEnabled() ? metrics.createMetrics(workerExec, <span class="string">"worker"</span>, <span class="string">"vert.x-worker-thread"</span>, options.getWorkerPoolSize()) : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</div></pre></td></tr></table></figure>
<p>Worker线程同样由<code>VertxThreadFactory</code>构造，类型为<code>VertxThread</code>，用于执行阻塞任务。我们同样可以在配置中指定其数目。</p>
<h2 id="内部阻塞线程池">内部阻塞线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ExecutorService internalBlockingExec = Executors.newFixedThreadPool(options.getInternalBlockingPoolSize(),</div><div class="line">    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-internal-blocking-"</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime()));</div><div class="line">PoolMetrics internalBlockingPoolMetrics = isMetricsEnabled() ? metrics.createMetrics(internalBlockingExec, <span class="string">"worker"</span>, <span class="string">"vert.x-internal-blocking"</span>, options.getInternalBlockingPoolSize()) : <span class="keyword">null</span>;</div><div class="line">internalBlockingPool = <span class="keyword">new</span> WorkerPool(internalBlockingExec, internalBlockingPoolMetrics);</div></pre></td></tr></table></figure>
<p>Internal Blocking Pool可能设计用于内部使用，在<code>executeBlocking(Action&lt;T&gt; action, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</code>这个版本的方法中就使用了它。</p>
<h2 id="Acceptor_Event_Loop线程池">Acceptor Event Loop线程池</h2><p>大家可能会发现<code>VertxImpl</code>类中还有一个<code>acceptorEventLoopGroup</code>。顾名思义，它是Netty中的Acceptor线程池，负责处理客户端的连接请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">acceptorEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, acceptorEventLoopThreadFactory);</div><div class="line">acceptorEventLoopGroup.setIoRatio(<span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>由于系统只有一个服务端端口需要监听，因此这里只需要一个线程。</p>
<p>Vert.x中的<code>HttpServer</code>就利用了<code>acceptorEventLoopGroup</code>处理客户端的连接请求，具体的实现后边会另起一篇介绍。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vert.x 技术内幕 | executeBlocking 实现原理]]></title>
      <url>http://www.sczyh30.com/posts/Vert-x/vertx-advanced-execute-blocking-internal/</url>
      <content type="html"><![CDATA[<h1 id="引入">引入</h1><p>大家都知道，Vert.x中的<code>executeBlocking</code>方法用于执行阻塞任务，并且有两种模式：有序执行和无序执行。下面我们来看两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">vertx.setPeriodic(<span class="number">1000</span>, t -&gt; &#123;</div><div class="line">  vertx.executeBlocking(future -&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep(<span class="number">200</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    System.out.println(Thread.currentThread().getName());</div><div class="line">    future.complete();</div><div class="line">  &#125;, r -&gt; &#123;&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">vertx.setPeriodic(<span class="number">1000</span>, t -&gt; &#123;</div><div class="line">  vertx.executeBlocking(future -&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep(<span class="number">2000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    System.out.println(Thread.currentThread().getName());</div><div class="line">    future.complete();</div><div class="line">  &#125;, r -&gt; &#123;&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们思考一下，每段代码每次执行的时候使用的线程相同么？正常情况下大家都知道<code>executeBlocking</code>底层使用了Worker线程池，因此貌似两种情况没什么区别，都是轮询Worker线程池，每次可能用不同的Worker线程。但是我们测一下：</p>
<p>第一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-1</div><div class="line">vert.x-worker-thread-2</div><div class="line">vert.x-worker-thread-3</div><div class="line">vert.x-worker-thread-4</div></pre></td></tr></table></figure>
<p>第二段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-0</div><div class="line">vert.x-worker-thread-0</div></pre></td></tr></table></figure>
<p>额。。。两段代码每次执行的线程居然有差异？第二次为什么每次都用相同的Worker线程？其实，大家可能忽略了一点：<code>executeBlocking</code>方法默认<strong>顺序执行</strong>提交的阻塞任务。今天我们就来探究一下<code>executeBlocking</code>内部的实现。</p>
<h1 id="Worker线程池">Worker线程池</h1><p>我们来回顾一下Vert.x底层的Worker线程池，它在创建<code>VertxImpl</code>实例的时候进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService workerExec = Executors.newFixedThreadPool(options.getWorkerPoolSize(),</div><div class="line">    <span class="keyword">new</span> VertxThreadFactory(<span class="string">"vert.x-worker-thread-"</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime()));</div><div class="line">PoolMetrics workerPoolMetrics = isMetricsEnabled() ? metrics.createMetrics(workerExec, <span class="string">"worker"</span>, <span class="string">"vert.x-worker-thread"</span>, options.getWorkerPoolSize()) : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</div></pre></td></tr></table></figure>
<p>可以看到底层的Worker线程池本质上是一种<code>FixedThreadPool</code>，里面的线程由<code>VertxThreadFactory</code>控制生成，对应的线程类型为<code>VertxThread</code>。Vert.x内部用<code>WorkerPool</code>类对线程池以及线程池相关的Metrics类进行了封装。</p>
<h1 id="阻塞任务在哪里执行？">阻塞任务在哪里执行？</h1><p>有了Worker线程池的基础，我们来看一下<code>Vertx</code>实例中的<code>executeBlocking</code>方法，它的过程很简单：获取当前的Vert.x Context（没有就创建），然后委托调用<code>Context</code>里的<code>executeBlocking</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, <span class="keyword">boolean</span> ordered,</span></span></div><div class="line">                                Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler) &#123;</div><div class="line">  ContextImpl context = getOrCreateContext();</div><div class="line">  context.executeBlocking(blockingCodeHandler, ordered, asyncResultHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler,</span></span></div><div class="line">                                Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler) &#123;</div><div class="line">  executeBlocking(blockingCodeHandler, <span class="keyword">true</span>, asyncResultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此方法中可以看到，<code>ordered</code>标志位默认为<code>true</code>，即默认按提交的次序执行阻塞任务。</p>
<p>我们再来看一下<code>ContextImpl</code>类中的<code>executeBlocking</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, <span class="keyword">boolean</span> ordered, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</span> </span>&#123;</div><div class="line">  executeBlocking(<span class="keyword">null</span>, blockingCodeHandler, resultHandler, ordered ? workerExec : workerPool.executor(), workerPool.metrics());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Action&lt;T&gt; action, Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler,</span></span></div><div class="line">    Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler,</div><div class="line">    Executor exec, PoolMetrics metrics) &#123;</div><div class="line">  Object queueMetric = metrics != <span class="keyword">null</span> ? metrics.submitted() : <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    exec.execute(() -&gt; &#123;</div><div class="line">      Object execMetric = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</div><div class="line">        execMetric = metrics.begin(queueMetric);</div><div class="line">      &#125;</div><div class="line">      Future&lt;T&gt; res = Future.future();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (blockingCodeHandler != <span class="keyword">null</span>) &#123;</div><div class="line">          ContextImpl.setContext(<span class="keyword">this</span>);</div><div class="line">          blockingCodeHandler.handle(res);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          T result = action.perform();</div><div class="line">          res.complete(result);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        res.fail(e);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</div><div class="line">        metrics.end(execMetric, res.succeeded());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (resultHandler != <span class="keyword">null</span>) &#123;</div><div class="line">        runOnContext(v -&gt; res.setHandler(resultHandler));</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">catch</span> (RejectedExecutionException ignore) &#123;</div><div class="line">    <span class="comment">// Pool is already shut down</span></div><div class="line">    <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</div><div class="line">      metrics.rejected(queueMetric);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它调用了另一个具体版本的<code>executeBlocking</code>方法，其中第四个参数即为要执行阻塞任务的线程池。如果要有序执行(<code>ordered</code>为true)，底层就使用<code>context</code>实例里的<code>workerExec</code>线程池；如果无序执行，就调用<code>workerPool</code>的<code>executor</code>方法获取另一种线程池。</p>
<p>看到这里，我们大致已经想到了，有序执行和无序执行两种模式使用不同的线程池，因此底层实现肯定有差异。我们来看一下前面提到的两个线程池，它们都是<code>ContextImpl</code>类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> WorkerPool workerPool;</div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Executor workerExec;</div></pre></td></tr></table></figure>
<p>在通过<code>Vertx</code>实例创建<code>Context</code>的时候，这几个变量会被初始化，其来源就是之前我们看过的<code>VertxImpl</code>实例中的Worker线程池。看一下<code>ContextImpl</code>类的构造函数就一目了然了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.workerPool = workerPool;</div><div class="line"><span class="keyword">this</span>.workerExec = workerPool.createOrderedExecutor();</div></pre></td></tr></table></figure>
<p>嗯。。。有序执行对应的线程池通过<code>workerPool</code>的<code>createOrderedExecutor</code>方法获得，而无序执行对应的线程池通过<code>workerPool</code>的<code>executor</code>方法获得。因此，<code>WorkerPool</code>类是一个关键点，我们稍后就看一下其实现。</p>
<p>注意Vert.x规定,<code>blockingCodeHandler</code>中的逻辑（即阻塞任务）在Worker线程内执行，而<code>resultHandler</code>内的逻辑（结果处理）需要在Vert.x Conext中执行，因此前面需要预先设置当前使用的Worker线程的<code>Context</code>为<code>this</code>以便后面调用<code>runOnContext</code>方法执行结果处理逻辑。</p>
<p>下面就来看一下有序执行和无序执行这两种线程池的具体区别。</p>
<h1 id="无序执行">无序执行</h1><p>我们看一下<code>WorkerPool</code>类的源码中获取无序执行线程池的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ExecutorService <span class="title">executor</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> pool;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>executor</code>方法直接返回了内部的<code>pool</code>线程池，而<code>pool</code>线程池其实就是<code>VertxImpl</code>中的<code>workerExec</code>线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</div></pre></td></tr></table></figure>
<p>OK！如果大家熟悉并发的话，大家应该对无序执行对应的线程池 —— Worker线程池的行为非常清楚了。它属于一种<code>FixedThreadPool</code>，底层通过阻塞队列<code>LinkedBlockingQueue</code>实现。底层通过轮询算法获取Worker线程执行任务。</p>
<h1 id="有序执行">有序执行</h1><p>下面是时候看有序执行对应的逻辑了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OrderedExecutorFactory orderedFact;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolMetrics metrics;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">WorkerPool</span><span class="params">(ExecutorService pool, PoolMetrics metrics)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.orderedFact = <span class="keyword">new</span> OrderedExecutorFactory(pool);</div><div class="line">  <span class="keyword">this</span>.pool = pool;</div><div class="line">  <span class="keyword">this</span>.metrics = metrics;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Executor <span class="title">createOrderedExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> orderedFact.getExecutor();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到有序执行对应的线程池是通过<code>OrderedExecutorFactory</code>创建的。其实，<code>OrderedExecutorFactory</code>类会生成真正的有序执行线程池<code>OrderedExecutor</code>，它其实是对Worker线程池<code>pool</code>的一个简单包装，仅仅添加了有序执行相关的逻辑，最后还是委托Worker线程池进行任务处理。</p>
<p>那么<code>OrderedExecutor</code>是如何实现顺序执行的呢？<code>OrderedExecutor</code>内部维护着一个任务队列。每当调用<code>executeBlocking</code>方法执行阻塞过程的时候，Vert.x会将阻塞过程包装成<code>Runnable</code>然后置入<code>OrderedExecutor</code>中的任务队列中；同时如果<code>OrderedExecutor</code>没有开始执行任务，就委托内部的Worker线程池执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (tasks) &#123;</div><div class="line">    tasks.add(command);</div><div class="line">    <span class="keyword">if</span> (!running) &#123;</div><div class="line">      running = <span class="keyword">true</span>;</div><div class="line">      parent.execute(runner);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，最后委托Worker线程池执行的线程其实是又包装了一层的<code>runner</code>线程。<code>runner</code>的逻辑不难想：不断地从任务队列中取出队首的<code>Runnable</code>然后调用其<code>run</code>方法执行（相当于执行了此任务，只不过在runner对应的线程中）；如果没有任务了就结束本线程。</p>
<p>这里就出现了一种情况：大批量提交阻塞任务的时候，线程池的状态<code>running</code>一直为<code>true</code>，此时所有的任务都积压到任务队列中，而执行所有任务的线程只有一个 —— <code>runner</code>对应的线程。这种情况其实很好想，因为要保证有序执行，就只能让它一个接一个地在同个线程中执行。如果在不同线程中依次执行则不好调度，如果直接并行执行则不能保证有序性。</p>
<p>所以，根据<code>OrderedExecutor</code>线程池的内部实现，只要提交任务的间隔时间小于任务执行的时间，底层其实就仅执行了一次<code>runner</code>，也就是说所有提交的阻塞任务都只在一个线程下跑（running标志位控制）。</p>
<p>这样就可以很好地解释我们一开始提出的问题了。当<code>sleep(200), setPeriodic(1000)</code>的时候，提交任务的间隔时间大于任务执行的时间，这样每次的<code>runner</code>就可以在下一个任务提交之前执行完，因此每次所用的线程会不同（轮询策略）；而<code>sleep(2000), setPeriodic(1000)</code>的时候，提交任务的间隔时间小于任务执行的时间，底层最后都归结到一个<code>runner</code>中执行了，因此所有过程都是在同一个Worker线程执行的（很好想，保证有序就要串行执行）。</p>
<p>当然，如果不想有序执行，可以用<code>void executeBlocking(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, boolean ordered, Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler)</code>这个版本的<code>executeBlocking</code>方法，并将<code>ordered</code>标志位设为<code>false</code>。根据上面的源码，底层会直接使用Worker线程池而不是<code>OrderedExecutor</code>线程池，这样就不会有上面<code>OrderedExecutor</code>的情况了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vert.x 技术内幕 | 异步RPC实现原理]]></title>
      <url>http://www.sczyh30.com/posts/Vert-x/vertx-advanced-async-rpc/</url>
      <content type="html"><![CDATA[<p>经常有一些开发者在group中问到，如何利用Vert.x进行RPC通信。其实，Vert.x提供了一个组件 —— <strong>Vert.x Service Proxy</strong>，专门用于进行异步RPC通信（通过Event Bus）。Vert.x Service Proxy会自动生成代理类进行消息的包装与解码、发送与接收以及超时处理，可以为我们省掉不少代码。之前我在Vert.x Blueprint中已经详细讲解了<strong>Vert.x Service Proxy</strong>的使用，大家可以参考 <a href="http://www.sczyh30.com/vertx-blueprint-job-queue/cn/kue-core/index.html#异步rpc">Vert.x Kue 文档</a> 中的相关部分。本篇文章中我们将探索一下通过<strong>Vert.x Service Proxy</strong>生成的代理类进行异步RPC的原理，对应的Vert.x版本为<strong>3.3.2</strong>。</p>
<p>传统的RPC想必大家都不陌生，但是传统的RPC有个缺陷：传统的RPC都是阻塞型的，当调用者远程调用服务时需要阻塞着等待调用结果，这与Vert.x的异步开发模式相违背；而且，传统的RPC未对容错而设计。</p>
<p>因此，Vert.x提供了Service Proxy用于进行异步RPC，其底层依托Clustered Event Bus进行通信。我们只需要按照规范编写我们的服务接口（一般称为Event Bus服务），并加上<code>@ProxyGen</code>注解，Vert.x就会自动为我们生成相应的代理类在底层处理RPC。有了Service Proxy，我们只需给异步方法提供一个回调函数<code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>，在调用结果发送过来的时候会自动调用绑定的回调函数进行相关的处理，这样就与Vert.x的异步开发模式相符了。由于<code>AsyncResult</code>本身就是为容错而设计的（两个状态），因此这里的RPC也具有了容错性。</p>
<h1 id="原理简介">原理简介</h1><p>假设有一个Event Bus服务接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ProxyGen</span></div><div class="line"><span class="meta">@VertxGen</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeService</span> </span>&#123;</div><div class="line"></div><div class="line">  String SERVICE_ADDRESS = <span class="string">"service.example"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> SomeService <span class="title">createService</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SomeServiceImpl(vertx, config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> SomeService <span class="title">createProxy</span><span class="params">(Vertx vertx)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ProxyHelper.createProxy(SomeService.class, vertx, SERVICE_ADDRESS);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">SomeService <span class="title">process</span><span class="params">(String id, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; resultHandler)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里定义了一个异步方法<code>process</code>，其异步调用返回的结果是<code>AsyncResult&lt;JsonObject&gt;</code>类型的。由于异步RPC底层通过Clustered Event Bus进行通信，我们需要给器指定一个通信地址<code>SERVICE_ADDRESS</code>。<code>@Fluent</code>注解代表此方法返回自身，便于进行组合。我们同时还提供了两个辅助方法：<code>createService</code>方法用于创建服务实例，而<code>createProxy</code>方法则通过<code>ProxyHelper</code>辅助类创建服务代理实例。</p>
<p>假设服务提供端A注册了一个<code>SomeService</code>类型的服务代理，服务调用端B需要通过异步RPC调用服务的<code>process</code>方法，此时调用端B可以利用<code>ProxyHelper</code>获取服务实例并进行服务调用。B中获取的服务其实是一个<strong>服务代理类</strong>，而真正的服务实例在A处。何为服务代理？服务代理可以帮助我们向服务提供端发送调用请求，并且响应调用结果。那么如何发送调用请求呢？相信大家能想到，是调用端B将调用参数和方法名称等必要信息包装成集群消息(<code>ClusteredMessage</code>)，然后通过<code>send</code>方法将请求通过Clustered Event Bus发送至服务提供端A处（需要提供此服务的通信地址）。A在注册服务的时候会创建一个<code>MessageConsumer</code>监听此服务的地址来响应调用请求。当接收到调用请求的时候，A会在本地调用方法，并将结果回复至调用端。所以异步RPC本质上其实是一个基于<strong>代理模式</strong>的 <strong>Request/Response</strong> 消息模式。</p>
<p>用时序图来描述一下上述过程：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertx-async-rpc-sequence.png" alt="Sequence Diagram of Async RPC"></p>
<h1 id="引入">引入</h1><p>以之前的<code>SomeService</code>接口为例，我们可以在集群中的一个节点上注册服务实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SomeService service = SomeService.createService(vertx, config);</div><div class="line">ProxyHelper.registerService(SomeService.class, vertx, service, SomeService.SERVICE_ADDRESS);</div></pre></td></tr></table></figure>
<p>然后在另一个节点上获取此服务实例的代理，并进行服务调用。调用的时候看起来就像在本地调用(LPC)一样，其实是进行了RPC通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SomeService proxyService = SomeService.createProxy(vertx);</div><div class="line"></div><div class="line"><span class="comment">// invoke the service</span></div><div class="line">proxyService.process(<span class="string">"fuck"</span>, ar -&gt; &#123;</div><div class="line">  <span class="comment">// process the result...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其实，这里获取到的<code>proxyService</code>实例的真正类型是Vert.x自动生成的服务代理类<code>SomeServiceVertxEBProxy</code>类，里面封装了通过Event Bus进行通信的逻辑。我们首先来讲一下Service Proxy生成代理类的命名规范。</p>
<h1 id="代理类命名规范">代理类命名规范</h1><p>Vert.x Service Proxy在生成代理类时遵循一定的规范。假设有一Event Bus服务接口<code>SomeService</code>，Vert.x会自动为其生成代理类以及代理处理器：</p>
<ul>
<li>代理类的命名规范为 <strong>接口名</strong> + <code>VertxEBProxy</code>。比如<code>SomeService</code>接口对应的代理类名称为<code>SomeServiceVertxEBProxy</code></li>
<li>代理类会继承原始的服务接口并实现所有方法的代理逻辑</li>
<li>代理处理器的命名规范为 <strong>接口名</strong> + <code>VertxProxyHandler</code>。比如<code>SomeService</code>接口对应的代理处理器名称为<code>SomeServiceVertxProxyHandler</code></li>
<li>代理处理器会继承<code>ProxyHandler</code>抽象类</li>
</ul>
<p><code>ProxyHelper</code>辅助类中注册服务以及创建代理都是遵循了这个规范。</p>
<h1 id="在Event_Bus上注册服务">在Event Bus上注册服务</h1><p>我们通过<code>ProxyHelper</code>辅助类中的<code>registerService</code>方法来向Event Bus上注册Event Bus服务，来看其具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MessageConsumer&lt;JsonObject&gt; <span class="title">registerService</span><span class="params">(Class&lt;T&gt; clazz, Vertx vertx, T service, String address,</span></span></div><div class="line">                                                              <span class="keyword">boolean</span> topLevel,</div><div class="line">                                                              <span class="keyword">long</span> timeoutSeconds) &#123;</div><div class="line">  String handlerClassName = clazz.getName() + <span class="string">"VertxProxyHandler"</span>;</div><div class="line">  Class&lt;?&gt; handlerClass = loadClass(handlerClassName, clazz);</div><div class="line">  Constructor constructor = getConstructor(handlerClass, Vertx.class, clazz, <span class="keyword">boolean</span>.class, <span class="keyword">long</span>.class);</div><div class="line">  Object instance = createInstance(constructor, vertx, service, topLevel, timeoutSeconds);</div><div class="line">  ProxyHandler handler = (ProxyHandler) instance;</div><div class="line">  <span class="keyword">return</span> handler.registerHandler(address);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先根据约定生成对应的代理<code>Handler</code>的名称，然后通过类加载器加载对应的<code>Handler</code>类，再通过反射来创建代理<code>Handler</code>的实例，最后调用<code>handler</code>的<code>registerHandler</code>方法注册服务地址。</p>
<p><code>registerHandler</code>方法的实现在Vert.x生成的各个代理处理器中。以之前的<code>SomeService</code>为例，我们来看一下其对应的代理处理器<code>SomeServiceVertxProxyHandler</code>实现。首先是注册并订阅地址的<code>registerHandler</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MessageConsumer&lt;JsonObject&gt; <span class="title">registerHandler</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">  MessageConsumer&lt;JsonObject&gt; consumer = vertx.eventBus().&lt;JsonObject&gt;consumer(address).handler(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">this</span>.setConsumer(consumer);</div><div class="line">  <span class="keyword">return</span> consumer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>registerHandler</code>方法的实现非常简单，就是通过<code>consumer</code>方法在<code>address</code>地址上绑定了<code>SomeServiceVertxProxyHandler</code>自身。那么<code>SomeServiceVertxProxyHandler</code>是如何处理来自服务调用端的服务调用请求，并将调用结果返回到请求端呢？在回答这个问题之前，我们先来看看代理端（调用端）是如何发送服务调用请求的，这就要看对应的服务代理类的实现了。</p>
<h1 id="服务调用">服务调用</h1><p>我们来看一下服务调用端是如何发出服务调用请求的消息的。之前已经介绍过，服务调用端是通过Event Bus的<code>send</code>方法发送调用请求的，并且会提供一个<code>replyHandler</code>来等待方法调用的结果。调用的方法名称会存放在消息中名为<code>action</code>的header中。以之前<code>SomeService</code>的代理类<code>SomeServiceVertxEBProxy</code>中<code>process</code>方法的请求为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SomeService <span class="title">process</span><span class="params">(String id, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; resultHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (closed) &#123;</div><div class="line">    resultHandler.handle(Future.failedFuture(<span class="keyword">new</span> IllegalStateException(<span class="string">"Proxy is closed"</span>)));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  JsonObject _json = <span class="keyword">new</span> JsonObject();</div><div class="line">  _json.put(<span class="string">"id"</span>, id);</div><div class="line">  DeliveryOptions _deliveryOptions = (_options != <span class="keyword">null</span>) ? <span class="keyword">new</span> DeliveryOptions(_options) : <span class="keyword">new</span> DeliveryOptions();</div><div class="line">  _deliveryOptions.addHeader(<span class="string">"action"</span>, <span class="string">"process"</span>);</div><div class="line">  _vertx.eventBus().&lt;JsonObject&gt;send(_address, _json, _deliveryOptions, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.failed()) &#123;</div><div class="line">      resultHandler.handle(Future.failedFuture(res.cause()));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      resultHandler.handle(Future.succeededFuture(res.result().body()));</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到代理类把此方法传入的参数都放到一个<code>JsonObject</code>中了，并将要调用的方法名称存放在消息中名为<code>action</code>的header中。代理方法通过<code>send</code>方法将包装好的消息发送至之前注册的服务地址处，并且绑定<code>replyHandler</code>等待调用结果，然后使用我们传入到<code>process</code>方法中的<code>resultHandler</code>对结果进行处理。是不是很简单呢？</p>
<h1 id="服务提供端的调用逻辑">服务提供端的调用逻辑</h1><p>调用请求发出之后，我们的服务提供端就会收到调用请求消息，然后执行<code>SomeServiceVertxProxyHandler</code>中的处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;JsonObject&gt; msg)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    JsonObject json = msg.body();</div><div class="line">    String action = msg.headers().get(<span class="string">"action"</span>);</div><div class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"action not specified"</span>);</div><div class="line">    &#125;</div><div class="line">    accessed();</div><div class="line">    <span class="keyword">switch</span> (action) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">"process"</span>: &#123;</div><div class="line">        service.process((java.lang.String)json.getValue(<span class="string">"id"</span>), createHandler(msg));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">default</span>: &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid action: "</span> + action);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">    msg.reply(<span class="keyword">new</span> ServiceException(<span class="number">500</span>, t.getMessage()));</div><div class="line">    <span class="keyword">throw</span> t;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>handle</code>方法首先从消息header中获取方法名称，如果获取不到则调用失败；接着<code>handle</code>方法会调用<code>accessed</code>方法记录最后调用服务的时间戳，这是为了实现超时的逻辑，后面我们会讲。接着<code>handle</code>方法会根据方法名称分派对应的逻辑，在“真正”的服务实例上调用方法。注意异步RPC的过程本质是 <strong>Request/Response</strong> 模式，因此这里的异步结果处理函数<code>resultHandler</code>应该将调用结果发送回调用端。此<code>resultHandler</code>是通过<code>createHandler</code>方法生成的，逻辑很清晰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; Handler&lt;AsyncResult&lt;T&gt;&gt; createHandler(Message msg) &#123;</div><div class="line">  <span class="keyword">return</span> res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.failed()) &#123;</div><div class="line">      <span class="keyword">if</span> (res.cause() <span class="keyword">instanceof</span> ServiceException) &#123;</div><div class="line">        msg.reply(res.cause());</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        msg.reply(<span class="keyword">new</span> ServiceException(-<span class="number">1</span>, res.cause().getMessage()));</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (res.result() != <span class="keyword">null</span>  &amp;&amp; res.result().getClass().isEnum()) &#123;</div><div class="line">        msg.reply(((Enum) res.result()).name());</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        msg.reply(res.result());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，一旦在服务提供端的调用过程完成时，调用结果就会被发送回调用端。这样调用端就可以调用结果执行真正的处理逻辑了。</p>
<h1 id="超时处理">超时处理</h1><p>Vert.x自动生成的代理处理器内都封装了一个简单的超时处理逻辑，它是通过定时器定时检查最后的调用时间实现的。逻辑比较简单，直接放上相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SomeServiceVertxProxyHandler</span><span class="params">(Vertx vertx, SomeService service, <span class="keyword">boolean</span> topLevel, <span class="keyword">long</span> timeoutSeconds)</span> </span>&#123;</div><div class="line">  <span class="comment">// 前面代码略。。。</span></div><div class="line">  <span class="keyword">if</span> (timeoutSeconds != -<span class="number">1</span> &amp;&amp; !topLevel) &#123;</div><div class="line">    <span class="keyword">long</span> period = timeoutSeconds * <span class="number">1000</span> / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (period &gt; <span class="number">10000</span>) &#123;</div><div class="line">      period = <span class="number">10000</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.timerID = vertx.setPeriodic(period, <span class="keyword">this</span>::checkTimedOut);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.timerID = -<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  accessed();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkTimedOut</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">  <span class="keyword">long</span> now = System.nanoTime();</div><div class="line">  <span class="keyword">if</span> (now - lastAccessed &gt; timeoutSeconds * <span class="number">1000000000</span>) &#123;</div><div class="line">    close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦超时，就自动调用<code>close</code>方法终止定时器，注销响应服务调用请求的consumer并关闭代理。</p>
<h1 id="代码是如何生成的？">代码是如何生成的？</h1><p>大家可能会很好奇，这些服务代理类是怎么生成出来的？其实，这都是Vert.x Codegen的功劳。Vert.x Codegen的本质是一个 <strong>注解处理器</strong>(APT)，它可以扫描源码中是否包含要处理的注解，检查规范后根据响应的模板生成对应的代码，这就是注解处理器的作用(注解处理器于JDK 1.6引入)。为了让Codegen正确地生成代码，我们需要配置编译参数来确保注解处理器能够正常的工作，具体的可以参考 <a href="https://github.com/vert-x3/vertx-codegen/blob/master/README.md" target="_blank" rel="external">Vert.x Codegen的文档</a> （之前里面缺了Gradle相关的实例，我给补上了）。</p>
<p>Vert.x Codegen使用MVEL2作为生成代码的模板，扩展名为<code>*.templ</code>，比如代理类和代理处理器的模板就位于 <a href="https://github.com/vert-x3/vertx-service-proxy/tree/master/src/main/resources/serviceproxy/template" target="_blank" rel="external">vert-x3/vertx-service-proxy</a> 中，配置文件类似于这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"Proxy"</span>,</div><div class="line">  <span class="attr">"generators"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"kind"</span>: <span class="string">"proxy"</span>,</div><div class="line">      <span class="attr">"fileName"</span>: <span class="string">"ifaceFQCN + 'VertxEBProxy.java'"</span>,</div><div class="line">      <span class="attr">"templateFileName"</span>: <span class="string">"serviceproxy/template/proxygen.templ"</span></div><div class="line">    &#125;,&#123;</div><div class="line">      <span class="attr">"kind"</span>: <span class="string">"proxy"</span>,</div><div class="line">      <span class="attr">"fileName"</span>: <span class="string">"ifaceFQCN + 'VertxProxyHandler.java'"</span>,</div><div class="line">      <span class="attr">"templateFileName"</span>: <span class="string">"serviceproxy/template/handlergen.templ"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的代码生成逻辑还要涉及APT及MVEL2的知识，这里就不展开讲了，有兴趣的朋友可以研究研究Vert.x Codegen的源码。</p>
<h1 id="优点与缺点">优点与缺点</h1><p>Vert.x提供的这种Async RPC有着许多优点：</p>
<ul>
<li>通过Clustered Event Bus传输消息，不需引入其它额外的组件</li>
<li>自动生成代理类及代理处理器，可以帮助我们做消息封装、传输、编码解码以及超时处理等问题，省掉不少冗余代码，让我们可以以LPC的方式进行RPC通信</li>
<li>多语言支持(Polyglot support)。这是Vert.x的一大亮点。只要加上<code>@VertxGen</code>注解并在编译期依赖中加上对应语言的依赖(如<code>vertx-lang-ruby</code>)，Vert.x Codegen就会自动处理注解并生成对应语言的服务代理（通过调用Java版本的服务代理实现）。这样Async RPC可以真正地做到不限language</li>
</ul>
<p>当然Vert.x要求我们的服务接口必须是 <strong>基于回调的</strong>，这样写起来可能会不优雅。还好<code>@VertxGen</code>注解支持生成Rx版本的服务类，因此只要加上<code>vertx-rx-java</code>依赖，Codegen就能生成对应的Rx风格的服务类（异步方法返回<code>Observable</code>），这样我们就能以更reactive的风格来构建应用了，岂不美哉？</p>
<p>当然，为了考虑多语言支持的兼容性，Vert.x在传递消息的时候依然使用了传统的JSON，这样传输效率可能不如Protobuf高，但是不一定成为瓶颈。（看业务情况。真正的瓶颈一般还是在DB上）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Distributed System | RPC模块设计与实现]]></title>
      <url>http://www.sczyh30.com/posts/Distributed-System/distributed-system-rpc-design/</url>
      <content type="html"><![CDATA[<p>RPC是分布式系统中不可缺少的一部分。之前接触过几种RPC模块，这里就总结一下常见RPC模块的设计思想和实现。最后我们来设计一个可以方便进行RPC调用的RPC模块。</p>
<h1 id="RPC模块设计需要考虑的问题">RPC模块设计需要考虑的问题</h1><p>RPC模块将网络通信的过程封装成了方法调用的过程。从使用者的角度来看，在调用端进行RPC调用，就像进行本地函数调用一样；而在背后，RPC模块会将先调用端的函数名称、参数等调用信息序列化，其中序列化的方式有很多种，比如Java原生序列化、JSON、Protobuf等。接着RPC模块会将序列化后的消息通过某种协议(如TCP, AMQP等)发送到被调用端，被调用端在收到消息以后会对其解码，还原成调用信息，然后在本地进行方法调用，然后把调用结果发送回调用端，这样一次RPC调用过程就完成了。在这个过程中，我们要考虑到一些问题：</p>
<ul>
<li>设计成什么样的调用模型？</li>
<li>调用信息通过什么样的方式序列化？通过哪种协议传输？性能如何？可靠性如何？</li>
<li>分布式系统中最关注的问题：出现failure如何应对？如何容错？</li>
</ul>
<p>我们一点一点来思考。第一点是设计成什么样的调用模型。常见的几种模型：</p>
<ul>
<li>服务代理。即实现一个服务接口，被调用端实现此服务接口，实现对应的方法逻辑，并写好RPC调用信息接收部分；调用端通过RPC模块获取一个服务代理实例，这个服务代理实例继承了服务接口并封装了相应的远程调用逻辑（包括消息的编码、解码、传输等）。调用端通过这个服务代理实例进行RPC调用。像Vert.x Service Proxy和grpc都是这种模型。这样的RPC模块需要具备生成服务代理类的功能</li>
<li>直接调用，即设计特定的API用于RPC调用。比如Go的rpc包，里面的<code>Client</code>就提供了一个<code>Call</code>方法用于任意RPC调用，调用者需要传入方法名称、参数以及返回值指针（异步模式下传入callback handler）</li>
</ul>
<p>我更倾向于选择服务代理这种模型，因为服务代理这种模型在进行RPC调用的时候就像直接LPC一样方便，但是需要RPC模块生成服务代理类，实现起来可能会麻烦些；当然Go的rpc包封装的也比较好，调用也比较方便，考虑到Go的类型系统，这已经不错了。。。</p>
<p>RPC调用耗时会包含通信耗时和本地调用耗时。当网络状况不好的时候，RPC调用可能会很长时间才能得到结果。对传统的同步RPC模式来说，这期间会阻塞调用者的调用线程。当需要进行大量RPC调用的时候，这种阻塞就伤不起了。这时候，异步RPC模式就派上用场了。我们可以对传统RPC模式稍加改造，把服务接口设计成异步模式的，即每个方法都要绑定一个回调函数，或利用Future-Promise模型返回一个<code>Future</code>。设计成异步模式以后，整个架构的灵活性就能得到很大的提升。</p>
<p>第二点是调用信息的序列化反序列化以及传输。序列化主要分为文本(如JSON, XML等)和二进制(如Thrift, Protocol等)两种，不同的序列化策略性能不同，因此我们应该尽量选择性能高，同时便于开发的序列化策略。在大型项目中我们常用Protobuf，性能比较好，支持多语言，但是需要单独定义<code>.proto</code>文件；有的时候我们会选择JSON，尽管效率不是很高但是方便，比如Vert.x Service Proxy就选择了JSON格式(底层依赖Event Bus)。另一点就是传输协议的选择。通常情况下我们会选择TCP协议(各种基于TCP的应用层协议，如HTTP/2)进行通信，当然用基于AMQP协议的消息队列也可以，两者都比较可靠。</p>
<p>这里还需提一点：如何高效地并发处理request/response，这依赖于通信模块的实现。拿Java来说，基于Netty NIO或者Java AIO的I/O多路复用都可以很好地并发处理请求；而像Go RPC则是来一个request就创建一个Goroutine并在其中处理请求(Goroutine作为轻量级用户态线程，创建性能消耗小)。</p>
<p>最后一点也是最重要的一点：实现容错，这也是分布式系统设计要考虑的一个核心。想象一下一次RPC调用过程中可能产生的各种failure：</p>
<ul>
<li>网络拥塞</li>
<li>丢包，通信异常</li>
<li>服务提供端挂了，调用端得不到response</li>
</ul>
<p>一种简单的应对方式是不断地超时重传，即 <em>at least once</em> 模式。调用端设置一个超时定时器，若一定时间内没有收到response就继续发送调用请求，直到收到response或请求次数达到阈值。这种模式会发送重复请求，因此只适用于幂等性的操作，即执行多次结果相同的操作，比如读取操作。当然服务提供端也可以实现对应的逻辑来检查重复的请求。</p>
<p>更符合我们期望的容错方案是 <em>at most once</em> 模式。<em>at most once</em> 模式要求服务提供端检查重复请求，如果检查到当前请求是重复请求则返回之前的调用结果。服务提供端需要缓存之前的调用结果。这里面有几点需要考虑：</p>
<ul>
<li>如何实现重传和重复请求检测？是依靠协议（如TCP的超时重传）还是自己实现？</li>
</ul>
<p>如果自己实现的话：</p>
<ul>
<li>如何检查重复请求？我们可以给每个请求生成一个独一无二的标识符(xid)，并且在重传请求的时候使用相同的xid进行重传。用伪代码可以表示为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (seen(xid)) &#123;</div><div class="line">  result = oldResult;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  result = call(...);</div><div class="line">  oldResult = result;</div><div class="line">  setCurrentId(xid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如何保证xid是独一无二的？可以考虑使用UUID或者不同seed下的随机数。</li>
<li>服务请求端需要在一个合适的时间丢弃掉保存的之前缓存的调用结果。</li>
<li>当某个RPC调用过程还正在执行时，如何应对另外的重复请求？这种情况可以设置一个flag用于标识是否正在执行。</li>
<li>如果服务调用端挂了并且重启怎么办？如果服务调用端将xid和调用结果缓存在内存中，那么保存的信息就丢失了。因此我们可以考虑将缓存信息定时写入硬盘，或者写入replication server中，当然这些情况就比较复杂了，涉及到高可用和一致性的问题。</li>
</ul>
<p>由此可见，虽然RPC模块看似比较简单，但是设计的时候要考虑的问题还是非常多的。尤其是在保证性能的基础上又要保证可靠性，还要保证开发者的易用性，这就需要细致地思考了。</p>
<h1 id="常见RPC模块实现">常见RPC模块实现</h1><p>这里我来简单总结一下用过的常见的几个RPC模块的使用及实现思路。</p>
<h2 id="Go_RPC">Go RPC</h2><p>Go的<code>rpc</code>包使用了Go自己的gob协议作为序列化协议(通过<code>encoding/gob</code>模块内的<code>Encoder</code>/<code>Decoder</code>进行编码和解码)，而传输协议可以直接使用TCP(<code>Dial</code>方法)或者使用HTTP(<code>DialHTTP</code>)方法。开发者需要在服务端定义struct并且实现各种方法，然后将struct注册到服务端。需要进行RPC调用的时候，我们就可以在调用端通过<code>Call</code>方法（同步）或者<code>Go</code>方法（异步）进行调用。同步模式下调用结果即为<code>reply</code>指针所指的对象，而异步模式则会在调用结果准备就绪后通知绑定的channel并执行处理。</p>
<p>在rpc包的实现中(<code>net/rpc/server.go</code>)，每个注册的服务类都被封装成了一个<code>service</code>结构体，而其中的每个方法则被封装成了一个<code>methodType</code>结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> methodType <span class="keyword">struct</span> &#123;</div><div class="line">	sync.Mutex <span class="comment">// protects counters</span></div><div class="line">	method     reflect.Method</div><div class="line">	ArgType    reflect.Type</div><div class="line">	ReplyType  reflect.Type</div><div class="line">	numCalls   <span class="keyword">uint</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</div><div class="line">	name   <span class="keyword">string</span>                 <span class="comment">// name of service</span></div><div class="line">	rcvr   reflect.Value          <span class="comment">// receiver of methods for the service</span></div><div class="line">	typ    reflect.Type           <span class="comment">// type of the receiver</span></div><div class="line">	method <span class="keyword">map</span>[<span class="keyword">string</span>]*methodType <span class="comment">// registered methods</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个服务端都被封装成了一个<code>Server</code>结构体，其中的<code>serviceMap</code>存储着各个服务类的元数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</div><div class="line">	mu         sync.RWMutex <span class="comment">// protects the serviceMap</span></div><div class="line">	serviceMap <span class="keyword">map</span>[<span class="keyword">string</span>]*service</div><div class="line">	reqLock    sync.Mutex <span class="comment">// protects freeReq</span></div><div class="line">	freeReq    *Request</div><div class="line">	respLock   sync.Mutex <span class="comment">// protects freeResp</span></div><div class="line">	freeResp   *Response</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RPC Server处理调用请求的默认路径是<code>/_goRPC_</code>。当请求到达时，Go就会调用<code>Server</code>结构体实现的<code>ServeHTTP</code>方法，经<code>ServeConn</code>方法传入gob codec预处理以后最终在<code>ServeCodec</code>方法内处理请求并进行调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeCodec</span><span class="params">(codec ServerCodec)</span></span> &#123;</div><div class="line">	sending := <span class="built_in">new</span>(sync.Mutex)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		service, mtype, req, argv, replyv, keepReading, err := server.readRequest(codec)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> debugLog &amp;&amp; err != io.EOF &#123;</div><div class="line">				log.Println(<span class="string">"rpc:"</span>, err)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> !keepReading &#123;</div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// send a response if we actually managed to read a header.</span></div><div class="line">			<span class="keyword">if</span> req != <span class="literal">nil</span> &#123;</div><div class="line">				server.sendResponse(sending, req, invalidRequest, codec, err.Error())</div><div class="line">				server.freeRequest(req)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">go</span> service.call(server, sending, mtype, req, argv, replyv, codec)</div><div class="line">	&#125;</div><div class="line">	codec.Close()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果成功读取请求数据，那么接下来RPC Server就会新建一个Goroutine用来在本地执行方法，并向调用端返回response：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">call</span><span class="params">(server *Server, sending *sync.Mutex, mtype *methodType, req *Request, argv, replyv reflect.Value, codec ServerCodec)</span></span> &#123;</div><div class="line">	mtype.Lock()</div><div class="line">	mtype.numCalls++</div><div class="line">	mtype.Unlock()</div><div class="line">	function := mtype.method.Func</div><div class="line">	<span class="comment">// Invoke the method, providing a new value for the reply.</span></div><div class="line">	returnValues := function.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)</div><div class="line">	<span class="comment">// The return value for the method is an error.</span></div><div class="line">	errInter := returnValues[<span class="number">0</span>].Interface()</div><div class="line">	errmsg := <span class="string">""</span></div><div class="line">	<span class="keyword">if</span> errInter != <span class="literal">nil</span> &#123;</div><div class="line">		errmsg = errInter.(error).Error()</div><div class="line">	&#125;</div><div class="line">	server.sendResponse(sending, req, replyv.Interface(), codec, errmsg)</div><div class="line">	server.freeRequest(req)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在执行调用的过程中应该注意并发问题，防止资源争用，修改数据时需要对数据加锁；至于方法的执行就是利用了Go的反射机制。调用完以后，RPC Server接着调用<code>sendResponse</code>方法发送response，其中写入response的时候同样需要加锁，防止资源争用。</p>
<h2 id="grpc">grpc</h2><p>grpc是Google开源的一个通用的RPC框架，支持C, Java和Go等语言。既然是Google出品，序列化协议必然用protobuf啦（毕竟高效），传输协议使用HTTP/2，非常不错。开发时需要在<code>.proto</code>文件里定义数据类型以及服务接口，然后配上protoc的grpc插件就能够自动生成各个语言的服务接口和代理类。粗略地看了下grpc-java的源码，底层利用Netty和OkHttp实现HTTP通信，性能应该不错。</p>
<h2 id="Vert-x_Service_Proxy">Vert.x Service Proxy</h2><p>Vert.x Service Proxy是Vert.x的一个异步RPC组件，支持通过各种JVM语言(Java, Scala, JS, JRuby, Groovy等)进行RPC调用。使用Vert.x Service Proxy时我们只需要按照异步开发模式编写服务接口，加上相应的注解，Vert.x Service Proxy就会自动生成相应的服务代理类和服务调用处理类。Vert.x Service Proxy底层借助Event Bus进行通信，调用时将调用消息包装成JSON数据然后通过Event Bus传输到服务端，得到结果后再返回给调用端。Vert.x的一大特性就是异步、响应式编程，因此Vert.x Service Proxy的RPC模型为异步RPC，用起来非常方便。几个异步过程可以通过各种组合子串成一串，妥妥的reactive programming的风格~</p>
<p>更多的关于Vert.x Service Proxy的实现原理的内容可以看这一篇：<a href="http://www.sczyh30.com/posts/Vert-x/vertx-advanced-async-rpc/">Vert.x 技术内幕 | 异步RPC实现原理</a>。</p>
<p>PS: 我经常吐槽Vert.x Service Proxy这个名字，因为光看名字很多人不知道它可以用来实现RPC，导致了很多人以为Vert.x不能做RPC。。。应该改名叫Vert.x Async RPC比较合适。。。当然它还有很大的改进空间，主要是被Vert.x Event Bus的性能和可靠性给拖累了。。。</p>
<h2 id="Java_RMI">Java RMI</h2><p>Java RMI(Remote Method Invocation)是Java里的一种RPC编程接口，类似于服务代理的一种模式。用起来不是很方便。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vert.x 技术内幕 | Event Bus 源码分析 (集群模式)]]></title>
      <url>http://www.sczyh30.com/posts/Vert-x/vertx-advanced-clustered-event-bus-internal/</url>
      <content type="html"><![CDATA[<p><a href="http://www.sczyh30.com/posts/Vert-x/vertx-advanced-local-event-bus-internal/">上篇文章</a>中我们探索了Local模式下Event Bus的源码，在这篇文章中我们来探索一下Vert.x中的Clustered Event Bus是如何实现的。对应的Vert.x版本为<strong>3.3.2</strong>。</p>
<h1 id="集群模式介绍">集群模式介绍</h1><p>我们先来简单地介绍一下集群模式下Event Bus的基本原理。</p>
<p>我们可以通过集群模式下的Event Bus在不同的服务器之间进行通信，其本质为TCP通信。Vert.x集群模式需要一个集群管理器（默认为<code>HazelcastClusterManager</code>）来管理集群的状态，存储元数据。当我们在某个节点A给集群模式的Event Bus绑定一个对应地址<code>address</code>的<code>consumer</code>的时候，Event Bus会将此节点的<code>ServerID</code>（包含<code>host</code>和<code>port</code>信息）存储至集群管理器的共享Map中，<code>key</code>为绑定的地址<code>address</code>，value为绑定了此地址<code>address</code>的所有结点的<code>ServerID</code>集合（可以看作是具有负载均衡功能的<code>Set</code>）。集群中的所有节点都可以从集群管理器中获取Map记录。并且绑定consumer的同时节点A会建立一个<code>NetServer</code>接收数据。这样，我们再通过另一个结点B向此地址<code>address</code>发送消息的时候，B就会从集群管理器中取出此地址对应的<code>ServerID</code>集合，并根据是点对点发送还是发布，根据相应的策略创建<code>NetClient</code>执行消息分发逻辑。这样，对应的<code>NetServer</code>收到数据后会对其进行解码然后在本地进行消息的处理。</p>
<p>集群模式下我们还需要注意几个问题：</p>
<ul>
<li>某个节点挂了怎么办？</li>
<li>如何确保结点的高可用性？</li>
</ul>
<p>当某个节点挂掉的时候，其连接将会不可用，集群管理器就会将此节点的信息从集群中移除，并且传播到所有的节点删除对应缓存的信息，这样发消息的时候就不会发送到挂掉的无效节点处。至于高可用性，Vert.x提供了高可用管理器<code>HAManager</code>用于实现高可用性，在发生故障时能够快速failover，详情可见<a href="http://vertx.io/docs/vertx-core/java/#_high_availability_and_fail_over" target="_blank" rel="external">官方文档</a>。</p>
<p>好了，下面我们就来分析一下Clustered Event Bus的源码。集群模式下Event Bus的类型为<code>ClusteredEventBus</code>，它继承了单机模式的<code>EventBusImpl</code>类。其初始化过程与Local模式大同小异，因此这里就直接分析发送和接受消息相关的逻辑了。</p>
<h1 id="绑定MessageConsumer">绑定MessageConsumer</h1><p>我们还是先来看<code>consumer</code>方法的逻辑。前面的调用逻辑都和Local模式下相同，可以参考之前的文章。不同之处在添加记录的地方。Cluster模式下Event Bus需要将当前机器的位置存储至Map中并且传播至集群内的所有节点，因此<code>ClusteredEventBus</code>重写了四个参数版本的<code>addRegistration</code>方法（之前在<code>EventBusImpl</code>类中这个版本的方法用处不大，这里用处就大了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addRegistration</span><span class="params">(<span class="keyword">boolean</span> newAddress, String address,</span></span></div><div class="line">                                   <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly,</div><div class="line">                                   Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler) &#123;</div><div class="line">  <span class="keyword">if</span> (newAddress &amp;&amp; subs != <span class="keyword">null</span> &amp;&amp; !replyHandler &amp;&amp; !localOnly) &#123;</div><div class="line">    <span class="comment">// Propagate the information</span></div><div class="line">    subs.add(address, serverID, completionHandler);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    completionHandler.handle(Future.succeededFuture());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要绑定<code>MessageConsumer</code>对应的地址在本地中没有注册过，并且不是Event Bus自动生成的reply consumer，并且允许在集群范围内传播的话，Event Bus就会将当前机器的位置添加到集群内的记录<code>subs</code>中。<code>subs</code>的类型为<code>AsyncMultiMap</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> AsyncMultiMap&lt;String, ServerID&gt; subs;</div></pre></td></tr></table></figure>
<p>ClusteredEventBus启动时会对其进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">clusterManager.&lt;String, ServerID&gt;getAsyncMultiMap(SUBS_MAP_NAME, ar2 -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (ar2.succeeded()) &#123;</div><div class="line">    subs = ar2.result();</div><div class="line">    <span class="comment">// 其他代码暂略。。。</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 代码略。。。</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从名字就可以看出来，<code>AsyncMultiMap</code>允许<strong>一键多值</strong>，并且其变动可以<strong>在集群范围内传播</strong>。由于<code>AsyncMultiMap</code>是<strong>集群范围内</strong>的，因此对其操作都是异步的。在这里我们可以简单地把它看作是一个<code>Map&lt;String, ChoosableIterable&lt;ServerID&gt;&gt;</code>类型的键值对，其中<code>ChoosableIterable</code>与之前见到过的<code>Handlers</code>类似，属于可以通过轮询算法获取某一元素的集合。<code>subs</code>的key为绑定的地址，value为绑定此地址的机器位置的集合。机器的位置用<code>ServerID</code>表示，里面包含了该机器的<code>host</code>和<code>port</code>。这样，每当我们向某个地址绑定一个<code>MessageConsumer</code>的时候，绑定consumer的<code>ServerID</code>就会被记录到集群中并与地址相对应，其它机器在向此地址发送（或发布）消息的时候，Event Bus就可以从集群中获取在此地址上绑定了consumer的所有<code>ServerID</code>，再根据相应的策略选出合适的<code>ServerID</code>建立TCP通信将数据发送至对应机器中，对应机器收到消息后解码并在本地对其进行处理。</p>
<p>这里面还需要注意一点：我们可以在<code>EventBusOptions</code>中指定<code>ServerID</code>的<code>port</code>和<code>host</code>，若不指定则<code>port</code>将随机分配(<code>NetServer</code>的特性)。</p>
<p>剩下的过程也就大同小异了。至于<code>unregister</code>方法，无非就是将底层的<code>removeRegistration</code>方法重写，从<code>subs</code>中删除对应的<code>ServerID</code>并传播至其它节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeRegistration</span><span class="params">(HandlerHolder lastHolder, String address,</span></span></div><div class="line">                                      Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler) &#123;</div><div class="line">  <span class="keyword">if</span> (lastHolder != <span class="keyword">null</span> &amp;&amp; subs != <span class="keyword">null</span> &amp;&amp; !lastHolder.isLocalOnly()) &#123;</div><div class="line">    removeSub(address, serverID, completionHandler);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    callCompletionHandlerAsync(completionHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeSub</span><span class="params">(String subName, ServerID theServerID, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">  subs.remove(subName, theServerID, ar -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (!ar.succeeded()) &#123;</div><div class="line">      log.error(<span class="string">"Failed to remove sub"</span>, ar.cause());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (ar.result()) &#123;</div><div class="line">        <span class="keyword">if</span> (completionHandler != <span class="keyword">null</span>) &#123;</div><div class="line">          completionHandler.handle(Future.succeededFuture());</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (completionHandler != <span class="keyword">null</span>) &#123;</div><div class="line">          completionHandler.handle(Future.failedFuture(<span class="string">"sub not found"</span>));</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="消息的发送/发布">消息的发送/发布</h1><p>集群模式下的消息与本地模式下的消息不同。集群模式下的消息实体类型为<code>ClusteredMessage</code>，它继承了<code>MessageImpl</code>消息实体类，并且根据远程传输的特性实现了一种Wire Protocol用于远程传输消息，并负责消息的编码和解码。具体的实现就不展开说了，如果有兴趣的话可以阅读<code>ClusteredMessage</code>类中相关方法的实现。</p>
<p>我们上篇文章提到过，Event Bus底层通过<code>createMessage</code>方法创建消息。因此<code>ClusteredEventBus</code>里就对此方法进行了重写，当然改动就是把<code>MessageImpl</code>替换成了<code>ClusteredMessage</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> MessageImpl <span class="title">createMessage</span><span class="params">(<span class="keyword">boolean</span> send, String address, MultiMap headers, Object body, String codecName)</span> </span>&#123;</div><div class="line">  Objects.requireNonNull(address, <span class="string">"no null address accepted"</span>);</div><div class="line">  MessageCodec codec = codecManager.lookupCodec(body, codecName);</div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  ClusteredMessage msg = <span class="keyword">new</span> ClusteredMessage(serverID, address, <span class="keyword">null</span>, headers, body, codec, send, <span class="keyword">this</span>);</div><div class="line">  <span class="keyword">return</span> msg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就是消息的发送逻辑了。<code>ClusteredEventBus</code>重写了<code>sendOrPub</code>方法，此方法存在于<code>SendContextImpl</code>类中的<code>next</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (iter.hasNext()) &#123;</div><div class="line">    Handler&lt;SendContext&gt; handler = iter.next();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      handler.handle(<span class="keyword">this</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">      log.error(<span class="string">"Failure in interceptor"</span>, t);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    sendOrPub(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看一下<code>ClusteredEventBus</code>是如何进行集群内消息的分发的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendOrPub</span><span class="params">(SendContextImpl&lt;T&gt; sendContext)</span> </span>&#123;</div><div class="line">  String address = sendContext.message.address();</div><div class="line">  Handler&lt;AsyncResult&lt;ChoosableIterable&lt;ServerID&gt;&gt;&gt; resultHandler = asyncResult -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (asyncResult.succeeded()) &#123;</div><div class="line">      ChoosableIterable&lt;ServerID&gt; serverIDs = asyncResult.result();</div><div class="line">      <span class="keyword">if</span> (serverIDs != <span class="keyword">null</span> &amp;&amp; !serverIDs.isEmpty()) &#123;</div><div class="line">        sendToSubs(serverIDs, sendContext);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        metrics.messageSent(address, !sendContext.message.send(), <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">        deliverMessageLocally(sendContext);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      log.error(<span class="string">"Failed to send message"</span>, asyncResult.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">if</span> (Vertx.currentContext() == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// Guarantees the order when there is no current context</span></div><div class="line">    sendNoContext.runOnContext(v -&gt; &#123;</div><div class="line">      subs.get(address, resultHandler);</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    subs.get(address, resultHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Event Bus需要从传入的<code>sendContext</code>中获取要发送至的地址。接着Event Bus需要从集群管理器中获取在此地址上绑定consumer的所有<code>ServerID</code>，这个过程是异步的，并且需要在Vert.x Context中执行。如果获取记录成功，我们会得到一个可通过轮询算法获取<code>ServerID</code>的集合(类型为<code>ChoosableIterable&lt;ServerID&gt;</code>)。如果集合为空，则代表集群内其它节点没有在此地址绑定consumer（或者由于一致性问题没有同步），Event Bus就将消息通过<code>deliverMessageLocally</code>方法在本地进行相应的分发。<code>deliverMessageLocally</code>方法的逻辑之前我们已经详细讲过了，这里就不再细说了；如果集合不为空，Event Bus就调用<code>sendToSubs</code>方法进行下一步操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendToSubs</span><span class="params">(ChoosableIterable&lt;ServerID&gt; subs, SendContextImpl&lt;T&gt; sendContext)</span> </span>&#123;</div><div class="line">  String address = sendContext.message.address();</div><div class="line">  <span class="keyword">if</span> (sendContext.message.send()) &#123;</div><div class="line">    <span class="comment">// Choose one</span></div><div class="line">    ServerID sid = subs.choose();</div><div class="line">    <span class="keyword">if</span> (!sid.equals(serverID)) &#123;  <span class="comment">//We don't send to this node</span></div><div class="line">      metrics.messageSent(address, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">      sendRemote(sid, sendContext.message);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      metrics.messageSent(address, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">      deliverMessageLocally(sendContext);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Publish</span></div><div class="line">    <span class="keyword">boolean</span> local = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> remote = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span> (ServerID sid : subs) &#123;</div><div class="line">      <span class="keyword">if</span> (!sid.equals(serverID)) &#123;  <span class="comment">//We don't send to this node</span></div><div class="line">        remote = <span class="keyword">true</span>;</div><div class="line">        sendRemote(sid, sendContext.message);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        local = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    metrics.messageSent(address, <span class="keyword">true</span>, local, remote);</div><div class="line">    <span class="keyword">if</span> (local) &#123;</div><div class="line">      deliverMessageLocally(sendContext);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就到了分<code>send</code>和<code>publish</code>的时候了。如果发送消息的模式为点对点模式(<code>send</code>)，Event Bus会从给的的集合中通过轮询算法获取一个<code>ServerID</code>。然后Event Bus会检查获取到的<code>ServerID</code>是否与本机<code>ServerID</code>相同，如果相同则代表在一个机子上，直接记录metrics信息并且调用<code>deliverMessageLocally</code>方法往本地发送消息即可；如果不相同，Event Bus就会调用<code>sendRemote</code>方法执行真正的远程消息发送逻辑。发布订阅模式的逻辑与其大同小异，只不过需要遍历一下<code>ChoosableIterable&lt;ServerID&gt;</code>集合，然后依次执行之前讲过的逻辑。注意如果要在本地发布消息只需要发一次。</p>
<p>真正的远程消息发送逻辑在<code>sendRemote</code>方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRemote</span><span class="params">(ServerID theServerID, MessageImpl message)</span> </span>&#123;</div><div class="line">  ConnectionHolder holder = connections.get(theServerID);</div><div class="line">  <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</div><div class="line">    holder = <span class="keyword">new</span> ConnectionHolder(<span class="keyword">this</span>, theServerID, options);</div><div class="line">    ConnectionHolder prevHolder = connections.putIfAbsent(theServerID, holder);</div><div class="line">    <span class="keyword">if</span> (prevHolder != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// Another one sneaked in</span></div><div class="line">      holder = prevHolder;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      holder.connect();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  holder.writeMessage((ClusteredMessage)message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一开始我们就提到过，节点之间通过Event Bus进行通信的本质是TCP，因此这里需要创建一个<code>NetClient</code>作为TCP服务端，连接到之前获取的<code>ServerID</code>对应的节点然后将消息通过TCP协议发送至接收端。这里Vert.x用一个封装类<code>ConnectionHolder</code>对<code>NetClient</code>进行了一些封装。</p>
<p><code>ClusteredEventBus</code>中维持着一个<code>connections</code>哈希表对用于保存<code>ServerID</code>对应的连接<code>ConnectionHolder</code>。在<code>sendRemote</code>方法中,Event Bus首先会从<code>connections</code>中获取<code>ServerID</code>对应的连接。如果获取不到就创建连接并将其添加至<code>connections</code>记录中并调用对应<code>ConnectionHolder</code>的<code>connect</code>方法建立连接；最后调用<code>writeMessage</code>方法将消息编码后通过TCP发送至对应的接收端。</p>
<p>那么<code>ConnectionHolder</code>是如何实现的呢？我们来看一下其构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ConnectionHolder(ClusteredEventBus eventBus, ServerID serverID, EventBusOptions options) &#123;</div><div class="line">  <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">  <span class="keyword">this</span>.serverID = serverID;</div><div class="line">  <span class="keyword">this</span>.vertx = eventBus.vertx();</div><div class="line">  <span class="keyword">this</span>.metrics = eventBus.getMetrics();</div><div class="line">  NetClientOptions clientOptions = <span class="keyword">new</span> NetClientOptions(options.toJson());</div><div class="line">  ClusteredEventBus.setCertOptions(clientOptions, options.getKeyCertOptions());</div><div class="line">  ClusteredEventBus.setTrustOptions(clientOptions, options.getTrustOptions());</div><div class="line">  client = <span class="keyword">new</span> NetClientImpl(eventBus.vertx(), clientOptions, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>ConnectionHolder</code>初始化的时候会创建一个<code>NetClient</code>作为TCP请求端，而请求的对象就是接收端的<code>NetServer</code>(后边会讲)，客户端配置已经在<code>EventBusOptions</code>中事先配置好了。我们来看看<code>connect</code>方法是如何建立连接的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (connected) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already connected"</span>);</div><div class="line">  &#125;</div><div class="line">  client.connect(serverID.port, serverID.host, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      connected(res.result());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      close();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到这里很简单地调用了<code>NetClient#connect</code>方法建立TCP连接，如果建立连接成功的话会得到一个<code>NetSocket</code>对象。Event Bus接着将其传至<code>connected</code>方法中进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(NetSocket socket)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.socket = socket;</div><div class="line">  connected = <span class="keyword">true</span>;</div><div class="line">  socket.exceptionHandler(t -&gt; close());</div><div class="line">  socket.closeHandler(v -&gt; close());</div><div class="line">  socket.handler(data -&gt; &#123;</div><div class="line">    <span class="comment">// Got a pong back</span></div><div class="line">    vertx.cancelTimer(timeoutID);</div><div class="line">    schedulePing();</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// Start a pinger</span></div><div class="line">  schedulePing();</div><div class="line">  <span class="keyword">for</span> (ClusteredMessage message : pending) &#123;</div><div class="line">    Buffer data = message.encodeToWire();</div><div class="line">    metrics.messageWritten(message.address(), data.length());</div><div class="line">    socket.write(data);</div><div class="line">  &#125;</div><div class="line">  pending.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Event Bus通过<code>exceptionHandler</code>和<code>closeHandler</code>方法给连接对应的<code>NetSocket</code>绑定异常回调和连接关闭回调，触发的时候都调用<code>close</code>方法关闭连接；为了保证不丢失连接，消息发送方每隔一段时间就需要对消息接收方发送一次心跳包（<code>PING</code>），如果消息接收方在一定时间内没有回复，那么就认为连接丢失，调用<code>close</code>方法关闭连接。心跳检测的逻辑在<code>schedulePing</code>方法中，比较清晰，这里就不详细说了。大家会发现<code>ConnectionHolder</code>里也有个消息队列（缓冲区）<code>pending</code>，并且这里会将队列中的消息依次通过TCP发送至接收端。为什么需要这样呢？其实，这要从创建TCP客户端说起。创建TCP客户端这个过程应该是异步的，需要消耗一定时间，而<code>ConnectionHolder</code>中封装的<code>connect</code>方法却是同步式的。前面我们刚刚看过，通过<code>connect</code>方法建立连接以后会接着调用<code>writeMessage</code>方法发送消息，而这时候客户端连接可能还没建立，因此需要这么个缓冲区先存着，等着连接建立了再一块发送出去（存疑：为什么不将<code>connect</code>方法直接设计成异步的？）。</p>
<p>至于发送消息的<code>writeMessage</code>方法，其逻辑一目了然：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeMessage</span><span class="params">(ClusteredMessage message)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (connected) &#123;</div><div class="line">    Buffer data = message.encodeToWire();</div><div class="line">    metrics.messageWritten(message.address(), data.length());</div><div class="line">    socket.write(data);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (pending == <span class="keyword">null</span>) &#123;</div><div class="line">      pending = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    pending.add(message);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果连接已建立，Event Bus就会调用对应<code>ClusteredMessage</code>的<code>encodeToWire</code>方法将其转化为字节流<code>Buffer</code>，然后记录metrics信息，最后通过<code>socket</code>的<code>write</code>方法将消息写入到Socket中，这样消息就从发送端通过TCP发送到了接收端。如果连接未建立，就如之前讲的那样，先把消息存到消息队列中，等连接建立了再一块发出去。</p>
<p>这样，Clustered Event Bus下消息的发送逻辑就理清楚了。下面我们看一下接收端是如何接收消息并在本地进行消息的处理的。</p>
<h1 id="消息的接收">消息的接收</h1><p>一开始我们提到过，每个节点的Clustered Event Bus在启动时都会创建一个<code>NetServer</code>作为接收消息的TCP服务端。TCP Server的<code>port</code>和<code>host</code>可以在<code>EventBusOptions</code>中指定，如果不指定的话默认随机分配<code>port</code>，然后Event Bus会根据<code>NetServer</code>的配置来生成当前节点的<code>ServerID</code>。</p>
<p>创建TCP Server的逻辑在<code>start</code>方法中，与接受消息有关的逻辑就是这一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.connectHandler(getServerHandler());</div></pre></td></tr></table></figure>
<p>我们知道，<code>NetServer</code>的<code>connectHandler</code>方法用于绑定对服务端Socket的处理函数，而这里绑定的处理函数是由<code>getServerHandler</code>方法生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Handler&lt;NetSocket&gt; <span class="title">getServerHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> socket -&gt; &#123;</div><div class="line">    RecordParser parser = RecordParser.newFixed(<span class="number">4</span>, <span class="keyword">null</span>);</div><div class="line">    Handler&lt;Buffer&gt; handler = <span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</div><div class="line">      <span class="keyword">int</span> size = -<span class="number">1</span>;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buff)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (size == -<span class="number">1</span>) &#123;</div><div class="line">          size = buff.getInt(<span class="number">0</span>);</div><div class="line">          parser.fixedSizeMode(size);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          ClusteredMessage received = <span class="keyword">new</span> ClusteredMessage();</div><div class="line">          received.readFromWire(buff, codecManager);</div><div class="line">          metrics.messageRead(received.address(), buff.length());</div><div class="line">          parser.fixedSizeMode(<span class="number">4</span>);</div><div class="line">          size = -<span class="number">1</span>;</div><div class="line">          <span class="keyword">if</span> (received.codec() == CodecManager.PING_MESSAGE_CODEC) &#123;</div><div class="line">            <span class="comment">// Just send back pong directly on connection</span></div><div class="line">            socket.write(PONG);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            deliverMessageLocally(received);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    parser.setOutput(handler);</div><div class="line">    socket.handler(parser);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑非常清晰。这里Event Bus使用了<code>RecordParser</code>来获取发送过来的对应长度的<code>Buffer</code>，并将其绑定在<code>NetServer</code>的Socket上。真正的解析<code>Buffer</code>并处理的逻辑在内部的<code>handler</code>中。之前<code>ClusteredMessage</code>中的Wire Protocol规定<code>Buffer</code>的首部第一个<code>int</code>值为要发送<code>Buffer</code>的长度（逻辑见<code>ClusteredMessage#encodeToWire</code>方法），因此这里首先获取长度，然后给<code>parser</code>设定正确的fixed size，这样<code>parser</code>就可以截取正确长度的<code>Buffer</code>流了。下面Event Bus会创建一个空的<code>ClusteredMessage</code>，然后调用其<code>readFromWire</code>方法从<code>Buffer</code>中重建消息。当然这里还要记录消息已经读取的metrics信息。接着检测收到的消息实体类型是否为心跳检测包(<code>PING</code>)，如果是的话就发送回ACK消息(<code>PONG</code>)；如果不是心跳包，则代表是正常的消息，Event Bus就调用我们熟悉的<code>deliverMessageLocally</code>函数在本地进行分发处理，接下来的过程就和Local模式一样了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vert.x 技术内幕 | Event Bus 源码分析 (Local模式)]]></title>
      <url>http://www.sczyh30.com/posts/Vert-x/vertx-advanced-local-event-bus-internal/</url>
      <content type="html"><![CDATA[<p>Event Bus是Vert.x的“神经系统”，是最为关键的几个部分之一。今天我们就来探索一下Event Bus的实现原理。本篇分析的是Local模式的Event Bus，对应的Vert.x版本为<strong>3.3.2</strong>。</p>
<p>本文假定读者有一定的并发编程基础以及Vert.x使用基础，并且对Vert.x的线程模型以及<a href="http://vertx.io/docs/vertx-core/java/#streams" target="_blank" rel="external">back-pressure</a>有所了解。</p>
<h1 id="Local_Event_Bus的创建">Local Event Bus的创建</h1><p>一般情况下，我们通过<code>Vertx</code>的<code>eventBus</code>方法来创建或获取一个<code>EventBus</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Vertx vertx = Vertx.vertx();</div><div class="line">EventBus eventBus = vertx.eventBus();</div></pre></td></tr></table></figure>
<p><code>eventBus</code>方法定义于<code>Vertx</code>接口中，我们来看一下其位于<code>VertxImpl</code>类中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">eventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (eventBus == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// If reading from different thread possibility that it's been set but not visible - so provide</span></div><div class="line">    <span class="comment">// memory barrier</span></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">return</span> eventBus;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> eventBus;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到此方法返回<code>VertxImpl</code>实例中的<code>eventBus</code>成员，同时需要注意并发可见性问题。那么<code>eventBus</code>成员是何时初始化的呢？答案在<code>VertxImpl</code>类的构造函数中。这里截取相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (options.isClustered()) &#123;</div><div class="line">  <span class="comment">// 集群模式相关逻辑</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.clusterManager = <span class="keyword">null</span>;</div><div class="line">  createAndStartEventBus(options, resultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>VertxImpl</code>内部是通过<code>createAndStartEventBus</code>方法来初始化<code>eventBus</code>的。我们来看一下其逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndStartEventBus</span><span class="params">(VertxOptions options, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (options.isClustered()) &#123;</div><div class="line">    eventBus = <span class="keyword">new</span> ClusteredEventBus(<span class="keyword">this</span>, options, clusterManager, haManager);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    eventBus = <span class="keyword">new</span> EventBusImpl(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  eventBus.start(ar2 -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (ar2.succeeded()) &#123;</div><div class="line">      <span class="comment">// If the metric provider wants to use the event bus, it cannot use it in its constructor as the event bus</span></div><div class="line">      <span class="comment">// may not be initialized yet. We invokes the eventBusInitialized so it can starts using the event bus.</span></div><div class="line">      metrics.eventBusInitialized(eventBus);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (resultHandler != <span class="keyword">null</span>) &#123;</div><div class="line">        resultHandler.handle(Future.succeededFuture(<span class="keyword">this</span>));</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      log.error(<span class="string">"Failed to start event bus"</span>, ar2.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到此方法通过<code>eventBus = new EventBusImpl(this)</code>将<code>eventBus</code>进行了初始化(Local模式为<code>EventBusImpl</code>)，并且调用<code>eventBus</code>的<code>start</code>方法对其进行一些额外的初始化工作。我们来看一下<code>EventBusImpl</code>类的<code>start</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (started) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already started"</span>);</div><div class="line">  &#125;</div><div class="line">  started = <span class="keyword">true</span>;</div><div class="line">  completionHandler.handle(Future.succeededFuture());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先初始化过程需要防止race condition，因此方法为<code>synchronized</code>的。该方法仅仅将<code>EventBusImpl</code>类中的一个<code>started</code>标志位设为<code>true</code>来代表Event Bus已启动。注意<code>started</code>标志位为<code>volatile</code>的，这样可以保证其可见性，确保其它线程通过<code>checkStarted</code>方法读到的<code>started</code>结果总是最新的。设置完<code>started</code>标志位后，Vert.x会接着调用传入的<code>completionHandler</code>处理函数，也就是上面我们在<code>createAndStartEventBus</code>方法中看到的 —— 调用<code>metrics</code>成员的<code>eventBusInitialized</code>方法以便Metrics类可以在Event Bus初始化完毕后使用它（不过默认情况下此方法的逻辑为空）。</p>
<p>可以看到初始化过程还是比较简单的，我们接下来先来看看订阅消息 —— <code>consumer</code>方法的逻辑。</p>
<h1 id="consume">consume</h1><p>我们来看一下<code>consumer</code>方法的逻辑，其原型位于<code>EventBus</code>接口中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address)</span></span>;</div><div class="line">&lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address, Handler&lt;Message&lt;T&gt;&gt; handler)</span></span>;</div></pre></td></tr></table></figure>
<p>其实现位于<code>EventBusImpl</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address, Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</div><div class="line">  Objects.requireNonNull(handler, <span class="string">"handler"</span>);</div><div class="line">  MessageConsumer&lt;T&gt; consumer = consumer(address);</div><div class="line">  consumer.handler(handler);</div><div class="line">  <span class="keyword">return</span> consumer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先要确保传入的<code>handler</code>不为空，然后Vert.x会调用只接受一个<code>address</code>参数的<code>consumer</code>方法获取对应的<code>MessageConsumer</code>，最后给获取到的<code>MessageConsumer</code>绑定上传入的<code>handler</code>。我们首先来看一下另一个<code>consumer</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">  checkStarted();</div><div class="line">  Objects.requireNonNull(address, <span class="string">"address"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HandlerRegistration&lt;&gt;(vertx, metrics, <span class="keyword">this</span>, address, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, -<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Vert.x会检查Event Bus是否已经启动，并且确保传入的地址不为空。然后Vert.x会传入一大堆参数创建一个新的<code>HandlerRegistration</code>类型的实例，并返回。可以推测<code>HandlerRegistration</code>是<code>MessageConsumer</code>接口的具体实现，它一定非常重要。所以我们来看一看<code>HandlerRegistration</code>类是个啥玩意。首先看一下<code>HandlerRegistration</code>的类体系结构：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vertx-handlerregistration-ch.png" alt=""></p>
<p>可以看到<code>HandlerRegistration</code>类同时继承了<code>MessageConsumer&lt;T&gt;</code>以及<code>Handler&lt;Message&lt;T&gt;&gt;</code>接口，从其类名可以看出它相当于一个”Handler注册记录”，是非常重要的一个类。它有一堆的成员变量，构造函数对<code>vertx</code>, <code>metrics</code>, <code>eventBus</code>, <code>address</code>（发送地址）, <code>repliedAddress</code>（回复地址）, <code>localOnly</code>（是否在集群内传播）, <code>asyncResultHandler</code>等几个成员变量进行初始化，并且检查超时时间<code>timeout</code>，如果设定了超时时间那么设定并保存超时计时器（仅用于reply handler中），如果计时器时间到，代表回复超时。因为有一些函数还没介绍，超时的逻辑我们后边再讲。</p>
<blockquote>
<p>Note: 由于<code>MessageConsumer</code>接口继承了<code>ReadStream</code>接口，因此它支持back-pressure，其实现就在<code>HandlerRegistration</code>类中。我们将稍后解析back-pressure的实现。</p>
</blockquote>
<p>现在回到<code>consumer</code>方法中来。创建了<code>MessageConsumer</code>实例后，我们接着调用它的<code>handler</code>方法绑定上对应的消息处理函数。<code>handler</code>方法的实现位于<code>HandlerRegistration</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> MessageConsumer&lt;T&gt; <span class="title">handler</span><span class="params">(Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.handler = handler;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handler != <span class="keyword">null</span> &amp;&amp; !registered) &#123;</div><div class="line">    registered = <span class="keyword">true</span>;</div><div class="line">    eventBus.addRegistration(address, <span class="keyword">this</span>, repliedAddress != <span class="keyword">null</span>, localOnly);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.handler == <span class="keyword">null</span> &amp;&amp; registered) &#123;</div><div class="line">    <span class="comment">// This will set registered to false</span></div><div class="line">    <span class="keyword">this</span>.unregister();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，<code>handler</code>方法将此<code>HandlerRegistration</code>中的<code>handler</code>成员设置为传入的消息处理函数。<code>HandlerRegistration</code>类中有一个<code>registered</code>标志位代表是否已绑定消息处理函数。<code>handler</code>方法会检查传入的<code>handler</code>是否为空且是否已绑定消息处理函数。如果不为空且未绑定，Vert.x就会将<code>registered</code>标志位设为<code>true</code>并且调用<code>eventBus</code>的<code>addRegistration</code>方法将此consumer注册至Event Bus上；如果<code>handler</code>为空且已绑定消息处理函数，我们就调用<code>unregister</code>方法注销当前的consumer。我们稍后会分析<code>unregister</code>方法的实现。</p>
<p>前面提到过注册consumer的逻辑位于Event Bus的<code>addRegistration</code>方法中，因此我们来分析一下它的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; registration,</span></span></div><div class="line">                                   <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly) &#123;</div><div class="line">  Objects.requireNonNull(registration.getHandler(), <span class="string">"handler"</span>);</div><div class="line">  <span class="keyword">boolean</span> newAddress = addLocalRegistration(address, registration, replyHandler, localOnly);</div><div class="line">  addRegistration(newAddress, address, replyHandler, localOnly, registration::setResult);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>addRegistration</code>方法接受四个参数：发送地址<code>address</code>、传入的consumer <code>registration</code>、代表是否为reply handler的标志位<code>replyHandler</code>以及代表是否在集群范围内传播的标志位<code>localOnly</code>。首先确保传入的<code>HandlerRegistration</code>不为空。然后Vert.x会调用<code>addLocalRegistration</code>方法将此consumer注册至Event Bus上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">addLocalRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; registration,</span></span></div><div class="line">                                           <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly) &#123;</div><div class="line">  Objects.requireNonNull(address, <span class="string">"address"</span>);</div><div class="line"></div><div class="line">  Context context = Vertx.currentContext();</div><div class="line">  <span class="keyword">boolean</span> hasContext = context != <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">if</span> (!hasContext) &#123;</div><div class="line">    <span class="comment">// Embedded</span></div><div class="line">    context = vertx.getOrCreateContext();</div><div class="line">  &#125;</div><div class="line">  registration.setHandlerContext(context);</div><div class="line"></div><div class="line">  <span class="keyword">boolean</span> newAddress = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  HandlerHolder holder = <span class="keyword">new</span> HandlerHolder&lt;&gt;(metrics, registration, replyHandler, localOnly, context);</div><div class="line"></div><div class="line">  Handlers handlers = handlerMap.get(address);</div><div class="line">  <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</div><div class="line">    handlers = <span class="keyword">new</span> Handlers();</div><div class="line">    Handlers prevHandlers = handlerMap.putIfAbsent(address, handlers);</div><div class="line">    <span class="keyword">if</span> (prevHandlers != <span class="keyword">null</span>) &#123;</div><div class="line">      handlers = prevHandlers;</div><div class="line">    &#125;</div><div class="line">    newAddress = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  handlers.list.add(holder);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (hasContext) &#123;</div><div class="line">    HandlerEntry entry = <span class="keyword">new</span> HandlerEntry&lt;&gt;(address, registration);</div><div class="line">    context.addCloseHook(entry);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> newAddress;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先该方法要确保地址<code>address</code>不为空，接着它会获取当前线程下对应的Vert.x Context，如果获取不到则表明当前不在<code>Verticle</code>中（即Embedded），需要调用<code>vertx.getOrCreateContext()</code>来获取<code>Context</code>；然后将获取到的<code>Context</code>赋值给<code>registration</code>内部的<code>handlerContext</code>（代表消息处理对应的Vert.x Context）。</p>
<p>下面就要将给定的<code>registration</code>注册至Event Bus上了。这里Vert.x用一个<code>HandlerHolder</code>类来包装<code>registration</code>和<code>context</code>。接着Vert.x会从存储消息处理<code>Handler</code>的哈希表<code>handlerMap</code>中获取给定地址对应的<code>Handlers</code>，哈希表的类型为<code>ConcurrentMap&lt;String, Handlers&gt;</code>，key为地址，value为对应的<code>HandlerHolder</code>集合。注意这里的<code>Handlers</code>类代表一些<code>Handler</code>的集合，它内部维护着一个列表<code>list</code>用于存储每个<code>HandlerHolder</code>。<code>Handlers</code>类中只有一个<code>choose</code>函数，此函数根据轮询算法从<code>HandlerHolder</code>集合中选定一个<code>HandlerHolder</code>，这即是Event Bus发送消息时实现load-balancing的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handlers</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger pos = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> List&lt;HandlerHolder&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> HandlerHolder <span class="title">choose</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="keyword">int</span> size = list.size();</div><div class="line">      <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> p = pos.getAndIncrement();</div><div class="line">      <span class="keyword">if</span> (p &gt;= size - <span class="number">1</span>) &#123;</div><div class="line">        pos.set(<span class="number">0</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> list.get(p);</div><div class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">        <span class="comment">// Can happen</span></div><div class="line">        pos.set(<span class="number">0</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取到对应的<code>handlers</code>以后，Vert.x首先需要检查其是否为空，如果为空代表此地址还没有注册消息处理<code>Handler</code>，Vert.x就会创建一个<code>Handlers</code>并且将其置入<code>handlerMap</code>中，将<code>newAddress</code>标志位设为<code>true</code>代表这是一个新注册的地址，然后将其赋值给<code>handlers</code>。接着我们向<code>handlers</code>中的<code>HandlerHolder</code>列表<code>list</code>中添加刚刚创建的<code>HandlerHolder</code>实例，这样就将<code>registration</code>注册至Event Bus中了。</p>
<p>前面判断当前线程是否在Vert.x Context的标志位<code>hasContext</code>还有一个用途：如果当前线程在Vert.x Context下（比如在Verticle中），Vert.x会通过<code>addCloseHook</code>方法给当前的<code>context</code>添加一个钩子函数用于注销当前绑定的<code>registration</code>。当对应的<code>Verticle</code>被undeploy的时候，此Verticle绑定的所有消息处理<code>Handler</code>都会被unregister。Hook的类型为<code>HandlerEntry&lt;T&gt;</code>，它继承了<code>Closeable</code>接口，对应的逻辑在<code>close</code>函数中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerEntry</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String address;</div><div class="line">  <span class="keyword">final</span> HandlerRegistration&lt;T&gt; handler;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HandlerEntry</span><span class="params">(String address, HandlerRegistration&lt;T&gt; handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.address = address;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="comment">// Called by context on undeploy</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">    handler.unregister(completionHandler);</div><div class="line">    completionHandler.handle(Future.succeededFuture());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>close</code>函数会将绑定的<code>registration</code>从Event Bus的<code>handlerMap</code>中移除并执行<code>completionHandler</code>中的逻辑，<code>completionHandler</code>可由用户指定。</p>
<p>那么在哪里调用这些绑定的hook呢？答案是在<code>DeploymentManager</code>类中的<code>doUndeploy</code>方法中，通过<code>context</code>的<code>runCloseHooks</code>方法执行绑定的hook函数。相关代码如下（只截取相关逻辑）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doUndeploy</span><span class="params">(ContextImpl undeployingContext, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">  <span class="comment">// 前面代码略</span></div><div class="line">  context.runCloseHooks(ar2 -&gt; &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ar2.failed()) &#123;</div><div class="line">      <span class="comment">// Log error but we report success anyway</span></div><div class="line">      log.error(<span class="string">"Failed to run close hook"</span>, ar2.cause());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (ar.succeeded() &amp;&amp; undeployCount.incrementAndGet() == numToUndeploy) &#123;</div><div class="line">      reportSuccess(<span class="keyword">null</span>, undeployingContext, completionHandler);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ar.failed() &amp;&amp; !failureReported.get()) &#123;</div><div class="line">      failureReported.set(<span class="keyword">true</span>);</div><div class="line">      reportFailure(ar.cause(), undeployingContext, completionHandler);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// 后面代码略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再回到<code>addRegistration</code>方法中。刚才<code>addLocalRegistration</code>方法的返回值<code>newAddress</code>代表对应的地址是否为新注册的。接着我们调用另一个版本的<code>addRegistration</code>方法，传入了一大堆参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addRegistration</span><span class="params">(<span class="keyword">boolean</span> newAddress, String address,</span></span></div><div class="line">                                   <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly,</div><div class="line">                                   Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler) &#123;</div><div class="line">  completionHandler.handle(Future.succeededFuture());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好吧，传入的前几个参数没用到。。。最后一个参数<code>completionHandler</code>传入的是<code>registration::setResult</code>方法引用，也就是说这个方法调用了对应<code>registration</code>的<code>setResult</code>方法。其实现位于<code>HandlerRegistration</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(AsyncResult&lt;Void&gt; result)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.result = result;</div><div class="line">  <span class="keyword">if</span> (completionHandler != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (result.succeeded()) &#123;</div><div class="line">      metric = metrics.handlerRegistered(address, repliedAddress);</div><div class="line">    &#125;</div><div class="line">    Handler&lt;AsyncResult&lt;Void&gt;&gt; callback = completionHandler;</div><div class="line">    vertx.runOnContext(v -&gt; callback.handle(result));</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.failed()) &#123;</div><div class="line">    log.error(<span class="string">"Failed to propagate registration for handler "</span> + handler + <span class="string">" and address "</span> + address);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    metric = metrics.handlerRegistered(address, repliedAddress);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先先设置<code>registration</code>内部的<code>result</code>成员（正常情况下为<code>Future.succeededFuture()</code>）。接着Vert.x会判断<code>registration</code>是否绑定了<code>completionHandler</code>（与之前的<code>completionHandler</code>不同，这里的<code>completionHandler</code>是<code>MessageConsumer</code>注册成功时调用的<code>Handler</code>），若绑定则记录Metrics信息(<code>handlerRegistered</code>)并在Vert.x Context内调用<code>completionHandler</code>的逻辑；若未绑定<code>completionHandler</code>则仅记录Metrics信息。</p>
<p>到此为止，<code>consumer</code>方法的逻辑就分析完了。在分析<code>send</code>和<code>publish</code>方法的逻辑之前，我们先来看一下如何注销绑定的<code>MessageConsumer</code>。</p>
<h1 id="unregister">unregister</h1><p>我们通过调用<code>MessageConsumer</code>的<code>unregister</code>方法实现注销操作。Vert.x提供了两个版本的<code>unregister</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span></span>;</div></pre></td></tr></table></figure>
<p>其中第二个版本的<code>unregister</code>方法会在注销操作完成时调用传入的<code>completionHandler</code>。比如在cluster范围内注销consumer需要消耗一定的时间在集群内传播，因此第二个版本的方法就会派上用场。我们来看一下其实现，它们最后都是调用了<code>HandlerRegistration</code>类的<code>doUnregister</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler, <span class="keyword">boolean</span> callEndHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (timeoutID != -<span class="number">1</span>) &#123;</div><div class="line">    vertx.cancelTimer(timeoutID);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (endHandler != <span class="keyword">null</span> &amp;&amp; callEndHandler) &#123;</div><div class="line">    Handler&lt;Void&gt; theEndHandler = endHandler;</div><div class="line">    Handler&lt;AsyncResult&lt;Void&gt;&gt; handler = completionHandler;</div><div class="line">    completionHandler = ar -&gt; &#123;</div><div class="line">      theEndHandler.handle(<span class="keyword">null</span>);</div><div class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">        handler.handle(ar);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (registered) &#123;</div><div class="line">    registered = <span class="keyword">false</span>;</div><div class="line">    eventBus.removeRegistration(address, <span class="keyword">this</span>, completionHandler);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    callCompletionHandlerAsync(completionHandler);</div><div class="line">  &#125;</div><div class="line">  registered = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果设定了超时定时器(<code>timeoutID</code>合法)，那么Vert.x会首先将定时器关闭。接着Vert.x会判断是否需要调用<code>endHandler</code>。那么<code>endHandler</code>又是什么呢？前面我们提到过<code>MessageConsumer</code>接口继承了<code>ReadStream</code>接口，而<code>ReadStream</code>接口定义了一个<code>endHandler</code>方法用于绑定一个<code>endHandler</code>，当stream中的数据读取完毕时会调用。而在Event Bus中，消息源源不断地从一处发送至另一处，因此只有在某个consumer<br>被unregister的时候，其对应的stream才可以叫“读取完毕”，因此Vert.x选择在<code>doUnregister</code>方法中调用<code>endHandler</code>。</p>
<p>接着Vert.x会判断此consumer是否已注册消息处理函数<code>Handler</code>（通过检查<code>registered</code>标志位），若已注册则将对应的<code>Handler</code>从Event Bus中的<code>handlerMap</code>中移除并将<code>registered</code>设为<code>false</code>；若还未注册<code>Handler</code>且提供了注销结束时的回调<code>completionHandler</code>(注意不是<code>HandlerRegistration</code>类的成员变量<code>completionHandler</code>，而是之前第二个版本的<code>unregister</code>中传入的<code>Handler</code>，用同样的名字很容易混。。。)，则通过<code>callCompletionHandlerAsync</code>方法调用回调函数。</p>
<p>从Event Bus中移除<code>Handler</code>的逻辑位于<code>EventBusImpl</code>类的<code>removeRegistration</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; handler, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</div><div class="line">  HandlerHolder holder = removeLocalRegistration(address, handler);</div><div class="line">  removeRegistration(holder, address, completionHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeRegistration</span><span class="params">(HandlerHolder handlerHolder, String address,</span></span></div><div class="line">                                      Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler) &#123;</div><div class="line">  callCompletionHandlerAsync(completionHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">HandlerHolder <span class="title">removeLocalRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; handler)</span> </span>&#123;</div><div class="line">  Handlers handlers = handlerMap.get(address);</div><div class="line">  HandlerHolder lastHolder = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (handlers) &#123;</div><div class="line">      <span class="keyword">int</span> size = handlers.list.size();</div><div class="line">      <span class="comment">// Requires a list traversal. This is tricky to optimise since we can't use a set since</span></div><div class="line">      <span class="comment">// we need fast ordered traversal for the round robin</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        HandlerHolder holder = handlers.list.get(i);</div><div class="line">        <span class="keyword">if</span> (holder.getHandler() == handler) &#123;</div><div class="line">          handlers.list.remove(i);</div><div class="line">          holder.setRemoved();</div><div class="line">          <span class="keyword">if</span> (handlers.list.isEmpty()) &#123;</div><div class="line">            handlerMap.remove(address);</div><div class="line">            lastHolder = holder;</div><div class="line">          &#125;</div><div class="line">          holder.getContext().removeCloseHook(<span class="keyword">new</span> HandlerEntry&lt;&gt;(address, holder.getHandler()));</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> lastHolder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其真正的<code>unregister</code>逻辑位于<code>removeLocalRegistration</code>方法中。首先需要从<code>handlerMap</code>中获取地址对应的<code>Handlers</code>实例<code>handlers</code>，如果<code>handlers</code>不为空，为了防止并发问题，Vert.x需要对其加锁后再进行操作。Vert.x需要遍历<code>handlers</code>中的列表，遇到与传入的<code>HandlerRegistration</code>相匹配的<code>HandlerHolder</code>就将其从列表中移除，然后调用对应<code>holder</code>的<code>setRemoved</code>方法标记其为已注销并记录Metrics数据（<code>handlerUnregistered</code>）。如果移除此<code>HandlerHolder</code>后<code>handlers</code>没有任何注册的<code>Handler</code>了，就将该地址对应的<code>Handlers</code>实例从<code>handlerMap</code>中移除并保存刚刚移除的<code>HandlerHolder</code>。另外，由于已经将此consumer注销，在undeploy verticle的时候不需要再进行unregister，因此这里还要将之前注册到context的hook移除。</p>
<p>调用完<code>removeLocalRegistration</code>方法以后，Vert.x会调用另一个版本的<code>removeRegistration</code>方法，调用<code>completionHandler</code>（用户在第二个版本的<code>unregister</code>方法中传入的处理函数）对应的逻辑，其它的参数都没什么用。。。</p>
<p>这就是<code>MessageConsumer</code>注销的逻辑实现。下面就到了本文的另一重头戏了 —— 发送消息相关的函数<code>send</code>和<code>publish</code>。</p>
<h1 id="send_&amp;_publish">send &amp; publish</h1><p><code>send</code>和<code>publish</code>的逻辑相近，只不过一个是发送至目标地址的某一消费者，一个是发布至目标地址的所有消费者。Vert.x使用一个标志位<code>send</code>来代表是否为点对点发送模式。</p>
<p>几个版本的<code>send</code>和<code>publish</code>最终都归结于生成消息对象然后调用<code>sendOrPubInternal</code>方法执行逻辑，只不过<code>send</code>标志位不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">EventBus <span class="title">send</span><span class="params">(String address, Object message, DeliveryOptions options, Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</div><div class="line">  sendOrPubInternal(createMessage(<span class="keyword">true</span>, address, options.getHeaders(), message, options.getCodecName()), options, replyHandler);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">publish</span><span class="params">(String address, Object message, DeliveryOptions options)</span> </span>&#123;</div><div class="line">  sendOrPubInternal(createMessage(<span class="keyword">false</span>, address, options.getHeaders(), message, options.getCodecName()), options, <span class="keyword">null</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个方法中都是通过<code>createMessage</code>方法来生成对应的消息对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> MessageImpl <span class="title">createMessage</span><span class="params">(<span class="keyword">boolean</span> send, String address, MultiMap headers, Object body, String codecName)</span> </span>&#123;</div><div class="line">  Objects.requireNonNull(address, <span class="string">"no null address accepted"</span>);</div><div class="line">  MessageCodec codec = codecManager.lookupCodec(body, codecName);</div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  MessageImpl msg = <span class="keyword">new</span> MessageImpl(address, <span class="keyword">null</span>, headers, body, codec, send, <span class="keyword">this</span>);</div><div class="line">  <span class="keyword">return</span> msg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createMessage</code>方法接受5个参数：<code>send</code>即上面提到的标志位，<code>address</code>为发送目标地址，<code>headers</code>为设置的header，<code>body</code>代表发送的对象，<code>codecName</code>代表对应的Codec（消息编码解码器）名称。<code>createMessage</code>方法首先会确保地址不为空，然后通过<code>codecManager</code>来获取对应的<code>MessageCodec</code>。如果没有提供Codec(即<code>codecName</code>为空)，那么<code>codecManager</code>会根据发送对象<code>body</code>的类型来提供内置的Codec实现（具体逻辑请见<a href="https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/eventbus/impl/CodecManager.java#L47" target="_blank" rel="external">此处</a>）。准备好<code>MessageCodec</code>后，<code>createMessage</code>方法就会创建一个<code>MessageImpl</code>实例并且返回。</p>
<p>这里我们还需要了解一下<code>MessageImpl</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageImpl</span><span class="params">(String address, String replyAddress, MultiMap headers, U sentBody,</span></span></div><div class="line">                   MessageCodec&lt;U, V&gt; messageCodec,</div><div class="line">                   <span class="keyword">boolean</span> send, EventBusImpl bus) &#123;</div><div class="line">  <span class="keyword">this</span>.messageCodec = messageCodec; <span class="comment">// Codec</span></div><div class="line">  <span class="keyword">this</span>.address = address; <span class="comment">// 发送目标地址</span></div><div class="line">  <span class="keyword">this</span>.replyAddress = replyAddress; <span class="comment">// 回复地址</span></div><div class="line">  <span class="keyword">this</span>.headers = headers; <span class="comment">// header</span></div><div class="line">  <span class="keyword">this</span>.sentBody = sentBody; <span class="comment">// 发送的对象</span></div><div class="line">  <span class="keyword">this</span>.send = send; <span class="comment">// 是否为点对点模式</span></div><div class="line">  <span class="keyword">this</span>.bus = bus; <span class="comment">// 相关的Event Bus实例</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createMessage</code>方法并没有设置回复地址<code>replyAddress</code>。如果用户指定了<code>replyHandler</code>的话，后边<code>sendOrPubInternal</code>方法会对此消息实体进行加工，设置<code>replyAddress</code>并生成回复逻辑对应的<code>HandlerRegistration</code>。</p>
<p>我们看一下<code>sendOrPubInternal</code>方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendOrPubInternal</span><span class="params">(MessageImpl message, DeliveryOptions options,</span></span></div><div class="line">                                   Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler) &#123;</div><div class="line">  checkStarted();</div><div class="line">  HandlerRegistration&lt;T&gt; replyHandlerRegistration = createReplyHandlerRegistration(message, options, replyHandler);</div><div class="line">  SendContextImpl&lt;T&gt; sendContext = <span class="keyword">new</span> SendContextImpl&lt;&gt;(message, options, replyHandlerRegistration);</div><div class="line">  sendContext.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它接受三个参数：要发送的消息<code>message</code>，发送配置选项<code>options</code>以及回复处理函数<code>replyHandler</code>。首先<code>sendOrPubInternal</code>方法要检查Event Bus是否已启动，接着如果绑定了回复处理函数，Vert.x就会调用<code>createReplyHandlerRegistration</code>方法给消息实体<code>message</code>包装上回复地址，并且生成对应的reply consumer。接着Vert.x创建了一个包装消息的<code>SendContextImpl</code>实例并调用了其<code>next</code>方法。</p>
<p>我们一步一步来解释。首先是<code>createReplyHandlerRegistration</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">HandlerRegistration&lt;T&gt; <span class="title">createReplyHandlerRegistration</span><span class="params">(MessageImpl message, DeliveryOptions options, Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (replyHandler != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">long</span> timeout = options.getSendTimeout();</div><div class="line">    String replyAddress = generateReplyAddress();</div><div class="line">    message.setReplyAddress(replyAddress);</div><div class="line">    Handler&lt;Message&lt;T&gt;&gt; simpleReplyHandler = convertHandler(replyHandler);</div><div class="line">    HandlerRegistration&lt;T&gt; registration =</div><div class="line">      <span class="keyword">new</span> HandlerRegistration&lt;&gt;(vertx, metrics, <span class="keyword">this</span>, replyAddress, message.address, <span class="keyword">true</span>, replyHandler, timeout);</div><div class="line">    registration.handler(simpleReplyHandler);</div><div class="line">    <span class="keyword">return</span> registration;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createReplyHandlerRegistration</code>方法首先检查传入的<code>replyHandler</code>是否为空（是否绑定了<code>replyHandler</code>，回复处理函数），如果为空则代表不需要处理回复，直接返回<code>null</code>；若<code>replyHandler</code>不为空，<code>createReplyHandlerRegistration</code>方法就会从配置中获取reply的最大超时时长(默认30s)，然后调用<code>generateReplyAddress</code>方法生成对应的回复地址<code>replyAddress</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong replySequence = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">generateReplyAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Long.toString(replySequence.incrementAndGet());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成回复地址的逻辑有点简单。。。。<code>EventBusImpl</code>实例中维护着一个<code>AtomicLong</code>类型的<code>replySequence</code>成员变量代表对应的回复地址。每次生成的时候都会使其自增，然后转化为String。也就是说生成的<code>replyAddress</code>都类似于”1”、”5”这样，而不是我们想象中的直接回复至sender的地址。。。</p>
<p>生成完毕以后，<code>createReplyHandlerRegistration</code>方法会将生成的<code>replyAddress</code>设定到消息对象<code>message</code>中。接着Vert.x会通过<code>convertHandler</code>方法对<code>replyHandler</code>进行包装处理并生成类型简化为<code>Handler&lt;Message&lt;T&gt;&gt;</code>的<code>simpleReplyHandler</code>，它用于绑定至后面创建的reply consumer上。接着Vert.x会创建对应的reply consumer。关于<code>reply</code>操作的实现，我们后边会详细讲述。下面Vert.x就通过<code>handler</code>方法将生成的回复处理函数<code>simpleReplyHandler</code>绑定至创建好的reply consumer中，其底层实现我们之前已经分析过了，这里就不再赘述。最后此方法返回生成的<code>registration</code>，即对应的reply consumer。注意这个reply consumer是<strong>一次性</strong>的，也就是说Vert.x会在其接收到回复或超时的时候自动对其进行注销。</p>
<p>OK，现在回到<code>sendOrPubInternal</code>方法中来。下面Vert.x会创建一个<code>SendContextImpl</code>实例并调用其<code>next</code>方法。<code>SendContextImpl</code>类实现了<code>SendContext</code>接口，它相当于一个消息的封装体，并且可以与Event Bus中的<code>interceptors</code>（拦截器）结合使用。</p>
<p><code>SendContext</code>接口定义了三个方法：</p>
<ul>
<li><code>message</code>: 获取当前<code>SendContext</code>包装的消息实体</li>
<li><code>next</code>: 调用下一个消息拦截器</li>
<li><code>send</code>: 代表消息的发送模式是否为点对点模式</li>
</ul>
<p>在Event Bus中，消息拦截器本质上是一个<code>Handler&lt;SendContext&gt;</code>类型的处理函数。Event Bus内部存储着一个<code>interceptors</code>列表用于存储绑定的消息拦截器。我们可以通过<code>addInterceptor</code>和<code>removeInterceptor</code>方法进行消息拦截器的添加和删除操作。如果要进行链式拦截，则在每个拦截器中都应该调用对应<code>SendContext</code>的<code>next</code>方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eventBus.addInterceptor(sc -&gt; &#123;</div><div class="line">  <span class="comment">// 一些处理逻辑</span></div><div class="line">  sc.next(); <span class="comment">// 调用下一个拦截器</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们来看一下<code>SendContextImpl</code>类中<code>next</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SendContextImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">SendContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> MessageImpl message;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> DeliveryOptions options;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> HandlerRegistration&lt;T&gt; handlerRegistration;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Handler&lt;SendContext&gt;&gt; iter;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SendContextImpl</span><span class="params">(MessageImpl message, DeliveryOptions options, HandlerRegistration&lt;T&gt; handlerRegistration)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.message = message;</div><div class="line">    <span class="keyword">this</span>.options = options;</div><div class="line">    <span class="keyword">this</span>.handlerRegistration = handlerRegistration;</div><div class="line">    <span class="keyword">this</span>.iter = interceptors.iterator();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Message&lt;T&gt; <span class="title">message</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (iter.hasNext()) &#123;</div><div class="line">      Handler&lt;SendContext&gt; handler = iter.next();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        handler.handle(<span class="keyword">this</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        log.error(<span class="string">"Failure in interceptor"</span>, t);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      sendOrPub(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> message.send();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，<code>SendContextImpl</code>类中维护了一个拦截器列表对应的迭代器。每次调用<code>next</code>方法时，如果迭代器中存在拦截器，就将下个拦截器取出并进行相关调用。如果迭代器为空，则代表拦截器都已经调用完毕，Vert.x就会调用<code>EventBusImpl</code>类下的<code>sendOrPub</code>方法进行消息的发送操作。</p>
<p><code>sendOrPub</code>方法仅仅在metrics模块中记录相关数据(<code>messageSent</code>)，最后调用<code>deliverMessageLocally(SendContextImpl&lt;T&gt;)</code>方法执行消息的发送逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">deliverMessageLocally</span><span class="params">(SendContextImpl&lt;T&gt; sendContext)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!deliverMessageLocally(sendContext.message)) &#123;</div><div class="line">    <span class="comment">// no handlers</span></div><div class="line">    metrics.replyFailure(sendContext.message.address, ReplyFailure.NO_HANDLERS);</div><div class="line">    <span class="keyword">if</span> (sendContext.handlerRegistration != <span class="keyword">null</span>) &#123;</div><div class="line">      sendContext.handlerRegistration.sendAsyncResultFailure(ReplyFailure.NO_HANDLERS, <span class="string">"No handlers for address "</span></div><div class="line">                                                             + sendContext.message.address);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面又套了一层。。。它最后其实是调用了<code>deliverMessageLocally(MessageImpl)</code>方法。此方法返回值代表发送消息的目标地址是否注册有<code>MessageConsumer</code>，如果没有(<code>false</code>)则记录错误并调用<code>sendContext</code>中保存的回复处理函数处理错误（如果绑定了<code>replyHandler</code>的话）。</p>
<p><code>deliverMessageLocally(MessageImpl)</code>方法是真正区分<code>send</code>和<code>publish</code>的地方，我们来看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">deliverMessageLocally</span><span class="params">(MessageImpl msg)</span> </span>&#123;</div><div class="line">  msg.setBus(<span class="keyword">this</span>);</div><div class="line">  Handlers handlers = handlerMap.get(msg.address());</div><div class="line">  <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (msg.send()) &#123;</div><div class="line">      <span class="comment">//Choose one</span></div><div class="line">      HandlerHolder holder = handlers.choose();</div><div class="line">      metrics.messageReceived(msg.address(), !msg.send(), isMessageLocal(msg), holder != <span class="keyword">null</span> ? <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">      <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</div><div class="line">        deliverToHandler(msg, holder);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Publish</span></div><div class="line">      metrics.messageReceived(msg.address(), !msg.send(), isMessageLocal(msg), handlers.list.size());</div><div class="line">      <span class="keyword">for</span> (HandlerHolder holder: handlers.list) &#123;</div><div class="line">        deliverToHandler(msg, holder);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    metrics.messageReceived(msg.address(), !msg.send(), isMessageLocal(msg), <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Vert.x需要从<code>handlerMap</code>中获取目标地址对应的处理函数集合<code>handlers</code>。接着，如果<code>handlers</code>不为空的话，Vert.x就会判断消息实体的<code>send</code>标志位。如果<code>send</code>标志位为<code>true</code>则代表以点对点模式发送，Vert.x就会通过<code>handlers</code>的<code>choose</code>方法(之前提到过)，按照轮询算法来获取其中的某一个<code>HandlerHolder</code>。获取到<code>HandlerHolder</code>之后，Vert.x会通过<code>deliverToHandler</code>方法将消息分发至<code>HandlerHolder</code>中进行处理；如果<code>send</code>标志位为<code>false</code>则代表向所有消费者发布消息，Vert.x就会对<code>handlers</code>中的每一个<code>HandlerHolder</code>依次调用<code>deliverToHandler</code>方法，以便将消息分发至所有注册到此地址的<code>Handler</code>中进行处理。</p>
<p>消息处理的真正逻辑就在<code>deliverToHandler</code>方法中。我们来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">deliverToHandler</span><span class="params">(MessageImpl msg, HandlerHolder&lt;T&gt; holder)</span> </span>&#123;</div><div class="line">  <span class="comment">// Each handler gets a fresh copy</span></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  Message&lt;T&gt; copied = msg.copyBeforeReceive();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (metrics.isEnabled()) &#123;</div><div class="line">    metrics.scheduleMessage(holder.getHandler().getMetric(), msg.isLocal());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  holder.getContext().runOnContext((v) -&gt; &#123;</div><div class="line">    <span class="comment">// Need to check handler is still there - the handler might have been removed after the message were sent but</span></div><div class="line">    <span class="comment">// before it was received</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!holder.isRemoved()) &#123;</div><div class="line">        holder.getHandler().handle(copied);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="keyword">if</span> (holder.isReplyHandler()) &#123;</div><div class="line">        holder.getHandler().unregister();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先<code>deliverToHandler</code>方法会复制一份要发送的消息，然后<code>deliverToHandler</code>方法会调用<code>metrics</code>的<code>scheduleMessage</code>方法记录对应的Metrics信息（计划对消息进行处理。此函数修复了<a href="https://github.com/eclipse/vert.x/issues/1480" target="_blank" rel="external">Issue 1480</a>）。接着<code>deliverToHandler</code>方法会从传入的<code>HandlerHolder</code>中获取对应的Vert.x Context，然后调用<code>runOnContext</code>方法以便可以让消息处理逻辑在Vert.x Context中执行。为防止对应的handler在处理之前被移除，这里还需要检查一下<code>holder</code>的<code>isRemoved</code>属性。如果没有移除，那么就从<code>holder</code>中获取对应的<code>handler</code>并调用其<code>handle</code>方法执行消息的处理逻辑。注意这里获取的<code>handler</code>实际上是一个<code>HandlerRegistration</code>。前面提到过<code>HandlerRegistration</code>类同时实现了<code>MessageConsumer</code>接口和<code>Handler</code>接口，因此它兼具这两个接口所期望的功能。另外，之前我们提到过Vert.x会自动注销接收过回复的reply consumer，其逻辑就在这个finally块中。Vert.x会检查<code>holder</code>中的<code>handler</code>是否为reply handler（reply consumer)，如果是的话就调用其<code>unregister</code>方法将其注销，来确保reply consumer为一次性的。</p>
<p>之前我们提到过<code>MessageConsumer</code>继承了<code>ReadStream</code>接口，因此<code>HandlerRegistration</code>需要实现flow control(back-pressure)的相关逻辑。那么如何实现呢？我们看到,<code>HandlerRegistration</code>类中有一个<code>paused</code>标志位代表是否还继续处理消息。<code>ReadStream</code>接口中定义了两个函数用于控制stream的通断：当处理速度小于读取速度(发生拥塞)的时候我们可以通过<code>pause</code>方法暂停消息的传递，将积压的消息暂存于内部的消息队列（缓冲区）<code>pending</code>中；当相对速度正常的时候，我们可以通过<code>resume</code>方法恢复消息的传递和处理。</p>
<p>我们看一下<code>HandlerRegistration</code>中<code>handle</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;T&gt; message)</span> </span>&#123;</div><div class="line">  Handler&lt;Message&lt;T&gt;&gt; theHandler;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (paused) &#123;</div><div class="line">      <span class="keyword">if</span> (pending.size() &lt; maxBufferedMessages) &#123;</div><div class="line">        pending.add(message);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (discardHandler != <span class="keyword">null</span>) &#123;</div><div class="line">          discardHandler.handle(message);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          log.warn(<span class="string">"Discarding message as more than "</span> + maxBufferedMessages + <span class="string">" buffered in paused consumer"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (pending.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">        pending.add(message);</div><div class="line">        message = pending.poll();</div><div class="line">      &#125;</div><div class="line">      theHandler = handler;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  deliver(theHandler, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然。。。<code>handle</code>方法在处理消息的基础上实现了拥塞控制的功能。为了防止资源争用，需要对自身进行加锁；首先<code>handle</code>方法会判断当前的<code>consumer</code>是否为<code>paused</code>状态，如果为<code>paused</code>状态，<code>handle</code>方法会检查当前缓冲区大小是否已经超过给定的最大缓冲区大小<code>maxBufferedMessages</code>，如果没超过，就将收到的消息push到缓冲区中；如果大于或等于阈值，Vert.x就需要丢弃超出的那部分消息。如果当前的<code>consumer</code>为正常状态，则如果缓冲区不为空，就将收到的消息push到缓冲区中并从缓冲区中pull队列首端的消息，然后调用<code>deliver</code>方法执行真正的消息处理逻辑。注意这里是在锁之外执行<code>deliver</code>方法的，这是为了保证在multithreaded worker context下可以并发传递消息（见<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=473714" target="_blank" rel="external">Bug 473714
</a>）。由于multithreaded worker context允许在不同线程并发执行逻辑（见<a href="http://vertx.io/docs/vertx-core/java/#_multi_threaded_worker_verticles" target="_blank" rel="external">官方文档</a>），如果将<code>deliver</code>方法置于<code>synchronized</code>块之内，其他线程必须等待当前锁被释放才能进行消息的传递逻辑，因而不能做到“delivery concurrently”。</p>
<p><code>deliver</code>方法是真正执行“消息处理”逻辑的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Handler&lt;Message&lt;T&gt;&gt; theHandler, Message&lt;T&gt; message)</span> </span>&#123;</div><div class="line">  checkNextTick();</div><div class="line">  <span class="keyword">boolean</span> local = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">if</span> (message <span class="keyword">instanceof</span> ClusteredMessage) &#123;</div><div class="line">    <span class="comment">// A bit hacky</span></div><div class="line">    ClusteredMessage cmsg = (ClusteredMessage)message;</div><div class="line">    <span class="keyword">if</span> (cmsg.isFromWire()) &#123;</div><div class="line">      local = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  String creditsAddress = message.headers().get(MessageProducerImpl.CREDIT_ADDRESS_HEADER_NAME);</div><div class="line">  <span class="keyword">if</span> (creditsAddress != <span class="keyword">null</span>) &#123;</div><div class="line">    eventBus.send(creditsAddress, <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    metrics.beginHandleMessage(metric, local);</div><div class="line">    theHandler.handle(message);</div><div class="line">    metrics.endHandleMessage(metric, <span class="keyword">null</span>);</div><div class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    log.error(<span class="string">"Failed to handleMessage"</span>, e);</div><div class="line">    metrics.endHandleMessage(metric, e);</div><div class="line">    <span class="keyword">throw</span> e;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先Vert.x会调用<code>checkNextTick</code>方法来检查消息队列（缓冲区）中是否存在更多的消息等待被处理，如果有的话就取出队列首端的消息并调用<code>deliver</code>方法将其传递给<code>handler</code>进行处理。这里仍需要注意并发问题，相关实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkNextTick</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!pending.isEmpty()) &#123;</div><div class="line">    handlerContext.runOnContext(v -&gt; &#123;</div><div class="line">      Message&lt;T&gt; message;</div><div class="line">      Handler&lt;Message&lt;T&gt;&gt; theHandler;</div><div class="line">      <span class="keyword">synchronized</span> (HandlerRegistration.<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (paused || (message = pending.poll()) == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        theHandler = handler;</div><div class="line">      &#125;</div><div class="line">      deliver(theHandler, message);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查完消息队列以后，Vert.x会接着根据<code>message</code>判断消息是否仅在本地进行处理并给<code>local</code>标志位赋值，<code>local</code>标志位将在记录Metrics数据时用到。</p>
<p>接下来我们看到Vert.x从消息的<code>headers</code>中获取了一个地址<code>creditsAddress</code>，如果<code>creditsAddress</code>存在就向此地址发送一条消息，body为<code>1</code>。那么这个<code>creditsAddress</code>又是啥呢？其实，它与flow control有关，我们会在下面详细分析。发送完<code>credit</code>消息以后，接下来就到了调用<code>handler</code>处理消息的时刻了。在处理消息之前需要调用<code>metrics</code>的<code>beginHandleMessage</code>方法记录消息开始处理的metrics数据，在处理完消息以后需要调用<code>endHandleMessage</code>方法记录消息处理结束的metrics数据。</p>
<p>嗯。。。到此为止，消息的发送和处理过程就已经一目了然了。下面我们讲一讲之前代码中出现的<code>creditsAddress</code>到底是啥玩意～</p>
<h1 id="MessageProducer">MessageProducer</h1><p>之前我们提到过，Vert.x定义了两个接口作为 <strong>flow control aware object</strong> 的规范：<code>WriteStream</code>以及<code>ReadStream</code>。对于<code>ReadStream</code>我们已经不再陌生了，<code>MessageConsumer</code>就继承了它；那么大家应该可以想象到，有<code>MessageConsumer</code>就必有<code>MessageProducer</code>。不错，Vert.x中的<code>MessageProducer</code>接口对应某个<code>address</code>上的消息生产者，同时它继承了<code>WriteStream</code>接口，因此<code>MessageProducer</code>的实现类<code>MessageProducerImpl</code>同样具有flow control的能力。我们可以把<code>MessageProducer</code>看做是一个具有flow control功能的增强版的<code>EventBus</code>。我们可以通过<code>EventBus</code>接口的<code>publisher</code>方法创建一个<code>MessageProducer</code>。</p>
<p>对<code>MessageProducer</code>有了初步了解之后，我们就可以解释前面<code>deliver</code>方法中的<code>creditsAddress</code>了。<code>MessageProducer</code>接口的实现类 —— <code>MessageProducerImpl</code>类的流量控制功能是基于<code>credit</code>的，其内部会维护一个<code>credit</code>值代表“发送消息的能力”，其默认值等于<code>DEFAULT_WRITE_QUEUE_MAX_SIZE</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize = DEFAULT_WRITE_QUEUE_MAX_SIZE;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> credits = DEFAULT_WRITE_QUEUE_MAX_SIZE;</div></pre></td></tr></table></figure>
<p>在采用点对点模式发送消息的时候，<code>MessageProducer</code>底层会调用<code>doSend</code>方法进行消息的发送。发送依然利用Event Bus的<code>send</code>方法，只不过<code>doSend</code>方法中添加了flow control的相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> &lt;R&gt; <span class="function"><span class="keyword">void</span> <span class="title">doSend</span><span class="params">(T data, Handler&lt;AsyncResult&lt;Message&lt;R&gt;&gt;&gt; replyHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (credits &gt; <span class="number">0</span>) &#123;</div><div class="line">    credits--;</div><div class="line">    <span class="keyword">if</span> (replyHandler == <span class="keyword">null</span>) &#123;</div><div class="line">      bus.send(address, data, options);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      bus.send(address, data, options, replyHandler);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    pending.add(data);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与<code>MessageConsumer</code>类似，<code>MessageProducer</code>内部同样保存着一个消息队列（缓冲区）用于暂存堆积的消息。当<code>credits</code>大于<strong>0</strong>的时候代表可以发送消息（没有出现拥塞），Vert.x就会调用Event Bus的<code>send</code>方法进行消息的发送，同时<code>credits</code>要减1；如果<code>credits</code>小于等于0，则代表此时消息发送的速度太快，出现了拥塞，需要暂缓发送，因此将要发送的对象暂存于缓冲区中。大家可能会问，<code>credits</code>值不断减小，那么恢复消息发送能力（增大<code>credits</code>）的逻辑在哪呢？这就要提到<code>creditsAddress</code>了。我们看一下<code>MessageProducerImpl</code>类的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageProducerImpl</span><span class="params">(Vertx vertx, String address, <span class="keyword">boolean</span> send, DeliveryOptions options)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.vertx = vertx;</div><div class="line">  <span class="keyword">this</span>.bus = vertx.eventBus();</div><div class="line">  <span class="keyword">this</span>.address = address;</div><div class="line">  <span class="keyword">this</span>.send = send;</div><div class="line">  <span class="keyword">this</span>.options = options;</div><div class="line">  <span class="keyword">if</span> (send) &#123;</div><div class="line">    String creditAddress = UUID.randomUUID().toString() + <span class="string">"-credit"</span>;</div><div class="line">    creditConsumer = bus.consumer(creditAddress, msg -&gt; &#123;</div><div class="line">      doReceiveCredit(msg.body());</div><div class="line">    &#125;);</div><div class="line">    options.addHeader(CREDIT_ADDRESS_HEADER_NAME, creditAddress);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    creditConsumer = <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MessageProducerImpl</code>的构造函数中生成了一个<code>creditAddress</code>，然后给该地址绑定了一个<code>Handler</code>，当收到消息时调用<code>doReceiveCredit</code>方法执行解除拥塞，恢复消息发送的逻辑。<code>MessageProducerImpl</code>会将此<code>MessageConsumer</code>保存，以便在关闭消息生产者流的时候将其注销。接着构造函数会往<code>options</code>的<code>headers</code>中添加一条记录，保存对应的<code>creditAddress</code>，这也就是上面我们在<code>deliver</code>函数中获取的<code>creditAddress</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 位于HandlerRegistration类的deliver函数中</span></div><div class="line">String creditsAddress = message.headers().get(MessageProducerImpl.CREDIT_ADDRESS_HEADER_NAME);</div><div class="line"><span class="keyword">if</span> (creditsAddress != <span class="keyword">null</span>) &#123;</div><div class="line">  eventBus.send(creditsAddress, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，发送消息到<code>creditsAddress</code>的逻辑也就好理解了。由于<code>deliver</code>函数的逻辑就是处理消息，因此这里向<code>creditsAddress</code>发送一个 <strong>1</strong> 其实就是将对应的<code>credits</code>值加1。恢复消息发送的逻辑位于<code>MessageProducerImpl</code>类的<code>doReceiveCredit</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doReceiveCredit</span><span class="params">(<span class="keyword">int</span> credit)</span> </span>&#123;</div><div class="line">  credits += credit;</div><div class="line">  <span class="keyword">while</span> (credits &gt; <span class="number">0</span>) &#123;</div><div class="line">    T data = pending.poll();</div><div class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      credits--;</div><div class="line">      bus.send(address, data, options);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">final</span> Handler&lt;Void&gt; theDrainHandler = drainHandler;</div><div class="line">  <span class="keyword">if</span> (theDrainHandler != <span class="keyword">null</span> &amp;&amp; credits &gt;= maxSize / <span class="number">2</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.drainHandler = <span class="keyword">null</span>;</div><div class="line">    vertx.runOnContext(v -&gt; theDrainHandler.handle(<span class="keyword">null</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑一目了然。首先给<code>credits</code>加上发送过来的值（正常情况下为1），然后恢复发送能力，将缓冲区的数据依次取出、发送然后减小<code>credits</code>。同时如果<code>MessageProducer</code>绑定了<code>drainHandler</code>(消息流不拥塞的时候调用的逻辑，详见<a href="http://vertx.io/docs/vertx-core/java/#_writestream" target="_blank" rel="external">官方文档</a>)，并且<code>MessageProducer</code>发送的消息不再拥塞（<code>credits &gt;= maxSize / 2</code>），那么就在Vert.x Context中执行<code>drainHandler</code>中的逻辑。</p>
<p>怎么样，体会到Vert.x中flow control的强大之处了吧！官方文档中<code>MessageProducer</code>的篇幅几乎没有，只在介绍<code>WriteStream</code>的时候提了提，因此这部分也可以作为<code>MessageProducer</code>的参考。</p>
<h1 id="reply">reply</h1><p>最后就是消息的回复逻辑 —— <code>reply</code>方法了。<code>reply</code>方法的实现位于<code>MessageImpl</code>类中，最终调用的是<code>reply(Object, DeliveryOptions, Handler&lt;AsyncResult&lt;Message&lt;R&gt;&gt;&gt;)</code>这个版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function"><span class="keyword">void</span> <span class="title">reply</span><span class="params">(Object message, DeliveryOptions options, Handler&lt;AsyncResult&lt;Message&lt;R&gt;&gt;&gt; replyHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (replyAddress != <span class="keyword">null</span>) &#123;</div><div class="line">    sendReply(bus.createMessage(<span class="keyword">true</span>, replyAddress, options.getHeaders(), message, options.getCodecName()), options, replyHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里<code>reply</code>方法同样调用<code>EventBus</code>的<code>createMessage</code>方法创建要回复的消息实体，传入的<code>replyAddress</code>即为之前讲过的生成的非常简单的回复地址。然后再将消息实体、配置以及对应的<code>replyHandler</code>（如果有的话）传入<code>sendReply</code>方法进行消息的回复。最后其实是调用了Event Bus中的四个参数的<code>sendReply</code>方法，它的逻辑与之前讲过的<code>sendOrPubInternal</code>非常相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendReply</span><span class="params">(MessageImpl replyMessage, MessageImpl replierMessage, DeliveryOptions options,</span></span></div><div class="line">                             Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler) &#123;</div><div class="line">  <span class="keyword">if</span> (replyMessage.address() == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"address not specified"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    HandlerRegistration&lt;T&gt; replyHandlerRegistration = createReplyHandlerRegistration(replyMessage, options, replyHandler);</div><div class="line">    <span class="keyword">new</span> ReplySendContextImpl&lt;&gt;(replyMessage, options, replyHandlerRegistration, replierMessage).next();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数中<code>replyMessage</code>代表回复消息实体，<code>replierMessage</code>则代表回复者自身的消息实体(sender)。</p>
<p>如果地址为空则抛出异常；如果地址不为空，则先调用<code>createReplyHandlerRegistration</code>方法创建对应的<code>replyHandlerRegistration</code>。<code>createReplyHandlerRegistration</code>方法的实现之前已经讲过了。注意这里的<code>createReplyHandlerRegistration</code>其实对应的是此replier的回复，因为Vert.x中的 <strong>Request-Response</strong> 消息模型不限制相互回复（通信）的次数。当然如果没有指定此replier的回复的<code>replyHandler</code>，那么此处的<code>replyHandlerRegistration</code>就为空。最后<code>sendReply</code>方法会创建一个<code>ReplySendContextImpl</code>并调用其<code>next</code>方法。</p>
<p><code>ReplySendContextImpl</code>类同样是<code>SendContext</code>接口的一个实现（继承了<code>SendContextImpl</code>类）。<code>ReplySendContextImpl</code>比起其父类就多保存了一个<code>replierMessage</code>。<code>next</code>方法的逻辑与父类逻辑非常相似，只不过将回复的逻辑替换成了另一个版本的<code>sendReply</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (iter.hasNext()) &#123;</div><div class="line">    Handler&lt;SendContext&gt; handler = iter.next();</div><div class="line">    handler.handle(<span class="keyword">this</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    sendReply(<span class="keyword">this</span>, replierMessage);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而。。。<code>sendReply</code>方法并没有用到传入的<code>replierMessage</code>，所以这里最终还是调用了<code>sendOrPub</code>方法（尼玛，封装的<code>ReplySendContextImpl</code>貌似并没有什么卵用，可能为以后的扩展考虑？）。。。之后的逻辑我们都已经分析过了。</p>
<p>这里再强调一点。当我们发送消息同时指定<code>replyHandler</code>的时候，其内部为reply创建的reply consumer(类型为<code>HandlerRegistration</code>)指定了<code>timeout</code>。这个定时器从<code>HandlerRegistration</code>创建的时候就开始计时了。我们回顾一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (timeout != -<span class="number">1</span>) &#123;</div><div class="line">  timeoutID = vertx.setTimer(timeout, tid -&gt; &#123;</div><div class="line">    metrics.replyFailure(address, ReplyFailure.TIMEOUT);</div><div class="line">    sendAsyncResultFailure(ReplyFailure.TIMEOUT, <span class="string">"Timed out after waiting "</span> + timeout + <span class="string">"(ms) for a reply. address: "</span> + address);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计时器会在超时的时候记录错误并强制注销当前consumer。由于reply consumer是<strong>一次性的</strong>，当收到reply的时候，Vert.x会自动对reply consumer调用<code>unregister</code>方法对其进行注销（实现位于<code>EventBusImpl#deliverToHandler</code>方法中），而在注销逻辑中会关闭定时器（参见前面对<code>doUnregister</code>方法的解析）；如果超时，那么计时器就会触发，Vert.x会调用<code>sendAsyncResultFailure</code>方法注销当前reply consumer并处理错误。</p>
<h1 id="synchronized的性能问题">synchronized的性能问题</h1><p>大家可能看到为了防止race condition，Vert.x底层大量使用了<code>synchronized</code>关键字（重量级锁）。这会不会影响性能呢？其实，如果开发者遵循Vert.x的线程模型和开发规范（使用Verticle）的话，有些地方的<code>synchronized</code>对应的锁会被优化为 <strong>偏向锁</strong> 或 <strong>轻量级锁</strong>（因为通常都是同一个Event Loop线程获取对应的锁），这样性能总体开销不会太大。当然如果使用Multi-threaded worker verticles就要格外关注性能问题了。。。</p>
<h1 id="总结">总结</h1><p>我们来简略地总结一下Event Bus的工作原理。当我们调用<code>consumer</code>绑定一个<code>MessageConsumer</code>时，Vert.x会将它保存至Event Bus实例内部的Map中；当我们通过<code>send</code>或<code>publish</code>向对应的地址发送消息的时候，Vert.x会遍历Event Bus中存储consumer的Map，获取与地址相对应的consumer集合，然后根据相应的策略传递并处理消息(<code>send</code>通过轮询策略获取任意一个consumer并将消息传递至consumer中，<code>publish</code>则会将消息传递至所有注册到对应地址的consumer中)。同时，<code>MessageConsumer</code>和<code>MessageProducer</code>这两个接口的实现都具有flow control功能，因此它们也可以用在<code>Pump</code>中。</p>
<p>Event Bus是Vert.x中最为重要的一部分之一，探索Event Bus的源码可以加深我们对Event Bus工作原理的理解。作为开发者，只会使用框架是不够的，能够理解内部的实现原理和精华，并对其进行改进才是更为重要的。本篇文章分析的是Local模式下的Event Bus，下篇文章我们将来探索一下生产环境中更常用的 <strong>Clustered Event Bus</strong> 的实现原理，敬请期待！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最近真忙～]]></title>
      <url>http://www.sczyh30.com/posts/Life/busy-enough-2016-08/</url>
      <content type="html"><![CDATA[<p>最近越来越忙了，要忙各种项目，Blog都没空更了。。。等着抽空更新一波之前没发的文章。。。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/CoYX-A0XEAEYpu9.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vert.x Blueprint 系列教程(三) | Micro Shop 微服务实战]]></title>
      <url>http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/</url>
      <content type="html"><![CDATA[<p>Vert.x 蓝图项目已经发布至Vert.x官方网站：<a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x Blueprint Tutorials</a></p>
<hr>
<p><strong>Vert.x 蓝图系列</strong> 的第三篇教程出炉咯！这篇教程是微服务实战相关的主题。篇幅较长，team给了模板用于渲染对应的文档，因此这里就直接放链接了：</p>
<ul>
<li><a href="http://sczyh30.github.io/vertx-blueprint-microservice/cn/index.html" target="_blank" rel="external">Vert.x 蓝图 - Micro Shop 微服务实战 (开发篇)</a></li>
<li><a href="http://sczyh30.github.io/vertx-blueprint-microservice/cn/api-gateway.html" target="_blank" rel="external">Vert.x 蓝图 - Micro Shop 微服务实战 (API Gateway)</a></li>
</ul>
<p>对应的GitHub Repository:  <a href="https://github.com/sczyh30/vertx-blueprint-microservice" target="_blank" rel="external">sczyh30/vertx-blueprint-microservice</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vert.x Blueprint 系列教程(二) | Vert.x Kue 教程（Web部分）]]></title>
      <url>http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/</url>
      <content type="html"><![CDATA[<p><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">上部分蓝图教程</a>中我们一起探索了如何用Vert.x开发一个基于消息的应用。在这部分教程中，我们将粗略地探索一下<code>kue-http</code>模块的实现。</p>
<h1 id="Vert-x_Kue_REST_API">Vert.x Kue REST API</h1><p><code>kue-http</code>模块中只有一个类<code>KueHttpVerticle</code>，作为整个REST API以及UI服务的实现。对REST API部分来说，如果看过我们之前的 <a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x 蓝图 | 待办事项服务开发教程</a> 的话，你应该对这一部分非常熟悉了，因此这里我们就不详细解释了。有关使用Vert.x Web实现REST API的教程可参考 <a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x 蓝图 | 待办事项服务开发教程</a>。</p>
<h1 id="将Kue_UI与Vert-x_Web进行适配">将Kue UI与Vert.x Web进行适配</h1><p>除了REST API之外，我们还给Vert.x Kue提供了一个用户界面。我们复用了Automattic/Kue的用户界面所以我们就不用写前端代码了（部分API有变动的地方我已进行了修改）。我们只需要将前端代码与Vert.x Web适配即可。</p>
<p>首先，前端的代码都属于静态资源，因此我们需要配置路由来允许访问静态资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">router.route().handler(StaticHandler.create(root));</div></pre></td></tr></table></figure>
<p>这样我们就可以直接访问静态资源咯～</p>
<p>注意到Kue UI使用了<strong>Jade</strong>（最近貌似改名叫Pug了）作为模板引擎，因此我们需要一个Jade模板解析器。好在Vert.x Web提供了一个Jade模板解析的实现: <code>io.vertx:vertx-web-templ-jade</code>，所以我们可以利用这个实现来渲染UI。首先在类中定义一个<code>JadeTemplateEngine</code>并在<code>start</code>方法中初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">engine = JadeTemplateEngine.create();</div></pre></td></tr></table></figure>
<p>然后我们就可以写一个处理器方法来根据不同的任务状态来渲染UI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(RoutingContext context, String state)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String uiPath = <span class="string">"webroot/views/job/list.jade"</span>; <span class="comment">// (1)</span></div><div class="line">  String title = config().getString(<span class="string">"kue.ui.title"</span>, <span class="string">"Vert.x Kue"</span>);</div><div class="line">  kue.getAllTypes()</div><div class="line">    .setHandler(resultHandler(context, r -&gt; &#123;</div><div class="line">      context.put(<span class="string">"state"</span>, state) <span class="comment">// (2)</span></div><div class="line">        .put(<span class="string">"types"</span>, r)</div><div class="line">        .put(<span class="string">"title"</span>, title);</div><div class="line">      engine.render(context, uiPath, res -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">        <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">          context.response()</div><div class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>) <span class="comment">// (4)</span></div><div class="line">            .end(res.result());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          context.fail(res.cause());</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们需要给渲染引擎指定我们前端代码的地址 (1)。然后我们从Redis中获取其中所有的任务类型，然后向解析器context中添加任务状态、网页标题、任务类型等信息供渲染器渲染使用 (2)。接着我们就可以调用<code>engine.render(context, path, handler)</code>方法进行渲染 (3)。如果渲染成功，我们将页面写入HTTP Response (4)。</p>
<p>现在我们可以利用<code>render</code>方法去实现其它的路由函数了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUIActive</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  render(context, <span class="string">"active"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们给它绑个路由就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">router.route(KUE_UI_ACTIVE).handler(<span class="keyword">this</span>::handleUIActive);</div></pre></td></tr></table></figure>
<p>是不是非常方便呢？不仅如此，Vert.x Web还提供了其它各种模板引擎的支持，比如 <em>FreeMaker</em>, <em>Pebble</em> 以及 <em>Thymeleaf 3</em>。如果感兴趣的话，你可以查阅<a href="http://vertx.io/docs/vertx-web/java/#_templates" target="_blank" rel="external">官方文档</a>来获取详细的使用指南。</p>
<h1 id="展示时间！">展示时间！</h1><p>是不是等不及要看UI长啥样了？现在我们就来展示一下！首先构建项目：</p>
<pre><code><span class="title">gradle</span> build
</code></pre><p><code>kue-http</code>需要<code>kue-core</code>运行着（因为<code>kue-core</code>里注册了Event Bus服务），因此我们先运行<code>kue-core</code>，再运行<code>kue-http</code>。不要忘记运行Redis:</p>
<pre><code>redis-server
java -jar kue-core/build/libs/vertx-blueprint-kue-core<span class="class">.jar</span> -cluster -ha -conf config/config<span class="class">.json</span>
java -jar kue-http/build/libs/vertx-blueprint-kue-http<span class="class">.jar</span> -cluster -ha -conf config/config.json
</code></pre><p>为了更好地观察任务处理的流程，我们再运行一个示例：</p>
<pre><code>java -jar kue-example<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-example.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>好啦！现在在浏览器中访问<code>http://localhost:8080</code>，我们的Kue UI就呈现在我们眼前啦！</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/vertx_kue_ui_1.png" alt="Vert.x Kue UI"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）]]></title>
      <url>http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/</url>
      <content type="html"><![CDATA[<p>本文章是 <strong>Vert.x 蓝图系列</strong> 的第二篇教程。全系列：</p>
<ul>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</a></li>
<li>Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程</li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践</a></li>
</ul>
<h1 id="前言">前言</h1><p>欢迎回到Vert.x 蓝图系列～在本教程中，我们将利用Vert.x开发一个基于消息的应用 - Vert.x Kue，它是一个使用Vert.x开发的优先级工作队列，数据存储使用的是 <em>Redis</em> 。Vert.x Kue是<a href="https://github.com/Automattic/kue" target="_blank" rel="external">Automattic/kue</a>的Vert.x实现版本。我们可以使用Vert.x Kue来处理各种各样的任务，比如文件转换、订单处理等等。</p>
<p>通过本教程，你将会学习到以下内容：</p>
<ul>
<li>消息、消息系统以及事件驱动的运用</li>
<li>Vert.x <strong>Event Bus</strong> 的几种事件机制（发布/订阅、点对点模式）</li>
<li>设计 <strong>分布式</strong> 的Vert.x应用</li>
<li>工作队列的设计</li>
<li><strong>Vert.x Service Proxy</strong>（服务代理）的运用</li>
<li>更深层次的Redis运用</li>
</ul>
<p>本教程是 <a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x 蓝图系列</a> 的第二篇教程，对应的Vert.x版本为 <strong>3.3.3</strong> 。本教程中的完整代码已托管至<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/tree/master" target="_blank" rel="external">GitHub</a>。</p>
<h1 id="Vert-x的消息系统">Vert.x的消息系统</h1><p>既然我们要用Vert.x开发一个基于消息的应用，那么我们先来瞅一瞅Vert.x的消息系统吧～在Vert.x中，我们可以通过 <strong>Event Bus</strong> 来发送和接收各种各样的消息，这些消息可以来自不同的<code>Vertx</code>实例。怎么样，很酷吧？我们都将消息发送至Event Bus上的某个<strong>地址</strong>上，这个地址可以是任意的字符串。</p>
<p>Event Bus支持三种消息机制：<strong>发布/订阅</strong>(Publish/Subscribe)、<strong>点对点</strong>(Point to point)以及<strong>请求/回应</strong>(Request-Response)模式。下面我们就来看一看这几种机制。</p>
<h2 id="发布/订阅模式">发布/订阅模式</h2><p>在<strong>发布/订阅模式</strong>中，消息被发布到Event Bus的某一个地址上，所有订阅此地址的<code>Handler</code>都会接收到该消息并且调用相应的处理逻辑。我们来看一看示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">EventBus eventBus = vertx.eventBus();</div><div class="line"></div><div class="line">eventBus.consumer(<span class="string">"foo.bar.baz"</span>, r -&gt; &#123; <span class="comment">// subscribe to `foo.bar.baz` address</span></div><div class="line">  System.out.println(<span class="string">"1: "</span> + r.body());</div><div class="line">&#125;);</div><div class="line">eventBus.consumer(<span class="string">"foo.bar.baz"</span>, r -&gt; &#123; <span class="comment">// subscribe to `foo.bar.baz` address</span></div><div class="line">  System.out.println(<span class="string">"2: "</span> + r.body());</div><div class="line">&#125;);</div><div class="line"></div><div class="line">eventBus.publish(<span class="string">"foo.bar.baz"</span>, <span class="string">"+1s"</span>); <span class="comment">// 向此地址发送消息</span></div></pre></td></tr></table></figure>
<p>我们可以通过<code>vertx.eventBus()</code>方法获取<code>EventBus</code>的引用，然后我们就可以通过<code>consume</code>方法订阅某个地址的消息并且绑定一个<code>Handler</code>。接着我们通过<code>publish</code>向此地址发送消息。如果运行上面的例子，我们会得到一下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2: +1s</div><div class="line">1: +1s</div></pre></td></tr></table></figure>
<h2 id="点对点模式">点对点模式</h2><p>如果我们把上面的示例中的<code>publish</code>方法替代成<code>send</code>方法，上面的实例就变成<strong>点对点模式</strong>了。在点对点模式中，消息被发布到Event Bus的某一个地址上。Vert.x会将此消息传递给其中监听此地址的<code>Handler</code>之一。如果有多个<code>Handler</code>绑定到此地址，那么就使用轮询算法随机挑一个<code>Handler</code>传递消息。比如在此示例中，程序只会打印<code>2: +1s</code>或者<code>1: +1s</code>之中的一个。</p>
<h2 id="请求/回应模式">请求/回应模式</h2><p>当我们绑定的<code>Handler</code>接收到消息的时候，我们可不可以给消息的发送者回复呢？当然了！当我们通过<code>send</code>方法发送消息的时候，我们可以同时指定一个回复处理函数(reply handler)。然后当某个消息的订阅者接收到消息的时候，它就可以给发送者回复消息；如果发送者接收到了回复，发送者绑定的回复处理函数就会被调用。这就是<strong>请求/回应模式</strong>。</p>
<p>好啦，现在我们已经粗略了解了Vert.x中的消息系统 - Event Bus的基本使用，下面我们就看看Vert.x Kue的基本设计。有关更多关于Event Bus的信息请参考<a href="http://vertx.io/docs/vertx-core/java/#event_bus" target="_blank" rel="external">Vert.x Core Manual - Event Bus</a>。</p>
<h1 id="Vert-x_Kue_架构设计">Vert.x Kue 架构设计</h1><h2 id="Vert-x_Kue_组件划分">Vert.x Kue 组件划分</h2><p>在我们的项目中，我们将Vert.x Kue划分为两个模块：</p>
<ul>
<li><code>kue-core</code>: 核心组件，提供优先级队列的功能</li>
<li><code>kue-http</code>: Web组件，提供Web UI以及REST API</li>
</ul>
<p>另外我们还提供一个示例模块<code>kue-example</code>用于演示以及阐述如何使用Vert.x Kue。</p>
<p>既然我们的项目有两个模块，那么你一定会好奇：两个模块之间是如何进行通信的？并且如果我们写自己的Kue应用的话，我们该怎样去调用Kue Core中的服务呢？不要着急，谜底将在后边的章节中揭晓:-)</p>
<h2 id="Vert-x_Kue_核心模块">Vert.x Kue 核心模块</h2><p>回顾一下Vert.x Kue的作用 - 优先级工作队列，所以在Vert.x Kue的核心模块中我们设计了以下的类：</p>
<ul>
<li><code>Job</code> - 任务（作业）数据实体</li>
<li><code>JobService</code> - 异步服务接口，提供操作任务以及获取数据的相关逻辑</li>
<li><code>KueWorker</code> - 用于处理任务的Verticle</li>
<li><code>Kue</code> - 工作队列</li>
</ul>
<p>前边我们提到过，我们的两个组件之间需要一种通信机制可以互相通信 - 这里我们使用Vert.x的<strong>集群模式</strong>，即以clustered的模式来部署Verticle。这样的环境下的Event Bus同样也是集群模式的，因此各个组件可以通过集群模式下的Event Bus进行通信。很不错吧？在Vert.x的集群模式下，我们需要指定一个集群管理器<code>ClusterManager</code>。这里我们使用默认的<code>HazelcastClusterManager</code>，使用<strong>Hazelcast</strong>作为集群管理。</p>
<p>在Vert.x Kue中，我们将<code>JobService</code>服务发布至分布式的Event Bus上，这样其它的组件就可以通过Event Bus调用该服务了。我们设计了一个<code>KueVerticle</code>用于注册服务。Vert.x提供了Vert.x Service Proxy（服务代理组件），可以很方便地将服务注册至Event Bus上，然后在其它地方获取此服务的代理并调用。我们将在下面的章节中详细介绍<strong>Vert.x Service Proxy</strong>。</p>
<h2 id="基于Future的异步模式">基于Future的异步模式</h2><p>在我们的Vert.x Kue中，大多数的异步方法都是基于<code>Future</code>的。如果您看过蓝图系列的第一篇文章的话，您一定不会对这种模式很陌生。在Vert.x 3.3.2中，我们的<code>Future</code>支持基本的响应式的操作，比如<code>map</code>和<code>compose</code>。它们用起来非常方便，因为我们可以将多个<code>Future</code>以响应式的方式组合起来而不用担心陷入回调地狱中。</p>
<h2 id="Vert-x_Kue中的事件">Vert.x Kue中的事件</h2><p>正如我们在<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">Vert.x Kue 特性介绍</a>中提到的那样，Vert.x Kue支持两种级别的事件：<strong>任务事件(job events)</strong> 以及 <strong>队列事件(queue events)</strong>。在Vert.x Kue中，我们设计了三种事件地址：</p>
<ul>
<li><code>vertx.kue.handler.job.{handlerType}.{addressId}.{jobType}</code>: 某个特定任务的任务事件地址</li>
<li><code>vertx.kue.handler.workers.{eventType}</code>: （全局）队列事件地址</li>
<li><code>vertx.kue.handler.workers.{eventType}.{addressId}</code>: 某个特定任务的内部事件地址</li>
</ul>
<p>在<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">特性介绍文档</a>中，我们提到了以下几种任务事件：</p>
<ul>
<li><code>start</code> 开始处理一个任务 (<code>onStart</code>)</li>
<li><code>promotion</code> 一个延期的任务时间已到，提升至工作队列中 (<code>onPromotion</code>)</li>
<li><code>progress</code> 任务的进度变化 (<code>onProgress</code>)</li>
<li><code>failed_attempt</code> 任务处理失败，但是还可以重试 (<code>onFailureAttempt</code>)</li>
<li><code>failed</code> 任务处理失败并且不能重试 (<code>onFailure</code>)</li>
<li><code>complete</code> 任务完成 (<code>onComplete</code>)</li>
<li><code>remove</code> 任务从后端存储中移除 (<code>onRemove</code>)</li>
</ul>
<p>队列事件也相似，只不过需要加前缀<code>job_</code>。这些事件都会通过<code>send</code>方法发送至Event Bus上。每一个任务都有对应的任务事件地址，因此它们能够正确地接收到对应的事件并进行相应的处理逻辑。</p>
<p>特别地，我们还有两个内部事件：<code>done</code>和<code>done_fail</code>。<code>done</code>事件对应一个任务在底层的处理已经完成，而<code>done_fail</code>事件对应一个任务在底层的处理失败。这两个事件使用第三种地址进行传递。</p>
<h2 id="任务状态">任务状态</h2><p>在Vert.x Kue中，任务共有五种状态：</p>
<ul>
<li><code>INACTIVE</code>: 任务还未开始处理，在工作队列中等待处理</li>
<li><code>ACTIVE</code>: 任务正在处理中</li>
<li><code>COMPLETE</code>: 任务处理完成</li>
<li><code>FAILED</code>: 任务处理失败</li>
<li><code>DELAYED</code>: 任务延时处理，正在等待计时器时间到并提升至工作队列中</li>
</ul>
<p>我们使用状态图来描述任务状态的变化：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/job_state_machine.png" alt="Job State Machine"></p>
<p>以及任务状态的变化伴随的事件：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/event_emit_state_machine.png" alt="Events with state change"></p>
<h2 id="整体设计">整体设计</h2><p>为了让大家对Vert.x Kue的架构有大致的了解，我用一幅图来简略描述整个Vert.x Kue的设计：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_diagram.png" alt="Diagram - How Vert.x Kue works"></p>
<p>现在我们对Vert.x Kue的设计有了大致的了解了，下面我们就来看一看Vert.x Kue的代码实现了～</p>
<h1 id="项目结构">项目结构</h1><p>我们来开始探索Vert.x Kue的旅程吧！首先我们先从GitHub上clone源代码：</p>
<pre><code>git clone <span class="string">https:</span><span class="comment">//github.com/sczyh30/vertx-blueprint-job-queue.git</span>
</code></pre><p>然后你可以把项目作为Gradle项目导入你的IDE中。（如何导入请参考相关IDE帮助文档）</p>
<p>正如我们之前所提到的，我们的Vert.x Kue中有两个功能模块和一个实例模块，因此我们需要在Gradle工程文件中定义三个子工程。我们来看一下本项目中的<code>build.gradle</code>文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">configure(<span class="keyword">allprojects</span>) &#123; <span class="keyword">project</span> -&gt;</div><div class="line"></div><div class="line">  ext &#123;</div><div class="line">    vertxVersion = <span class="string">"3.3.2"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  apply plugin: <span class="string">'java'</span></div><div class="line"></div><div class="line">  <span class="keyword">repositories</span> &#123;</div><div class="line">    jcenter()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-core:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-codegen:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-rx-java:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-hazelcast:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-lang-ruby:$&#123;vertxVersion&#125;"</span>)</div><div class="line"></div><div class="line">    testCompile(<span class="string">"io.vertx:vertx-unit:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    testCompile <span class="keyword">group</span>: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.12'</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">sourceSets</span> &#123;</div><div class="line">    main &#123;</div><div class="line">      java &#123;</div><div class="line">        srcDirs += <span class="string">'src/main/generated'</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  compileJava &#123;</div><div class="line">    <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">    <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">project</span>(<span class="string">"kue-core"</span>) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-redis-client:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-service-proxy:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jar &#123;</div><div class="line">    archiveName = <span class="string">'vertx-blueprint-kue-core.jar'</span></div><div class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">    manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.queue.KueVerticle'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123; <span class="comment">// codegen</span></div><div class="line">    <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">    <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span></div><div class="line">    <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">    <span class="keyword">options</span>.compilerArgs = [</div><div class="line">      <span class="string">"-proc:only"</span>,</div><div class="line">      <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</div><div class="line">      <span class="string">"-AoutputDirectory=$&#123;project.projectDir&#125;/src/main"</span></div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  compileJava &#123;</div><div class="line">    <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">    <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line"></div><div class="line">    dependsOn annotationProcessing</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">project</span>(<span class="string">"kue-http"</span>) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web:$&#123;vertxVersion&#125;"</span>)</div><div class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web-templ-jade:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jar &#123;</div><div class="line">    archiveName = <span class="string">'vertx-blueprint-kue-http.jar'</span></div><div class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">    manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.http.KueHttpVerticle'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">project</span>(<span class="string">"kue-example"</span>) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jar &#123;</div><div class="line">    archiveName = <span class="string">'vertx-blueprint-kue-example.jar'</span></div><div class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">    manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.example.LearningVertxVerticle'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">task</span> wrapper(type: Wrapper) &#123;</div><div class="line">  gradleVersion = <span class="string">'2.12'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(⊙o⊙)…比之前的待办事项服务项目中的长不少诶。。。我们来解释一下：</p>
<ul>
<li>在<code>configure(allprojects)</code>作用域中，我们配置了一些全局信息（对所有子工程都适用）。</li>
<li>我们定义了三个子工程：<code>kue-core</code>、<code>kue-http</code>以及<code>kue-example</code>。这里我们来解释一下里面用到的依赖。在<code>kue-core</code>中，<code>vertx-redis-client</code>用于Redis通信，<code>vertx-service-proxy</code>用于Event Bus上的服务代理。在<code>kue-http</code>中，我们将<code>kue-core</code>子工程作为它的一个依赖。<code>vertx-web</code>和<code>vertx-web-templ-jade</code>用于Kue Web端的开发。</li>
<li>任务<code>annotationProcessing</code>用于注解处理（Vert.x Codegen）。我们已经在上一篇教程中介绍过了，这里就不展开讲了。</li>
</ul>
<p>我们还需要在 <code>settings.gradle</code> 中配置工程：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rootProject.name = <span class="string">'vertx-blueprint-job-queue'</span></div><div class="line"></div><div class="line"><span class="keyword">include</span> <span class="string">"kue-core"</span></div><div class="line"><span class="keyword">include</span> <span class="string">"kue-http"</span></div><div class="line"><span class="keyword">include</span> <span class="string">"kue-example"</span></div></pre></td></tr></table></figure>
<p>看完了配置文件以后，我们再来浏览一下我们的项目目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── build.gradle</div><div class="line">├── kue-core</div><div class="line">│   └── src</div><div class="line">│       ├── main</div><div class="line">│       │   ├── java</div><div class="line">│       │   └── resources</div><div class="line">│       └── test</div><div class="line">│           ├── java</div><div class="line">│           └── resources</div><div class="line">├── kue-example</div><div class="line">│   └── src</div><div class="line">│       ├── main</div><div class="line">│       │   ├── java</div><div class="line">│       │   └── resources</div><div class="line">│       └── test</div><div class="line">│           ├── java</div><div class="line">│           └── resources</div><div class="line">├── kue-http</div><div class="line">│   └── src</div><div class="line">│       ├── main</div><div class="line">│       │   ├── java</div><div class="line">│       │   └── resources</div><div class="line">│       └── test</div><div class="line">│           ├── java</div><div class="line">│           └── resources</div><div class="line">└── settings.gradle</div></pre></td></tr></table></figure>
<p>在Gradle中，项目的源码都位于<code>{projectName}/src/main/java</code>目录内。这篇教程是围绕Vert.x Kue Core的，所以我们的代码都在<code>kue-core</code>目录中。</p>
<p>好啦！现在我们已经对Vert.x Kue项目的整体结构有了大致的了解了，下面我们开始源码探索之旅！</p>
<h1 id="任务实体_-_不仅仅是一个数据对象">任务实体 - 不仅仅是一个数据对象</h1><p>Vert.x Kue是用来处理任务的，因此我们先来看一下代表任务实体的<code>Job</code>类。<code>Job</code>类位于<code>io.vertx.blueprint.kue.queue</code>包下。代码可能有点长，不要担心，我们把它分成几部分，分别来解析。</p>
<h2 id="任务成员属性">任务成员属性</h2><p>我们先来看一下<code>Job</code>类中的成员属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@DataObject</span>(generateConverter = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    <span class="comment">// job properties</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address_id;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> String zid;</div><div class="line">    <span class="keyword">private</span> String type;</div><div class="line">    <span class="keyword">private</span> JsonObject data;</div><div class="line">    <span class="keyword">private</span> Priority priority = Priority.NORMAL;</div><div class="line">    <span class="keyword">private</span> JobState state = JobState.INACTIVE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delay = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max_attempts = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> removeOnComplete = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ttl = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> JsonObject backoff;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> attempts = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> progress = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> JsonObject result;</div><div class="line"></div><div class="line">    <span class="comment">// job metrics</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> created_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> promote_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> updated_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> failed_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> started_at;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> duration;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我去。。。好多属性！我们一个一个地解释：</p>
<ul>
<li><code>address_id</code>: 一个UUID序列，作为Event Bus的地址</li>
<li><code>id</code>: 任务的编号(id)</li>
<li><code>type</code>: 任务的类型</li>
<li><code>data</code>: 任务携带的数据，以 <code>JsonObject</code> 类型表示</li>
<li><code>priority</code>: 任务优先级，以 <code>Priority</code> 枚举类型表示。默认优先级为正常(<code>NORMAL</code>)</li>
<li><code>delay</code>: 任务的延迟时间，默认是 <strong>0</strong></li>
<li><code>state</code>: 任务状态，以 <code>JobState</code> 枚举类型表示。默认状态为等待(<code>INACTIVE</code>)</li>
<li><code>attempts</code>: 任务已经尝试执行的次数</li>
<li><code>max_attempts</code>: 任务尝试执行次数的最大阈值</li>
<li><code>removeOnComplete</code>: 代表任务完成时是否自动从后台移除</li>
<li><code>zid</code>: <code>zset</code>操作对应的编号(zid)，保持先进先出顺序</li>
<li><code>ttl</code>: TTL(Time to live)</li>
<li><code>backoff</code>: 任务重试配置，以 <code>JsonObject</code> 类型表示</li>
<li><code>progress</code>: 任务执行的进度</li>
<li><code>result</code>: 任务执行的结果，以 <code>JsonObject</code> 类型表示</li>
</ul>
<p>还有这些统计数据：</p>
<ul>
<li><code>created_at</code>: 代表此任务创建的时间</li>
<li><code>promote_at</code>: 代表此任务从延时状态被提升至等待状态时的时间</li>
<li><code>updated_at</code>: 代表任务更新的时间</li>
<li><code>failed_at</code>: 代表任务失败的时间</li>
<li><code>started_at</code>: 代表任务开始的时间</li>
<li><code>duration</code>: 代表处理任务花费的时间，单位为毫秒(<code>ms</code>)</li>
</ul>
<p>你可能注意到在 <code>Job</code> 类中还存在着几个静态成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Job.class);</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vertx vertx;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisClient client;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> EventBus eventBus;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setVertx</span><span class="params">(Vertx v, RedisClient redisClient)</span> </span>&#123;</div><div class="line">  vertx = v;</div><div class="line">  client = redisClient;</div><div class="line">  eventBus = vertx.eventBus();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 <code>logger</code> 对象，我想大家应该都很熟悉，它代表一个Vert.x Logger实例用于日志记录。但是你一定想问为什么 <code>Job</code> 类中存在着一个<code>Vertx</code>类型的静态成员。<code>Job</code>类不应该是一个数据对象吗？当然咯！<code>Job</code>类代表一个数据对象，但<strong>不仅仅</strong>是一个数据对象。这里我模仿了一些Automattic/kue的风格，把一些任务相关逻辑方法放到了<code>Job</code>类里，它们大多都是基于<code>Future</code>的异步方法，因此可以很方便地去调用以及进行组合变换。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">job.save()</div><div class="line">    .compose(Job::updateNow)</div><div class="line">    .compose(j -&gt; j.log(<span class="string">"good!"</span>));</div></pre></td></tr></table></figure>
<p>由于我们不能在<code>Job</code>类被JVM加载的时候就获取<code>Vertx</code>实例，我们必须手动给<code>Job</code>类中的静态<code>Vertx</code>成员赋值。这里我们是在<code>Kue</code>类中对其进行赋值的。当我们创建一个工作队列的时候，<code>Job</code>类中的静态成员变量会被初始化。同时为了保证程序的正确性，我们需要一个方法来检测静态成员变量是否初始化。当我们在创建一个任务的时候，如果静态成员此时未被初始化，那么日志会给出警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">_checkStatic</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (vertx == <span class="keyword">null</span>) &#123;</div><div class="line">    logger.warn(<span class="string">"static Vertx instance in Job class is not initialized!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还注意到 <code>Job</code> 类也是由<code>@DataObject</code>注解修饰的。Vert.x Codegen可以处理含有<code>@DataObject</code>注解的类并生成对应的JSON转换器，并且Vert.x Service Proxy也需要数据对象。</p>
<p>在<code>Job</code>类中我们有四个构造函数。其中<code>address_id</code>成员必须在一个任务被创建时就被赋值，默认情况下此地址用一个唯一的UUID字符串表示。每一个构造函数中我们都要调用<code>_checkStatic</code>函数来检测静态成员变量是否被初始化。</p>
<h2 id="任务事件辅助函数">任务事件辅助函数</h2><p>正如我们之前所提到的那样，我们通过一个特定的地址<code>vertx.kue.handler.job.{handlerType}.{addressId}.{jobType}</code>在分布式的Event Bus上发送和接收任务事件(job events)。所以我们提供了两个用于发送和接收事件的辅助函数<code>emit</code>和<code>on</code>(类似于Node.js中的<code>EventEmitter</code>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Job <span class="title">on</span><span class="params">(String event, Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</div><div class="line">  logger.debug(<span class="string">"[LOG] On: "</span> + Kue.getCertainJobAddress(event, <span class="keyword">this</span>));</div><div class="line">  eventBus.consumer(Kue.getCertainJobAddress(event, <span class="keyword">this</span>), handler);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">emit</span><span class="params">(String event, Object msg)</span> </span>&#123;</div><div class="line">  logger.debug(<span class="string">"[LOG] Emit: "</span> + Kue.getCertainJobAddress(event, <span class="keyword">this</span>));</div><div class="line">  eventBus.send(Kue.getCertainJobAddress(event, <span class="keyword">this</span>), msg);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在后面的代码中，我们将频繁使用这两个辅助函数。</p>
<h2 id="Redis中的存储形式">Redis中的存储形式</h2><p>在我们探索相关的逻辑函数之前，我们先来描述一下Vert.x Kue的数据在Redis中是以什么样的形式存储的：</p>
<ul>
<li>所有的key都在<code>vertx_kue</code>命名空间下(以<code>vertx_kue:</code>作为前缀)</li>
<li><code>vertx:kue:job:{id}</code>: 存储任务实体的map</li>
<li><code>vertx:kue:ids</code>: 计数器，指示当前最大的任务ID</li>
<li><code>vertx:kue:job:types</code>: 存储所有任务类型的列表</li>
<li><code>vertx:kue:{type}:jobs</code>: 指示所有等待状态下的某种类型任务的列表</li>
<li><code>vertx_kue:jobs</code>: 存储所有任务<code>zid</code>的有序集合</li>
<li><code>vertx_kue:job:{state}</code>: 存储所有指定状态的任务<code>zid</code>的有序集合</li>
<li><code>vertx_kue:jobs:{type}:{state}</code>: 存储所有指定状态和类型的任务<code>zid</code>的有序集合</li>
<li><code>vertx:kue:job:{id}:log</code>: 存储指定<code>id</code>的任务对应日志的列表</li>
</ul>
<p>OK，下面我们就来看看<code>Job</code>类中重要的逻辑函数。</p>
<h2 id="改变任务状态">改变任务状态</h2><p>我们之前提到过，Vert.x Kue中的任务一共有五种状态。所有的任务相关的操作都伴随着任务状态的变换，因此我们先来看一下<code>state</code>方法的实现，它用于改变任务的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">state</span><span class="params">(JobState newState)</span> </span>&#123;</div><div class="line">  Future&lt;Job&gt; future = Future.future();</div><div class="line">  RedisClient client = RedisHelper.client(vertx, <span class="keyword">new</span> JsonObject()); <span class="comment">// use a new client to keep transaction</span></div><div class="line">  JobState oldState = <span class="keyword">this</span>.state;</div><div class="line">  client.transaction().multi(r0 -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (r0.succeeded()) &#123;</div><div class="line">      <span class="keyword">if</span> (oldState != <span class="keyword">null</span> &amp;&amp; !oldState.equals(newState)) &#123; <span class="comment">// (2)</span></div><div class="line">        client.transaction().zrem(RedisHelper.getStateKey(oldState), <span class="keyword">this</span>.zid, _failure())</div><div class="line">          .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + oldState.name()), <span class="keyword">this</span>.zid, _failure());</div><div class="line">      &#125;</div><div class="line">      client.transaction().hset(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), <span class="string">"state"</span>, newState.name(), _failure()) <span class="comment">// (3)</span></div><div class="line">        .zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure())</div><div class="line">        .zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + newState.name()), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure());</div><div class="line"></div><div class="line">      <span class="keyword">switch</span> (newState) &#123; <span class="comment">// dispatch different state</span></div><div class="line">        <span class="keyword">case</span> ACTIVE: <span class="comment">// (4)</span></div><div class="line">          client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</div><div class="line">            <span class="keyword">this</span>.priority.getValue() &lt; <span class="number">0</span> ? <span class="keyword">this</span>.priority.getValue() : -<span class="keyword">this</span>.priority.getValue(),</div><div class="line">            <span class="keyword">this</span>.zid, _failure());</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> DELAYED: <span class="comment">// (5)</span></div><div class="line">          client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</div><div class="line">            <span class="keyword">this</span>.promote_at, <span class="keyword">this</span>.zid, _failure());</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> INACTIVE: <span class="comment">// (6)</span></div><div class="line">          client.transaction().lpush(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="string">"1"</span>, _failure());</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.state = newState;</div><div class="line"></div><div class="line">      client.transaction().exec(r -&gt; &#123; <span class="comment">// (7)</span></div><div class="line">        <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">          future.complete(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          future.fail(r.cause());</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      future.fail(r0.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> future.compose(Job::updateNow);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们先创建了一个<code>Future</code>对象。然后我们调用了 <code>client.transaction().multi(handler)</code> 函数开始一次Redis事务 (1)。在Vert.x 3.3.2中，所有的Redis事务操作都移至<code>RedisTransaction</code>类中，所以我们需要先调用<code>client.transaction()</code>方法去获取一个事务实例，然后调用<code>multi</code>代表事务块的开始。</p>
<p>在<code>multi</code>函数传入的<code>Handler</code>中，我们先判定当前的任务状态。如果当前任务状态不为空并且不等于新的任务状态，我们就将Redis中存储的旧的状态信息移除 (2)。为了方便起见，我们提供了一个<code>RedisHelper</code>辅助类，里面提供了一些生成特定地址以及编码解码<code>zid</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.util;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.JobState;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Vertx;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisOptions;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisHelper</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERTX_KUE_REDIS_PREFIX = <span class="string">"vertx_kue"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">RedisHelper</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisClient <span class="title">client</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> RedisClient.create(vertx, options(config));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisOptions <span class="title">options</span><span class="params">(JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisOptions()</div><div class="line">      .setHost(config.getString(<span class="string">"redis.host"</span>, <span class="string">"127.0.0.1"</span>))</div><div class="line">      .setPort(config.getInteger(<span class="string">"redis.port"</span>, <span class="number">6379</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> VERTX_KUE_REDIS_PREFIX + <span class="string">":"</span> + key;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStateKey</span><span class="params">(JobState state)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> VERTX_KUE_REDIS_PREFIX + <span class="string">":jobs:"</span> + state.name();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createFIFO</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">    String idLen = <span class="string">""</span> + (<span class="string">""</span> + id).length();</div><div class="line">    <span class="keyword">int</span> len = <span class="number">2</span> - idLen.length();</div><div class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>)</div><div class="line">      idLen = <span class="string">"0"</span> + idLen;</div><div class="line">    <span class="keyword">return</span> idLen + <span class="string">"|"</span> + id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stripFIFO</span><span class="params">(String zid)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> zid.substring(zid.indexOf(<span class="string">'|'</span>) + <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">numStripFIFO</span><span class="params">(String zid)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Long.parseLong(zid.substring(zid.indexOf(<span class="string">'|'</span>) + <span class="number">1</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的key都必须在<code>vertx_kue</code>命名空间下，因此我们封装了一个<code>getKey</code>方法。我们还实现了<code>createFIFO</code>和<code>stripFIFO</code>方法用于生成<code>zid</code>以及解码<code>zid</code>。<code>zid</code>的格式使用了Automattic/Kue中的格式。</p>
<p>回到<code>state</code>方法来。我们使用<code>zrem(String key, String member, Handler&lt;AsyncResult&lt;String&gt;&gt; handler)</code>方法将特定的数据从有序集合中移除。两个key分别是<code>vertx_kue:job:{state}</code> 以及 <code>vertx_kue:jobs:{type}:{state}</code>；<code>member</code>对应着任务的<code>zid</code>。</p>
<p>接下来我们使用<code>hset</code>方法来变更新的状态 (3)，然后用<code>zadd</code>方法往<code>vertx_kue:job:{state}</code> 和 <code>vertx_kue:jobs:{type}:{state}</code>两个有序集合中添加此任务的<code>zid</code>，同时传递一个<strong>权重</strong>(score)。这个非常重要，我们就是通过这个实现<strong>优先级</strong>队列的。我们直接使用<code>priority</code>对应的值作为<code>score</code>。这样，当我们需要从Redis中获取任务的时候，我们就可以通过<code>zpop</code>方法获取优先级最高的任务。我们会在后面详细讲述。</p>
<p>不同的新状态需要不同的操作。对于<code>ACTIVE</code>状态，我们通过<code>zadd</code>命令将<code>zid</code>添加至<code>vertx_kue:jobs:ACTIVE</code>有序集合中并赋予优先级权值 (4)。对于<code>DELAYED</code>状态，我们通过<code>zadd</code>命令将<code>zid</code>添加至<code>vertx_kue:jobs:DELAYED</code>有序集合中并赋予提升时间(<code>promote_at</code>)权值 (5)。对于<code>INACTIVE</code>状态，我们向<code>vertx:kue:{type}:jobs</code>列表中添加一个元素 (6)。这些操作都是在Redis事务块内完成的。最后我们通过<code>exec</code>方法一并执行这些事务操作 (7)。如果执行成功，我们给<code>future</code>赋值（当前任务）。最后我们返回<code>future</code>并且与<code>updateNow</code>方法相组合。</p>
<p><code>updateNow</code>方法非常简单，就是把<code>updated_at</code>的值设为当前时间，然后存到Redis中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">Future&lt;Job&gt; <span class="title">updateNow</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.updated_at = System.currentTimeMillis();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.set(<span class="string">"updated_at"</span>, String.valueOf(updated_at));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="保存任务">保存任务</h2><p>这里我们来看一下整个<code>Job</code>类中最重要的方法之一 - <code>save</code>方法，它的作用是保存任务至Redis中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">save</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// check</span></div><div class="line">  Objects.requireNonNull(<span class="keyword">this</span>.type, <span class="string">"Job type cannot be null"</span>); <span class="comment">// (1)</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> update(); <span class="comment">// (2)</span></div><div class="line"></div><div class="line">  Future&lt;Job&gt; future = Future.future();</div><div class="line"></div><div class="line">  <span class="comment">// 生成id</span></div><div class="line">  client.incr(RedisHelper.getKey(<span class="string">"ids"</span>), res -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      <span class="keyword">this</span>.id = res.result();</div><div class="line">      <span class="keyword">this</span>.zid = RedisHelper.createFIFO(id); <span class="comment">// (4)</span></div><div class="line">      String key = RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.delay &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.state = JobState.DELAYED;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      client.sadd(RedisHelper.getKey(<span class="string">"job:types"</span>), <span class="keyword">this</span>.type, _failure()); <span class="comment">// (5)</span></div><div class="line">       <span class="keyword">this</span>.created_at = System.currentTimeMillis();</div><div class="line">       <span class="keyword">this</span>.promote_at = <span class="keyword">this</span>.created_at + <span class="keyword">this</span>.delay;</div><div class="line">       <span class="comment">// 保存任务</span></div><div class="line">       client.hmset(key, <span class="keyword">this</span>.toJson(), _completer(future, <span class="keyword">this</span>)); <span class="comment">// (6)</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      future.fail(res.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> future.compose(Job::update); <span class="comment">// (7)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，任务类型不能为空所以我们要检查<code>type</code>是否为空 (1)。接着，如果当前任务的id大于0，则代表此任务已经存储过（因为id是存储时分配），此时只需执行更新操作(<code>update</code>)即可 (2)。然后我们创建一个<code>Future</code>对象，然后使用<code>incr</code>方法从<code>vertx_kue:ids</code>字段获取一个新的<code>id</code> (3)。同时我们使用<code>RedisHelper.createFIFO(id)</code>方法来生成新的<code>zid</code> (4)。接着我们来判断任务延时是否大于0，若大于0则将当前任务状态设置为<code>DELAYED</code>。然后我们通过<code>sadd</code>方法将当前任务类型添加至<code>vertx:kue:job:types</code>列表中 (5) 并且保存任务创建时间(<code>created_at</code>)以及任务提升时间(<code>promote_at</code>)。经过这一系列的操作后，所有的属性都已准备好，所以我们可以利用<code>hmset</code>方法将此任务实体存储至<code>vertx:kue:job:{id}</code>哈希表中 (6)。如果存储操作成功，那么将当前任务实体赋给<code>future</code>，否则记录错误。最后我们返回此<code>future</code>并且将其与<code>update</code>方法进行组合。</p>
<p><code>update</code>方法进行一些更新操作，它的逻辑比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">Future&lt;Job&gt; <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">  Future&lt;Job&gt; future = Future.future();</div><div class="line">  <span class="keyword">this</span>.updated_at = System.currentTimeMillis();</div><div class="line"></div><div class="line">  client.transaction().multi(_failure())</div><div class="line">    .hset(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), <span class="string">"updated_at"</span>, String.valueOf(<span class="keyword">this</span>.updated_at), _failure())</div><div class="line">    .zadd(RedisHelper.getKey(<span class="string">"jobs"</span>), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure())</div><div class="line">    .exec(_completer(future, <span class="keyword">this</span>));</div><div class="line"></div><div class="line">  <span class="keyword">return</span> future.compose(r -&gt;</div><div class="line">    <span class="keyword">this</span>.state(<span class="keyword">this</span>.state));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>update</code>方法只做了三件微小的工作：存储任务更新时间、存储<code>zid</code>以及更改当前任务状态（组合<code>state</code>方法）。</p>
<p>最后总结一下将一个任务存储到Redis中经过的步骤：<code>save -&gt; update -&gt; state</code> :-)</p>
<h2 id="移除任务">移除任务</h2><p>移除任务非常简单，借助<code>zrem</code>和<code>del</code>方法即可。我们来看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Void&gt; <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">  Future&lt;Void&gt; future = Future.future();</div><div class="line">  client.transaction().multi(_failure())</div><div class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.stateName()), <span class="keyword">this</span>.zid, _failure())</div><div class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + <span class="keyword">this</span>.stateName()), <span class="keyword">this</span>.zid, _failure())</div><div class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs"</span>), <span class="keyword">this</span>.zid, _failure())</div><div class="line">    .del(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id + <span class="string">":log"</span>), _failure())</div><div class="line">    .del(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), _failure())</div><div class="line">    .exec(r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">"remove"</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"id"</span>, <span class="keyword">this</span>.id));</div><div class="line">        future.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        future.fail(r.cause());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  <span class="keyword">return</span> future;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到成功移除任务时，我们会向Event Bus上的特定地址发送<code>remove</code>任务事件。此事件包含着被移除任务的<code>id</code>。</p>
<h2 id="监听任务事件">监听任务事件</h2><p>我们可以通过几种 <code>onXXX</code> 方法来监听任务事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onComplete</span><span class="params">(Handler&lt;Job&gt; completeHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"complete"</span>, message -&gt; &#123;</div><div class="line">    completeHandler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onFailure</span><span class="params">(Handler&lt;JsonObject&gt; failureHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"failed"</span>, message -&gt; &#123;</div><div class="line">    failureHandler.handle((JsonObject) message.body());</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onFailureAttempt</span><span class="params">(Handler&lt;JsonObject&gt; failureHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"failed_attempt"</span>, message -&gt; &#123;</div><div class="line">    failureHandler.handle((JsonObject) message.body());</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onPromotion</span><span class="params">(Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"promotion"</span>, message -&gt; &#123;</div><div class="line">    handler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onStart</span><span class="params">(Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"start"</span>, message -&gt; &#123;</div><div class="line">    handler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onRemove</span><span class="params">(Handler&lt;JsonObject&gt; removeHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"start"</span>, message -&gt; &#123;</div><div class="line">    removeHandler.handle((JsonObject) message.body());</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onProgress</span><span class="params">(Handler&lt;Integer&gt; progressHandler)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">"progress"</span>, message -&gt; &#123;</div><div class="line">    progressHandler.handle((Integer) message.body());</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到不同的事件，对应接收的数据类型也有差异。我们来说明一下：</p>
<ul>
<li><code>onComplete</code>、<code>onPromotion</code> 以及 <code>onStart</code>: 发送的数据是对应的<code>Job</code>对象</li>
<li><code>onFailure</code> and <code>onFailureAttempt</code>: 发送的数据是<code>JsonObject</code>类型的，其格式类似于：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"job"</span>: &#123;&#125;,</div><div class="line">    <span class="attr">"extra"</span>: &#123;</div><div class="line">        <span class="attr">"message"</span>: <span class="string">"some_error"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>onProgress</code>: 发送的数据是当前任务进度</li>
<li><code>onRemove</code>: 发送的数据是<code>JsonObject</code>类型的，其中<code>id</code>代表被移除任务的编号</li>
</ul>
<h2 id="更新任务进度">更新任务进度</h2><p>我们可以通过<code>progress</code>方法来更新任务进度。看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">progress</span><span class="params">(<span class="keyword">int</span> complete, <span class="keyword">int</span> total)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> n = Math.min(<span class="number">100</span>, complete * <span class="number">100</span> / total); <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">this</span>.emit(<span class="string">"progress"</span>, n); <span class="comment">// (2)</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.setProgress(n) <span class="comment">// (3)</span></div><div class="line">    .set(<span class="string">"progress"</span>, String.valueOf(n))</div><div class="line">    .compose(Job::updateNow);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>progress</code>方法接受两个参数：第一个是当前完成的进度值，第二个是完成状态需要的进度值。我们首先计算出当前的进度 (1)，然后向特定地址发送<code>progress</code>事件 (2)。最后我们将进度存储至Redis中并更新时间，返回<code>Future</code> (3)。</p>
<h2 id="任务失败以及重试机制">任务失败以及重试机制</h2><p>当一个任务处理失败时，如果它有剩余的重试次数，Vert.x Kue会自动调用<code>failAttempt</code>方法进行重试。我们来看一下<code>failAttempt</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">Future&lt;Job&gt; <span class="title">failedAttempt</span><span class="params">(Throwable err)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.error(err)</div><div class="line">    .compose(Job::failed)</div><div class="line">    .compose(Job::attemptInternal);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(⊙o⊙)非常简短吧～实际上，<code>failAttempt</code>方法是三个异步方法的组合：<code>error</code>、<code>failed</code>以及<code>attemptInternal</code>。当一个任务需要进行重试的时候，我们首先向Event Bus发布 <code>error</code> 队列事件并且在Redis中记录日志，然后将当前的任务状态置为<code>FAILED</code>，最后重新处理此任务。</p>
<p>我们先来看一下<code>error</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">error</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.emitError(ex)</div><div class="line">    .set(<span class="string">"error"</span>, ex.getMessage())</div><div class="line">    .compose(j -&gt; j.log(<span class="string">"error | "</span> + ex.getMessage()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的逻辑很简单：首先我们向Event Bus发布 <strong>错误</strong> 事件，然后记录错误日志即可。这里我们封装了一个发布错误的函数<code>emitError</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">emitError</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">  JsonObject errorMessage = <span class="keyword">new</span> JsonObject().put(<span class="string">"id"</span>, <span class="keyword">this</span>.id)</div><div class="line">    .put(<span class="string">"message"</span>, ex.getMessage());</div><div class="line">  eventBus.publish(Kue.workerAddress(<span class="string">"error"</span>), errorMessage);</div><div class="line">  eventBus.send(Kue.getCertainJobAddress(<span class="string">"error"</span>, <span class="keyword">this</span>), errorMessage);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中发送的错误信息格式类似于下面的样子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"id"</span>: <span class="number">2052</span>,</div><div class="line">    <span class="attr">"message"</span>: <span class="string">"some error"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们再来看一下<code>failed</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">failed</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.failed_at = System.currentTimeMillis();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.updateNow()</div><div class="line">    .compose(j -&gt; j.set(<span class="string">"failed_at"</span>, String.valueOf(j.failed_at)))</div><div class="line">    .compose(j -&gt; j.state(JobState.FAILED));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简单，首先我们更新任务的更新时间和失败时间，然后通过<code>state</code>方法将当前任务状态置为<code>FAILED</code>即可。</p>
<p>任务重试的核心逻辑在<code>attemptInternal</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;Job&gt; <span class="title">attemptInternal</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> remaining = <span class="keyword">this</span>.max_attempts - <span class="keyword">this</span>.attempts; <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">if</span> (remaining &gt; <span class="number">0</span>) &#123; <span class="comment">// 还有重试次数</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.attemptAdd() <span class="comment">// (2)</span></div><div class="line">      .compose(Job::reattempt) <span class="comment">// (3)</span></div><div class="line">      .setHandler(r -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">          <span class="keyword">this</span>.emitError(r.cause()); <span class="comment">// (4)</span></div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123; <span class="comment">// (5)</span></div><div class="line">    <span class="keyword">return</span> Future.failedFuture(<span class="string">"No more attempts"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// (6)</span></div><div class="line">    <span class="keyword">return</span> Future.failedFuture(<span class="keyword">new</span> IllegalStateException(<span class="string">"Attempts Exceeded"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我们的<code>Job</code>数据对象中，我们存储了最大重试次数<code>max_attempts</code>以及已经重试的次数<code>attempts</code>，所以我们首先根据这两个数据计算剩余的重试次数<code>remaining</code> (1)。如果还有剩余次数的话，我们就先调用<code>attemptAdd</code>方法增加一次已重试次数并 (2)，然后我们调用<code>reattempt</code>方法执行真正的任务重试逻辑 (3)。最后返回这两个异步方法组合的<code>Future</code>。如果其中一个过程出现错误，我们就发布<code>error</code>事件 (4)。如果没有剩余次数了或者超出剩余次数了，我们直接返回错误。</p>
<p>在我们解析<code>reattempt</code>方法之前，我们先来回顾一下Vert.x Kue中的任务失败恢复机制。Vert.x Kue支持延时重试机制(retry backoff)，并且支持不同的策略（如 <strong>fixed</strong> 以及 <strong>exponential</strong>）。之前我们提到<code>Job</code>类中有一个<code>backoff</code>成员变量，它用于配置延时重试的策略。它的格式类似于这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"type"</span>: <span class="string">"fixed"</span>,</div><div class="line">    <span class="attr">"delay"</span>: <span class="number">5000</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>延时重试机制的实现在<code>getBackoffImpl</code>方法中，它返回一个<code>Function&lt;Integer, Long&gt;</code>对象，代表一个接受<code>Integer</code>类型（即<code>attempts</code>），返回<code>Long</code>类型（代表计算出的延时值）的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Function&lt;Integer, Long&gt; <span class="title">getBackoffImpl</span><span class="params">()</span> </span>&#123;</div><div class="line">  String type = <span class="keyword">this</span>.backoff.getString(<span class="string">"type"</span>, <span class="string">"fixed"</span>); <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">long</span> _delay = <span class="keyword">this</span>.backoff.getLong(<span class="string">"delay"</span>, <span class="keyword">this</span>.delay); <span class="comment">// (2)</span></div><div class="line">  <span class="keyword">switch</span> (type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"exponential"</span>: <span class="comment">// (3)</span></div><div class="line">      <span class="keyword">return</span> attempts -&gt; Math.round(_delay * <span class="number">0.5</span> * (Math.pow(<span class="number">2</span>, attempts) - <span class="number">1</span>));</div><div class="line">    <span class="keyword">case</span> <span class="string">"fixed"</span>:</div><div class="line">    <span class="keyword">default</span>: <span class="comment">// (4)</span></div><div class="line">      <span class="keyword">return</span> attempts -&gt; _delay;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们从<code>backoff</code>配置中获取延迟重试策略。目前Vert.x Kue支持两种策略：<code>fixed</code> 和 <code>exponential</code>。前者采用固定延迟时间，而后者采用指数增长型延迟时间。默认情况下Vert.x Kue会采用<code>fixed</code>策略 (1)。接下来我们从<code>backoff</code>配置中获取延迟时间，如果配置中没有指定，那么就使用任务对象中的延迟时间<code>delay</code> (2)。接下来就是根据具体的策略进行计算了。对于指数型延迟，我们计算<code>[delay * 0.5 * 2^attempts]</code>作为延迟时间 (3)；对于固定型延迟策略，我们直接使用获取到的延迟时间 (4)。</p>
<p>好啦，现在回到“真正的重试”方法 —— <code>reattempt</code>方法来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;Job&gt; <span class="title">reattempt</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.backoff != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">long</span> delay = <span class="keyword">this</span>.getBackoffImpl().apply(attempts); <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.setDelay(delay)</div><div class="line">      .setPromote_at(System.currentTimeMillis() + delay)</div><div class="line">      .update() <span class="comment">// (2)</span></div><div class="line">      .compose(Job::delayed); <span class="comment">// (3)</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.inactive(); <span class="comment">// (4)</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们先检查<code>backoff</code>配置是否存在，若存在则计算出对应的延时时间 (1) 并且设定<code>delay</code>和<code>promote_at</code>属性的值然后保存至Redis中 (2)。接着我们通过<code>delayed</code>方法将任务的状态设为延时(<code>DELAYED</code>) (3)。如果延时重试配置不存在，我们就通过<code>inactive</code>方法直接将此任务置入工作队列中 (4)。</p>
<p>这就是整个任务重试功能的实现，也不是很复杂蛤？观察上面的代码，我们可以发现<code>Future</code>组合无处不在。这种响应式的组合非常方便。想一想如果我们用回调的异步方式来写代码的话，我们很容易陷入回调地狱中(⊙o⊙)。。。几个回调嵌套起来总显得不是那么优美和简洁，而用响应式的、可组合的<code>Future</code>就可以有效地避免这个问题。</p>
<p>不错！到现在为止我们已经探索完<code>Job</code>类的源码了～下面我们来看一下<code>JobService</code>类。</p>
<h1 id="Event_Bus_服务_-_JobService">Event Bus 服务 - JobService</h1><p>在本章节中我们来探索一下<code>JobService</code>接口及其实现 —— 它包含着各种普通的操作和统计<code>Job</code>的逻辑。</p>
<h2 id="异步RPC">异步RPC</h2><p>我们的<code>JobService</code>是一个通用逻辑接口，因此我们希望应用中的每一个组件都能访问此服务，即进行RPC。在Vert.x中，我们可以将服务注册至Event Bus上，然后其它组件就可以通过Event Bus来远程调用注册的服务了。</p>
<p>传统的RPC有一个缺点：消费者需要阻塞等待生产者的回应。你可能想说：这是一种阻塞模型，和Vert.x推崇的异步开发模式不相符。没错！而且，传统的RPC不是真正<strong>面向失败设计</strong>的。</p>
<p>还好，Vert.x提供了一种高效的、响应式的RPC —— 异步RPC。我们不需要等待生产者的回应，而只需要传递一个<code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code>参数给异步方法。这样当收到生产者结果时，对应的<code>Handler</code>就会被调用，非常方便，这与Vert.x的异步开发模式相符。并且，<code>AsyncResult</code>也是面向失败设计的。</p>
<p>所以讲到这里，你可能想问：到底怎么在Event Bus上注册服务呢？我们是不是需要写一大堆的逻辑去包装和发送信息，然后在另一端解码信息并进行调用呢？不，这太麻烦了！有了Vert.x 服务代理，我们不需要这么做！Vert.x提供了一个组件 <strong>Vert.x Service Proxy</strong> 来自动生成服务代理。有了它的帮助，我们就只需要按照规范设计我们的异步服务接口，然后用<code>@ProxyGen</code>注解修饰即可。</p>
<p>[NOTE <code>@ProxyGen</code>注解的限制 | <code>@ProxyGen</code>注解的使用有诸多限制。比如，所有的异步方法都必须是基于回调的，也就是说每个方法都要接受一个<code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code>类型的参数。并且，类型<code>R</code>也是有限制的 —— 只允许基本类型以及数据对象类型。详情请参考<a href="http://vertx.io/docs/vertx-service-proxy/" target="_blank" rel="external">官方文档</a>。 ]</p>
<h2 id="异步服务接口">异步服务接口</h2><p>我们来看一下<code>JobService</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ProxyGen</span></div><div class="line"><span class="meta">@VertxGen</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> JobService <span class="title">create</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JobServiceImpl(vertx, config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> JobService <span class="title">createProxy</span><span class="params">(Vertx vertx, String address)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ProxyHelper.createProxy(JobService.class, vertx, address);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取任务，按照优先级顺序</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> id      job id</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Job&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 删除任务</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> id      job id</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">removeJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Void&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 判断任务是否存在</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> id      job id</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">existsJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Boolean&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取任务日志</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> id      job id</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getJobLog</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;JsonArray&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取某一范围内某个指定状态下的任务列表</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> state   expected job state</div><div class="line">   * <span class="doctag">@param</span> from    from</div><div class="line">   * <span class="doctag">@param</span> to      to</div><div class="line">   * <span class="doctag">@param</span> order   range order</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">jobRangeByState</span><span class="params">(String state, <span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取某一范围内某个指定状态和类型下的任务列表</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type    expected job type</div><div class="line">   * <span class="doctag">@param</span> state   expected job state</div><div class="line">   * <span class="doctag">@param</span> from    from</div><div class="line">   * <span class="doctag">@param</span> to      to</div><div class="line">   * <span class="doctag">@param</span> order   range order</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">jobRangeByType</span><span class="params">(String type, String state, <span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取某一范围内的任务列表（按照顺序或倒序）</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> from    from</div><div class="line">   * <span class="doctag">@param</span> to      to</div><div class="line">   * <span class="doctag">@param</span> order   range order</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">jobRange</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// 统计函数</span></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取指定状态和类型下的任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type    job type</div><div class="line">   * <span class="doctag">@param</span> state   job state</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">cardByType</span><span class="params">(String type, JobState state, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取某个状态下的任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> state   job state</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">card</span><span class="params">(JobState state, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取COMPLETE状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type    job type; if null, then return global metrics</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">completeCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取FAILED状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">failedCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取INACTIVE状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">inactiveCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取ACTIVE状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">activeCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取DELAYED状态任务的数量</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">delayedCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取当前存在的所有任务类型</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getAllTypes</span><span class="params">(Handler&lt;AsyncResult&lt;List&lt;String&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取指定状态下的所有任务的ID</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> state   job state</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getIdsByState</span><span class="params">(JobState state, Handler&lt;AsyncResult&lt;List&lt;Long&gt;&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 工作队列运行时间（ms）</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> handler async result handler</div><div class="line">   */</div><div class="line">  <span class="meta">@Fluent</span></div><div class="line">  <span class="function">JobService <span class="title">getWorkTime</span><span class="params">(Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到我们还为<code>JobService</code>接口添加了<code>@VertxGen</code>注解，Vert.x Codegen可以处理此注解生成多种语言版本的服务。</p>
<p>在<code>JobService</code>接口中我们还定义了两个静态方法：<code>create</code>用于创建一个任务服务实例，<code>createProxy</code>用于创建一个服务代理。</p>
<p><code>JobService</code>接口中包含一些任务操作和统计的相关逻辑，每个方法的功能都已经在注释中阐述了，因此我们就直接来看它的实现吧～</p>
<h2 id="任务服务的实现">任务服务的实现</h2><p><code>JobService</code>接口的实现位于<code>JobServiceImpl</code>类中，代码非常长，因此这里就不贴代码了。。。大家可以对照<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/kue-core/src/main/java/io/vertx/blueprint/kue/service/impl/JobServiceImpl.java" target="_blank" rel="external">GitHub中的代码</a>读下面的内容。</p>
<ul>
<li><code>getJob</code>: 获取任务的方法非常简单。直接利用<code>hgetall</code>命令从Redis中取出对应的任务即可。</li>
<li><code>removeJob</code>: 我们可以将此方法看作是<code>getJob</code>和<code>Job#remove</code>两个方法的组合。</li>
<li><code>existsJob</code>: 使用<code>exists</code>命令判断对应<code>id</code>的任务是否存在。</li>
<li><code>getJobLog</code>: 使用<code>lrange</code>命令从<code>vertx_kue:job:{id}:log</code>列表中取出日志。</li>
<li><code>rangeGeneral</code>: 使用<code>zrange</code>命令获取一定范围内的任务，这是一个通用方法。</li>
</ul>
<p>[NOTE <code>zrange</code> 操作 | <code>zrange</code> 返回某一有序集合中某个特定范围内的元素。详情请见<a href="http://redis.io/commands/zrange" target="_blank" rel="external">ZRANGE - Redis</a>。 ]</p>
<p>以下三个方法复用了<code>rangeGeneral</code>方法：</p>
<ul>
<li><code>jobRangeByState</code>: 指定状态，对应的key为<code>vertx_kue:jobs:{state}</code>。</li>
<li><code>jobRangeByType</code>: 指定状态和类型，对应的key为<code>vertx_kue:jobs:{type}:{state}</code>。</li>
<li><code>jobRange</code>: 对应的key为<code>vertx_kue:jobs</code>。</li>
</ul>
<p>这两个通用方法用于任务数量的统计：</p>
<ul>
<li><code>cardByType</code>: 利用<code>zcard</code>命令获取某一指定状态和类型下任务的数量。</li>
<li><code>card</code>: 利用<code>zcard</code>命令获取某一指定状态下任务的数量。</li>
</ul>
<p>下面五个辅助统计方法复用了上面两个通用方法：</p>
<ul>
<li><code>completeCount</code></li>
<li><code>failedCount</code></li>
<li><code>delayedCount</code></li>
<li><code>inactiveCount</code></li>
<li><code>activeCount</code></li>
</ul>
<p>接着看：</p>
<ul>
<li><code>getAllTypes</code>: 利用<code>smembers</code>命令获取<code>vertx_kue:job:types</code>集合中存储的所有的任务类型。</li>
<li><code>getIdsByState</code>: 使用<code>zrange</code>获取某一指定状态下所有任务的ID。</li>
<li><code>getWorkTime</code>: 使用<code>get</code>命令从<code>vertx_kue:stats:work-time</code>中获取Vert.x Kue的工作时间。</li>
</ul>
<h2 id="注册任务服务">注册任务服务</h2><p>既然完成了<code>JobService</code>的实现，接下来我们来看一下如何利用Service Proxy将服务注册至Event Bus上。这里我们还需要一个<code>KueVerticle</code>来创建要注册的服务实例，并且将其注册至Event Bus上。</p>
<p>打开<code>io.vertx.blueprint.kue.queue.KueVerticle</code>类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.queue;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.service.JobService;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.util.RedisHelper;</div><div class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"><span class="keyword">import</span> io.vertx.core.logging.Logger;</div><div class="line"><span class="keyword">import</span> io.vertx.core.logging.LoggerFactory;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</div><div class="line"><span class="keyword">import</span> io.vertx.serviceproxy.ProxyHelper;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KueVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Job.class);</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EB_JOB_SERVICE_ADDRESS = <span class="string">"vertx.kue.service.job.internal"</span>; <span class="comment">// (1)</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> JsonObject config;</div><div class="line">  <span class="keyword">private</span> JobService jobService;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">this</span>.config = config();</div><div class="line">    <span class="keyword">this</span>.jobService = JobService.create(vertx, config); <span class="comment">// (2)</span></div><div class="line">    <span class="comment">// create redis client</span></div><div class="line">    RedisClient redisClient = RedisHelper.client(vertx, config);</div><div class="line">    redisClient.ping(pr -&gt; &#123; <span class="comment">// (3) test connection</span></div><div class="line">      <span class="keyword">if</span> (pr.succeeded()) &#123;</div><div class="line">        logger.info(<span class="string">"Kue Verticle is running..."</span>);</div><div class="line"></div><div class="line">        <span class="comment">// (4) register job service</span></div><div class="line">        ProxyHelper.registerService(JobService.class, vertx, jobService, EB_JOB_SERVICE_ADDRESS);</div><div class="line"></div><div class="line">        future.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        logger.error(<span class="string">"oops!"</span>, pr.cause());</div><div class="line">        future.fail(pr.cause());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们需要定义一个地址用于服务注册 (1)。在<code>start</code>方法中，我们创建了一个任务服务实例 (2)，然后通过<code>ping</code>命令测试Redis连接 (3)。如果连接正常，那么我们就可以通过<code>ProxyHelper</code>类中的<code>registerService</code>辅助方法来将服务实例注册至Event Bus上 (4)。</p>
<p>这样，一旦我们在集群模式下部署<code>KueVerticle</code>，服务就会被发布至Event Bus上，然后我们就可以在其他组件中去远程调用此服务了。很奇妙吧！</p>
<h1 id="Kue_-_工作队列">Kue - 工作队列</h1><p><code>Kue</code>类代表着工作队列。我们来看一下<code>Kue</code>类的实现。首先先看一下其构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Kue</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.vertx = vertx;</div><div class="line">  <span class="keyword">this</span>.config = config;</div><div class="line">  <span class="keyword">this</span>.jobService = JobService.createProxy(vertx, EB_JOB_SERVICE_ADDRESS);</div><div class="line">  <span class="keyword">this</span>.client = RedisHelper.client(vertx, config);</div><div class="line">  Job.setVertx(vertx, RedisHelper.client(vertx, config)); <span class="comment">// init static vertx instance inner job</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们需要注意两点：第一点，我们通过<code>createProxy</code>方法来创建一个<code>JobService</code>的服务代理；第二点，之前提到过，我们需要在这里初始化<code>Job</code>类中的静态成员变量。</p>
<h2 id="基于Future的封装">基于Future的封装</h2><p>我们的<code>JobService</code>是基于回调的，这是服务代理组件所要求的。为了让Vert.x Kue更加响应式，使用起来更加方便，我们在<code>Kue</code>类中以基于Future的异步模式封装了<code>JobService</code>中的所有异步方法。这很简单，比如这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Fluent</span></div><div class="line"><span class="function">JobService <span class="title">getJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Job&gt;&gt; handler)</span></span>;</div></pre></td></tr></table></figure>
<p>可以这么封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Future&lt;Optional&lt;Job&gt;&gt; getJob(<span class="keyword">long</span> id) &#123;</div><div class="line">  Future&lt;Optional&lt;Job&gt;&gt; future = Future.future();</div><div class="line">  jobService.getJob(id, r -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">      future.complete(Optional.ofNullable(r.result()));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      future.fail(r.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> future;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是加一层<code>Future</code>。其它的封装过程也类似所以我们就不细说了。</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_future_based_methods.png" alt=""></p>
<h2 id="process和processBlocking方法">process和processBlocking方法</h2><p><code>process</code>和<code>processBlocking</code>方法用于处理任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">process</span><span class="params">(String type, <span class="keyword">int</span> n, Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The process times must be positive"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</div><div class="line">    processInternal(type, handler, <span class="keyword">false</span>);</div><div class="line">  &#125;<span class="function">f</span></div><div class="line">  <span class="title">setupTimers</span><span class="params">()</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">process</span><span class="params">(String type, Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  processInternal(type, handler, <span class="keyword">false</span>);</div><div class="line">  setupTimers();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">processBlocking</span><span class="params">(String type, <span class="keyword">int</span> n, Handler&lt;Job&gt; handler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The process times must be positive"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</div><div class="line">    processInternal(type, handler, <span class="keyword">true</span>);</div><div class="line">  &#125;</div><div class="line">  setupTimers();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个<code>process</code>方法都类似 —— 它们都是使用<strong>Event Loop</strong>线程处理任务的，其中第一个方法还可以指定同时处理任务数量的阈值。我们来回顾一下使用<strong>Event Loop</strong>线程的注意事项 —— 我们不能阻塞Event Loop线程。因此如果我们需要在处理任务时做一些耗时的操作，我们可以使用<code>processBlocking</code>方法。这几个方法的代码看起来都差不多，那么区别在哪呢？之前我们提到过，我们设计了一种Verticle - <code>KueWorker</code>，用于处理任务。因此对于<code>process</code>方法来说，<code>KueWorker</code>就是一种普通的Verticle；而对于<code>processBlocking</code>方法来说，<code>KueWorker</code>是一种<strong>Worker Verticle</strong>。这两种Verticle有什么不同呢？区别在于，Worker Verticle会使用<strong>Worker线程</strong>，因此即使我们执行一些耗时的操作，Event Loop线程也不会被阻塞。</p>
<p>创建及部署<code>KueWorker</code>的逻辑在<code>processInternal</code>方法中，这三个方法都使用了<code>processInternal</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processInternal</span><span class="params">(String type, Handler&lt;Job&gt; handler, <span class="keyword">boolean</span> isWorker)</span> </span>&#123;</div><div class="line">  KueWorker worker = <span class="keyword">new</span> KueWorker(type, handler, <span class="keyword">this</span>); <span class="comment">// (1)</span></div><div class="line">  vertx.deployVerticle(worker, <span class="keyword">new</span> DeploymentOptions().setWorker(isWorker), r0 -&gt; &#123; <span class="comment">// (2)</span></div><div class="line">    <span class="keyword">if</span> (r0.succeeded()) &#123;</div><div class="line">      <span class="keyword">this</span>.on(<span class="string">"job_complete"</span>, msg -&gt; &#123;</div><div class="line">        <span class="keyword">long</span> dur = <span class="keyword">new</span> Job(((JsonObject) msg.body()).getJsonObject(<span class="string">"job"</span>)).getDuration();</div><div class="line">        client.incrby(RedisHelper.getKey(<span class="string">"stats:work-time"</span>), dur, r1 -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">          <span class="keyword">if</span> (r1.failed())</div><div class="line">            r1.cause().printStackTrace();</div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们创建一个<code>KueWorker</code>实例 (1)。我们将在稍后详细介绍<code>KueWorker</code>的实现。然后我们根据提供的配置来部署此<code>KueWorker</code> (2)。<code>processInternal</code>方法的第三个参数代表此<code>KueWorker</code>是否为worker verticle。如果部署成功，我们就监听<code>complete</code>事件。每当接收到<code>complete</code>事件的时候，我们获取收到的信息（处理任务消耗的时间），然后用<code>incrby</code>增加对应的工作时间 (3)。</p>
<p>再回到前面三个处理方法中。除了部署<code>KueWorker</code>以外，我们还调用了<code>setupTimers</code>方法，用于设定定时器以监测延时任务以及监测活动任务TTL。</p>
<h2 id="监测延时任务">监测延时任务</h2><p>Vert.x Kue支持延时任务，因此我们需要在任务延时时间到达时将任务“提升”至工作队列中等待处理。这个工作是在<code>checkJobPromotion</code>方法中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkJobPromotion</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> timeout = config.getInteger(<span class="string">"job.promotion.interval"</span>, <span class="number">1000</span>); <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">int</span> limit = config.getInteger(<span class="string">"job.promotion.limit"</span>, <span class="number">1000</span>); <span class="comment">// (2)</span></div><div class="line">  vertx.setPeriodic(timeout, l -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">    client.zrangebyscore(RedisHelper.getKey(<span class="string">"jobs:DELAYED"</span>), String.valueOf(<span class="number">0</span>), String.valueOf(System.currentTimeMillis()),</div><div class="line">      <span class="keyword">new</span> RangeLimitOptions(<span class="keyword">new</span> JsonObject().put(<span class="string">"offset"</span>, <span class="number">0</span>).put(<span class="string">"count"</span>, limit)), r -&gt; &#123;  <span class="comment">// (4)</span></div><div class="line">        <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">          r.result().forEach(r1 -&gt; &#123;</div><div class="line">            <span class="keyword">long</span> id = Long.parseLong(RedisHelper.stripFIFO((String) r1));</div><div class="line">            <span class="keyword">this</span>.getJob(id).compose(jr -&gt; jr.get().inactive())  <span class="comment">// (5)</span></div><div class="line">              .setHandler(jr -&gt; &#123;</div><div class="line">                <span class="keyword">if</span> (jr.succeeded()) &#123;</div><div class="line">                  jr.result().emit(<span class="string">"promotion"</span>, jr.result().getId()); <span class="comment">// (6)</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  jr.cause().printStackTrace();</div><div class="line">                &#125;</div><div class="line">              &#125;);</div><div class="line">          &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          r.cause().printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们从配置中获取监测延时任务的间隔(<code>job.promotion.interval</code>，默认1000ms)以及提升数量阈值(<code>job.promotion.limit</code>，默认1000)。然后我们使用<code>vertx.setPeriodic</code>方法设一个周期性的定时器 (3)，每隔一段时间就从Redis中获取需要被提升的任务 (4)。这里我们通过<code>zrangebyscore</code>获取每个需要被提升任务的<code>id</code>。我们来看一下<code>zrangebyscore</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">RedisClient <span class="title">zrangebyscore</span><span class="params">(String key, String min, String max, RangeLimitOptions options, Handler&lt;AsyncResult&lt;JsonArray&gt;&gt; handler)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><code>key</code>: 某个有序集合的key，即<code>vertx_kue:jobs:DELAYED</code></li>
<li><code>min</code> and <code>max</code>: 最小值以及最大值（按照某种模式）。这里<code>min</code>是<strong>0</strong>，而<code>max</code>是当前时间戳</li>
</ul>
<p>我们来回顾一下<code>Job</code>类中的<code>state</code>方法。当我们要把任务状态设为<code>DELAYED</code>的时候，我们将score设为<code>promote_at</code>时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> DELAYED:</div><div class="line">  client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</div><div class="line">    <span class="keyword">this</span>.promote_at, <span class="keyword">this</span>.zid, _failure());</div></pre></td></tr></table></figure>
<p>因此我们将<code>max</code>设为当前时间(<code>System.currentTimeMillis()</code>)，只要当前时间超过需要提升的时间，这就说明此任务可以被提升了。</p>
<ul>
<li><code>options</code>: range和limit配置。这里我们需要指定<code>LIMIT</code>值所以我们用<code>new RangeLimitOptions(new JsonObject().put(&quot;offset&quot;, 0).put(&quot;count&quot;, limit)</code>创建了一个配置</li>
</ul>
<p><code>zrangebyscore</code>的结果是一个<code>JsonArray</code>，里面包含着所有等待提升任务的<code>zid</code>。获得结果后我们就将每个<code>zid</code>转换为<code>id</code>，然后分别获取对应的任务实体，最后对每个任务调用<code>inactive</code>方法来将任务状态设为<code>INACTIVE</code> (5)。如果任务成功提升至工作队列，我们就发送<code>promotion</code>事件 (6)。</p>
<h2 id="CallbackKue_-_提供多语言支持">CallbackKue - 提供多语言支持</h2><p>我们知道，Vert.x支持多种语言(如JS，Ruby)，因此如果能让我们的Vert.x Kue支持多种语言那当然是极好的！这没有问题～Vert.x Codegen可以处理含<code>@VertxGen</code>注解的异步接口，生成多语言版本。<code>@VertxGen</code>注解同样限制异步方法 —— 需要基于回调，因此我们设计了一个<code>CallbackKue</code>接口用于提供多语言支持。<code>CallbackKue</code>的设计非常简单，其实现复用了<code>Kue</code>和<code>jobService</code>的代码。大家可以直接看源码，一目了然，这里就不细说了。</p>
<p>注意要生成多语言版本的代码，需要添加相应的依赖。比如要生成Ruby版本的代码就要向<code>build.gradle</code>中添加<code>compile(&quot;io.vertx:vertx-lang-ruby:${vertxVersion}&quot;)</code>。</p>
<h1 id="KueWorker_-_任务在此处理">KueWorker - 任务在此处理</h1><p>好啦，我们已经对Vert.x Kue Core的几个核心部分有了大致的了解了，现在是时候探索一下任务处理的本源 - <code>KueWorker</code>了～</p>
<p>每一个worker都对应一个特定的任务类型，并且绑定着特定的处理函数(<code>Handler</code>)，所以我们需要在创建的时候指定它们。</p>
<h2 id="prepareAndStart方法">prepareAndStart方法</h2><p>在<code>KueWorker</code>中，我们使用<code>prepareAndStart</code>方法来准备要处理的任务并且开始处理任务的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAndStart</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.getJobFromBackend().setHandler(jr -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (jr.succeeded()) &#123;</div><div class="line">      <span class="keyword">if</span> (jr.result().isPresent()) &#123;</div><div class="line">        <span class="keyword">this</span>.job = jr.result().get(); <span class="comment">// (2)</span></div><div class="line">        process(); <span class="comment">// (3)</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, <span class="string">"job_not_exist"</span>));</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"job not exist"</span>);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, jr.cause().getMessage()));</div><div class="line">        jr.cause().printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码比较直观。首先我们通过<code>getJobFromBackend</code>方法从Redis中按照优先级顺序获取任务 (1)。如果成功获取任务，我们就把获取到的任务保存起来 (2) 然后通过<code>process</code>方法处理任务 (3)。如果中间出现错误，我们需要发送<code>error</code>错误事件，其中携带错误信息。</p>
<h2 id="使用zpop按照优先级顺序获取任务">使用zpop按照优先级顺序获取任务</h2><p>我们来看一下我们是如何从Redis中按照优先级顺序获取任务实体的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Future&lt;Optional&lt;Job&gt;&gt; getJobFromBackend() &#123;</div><div class="line">  Future&lt;Optional&lt;Job&gt;&gt; future = Future.future();</div><div class="line">  client.blpop(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="number">0</span>, r1 -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (r1.failed()) &#123;</div><div class="line">      client.lpush(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="string">"1"</span>, r2 -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (r2.failed())</div><div class="line">          future.fail(r2.cause());</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.zpop(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":INACTIVE"</span>)) <span class="comment">// (2)</span></div><div class="line">        .compose(kue::getJob) <span class="comment">// (3)</span></div><div class="line">        .setHandler(r -&gt; &#123;</div><div class="line">          <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">            future.complete(r.result());</div><div class="line">          &#125; <span class="keyword">else</span></div><div class="line">            future.fail(r.cause());</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> future;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前我们已经了解到，每当我们保存一个任务的时候，我们都会向<code>vertx_kue:{type}:jobs</code>列表中插入一个新元素表示新的任务可供处理。因此这里我们通过<code>blpop</code>命令来等待可用的任务 (1)。一旦有任务可供处理，我们就利用<code>zpop</code>方法取出高优先级的任务的<code>zid</code> (2)。<code>zpop</code>命令是一个原子操作，用于从有序集合中弹出最小score值的元素。注意Redis没有实现<code>zpop</code>命令，因此我们需要自己实现。</p>
<p><a href="http://redis.io/topics/transactions#using-a-hrefcommandswatchwatcha-to-implement-zpop" target="_blank" rel="external">Redis官方文档</a>介绍了一种实现<code>zpop</code>命令的简单方法 - 利用 <code>WATCH</code>。这里我们利用另外一种思路实现<code>zpop</code>命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;Long&gt; <span class="title">zpop</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">  Future&lt;Long&gt; future = Future.future();</div><div class="line">  client.transaction()</div><div class="line">    .multi(_failure())</div><div class="line">    .zrange(key, <span class="number">0</span>, <span class="number">0</span>, _failure())</div><div class="line">    .zremrangebyrank(key, <span class="number">0</span>, <span class="number">0</span>, _failure())</div><div class="line">    .exec(r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">        JsonArray res = r.result();</div><div class="line">        <span class="keyword">if</span> (res.getJsonArray(<span class="number">0</span>).size() == <span class="number">0</span>) <span class="comment">// empty set</span></div><div class="line">          future.fail(<span class="keyword">new</span> IllegalStateException(<span class="string">"Empty zpop set"</span>));</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            future.complete(Long.parseLong(RedisHelper.stripFIFO(</div><div class="line">              res.getJsonArray(<span class="number">0</span>).getString(<span class="number">0</span>))));</div><div class="line">          &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">            future.fail(ex);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        future.fail(r.cause());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  <span class="keyword">return</span> future;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我们的<code>zpop</code>的实现中，我们首先开始了一个事务块，然后依次执行<code>zrange</code>和<code>zremrangebyrank</code>命令。有关这些命令的详情我们就不细说了，可以参考<a href="http://redis.io/commands" target="_blank" rel="external">Redis官方文档</a>。然后我们提交事务，如果提交成功，我们会获得一个<code>JsonArray</code>类型的结果。正常情况下我们都可以通过<code>res.getJsonArray(0).getString(0)</code>获取到对应的<code>zid</code>值。获取到<code>zid</code>值以后我们就可以将其转换为任务的<code>id</code>了，最后我们将<code>id</code>置于<code>Future</code>内（因为<code>zpop</code>也是一个异步方法）。</p>
<p>接着回到<code>getJobFromBackend</code>方法中。获取到对应的<code>id</code>之后，我们就可以通过<code>Kue</code>的<code>getJob</code>函数获取任务实体了 (3)。由于<code>getJobFromBackend</code>也是一个异步方法，因此我们同样将结果置于<code>Future</code>中。</p>
<h2 id="真正的“处理”逻辑">真正的“处理”逻辑</h2><p>前边讲了那么多，都是在为处理任务做准备。。。不要着急，现在终于到了真正的“处理”逻辑咯！我们看一下<code>process</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">long</span> curTime = System.currentTimeMillis();</div><div class="line">  <span class="keyword">this</span>.job.setStarted_at(curTime)</div><div class="line">    .set(<span class="string">"started_at"</span>, String.valueOf(curTime)) <span class="comment">// (1) set start time</span></div><div class="line">    .compose(Job::active) <span class="comment">// (2) set the job state to ACTIVE</span></div><div class="line">    .setHandler(r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">        Job j = r.result();</div><div class="line">        <span class="comment">// emit start event</span></div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"start"</span>, j, <span class="keyword">null</span>);  <span class="comment">// (3) emit job `start` event</span></div><div class="line">        <span class="comment">// (4) process logic invocation</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          jobHandler.handle(j);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">          j.done(ex);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// (5) consume the job done event</span></div><div class="line"></div><div class="line">        eventBus.consumer(Kue.workerAddress(<span class="string">"done"</span>, j), msg -&gt; &#123;</div><div class="line">          createDoneCallback(j).handle(Future.succeededFuture(</div><div class="line">            ((JsonObject) msg.body()).getJsonObject(<span class="string">"result"</span>)));</div><div class="line">        &#125;);</div><div class="line">        eventBus.consumer(Kue.workerAddress(<span class="string">"done_fail"</span>, j), msg -&gt; &#123;</div><div class="line">          createDoneCallback(j).handle(Future.failedFuture(</div><div class="line">            (String) msg.body()));</div><div class="line">        &#125;);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">this</span>.job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, r.cause().getMessage()));</div><div class="line">          r.cause().printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到了最核心的函数了！首先我们先给开始时间赋值 (1) 然后将任务状态置为<code>ACTIVE</code> (2)。如果这两个操作成功的话，我们就向Event Bus发送任务开始(<code>start</code>)事件 (3)。接下来我们调用真正的处理逻辑 - 之前绑定的<code>jobHandler</code> (4)。如果处理过程中抛出异常的话，Vert.x Kue就会调用<code>job.done(ex)</code>方法发送<code>done_fail</code>内部事件来通知worker任务处理失败。但是似乎没有看到在哪里接收并处理<code>done</code>和<code>done_fail</code>事件呢？就在这 (5)！一旦Vert.x Kue接收到这两个事件，它就会调用对应的<code>handler</code>去进行任务完成或失败的相应操作。这里的<code>handler</code>是由<code>createDoneCallback</code>方法生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; createDoneCallback(Job job) &#123;</div><div class="line">  <span class="keyword">return</span> r0 -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (job == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (r0.failed()) &#123;</div><div class="line">      <span class="keyword">this</span>.fail(r0.cause()); <span class="comment">// (1)</span></div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> dur = System.currentTimeMillis() - job.getStarted_at();</div><div class="line">    job.setDuration(dur)</div><div class="line">      .set(<span class="string">"duration"</span>, String.valueOf(dur)); <span class="comment">// (2)</span></div><div class="line">    JsonObject result = r0.result();</div><div class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">      job.setResult(result)</div><div class="line">        .set(<span class="string">"result"</span>, result.encodePrettily()); <span class="comment">// (3)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    job.complete().setHandler(r -&gt; &#123; <span class="comment">// (4)</span></div><div class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</div><div class="line">        Job j = r.result();</div><div class="line">        <span class="keyword">if</span> (j.isRemoveOnComplete()) &#123; <span class="comment">// (5)</span></div><div class="line">          j.remove();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"complete"</span>, j, <span class="keyword">null</span>); <span class="comment">// (6)</span></div><div class="line"></div><div class="line">        <span class="keyword">this</span>.prepareAndStart(); <span class="comment">// (7) 准备处理下一个任务</span></div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任务处理有两种情况：完成和失败，因此我们先来看任务成功处理的情况。我们首先给任务的用时(<code>duration</code>)赋值 (2)，并且如果任务产生了结果，也给结果(<code>result</code>)赋值 (3)。然后我们调用<code>job.complete</code>方法将状态设置为<code>COMPLETE</code> (4)。如果成功的话，我们就检查<code>removeOnComplete</code>标志位 (5) 并决定是否将任务从Redis中移除。然后我们向Event Bus发送任务完成事件(<code>complete</code>)以及队列事件<code>job_complete</code> (6)。现在这个任务的处理过程已经结束了，worker需要准备处理下一个任务了，因此最后我们调用<code>prepareAndStart</code>方法准备处理下一个<code>Job</code>。</p>
<h2 id="处理失败了怎么办？">处理失败了怎么办？</h2><p>人生不如意事十之八九，任务处理过程中很可能会遇见各种各样的问题而失败。当任务处理失败时，我们调用<code>KueWorker</code>中的<code>fail</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">  job.failedAttempt(ex).setHandler(r -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">      <span class="keyword">this</span>.error(r.cause(), job); <span class="comment">// (2)</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      Job res = r.result();</div><div class="line">      <span class="keyword">if</span> (res.hasAttempts()) &#123; <span class="comment">// (3)</span></div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"failed_attempt"</span>, job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, ex.getMessage()));</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"failed"</span>, job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, ex.getMessage())); <span class="comment">// (4)</span></div><div class="line">      &#125;</div><div class="line">      prepareAndStart(); <span class="comment">// (5)</span></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>面对失败时，我们首先通过<code>failedAttempt</code>方法尝试从错误中恢复 (1)。如果恢复失败（比如没有重试次数了）就向Event Bus发送<code>error</code>队列事件 (2)。如果恢复成功，我们就根据是否还有剩余重试次数来发送对应的事件(<code>failed</code>或者<code>failed_attempt</code>)。搞定错误以后，worker同样需要准备处理下一个任务了，因此最后我们调用<code>prepareAndStart</code>方法准备处理下一个<code>Job</code> (5)。</p>
<p>这就是<code>KueWorker</code>的全部实现，是不是很有趣呢？看了这么久的代码也有些累了，下面是时候来写个Kue应用跑一下咯～</p>
<h1 id="展示时间！">展示时间！</h1><p>在<code>io.vertx.blueprint.kue.example</code>包下(<code>kue-example</code>子工程)创建一个<code>LearningVertxVerticle</code>类，然后编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.example;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.Kue;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.Job;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.Priority;</div><div class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearningVertxVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 创建工作队列</span></div><div class="line">    Kue kue = Kue.createQueue(vertx, config());</div><div class="line"></div><div class="line">    <span class="comment">// 监听全局错误事件</span></div><div class="line">    kue.on(<span class="string">"error"</span>, message -&gt;</div><div class="line">      System.out.println(<span class="string">"[Global Error] "</span> + message.body()));</div><div class="line"></div><div class="line">    JsonObject data = <span class="keyword">new</span> JsonObject()</div><div class="line">      .put(<span class="string">"title"</span>, <span class="string">"Learning Vert.x"</span>)</div><div class="line">      .put(<span class="string">"content"</span>, <span class="string">"core"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 准备学习Vert.x，爽！</span></div><div class="line">    Job j = kue.createJob(<span class="string">"learn vertx"</span>, data)</div><div class="line">      .priority(Priority.HIGH)</div><div class="line">      .onComplete(r -&gt; &#123; <span class="comment">// 完成任务事件监听</span></div><div class="line">        System.out.println(<span class="string">"Feeling: "</span> + r.getResult().getString(<span class="string">"feeling"</span>, <span class="string">"none"</span>));</div><div class="line">    &#125;).onFailure(r -&gt; &#123; <span class="comment">// 任务失败事件监听</span></div><div class="line">        System.out.println(<span class="string">"eee...so difficult..."</span>);</div><div class="line">    &#125;).onProgress(r -&gt; &#123; <span class="comment">// 任务进度变更事件监听</span></div><div class="line">        System.out.println(<span class="string">"I love this! My progress =&gt; "</span> + r);</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 保存任务</span></div><div class="line">    j.save().setHandler(r0 -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r0.succeeded()) &#123;</div><div class="line">        <span class="comment">// 开始学习！</span></div><div class="line">        kue.processBlocking(<span class="string">"learn vertx"</span>, <span class="number">1</span>, job -&gt; &#123;</div><div class="line">          job.progress(<span class="number">10</span>, <span class="number">100</span>);</div><div class="line">          <span class="comment">// 3秒速成</span></div><div class="line">          vertx.setTimer(<span class="number">3000</span>, r1 -&gt; &#123;</div><div class="line">            job.setResult(<span class="keyword">new</span> JsonObject().put(<span class="string">"feeling"</span>, <span class="string">"amazing and wonderful!"</span>)) <span class="comment">// 结果</span></div><div class="line">              .done(); <span class="comment">// 完成啦！</span></div><div class="line">          &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.err.println(<span class="string">"Wow, something happened: "</span> + r0.cause().getMessage());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常情况下，一个Vert.x Kue应用可以分为几部分：创建工作队列、创建任务、保存任务以及处理任务。我们推荐开发者把应用写成<code>Verticle</code>的形式。</p>
<p>在这个例子中，我们要模拟一个学习Vert.x的任务！首先我们通过<code>Kue.createQueue</code>方法创建一个工作队列并且通过<code>on(error, handler)</code>方法监听全局错误(<code>error</code>)事件。接着我们通过<code>kue.createJob</code>方法创建学习任务，将优先级设定为<code>HIGH</code>，并且监听<code>complete</code>、<code>failed</code>以及<code>progress</code>事件。然后我们需要保存任务，保存完毕以后我们就可以通过<code>processBlocking</code>方法来执行耗时任务了。在处理逻辑中，我们首先通过<code>job.progress</code>方法将进度设为<code>10</code>，然后使用<code>vertx.setTimer</code>方法设一个3秒的定时器，定时器时间到以后赋予结果并完成任务。</p>
<p>像往常一样，我们还需要在<code>build.gradle</code>中配置一下。我们需要将<code>kue-example</code>子工程中的<code>Main-Verticle</code>属性设为刚才写的<code>io.vertx.blueprint.kue.example.LearningVertxVerticle</code>：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">project</span>(<span class="string">"kue-example"</span>) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jar &#123;</div><div class="line">    archiveName = <span class="string">'vertx-blueprint-kue-example.jar'</span></div><div class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">    manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.example.LearningVertxVerticle'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，到了展示时间了！打开终端，构建项目：</p>
<pre><code><span class="title">gradle</span> build
</code></pre><p>当然不要忘记运行Redis：</p>
<pre><code>redis-<span class="keyword">server</span>
</code></pre><p>然后我们先运行Vert.x Kue Core部分：</p>
<pre><code>java -jar kue-core<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-core.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>然后再运行我们的实例：</p>
<pre><code>java -jar kue-example<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-example.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>这时终端应该会依次显示输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">INFO: Kue Verticle is running...</div><div class="line">I love this! My progress =&gt; 10</div><div class="line">Feeling: amazing and wonderful!</div></pre></td></tr></table></figure>
<p>当然你也可以在Vert.x Kue的Web端查看任务情况。</p>
<h1 id="完成我们的探索之旅！">完成我们的探索之旅！</h1><p>棒极了！我们终于结束了我们的Vert.x Kue核心部分探索之旅～～！从这篇超长的教程中，你学到了如何利用Vert.x去开发一个基于消息的应用！太酷了！</p>
<p>如果想了解<code>kue-http</code>的实现，请移步<a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/">Vert.x 蓝图 | Vert.x Kue 教程（Web部分）</a>。如果想了解更多的关于Vert.x Kue的特性，请移步<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">Vert.x Kue 特性介绍</a>。</p>
<p>Vert.x能做的不仅仅是这些。想要了解更多的关于Vert.x的知识，请参考<a href="http://vertx.io/docs/" target="_blank" rel="external">Vert.x 官方文档</a> —— 这永远是资料最齐全的地方。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程]]></title>
      <url>http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/</url>
      <content type="html"><![CDATA[<p>本文章是 <a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x 蓝图系列</a> 的第一篇教程。全系列：</p>
<ul>
<li>Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程</a></li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践</a></li>
</ul>
<h1 id="前言">前言</h1><p>在本教程中，我们会使用Vert.x来一步一步地开发一个REST风格的Web服务 - Todo Backend，你可以把它看作是一个简单的待办事项服务，我们可以自由添加或者取消各种待办事项。</p>
<p>通过本教程，你将会学习到以下的内容：</p>
<ul>
<li><strong>Vert.x</strong> 是什么，以及其基本设计思想</li>
<li><code>Verticle</code>是什么，以及如何使用<code>Verticle</code></li>
<li>如何用 <strong>Vert.x Web</strong> 来开发REST风格的Web服务</li>
<li><strong>异步编程风格</strong> 的应用</li>
<li>如何通过 Vert.x 的各种组件来进行数据的存储操作（如 <em>Redis</em> 和 <em>MySQL</em>）</li>
</ul>
<p>本教程是 <strong>Vert.x 蓝图系列</strong> 的第一篇教程，对应的Vert.x版本为<strong>3.3.3</strong>。本教程中的完整代码已托管至<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/tree/master" target="_blank" rel="external">GitHub</a>。</p>
<h1 id="踏入Vert-x之门">踏入Vert.x之门</h1><p>朋友，欢迎来到Vert.x的世界！初次听说Vert.x，你一定会非常好奇：这是啥？让我们来看一下Vert.x的官方解释：</p>
<blockquote>
<p>Vert.x is a tool-kit for building reactive applications on the JVM.</p>
</blockquote>
<p>(⊙o⊙)哦哦。。。翻译一下，Vert.x是一个在JVM上构建 <strong>响应式</strong> 应用的 <strong>工具集</strong> 。这个定义比较模糊，我们来简单解释一下：<strong>工具集</strong> 意味着Vert.x非常轻量，可以嵌入到你当前的应用中而不需要改变现有的结构；另一个重要的描述是 <strong>响应式</strong> —— Vert.x就是为构建响应式应用（系统）而设计的。响应式系统这个概念在 <a href="http://reactivemanifesto.org/" target="_blank" rel="external">Reactive Manifesto</a> 中有详细的定义。我们在这里总结4个要点：</p>
<ul>
<li>响应式的(Responsive)：一个响应式系统需要在 <em>合理</em> 的时间内处理请求。</li>
<li>弹性的(Resilient)：一个响应式系统必须在遇到 <em>异常</em> （崩溃，超时， <code>500</code> 错误等等）的时候保持响应的能力，所以它必须要为 <em>异常处理</em> 而设计。</li>
<li>可伸缩的(Elastic)：一个响应式系统必须在不同的负载情况下都要保持响应能力，所以它必须能伸能缩，并且可以利用最少的资源来处理负载。</li>
<li>消息驱动：一个响应式系统的各个组件之间通过 <strong>异步消息传递</strong> 来进行交互。</li>
</ul>
<p>Vert.x是 <strong>事件驱动的</strong>，同时也是非阻塞的。首先，我们来介绍 <strong>Event Loop</strong> 的概念。Event Loop是一组负责分发和处理事件的线程。注意，我们绝对不能去阻塞Event Loop线程，否则事件的处理过程会被阻塞，我们的应用就失去了响应能力。因此当我们在写Vert.x应用的时候，我们要时刻谨记 <strong>异步非阻塞开发模式</strong> 而不是传统的阻塞开发模式。我们将会在下面详细讲解异步非阻塞开发模式。</p>
<h1 id="我们的应用_-_待办事项服务">我们的应用 - 待办事项服务</h1><p>我们的应用是一个REST风格的待办事项服务，它非常简单，整个API其实就围绕着 <em>增删改查</em> 四种操作。所以我们可以设计以下的路由：</p>
<ul>
<li>添加待办事项: <code>POST /todos</code></li>
<li>获取某一待办事项: <code>GET /todos/:todoId</code></li>
<li>获取所有待办事项: <code>GET /todos</code></li>
<li>更新待办事项: <code>PATCH /todos/:todoId</code></li>
<li>删除某一待办事项: <code>DELETE /todos/:todoId</code></li>
<li>删除所有待办事项: <code>DELETE /todos</code></li>
</ul>
<p>注意我们这里不讨论REST风格API的设计规范（仁者见仁,智者见智），因此你也可以用你喜欢的方式去定义路由。</p>
<p>下面我们开始开发我们的项目！High起来～～～</p>
<h1 id="说干就干！">说干就干！</h1><p>Vert.x Core提供了一些较为底层的处理HTTP请求的功能，这对于Web开发来说不是很方便，因为我们通常不需要这么底层的功能，因此<a href="http://vertx.io/docs/vertx-web/java" target="_blank" rel="external">Vert.x Web</a>应运而生。Vert.x Web基于Vert.x Core，并且提供一组更易于创建Web应用的上层功能（如路由）。</p>
<h2 id="Gradle配置文件">Gradle配置文件</h2><p>首先我们先来创建我们的项目。在本教程中我们使用<strong>Gradle</strong>作为构建工具，当然你也可以使用其它诸如Maven之类的构建工具。我们的项目目录里需要有：</p>
<ol>
<li><code>src/main/java</code> 文件夹（源码目录）</li>
<li><code>src/test/java</code> 文件夹（测试目录）</li>
<li><code>build.gradle</code> 文件（Gradle配置文件）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── build.gradle</div><div class="line">├── settings.gradle</div><div class="line">├── src</div><div class="line">│   ├── main</div><div class="line">│   │   └── java</div><div class="line">│   └── test</div><div class="line">│       └── java</div></pre></td></tr></table></figure>
<p>我们首先来创建 <code>build.gradle</code> 文件，这是Gradle对应的配置文件：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></div><div class="line"></div><div class="line">targetCompatibility = <span class="number">1.8</span></div><div class="line">sourceCompatibility = <span class="number">1.8</span></div><div class="line"></div><div class="line">repositories &#123;</div><div class="line">  jcenter()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line"></div><div class="line">  compile <span class="string">"io.vertx:vertx-core:3.3.3"</span></div><div class="line">  compile <span class="string">'io.vertx:vertx-web:3.3.3'</span></div><div class="line"></div><div class="line">  testCompile <span class="string">'io.vertx:vertx-unit:3.3.3'</span></div><div class="line">  testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能不是很熟悉Gradle，这不要紧。我们来解释一下：</p>
<ul>
<li>我们将 <code>targetCompatibility</code> 和 <code>sourceCompatibility</code> 这两个值都设为<strong>1.8</strong>，代表目标Java版本是Java 8。这非常重要，因为Vert.x就是基于Java 8构建的。</li>
<li>在<code>dependencies</code>中，我们声明了我们需要的依赖。<code>vertx-core</code> 和 <code>vert-web</code> 用于开发REST API。</li>
</ul>
<p>搞定<code>build.gradle</code>以后，我们开始写代码！</p>
<h2 id="待办事项对象">待办事项对象</h2><p>首先我们需要创建我们的数据实体对象 - <code>Todo</code> 实体。在<code>io.vertx.blueprint.todolist.entity</code>包下创建<code>Todo</code>类，并且编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.entity;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.codegen.annotations.DataObject;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@DataObject</span>(generateConverter = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger acc = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">// counter</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">  <span class="keyword">private</span> String title;</div><div class="line">  <span class="keyword">private</span> Boolean completed;</div><div class="line">  <span class="keyword">private</span> Integer order;</div><div class="line">  <span class="keyword">private</span> String url;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(Todo other)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = other.id;</div><div class="line">    <span class="keyword">this</span>.title = other.title;</div><div class="line">    <span class="keyword">this</span>.completed = other.completed;</div><div class="line">    <span class="keyword">this</span>.order = other.order;</div><div class="line">    <span class="keyword">this</span>.url = other.url;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(JsonObject obj)</span> </span>&#123;</div><div class="line">    TodoConverter.fromJson(obj, <span class="keyword">this</span>); <span class="comment">// 还未生成Converter的时候需要先注释掉，生成过后再取消注释</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(String jsonStr)</span> </span>&#123;</div><div class="line">    TodoConverter.fromJson(<span class="keyword">new</span> JsonObject(jsonStr), <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Todo</span><span class="params">(<span class="keyword">int</span> id, String title, Boolean completed, Integer order, String url)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">    <span class="keyword">this</span>.completed = completed;</div><div class="line">    <span class="keyword">this</span>.order = order;</div><div class="line">    <span class="keyword">this</span>.url = url;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> JsonObject <span class="title">toJson</span><span class="params">()</span> </span>&#123;</div><div class="line">    JsonObject json = <span class="keyword">new</span> JsonObject();</div><div class="line">    TodoConverter.toJson(<span class="keyword">this</span>, json);</div><div class="line">    <span class="keyword">return</span> json;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIncId</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = acc.incrementAndGet();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIncId</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> acc.get();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setIncIdWith</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    acc.set(n);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> title;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">isCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getOrElse(completed, <span class="keyword">false</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompleted</span><span class="params">(Boolean completed)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.completed = completed;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getOrElse(order, <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(Integer order)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.order = order;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> url;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.url = url;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    Todo todo = (Todo) o;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (id != todo.id) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (!title.equals(todo.title)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (completed != <span class="keyword">null</span> ? !completed.equals(todo.completed) : todo.completed != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">return</span> order != <span class="keyword">null</span> ? order.equals(todo.order) : todo.order == <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = id;</div><div class="line">    result = <span class="number">31</span> * result + title.hashCode();</div><div class="line">    result = <span class="number">31</span> * result + (completed != <span class="keyword">null</span> ? completed.hashCode() : <span class="number">0</span>);</div><div class="line">    result = <span class="number">31</span> * result + (order != <span class="keyword">null</span> ? order.hashCode() : <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Todo -&gt; &#123;"</span> +</div><div class="line">      <span class="string">"id="</span> + id +</div><div class="line">      <span class="string">", title='"</span> + title + <span class="string">'\''</span> +</div><div class="line">      <span class="string">", completed="</span> + completed +</div><div class="line">      <span class="string">", order="</span> + order +</div><div class="line">      <span class="string">", url='"</span> + url + <span class="string">'\''</span> +</div><div class="line">      <span class="string">'&#125;'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getOrElse</span><span class="params">(T value, T defaultValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? defaultValue : value;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Todo <span class="title">merge</span><span class="params">(Todo todo)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Todo(id,</div><div class="line">      getOrElse(todo.title, title),</div><div class="line">      getOrElse(todo.completed, completed),</div><div class="line">      getOrElse(todo.order, order),</div><div class="line">      url);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的 <code>Todo</code> 实体对象由序号<code>id</code>、标题<code>title</code>、次序<code>order</code>、地址<code>url</code>以及代表待办事项是否完成的一个标识<code>complete</code>组成。我们可以把它看作是一个简单的Java Bean。它可以被编码成JSON格式的数据，我们在后边会大量使用JSON（事实上，在Vert.x中JSON非常普遍）。同时注意到我们给<code>Todo</code>类加上了一个注解：<code>@DataObject</code>，这是用于生成JSON转换类的注解。</p>
<blockquote>
<p><code>@DataObject</code> 注解</p>
<p>被 <code>@DataObject</code> 注解的实体类需要满足以下条件：拥有一个拷贝构造函数以及一个接受一个 <code>JsonObject</code> 对象的构造函数。</p>
</blockquote>
<p>我们利用Vert.x Codegen来自动生成JSON转换类。我们需要在<code>build.gradle</code>中添加依赖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compileOnly <span class="string">'io.vertx:vertx-codegen:3.3.3'</span></div></pre></td></tr></table></figure>
<p>由于Vert.x Codegen仅在编译期生成代码，因此我们这里使用了<code>compileOnly</code>(相当于Maven中的<code>provided</code>。需要Gradle 2.12及以上版本)。同时，我们需要在<code>io.vertx.blueprint.todolist.entity</code>包中添加<code>package-info.java</code>文件来指引Vert.x Codegen生成代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Indicates that this module contains classes that need to be generated / processed.</div><div class="line"> */</div><div class="line"><span class="meta">@ModuleGen</span>(name = <span class="string">"vertx-blueprint-todo-entity"</span>, groupPackage = <span class="string">"io.vertx.blueprint.todolist.entity"</span>)</div><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.entity;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.codegen.annotations.ModuleGen;</div></pre></td></tr></table></figure>
<p>Vert.x Codegen本质上是一个注解处理器(annotation processing tool)，因此我们还需要在<code>build.gradle</code>中配置apt。往里面添加以下代码：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</div><div class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</div><div class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">  <span class="keyword">options</span>.compilerArgs = [</div><div class="line">    <span class="string">"-proc:only"</span>,</div><div class="line">    <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</div><div class="line">    <span class="string">"-AoutputDirectory=$&#123;destinationDir.absolutePath&#125;"</span></div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">sourceSets</span> &#123;</div><div class="line">  main &#123;</div><div class="line">    java &#123;</div><div class="line">      srcDirs += <span class="string">'src/main/generated'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">compileJava &#123;</div><div class="line">  <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">  <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line"></div><div class="line">  dependsOn annotationProcessing</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，每次我们在编译项目的时候，Vert.x Codegen都会自动检测含有 <code>@DataObject</code> 注解的类并且根据配置生成JSON转换类。在本例中，我们应该会得到一个 <code>TodoConverter</code> 类，然后我们可以在<code>Todo</code>类中使用它。</p>
<h2 id="Verticle">Verticle</h2><p>下面我们来写我们的应用组件。在<code>io.vertx.blueprint.todolist.verticles</code>包中创建<code>SingleApplicationVerticle</code>类，并编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.verticles;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</div><div class="line"><span class="keyword">import</span> io.vertx.redis.RedisOptions;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleApplicationVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_HOST = <span class="string">"0.0.0.0"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_HOST = <span class="string">"127.0.0.1"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_PORT = <span class="number">8082</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REDIS_PORT = <span class="number">6379</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> RedisClient redis;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      <span class="comment">// TODO with start...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的<code>SingleApplicationVerticle</code>类继承了<code>AbstractVerticle</code>抽象类。那么什么是 <code>Verticle</code> 呢？在Vert.x中，一个<code>Verticle</code>代表应用的某一组件。我们可以通过部署<code>Verticle</code>来运行这些组件。如果你了解 <strong>Actor</strong> 模型的话，你会发现它和Actor非常类似。</p>
<p>当<code>Verticle</code>被部署的时候，其<code>start</code>方法会被调用。我们注意到这里的<code>start</code>方法接受一个类型为<code>Future&lt;Void&gt;</code>的参数，这代表了这是一个异步的初始化方法。这里的<code>Future</code>代表着<code>Verticle</code>的初始化过程是否完成。你可以通过调用Future的<code>complete</code>方法来代表初始化过程完成，或者<code>fail</code>方法代表初始化过程失败。</p>
<p>现在我们<code>Verticle</code>的轮廓已经搞好了，那么下一步也就很明了了 - 创建HTTP Client并且配置路由，处理HTTP请求。</p>
<h1 id="Vert-x_Web与REST_API">Vert.x Web与REST API</h1><h2 id="创建HTTP服务端并配置路由">创建HTTP服务端并配置路由</h2><p>我们来给<code>start</code>方法加点东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  initData();</div><div class="line">  Router router = Router.router(vertx); <span class="comment">// &lt;1&gt;</span></div><div class="line">  <span class="comment">// CORS support</span></div><div class="line">  Set&lt;String&gt; allowHeaders = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">  allowHeaders.add(<span class="string">"x-requested-with"</span>);</div><div class="line">  allowHeaders.add(<span class="string">"Access-Control-Allow-Origin"</span>);</div><div class="line">  allowHeaders.add(<span class="string">"origin"</span>);</div><div class="line">  allowHeaders.add(<span class="string">"Content-Type"</span>);</div><div class="line">  allowHeaders.add(<span class="string">"accept"</span>);</div><div class="line">  Set&lt;HttpMethod&gt; allowMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">  allowMethods.add(HttpMethod.GET);</div><div class="line">  allowMethods.add(HttpMethod.POST);</div><div class="line">  allowMethods.add(HttpMethod.DELETE);</div><div class="line">  allowMethods.add(HttpMethod.PATCH);</div><div class="line"></div><div class="line">  router.route().handler(CorsHandler.create(<span class="string">"*"</span>) <span class="comment">// &lt;2&gt;</span></div><div class="line">    .allowedHeaders(allowHeaders)</div><div class="line">    .allowedMethods(allowMethods));</div><div class="line">  router.route().handler(BodyHandler.create()); <span class="comment">// &lt;3&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">// <span class="doctag">TODO:</span>routes</span></div><div class="line"></div><div class="line">  vertx.createHttpServer() <span class="comment">// &lt;4&gt;</span></div><div class="line">    .requestHandler(router::accept)</div><div class="line">    .listen(PORT, HOST, result -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (result.succeeded())</div><div class="line">          future.complete();</div><div class="line">        <span class="keyword">else</span></div><div class="line">          future.fail(result.cause());</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(⊙o⊙)…一长串代码诶。。是不是看着很晕呢？我们来详细解释一下。</p>
<p>首先我们创建了一个 <code>Router</code> 实例 （1）。这里的<code>Router</code>代表路由器，相信做过Web开发的开发者们一定不会陌生。路由器负责将对应的HTTP请求分发至对应的处理逻辑（Handler）中。每个<code>Handler</code>负责处理请求并且写入回应结果。当HTTP请求到达时，对应的<code>Handler</code>会被调用。</p>
<p>然后我们创建了两个<code>Set</code>：<code>allowHeaders</code>和<code>allowMethods</code>，并且我们向里面添加了一些HTTP Header以及HTTP Method，然后我们给路由器绑定了一个<code>CorsHandler</code> （2）。<code>route()</code>方法（无参数）代表此路由匹配所有请求。这两个<code>Set</code>的作用是支持 <em>CORS</em>，因为我们的API需要开启CORS以便配合前端正常工作。有关CORS的详细内容我们就不在这里细说了，详情可以参考<a href="http://enable-cors.org/server.html" target="_blank" rel="external">这里</a>。我们这里只需要知道如何开启CORS支持即可。</p>
<p>接下来我们给路由器绑定了一个全局的<code>BodyHandler</code> （3），它的作用是处理HTTP请求正文并获取其中的数据。比如，在实现添加待办事项逻辑的时候，我们需要读取请求正文中的JSON数据，这时候我们就可以用<code>BodyHandler</code>。</p>
<p>最后，我们通过<code>vertx.createHttpServer()</code>方法来创建一个HTTP服务端 （4）。注意这个功能是Vert.x Core提供的底层功能之一。然后我们将我们的路由处理器绑定到服务端上，这也是Vert.x Web的核心。你可能不熟悉<code>router::accept</code>这样的表示，这是Java 8中的 <em>方法引用</em>，它相当于一个分发路由的<code>Handler</code>。当有请求到达时，Vert.x会调用<code>accept</code>方法。然后我们通过<code>listen</code>方法监听8082端口。因为创建服务端的过程可能失败，因此我们还需要给<code>listen</code>方法传递一个<code>Handler</code>来检查服务端是否创建成功。正如我们前面所提到的，我们可以使用<code>future.complete</code>来表示过程成功，或者用<code>future.fail</code>来表示过程失败。</p>
<p>到现在为止，我们已经创建好HTTP服务端了，但我们还没有见到任何的路由呢！不要着急，是时候去声明路由了！</p>
<h2 id="配置路由">配置路由</h2><p>下面我们来声明路由。正如我们之前提到的，我们的路由可以设计成这样：</p>
<ul>
<li>添加待办事项: <code>POST /todos</code></li>
<li>获取某一待办事项: <code>GET /todos/:todoId</code></li>
<li>获取所有待办事项: <code>GET /todos</code></li>
<li>更新待办事项: <code>PATCH /todos/:todoId</code></li>
<li>删除某一待办事项: <code>DELETE /todos/:todoId</code></li>
<li>删除所有待办事项: <code>DELETE /todos</code></li>
</ul>
<blockquote>
<p>路径参数</p>
<p>在URL中，我们可以通过<code>:name</code>的形式定义路径参数。当处理请求的时候，Vert.x会自动获取这些路径参数并允许我们访问它们。拿我们的路由举个例子，<code>/todos/19</code> 将 <code>todoId</code> 映射为 <code>19</code>。</p>
</blockquote>
<p>首先我们先在 <code>io.vertx.blueprint.todolist</code> 包下创建一个<code>Constants</code>类用于存储各种全局常量（当然也可以放到其对应的类中）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Constants</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">/** API Route */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_GET = <span class="string">"/todos/:todoId"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_LIST_ALL = <span class="string">"/todos"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_CREATE = <span class="string">"/todos"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_UPDATE = <span class="string">"/todos/:todoId"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_DELETE = <span class="string">"/todos/:todoId"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_DELETE_ALL = <span class="string">"/todos"</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们将<code>start</code>方法中的<code>TODO</code>标识处替换为以下的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// routes</span></div><div class="line">router.get(Constants.API_GET).handler(<span class="keyword">this</span>::handleGetTodo);</div><div class="line">router.get(Constants.API_LIST_ALL).handler(<span class="keyword">this</span>::handleGetAll);</div><div class="line">router.post(Constants.API_CREATE).handler(<span class="keyword">this</span>::handleCreateTodo);</div><div class="line">router.patch(Constants.API_UPDATE).handler(<span class="keyword">this</span>::handleUpdateTodo);</div><div class="line">router.delete(Constants.API_DELETE).handler(<span class="keyword">this</span>::handleDeleteOne);</div><div class="line">router.delete(Constants.API_DELETE_ALL).handler(<span class="keyword">this</span>::handleDeleteAll);</div></pre></td></tr></table></figure>
<p>代码很直观、明了。我们用对应的方法（如<code>get</code>,<code>post</code>,<code>patch</code>等等）将路由路径与路由器绑定，并且我们调用<code>handler</code>方法给每个路由绑定上对应的<code>Handler</code>，接受的<code>Handler</code>类型为<code>Handler&lt;RoutingContext&gt;</code>。这里我们分别绑定了六个方法引用，它们的形式都类似于这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将在稍后实现这六个方法，这也是我们待办事项服务逻辑的核心。</p>
<h2 id="异步方法模式">异步方法模式</h2><p>我们之前提到过，Vert.x是 <strong>异步、非阻塞的</strong> 。每一个异步的方法总会接受一个 <code>Handler</code> 参数作为回调函数，当对应的操作完成时会调用接受的<code>Handler</code>，这是异步方法的一种实现。还有一种等价的实现是返回<code>Future</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAsync</span><span class="params">(A a, B b, Handler&lt;R&gt; handler)</span></span>;</div><div class="line"><span class="comment">// 这两种实现等价</span></div><div class="line"><span class="function">Future&lt;R&gt; <span class="title">doAsync</span><span class="params">(A a, B b)</span></span>;</div></pre></td></tr></table></figure>
<p>其中，<code>Future</code> 对象代表着一个操作的结果，这个操作可能还没有进行，可能正在进行，可能成功也可能失败。当操作完成时，<code>Future</code>对象会得到对应的结果。我们也可以通过<code>setHandler</code>方法给<code>Future</code>绑定一个<code>Handler</code>，当<code>Future</code>被赋予结果的时候，此<code>Handler</code>会被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Future&lt;R&gt; future = doAsync(A a, B b);</div><div class="line">future.setHandler(r -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">        <span class="comment">// 处理失败</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 操作结果</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Vert.x中大多数异步方法都是基于Handler的。而在本教程中，这两种异步模式我们都会接触到。</p>
<h2 id="待办事项逻辑实现">待办事项逻辑实现</h2><p>现在是时候来实现我们的待办事项业务逻辑了！这里我们使用 Redis 作为数据持久化存储。有关Redis的详细介绍请参照<a href="http://redis.io/" target="_blank" rel="external">Redis 官方网站</a>。Vert.x给我们提供了一个组件—— Vert.x-redis，允许我们以异步的形式操作Redis数据。</p>
<blockquote>
<p>如何安装Redis？</p>
<p>请参照Redis官方网站上详细的<a href="http://redis.io/download#installation" target="_blank" rel="external">安装指南</a>。</p>
</blockquote>
<h3 id="Vert-x_Redis">Vert.x Redis</h3><p>Vert.x Redis允许我们以异步的形式操作Redis数据。我们首先需要在<code>build.gradle</code>中添加以下依赖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> <span class="string">'io.vertx:vertx-redis-client:3.3.3'</span></div></pre></td></tr></table></figure>
<p>我们通过<code>RedisClient</code>对象来操作Redis中的数据，因此我们定义了一个类成员<code>redis</code>。在使用<code>RedisClient</code>之前，我们首先需要与Redis建立连接，并且需要配置（以<code>RedisOptions</code>的形式），后边我们再讲需要配置哪些东西。</p>
<p>我们来实现 <code>initData</code> 方法用于初始化 <code>RedisClient</code> 并且测试连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">  RedisOptions config = <span class="keyword">new</span> RedisOptions()</div><div class="line">      .setHost(config().getString(<span class="string">"redis.host"</span>, REDIS_HOST)) <span class="comment">// redis host</span></div><div class="line">      .setPort(config().getInteger(<span class="string">"redis.port"</span>, REDIS_PORT)); <span class="comment">// redis port</span></div><div class="line"></div><div class="line">  <span class="keyword">this</span>.redis = RedisClient.create(vertx, config); <span class="comment">// create redis client</span></div><div class="line"></div><div class="line">  redis.hset(Constants.REDIS_TODO_KEY, <span class="string">"24"</span>, Json.encodePrettily( <span class="comment">// test connection</span></div><div class="line">    <span class="keyword">new</span> Todo(<span class="number">24</span>, <span class="string">"Something to do..."</span>, <span class="keyword">false</span>, <span class="number">1</span>, <span class="string">"todo/ex"</span>)), res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.failed()) &#123;</div><div class="line">      LOGGER.error(<span class="string">"Redis service is not running!"</span>);</div><div class="line">      res.cause().printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们在加载Verticle的时候，我们会首先调用<code>initData</code>方法，这样可以保证<code>RedisClient</code>可以被正常创建。</p>
<h3 id="存储格式">存储格式</h3><p>我们知道，Redis支持各种格式的数据，并且支持多种方式存储（如<code>list</code>、<code>hash map</code>等）。这里我们将我们的待办事项存储在 <em>哈希表(map)</em> 中。我们使用待办事项的<code>id</code>作为key，JSON格式的待办事项数据作为value。同时，我们的哈希表本身也要有个key，我们把它命名为 <em>VERT_TODO</em>，并且存储到<code>Constants</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_TODO_KEY = <span class="string">"VERT_TODO"</span>;</div></pre></td></tr></table></figure>
<p>正如我们之前提到的，我们利用了生成的JSON数据转换类来实现<code>Todo</code>实体与JSON数据之间的转换（通过几个构造函数），在后面实现待办事项服务的时候可以广泛利用。</p>
<h3 id="获取/获取所有待办事项">获取/获取所有待办事项</h3><p>我们首先来实现获取待办事项的逻辑。正如我们之前所提到的，我们的处理逻辑方法需要接受一个<code>RoutingContext</code>类型的参数。我们看一下获取某一待办事项的逻辑方法(<code>handleGetTodo</code>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>); <span class="comment">// (1)</span></div><div class="line">  <span class="keyword">if</span> (todoID == <span class="keyword">null</span>)</div><div class="line">    sendError(<span class="number">400</span>, context.response()); <span class="comment">// (2)</span></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    redis.hget(Constants.REDIS_TODO_KEY, todoID, x -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">      <span class="keyword">if</span> (x.succeeded()) &#123;</div><div class="line">        String result = x.result();</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</div><div class="line">          sendError(<span class="number">404</span>, context.response());</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          context.response()</div><div class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">            .end(result); <span class="comment">// (4)</span></div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span></div><div class="line">        sendError(<span class="number">503</span>, context.response());</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们先通过<code>getParam</code>方法获取路径参数<code>todoId</code> (1)。我们需要检测路径参数获取是否成功，如果不成功就返回 <code>400 Bad Request</code> 错误 (2)。这里我们写一个函数封装返回错误response的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> statusCode, HttpServerResponse response)</span> </span>&#123;</div><div class="line">  response.setStatusCode(statusCode).end();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面，<code>end</code>方法是非常重要的。只有我们调用<code>end</code>方法时，对应的HTTP Response才能被发送回客户端。</p>
<p>再回到<code>handleGetTodo</code>方法中。如果我们成功获取到了<code>todoId</code>，我们可以通过<code>hget</code>操作从Redis中获取对应的待办事项 (3)。<code>hget</code>代表通过key从对应的哈希表中获取对应的value，我们来看一下<code>hget</code>函数的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">RedisClient <span class="title">hget</span><span class="params">(String key, String field, Handler&lt;AsyncResult&lt;String&gt;&gt; handler)</span></span>;</div></pre></td></tr></table></figure>
<p>第一个参数<code>key</code>对应哈希表的key，第二个参数<code>field</code>代表待办事项的key，第三个参数代表当获取操作成功时对应的回调。在<code>Handler</code>中，我们首先检查操作是否成功，如果不成功就返回<code>503</code>错误。如果成功了，我们就可以获取操作的结果了。结果是<code>null</code>的话，说明Redis中没有对应的待办事项，因此我们返回<code>404 Not Found</code>代表不存在。如果结果存在，那么我们就可以通过<code>end</code>方法将其写入response中 (4)。注意到我们所有的RESTful API都返回JSON格式的数据，所以我们将<code>content-type</code>头设为<code>JSON</code>。</p>
<p>获取所有待办事项的逻辑<code>handleGetAll</code>与<code>handleGetTodo</code>大体上类似，但实现上有些许不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  redis.hvals(Constants.REDIS_TODO_KEY, res -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      String encoded = Json.encodePrettily(res.result().stream() <span class="comment">// (2)</span></div><div class="line">        .map(x -&gt; <span class="keyword">new</span> Todo((String) x))</div><div class="line">        .collect(Collectors.toList()));</div><div class="line">      context.response()</div><div class="line">        .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">        .end(encoded); <span class="comment">// (3)</span></div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">      sendError(<span class="number">503</span>, context.response());</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们通过<code>hvals</code>操作 (1) 来获取某个哈希表中的所有数据（以JSON数组的形式返回，即<code>JsonArray</code>对象）。在Handler中我们还是像之前那样先检查操作是否成功。如果成功的话我们就可以将结果写入response了。注意这里我们不能直接将返回的<code>JsonArray</code>写入response。想象一下返回的<code>JsonArray</code>包括着待办事项的key以及对应的JSON数据（字符串形式），因此此时每个待办事项对应的JSON数据都被转义了，所以我们需要先把这些转义过的JSON数据转换成实体对象，再重新编码。</p>
<p>我们这里采用了一种响应式编程思想的方法。首先我们了解到<code>JsonArray</code>类继承了<code>Iterable&lt;Object&gt;</code>接口（是不是感觉它很像<code>List</code>呢？），因此我们可以通过<code>stream</code>方法将其转化为<code>Stream</code>对象。注意这里的<code>Stream</code>可不是传统意义上讲的输入输出流(I/O stream)，而是数据流(data flow)。我们需要对数据流进行一系列的变换处理操作，这就是响应式编程的思想（也有点函数式编程的思想）。我们将数据流中的每个字符串数据转换为<code>Todo</code>实体对象，这个过程是通过<code>map</code>算子实现的。我们这里就不深入讨论<code>map</code>算子了，但它在函数式编程中非常重要。在<code>map</code>过后，我们通过<code>collect</code>方法将数据流“归约”成<code>List&lt;Todo&gt;</code>。现在我们就可以通过<code>Json.encodePrettily</code>方法对得到的list进行编码了，转换成JSON格式的数据。最后我们将转换后的结果写入到response中 (3)。</p>
<h3 id="创建待办事项">创建待办事项</h3><p>经过了上面两个业务逻辑实现的过程，你应该开始熟悉Vert.x了～现在我们来实现创建待办事项的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">final</span> Todo todo = wrapObject(<span class="keyword">new</span> Todo(context.getBodyAsString()), context);</div><div class="line">    <span class="keyword">final</span> String encoded = Json.encodePrettily(todo);</div><div class="line">    redis.hset(Constants.REDIS_TODO_KEY, String.valueOf(todo.getId()),</div><div class="line">      encoded, res -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (res.succeeded())</div><div class="line">          context.response()</div><div class="line">            .setStatusCode(<span class="number">201</span>)</div><div class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">            .end(encoded);</div><div class="line">        <span class="keyword">else</span></div><div class="line">          sendError(<span class="number">503</span>, context.response());</div><div class="line">      &#125;);</div><div class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</div><div class="line">    sendError(<span class="number">400</span>, context.response());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们通过<code>context.getBodyAsString()</code>方法来从请求正文中获取JSON数据并转换成<code>Todo</code>实体对象 (1)。这里我们包装了一个处理<code>Todo</code>实例的方法，用于给其添加必要的信息（如URL）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Todo <span class="title">wrapObject</span><span class="params">(Todo todo, RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> id = todo.getId();</div><div class="line">  <span class="keyword">if</span> (id &gt; Todo.getIncId()) &#123;</div><div class="line">    Todo.setIncIdWith(id);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)</div><div class="line">    todo.setIncId();</div><div class="line">  todo.setUrl(context.request().absoluteURI() + <span class="string">"/"</span> + todo.getId());</div><div class="line">  <span class="keyword">return</span> todo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于没有ID（或者为默认ID）的待办事项，我们会给它分配一个ID。这里我们采用了自增ID的策略，通过<code>AtomicInteger</code>来实现。</p>
<p>然后我们通过<code>Json.encodePrettily</code>方法将我们的<code>Todo</code>实例再次编码成JSON格式的数据 (2)。接下来我们利用<code>hset</code>函数将待办事项实例插入到对应的哈希表中 (3)。如果插入成功，返回 <code>201</code> 状态码 (4)。</p>
<p>[NOTE 201 状态码? | 正如你所看到的那样，我们将状态码设为<code>201</code>，这代表<code>CREATED</code>（已创建）。另外，如果不指定状态码的话，Vert.x Web默认将状态码设为 <code>200 OK</code>。]</p>
<p>同时，我们接收到的HTTP请求首部可能格式不正确，因此我们需要在方法中捕获<code>DecodeException</code>异常。这样一旦捕获到<code>DecodeException</code>异常，我们就返回<code>400 Bad Request</code>状态码。</p>
<h3 id="更新待办事项">更新待办事项</h3><p>如果你想改变你的计划，你就需要更新你的待办事项。我们来实现更新待办事项的逻辑，它有点小复杂（或者说是，繁琐？）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PATCH /todos/:todoId</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUpdateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    String todoID = context.request().getParam(<span class="string">"todoId"</span>); <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">final</span> Todo newTodo = <span class="keyword">new</span> Todo(context.getBodyAsString()); <span class="comment">// (2)</span></div><div class="line">    <span class="comment">// handle error</span></div><div class="line">    <span class="keyword">if</span> (todoID == <span class="keyword">null</span> || newTodo == <span class="keyword">null</span>) &#123;</div><div class="line">      sendError(<span class="number">400</span>, context.response());</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    redis.hget(Constants.REDIS_TODO_KEY, todoID, x -&gt; &#123; <span class="comment">// (3)</span></div><div class="line">      <span class="keyword">if</span> (x.succeeded()) &#123;</div><div class="line">        String result = x.result();</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</div><div class="line">          sendError(<span class="number">404</span>, context.response()); <span class="comment">// (4)</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          Todo oldTodo = <span class="keyword">new</span> Todo(result);</div><div class="line">          String response = Json.encodePrettily(oldTodo.merge(newTodo)); <span class="comment">// (5)</span></div><div class="line">          redis.hset(Constants.REDIS_TODO_KEY, todoID, response, res -&gt; &#123; <span class="comment">// (6)</span></div><div class="line">            <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">              context.response()</div><div class="line">                .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">                .end(response); <span class="comment">// (7)</span></div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span></div><div class="line">        sendError(<span class="number">503</span>, context.response());</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</div><div class="line">    sendError(<span class="number">400</span>, context.response());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唔。。。一大长串代码诶。。。我们来看一下。首先我们从 <code>RoutingContext</code> 中获取路径参数 <code>todoId</code> (1)，这是我们想要更改待办事项对应的id。然后我们从请求正文中获取新的待办事项数据 (2)。这一步也有可能抛出 <code>DecodeException</code> 异常因此我们也需要去捕获它。要更新待办事项，我们需要先通过<code>hget</code>函数获取之前的待办事项 (3)，检查其是否存在。获取旧的待办事项之后，我们调用之前在<code>Todo</code>类中实现的<code>merge</code>方法将旧待办事项与新待办事项整合到一起 (5)，然后编码成JSON格式的数据。然后我们通过<code>hset</code>函数更新对应的待办事项 (6)（<code>hset</code>表示如果不存在就插入，存在就更新）。操作成功的话，返回 <code>200 OK</code> 状态。</p>
<p>这就是更新待办事项的逻辑～要有耐心哟，我们马上就要见到胜利的曙光了～下面我们来实现删除待办事项的逻辑。</p>
<h3 id="删除/删除全部待办事项">删除/删除全部待办事项</h3><p>删除待办事项的逻辑非常简单。我们利用<code>hdel</code>函数来删除某一待办事项，用<code>del</code>函数删掉所有待办事项（实际上是直接把那个哈希表给删了）。如果删除操作成功，返回<code>204 No Content</code> 状态。</p>
<p>这里直接给出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteOne</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">  redis.hdel(Constants.REDIS_TODO_KEY, todoID, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded())</div><div class="line">      context.response().setStatusCode(<span class="number">204</span>).end();</div><div class="line">    <span class="keyword">else</span></div><div class="line">      sendError(<span class="number">503</span>, context.response());</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  redis.del(Constants.REDIS_TODO_KEY, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded())</div><div class="line">      context.response().setStatusCode(<span class="number">204</span>).end();</div><div class="line">    <span class="keyword">else</span></div><div class="line">      sendError(<span class="number">503</span>, context.response());</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>啊哈！我们实现待办事项服务的Verticle已经完成咯～一颗赛艇！但是我们该如何去运行我们的<code>Verticle</code>呢？答案是，我们需要 <em>部署并运行</em> 我们的Verticle。还好Vert.x提供了一个运行Verticle的辅助工具：Vert.x Launcher，让我们来看看如何利用它。</p>
<h2 id="将应用与Vert-x_Launcher一起打包">将应用与Vert.x Launcher一起打包</h2><p>要通过Vert.x Launcher来运行Verticle，我们需要在<code>build.gradle</code>中配置一下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jar &#123;</div><div class="line">  <span class="comment">// by default fat jar</span></div><div class="line">  archiveName = <span class="string">'vertx-blueprint-todo-backend-fat.jar'</span></div><div class="line">  <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">  manifest &#123;</div><div class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.todolist.verticles.SingleApplicationVerticle'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在<code>jar</code>区块中，我们配置Gradle使其生成 <strong>fat-jar</strong>，并指定启动类。<em>fat-jar</em> 是一个给Vert.x应用打包的简便方法，它直接将我们的应用连同所有的依赖都给打包到jar包中去了，这样我们可以直接通过jar包运行我们的应用而不必再指定依赖的 <code>CLASSPATH</code></li>
<li>我们将<code>Main-Class</code>属性设为<code>io.vertx.core.Launcher</code>，这样就可以通过Vert.x Launcher来启动对应的Verticle了。另外我们需要将<code>Main-Verticle</code>属性设为我们想要部署的Verticle的类名（全名）。</li>
</ul>
<p>配置好了以后，我们就可以打包了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle build</div></pre></td></tr></table></figure>
<h2 id="运行我们的服务">运行我们的服务</h2><p>万事俱备，只欠东风。是时候运行我们的待办事项服务了！首先我们先启动Redis服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server</div></pre></td></tr></table></figure>
<p>然后运行服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar build/libs/vertx-blueprint-todo-backend-fat.jar</div></pre></td></tr></table></figure>
<p>如果没问题的话，你将会在终端中看到 <code>Succeeded in deploying verticle</code> 的字样。下面我们可以自由测试我们的API了，其中最简便的方法是借助 <a href="https://github.com/TodoBackend/todo-backend-js-spec" target="_blank" rel="external">todo-backend-js-spec</a> 来测试。</p>
<p>键入 <code>http://127.0.0.1:8082/todos</code>：</p>
<p><img src="https://github.com/sczyh30/vertx-blueprint-todo-backend/raw/master/docs/img/todo-test-input.png" alt=""></p>
<p>测试结果：</p>
<p><img src="https://github.com/sczyh30/vertx-blueprint-todo-backend/raw/master/docs/img/todo-test-result.png" alt=""></p>
<p>当然，我们也可以用其它工具，比如 <code>curl</code> ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">sczyh30@sczyh30-workshop:~$ curl http://127.0.0.1:8082/todos</div><div class="line">[ &#123;</div><div class="line">  "id" : 20578623,</div><div class="line">  "title" : "blah",</div><div class="line">  "completed" : false,</div><div class="line">  "order" : 95,</div><div class="line">  "url" : "http://127.0.0.1:8082/todos/20578623"</div><div class="line">&#125;, &#123;</div><div class="line">  "id" : 1744802607,</div><div class="line">  "title" : "blah",</div><div class="line">  "completed" : false,</div><div class="line">  "order" : 523,</div><div class="line">  "url" : "http://127.0.0.1:8082/todos/1744802607"</div><div class="line">&#125;, &#123;</div><div class="line">  "id" : 981337975,</div><div class="line">  "title" : "blah",</div><div class="line">  "completed" : false,</div><div class="line">  "order" : 95,</div><div class="line">  "url" : "http://127.0.0.1:8082/todos/981337975"</div><div class="line">&#125; ]</div></pre></td></tr></table></figure>
<h1 id="将服务与控制器分离">将服务与控制器分离</h1><p>啊哈～我们的待办事项服务已经可以正常运行了，但是回头再来看看 <code>SingleApplicationVerticle</code> 类的代码，你会发现它非常混乱，待办事项业务逻辑与控制器混杂在一起，让这个类非常的庞大，并且这也不利于我们服务的扩展。根据面向对象解耦的思想，我们需要将控制器部分与业务逻辑部分分离。</p>
<h2 id="用Future实现异步服务">用Future实现异步服务</h2><p>下面我们来设计我们的业务逻辑层。就像我们之前提到的那样，我们的服务需要是异步的，因此这些服务的方法要么需要接受一个<code>Handler</code>参数作为回调，要么需要返回一个<code>Future</code>对象。但是想象一下很多个<code>Handler</code>混杂在一起嵌套的情况，你会陷入 <em>回调地狱</em>，这是非常糟糕的。因此，这里我们用<code>Future</code>实现我们的待办事项服务。</p>
<p>在 <code>io.vertx.blueprint.todolist.service</code> 包下创建 <code>TodoService</code> 接口并且编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.entity.Todo;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Optional;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TodoService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">initData</span><span class="params">()</span></span>; <span class="comment">// 初始化数据（或数据库）</span></div><div class="line"></div><div class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">insert</span><span class="params">(Todo todo)</span></span>;</div><div class="line"></div><div class="line">  Future&lt;List&lt;Todo&gt;&gt; getAll();</div><div class="line"></div><div class="line">  Future&lt;Optional&lt;Todo&gt;&gt; getCertain(String todoID);</div><div class="line"></div><div class="line">  <span class="function">Future&lt;Todo&gt; <span class="title">update</span><span class="params">(String todoId, Todo newTodo)</span></span>;</div><div class="line"></div><div class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">delete</span><span class="params">(String todoId)</span></span>;</div><div class="line"></div><div class="line">  <span class="function">Future&lt;Boolean&gt; <span class="title">deleteAll</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到<code>getCertain</code>方法返回一个<code>Future&lt;Optional&lt;Todo&gt;&gt;</code>对象。那么<code>Optional</code>是啥呢？它封装了一个可能为空的对象。因为数据库里面可能没有与我们给定的<code>todoId</code>相对应的待办事项，查询的结果可能为空，因此我们给它包装上 <code>Optional</code>。<code>Optional</code> 可以避免万恶的 <code>NullPointerException</code>，并且它在函数式编程中用途特别广泛（在Haskell中对应 <strong>Maybe Monad</strong>）。</p>
<p>既然我们已经设计好我们的异步服务接口了，让我们来重构原先的Verticle吧！</p>
<h2 id="开始重构！">开始重构！</h2><p>我们创建一个新的Verticle。在 <code>io.vertx.blueprint.todolist.verticles</code> 包中创建 <code>TodoVerticle</code> 类，并编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.verticles;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.Constants;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.entity.Todo;</div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.service.TodoService;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</div><div class="line"><span class="keyword">import</span> io.vertx.core.AsyncResult;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Handler;</div><div class="line"><span class="keyword">import</span> io.vertx.core.http.HttpMethod;</div><div class="line"><span class="keyword">import</span> io.vertx.core.http.HttpServerResponse;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.DecodeException;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.Json;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.web.Router;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.web.RoutingContext;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.web.handler.BodyHandler;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.web.handler.CorsHandler;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"><span class="keyword">import</span> java.util.function.Consumer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"0.0.0.0"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8082</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> TodoService service;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Router router = Router.router(vertx);</div><div class="line">    <span class="comment">// CORS support</span></div><div class="line">    Set&lt;String&gt; allowHeaders = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    allowHeaders.add(<span class="string">"x-requested-with"</span>);</div><div class="line">    allowHeaders.add(<span class="string">"Access-Control-Allow-Origin"</span>);</div><div class="line">    allowHeaders.add(<span class="string">"origin"</span>);</div><div class="line">    allowHeaders.add(<span class="string">"Content-Type"</span>);</div><div class="line">    allowHeaders.add(<span class="string">"accept"</span>);</div><div class="line">    Set&lt;HttpMethod&gt; allowMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    allowMethods.add(HttpMethod.GET);</div><div class="line">    allowMethods.add(HttpMethod.POST);</div><div class="line">    allowMethods.add(HttpMethod.DELETE);</div><div class="line">    allowMethods.add(HttpMethod.PATCH);</div><div class="line"></div><div class="line">    router.route().handler(BodyHandler.create());</div><div class="line">    router.route().handler(CorsHandler.create(<span class="string">"*"</span>)</div><div class="line">      .allowedHeaders(allowHeaders)</div><div class="line">      .allowedMethods(allowMethods));</div><div class="line"></div><div class="line">    <span class="comment">// routes</span></div><div class="line">    router.get(Constants.API_GET).handler(<span class="keyword">this</span>::handleGetTodo);</div><div class="line">    router.get(Constants.API_LIST_ALL).handler(<span class="keyword">this</span>::handleGetAll);</div><div class="line">    router.post(Constants.API_CREATE).handler(<span class="keyword">this</span>::handleCreateTodo);</div><div class="line">    router.patch(Constants.API_UPDATE).handler(<span class="keyword">this</span>::handleUpdateTodo);</div><div class="line">    router.delete(Constants.API_DELETE).handler(<span class="keyword">this</span>::handleDeleteOne);</div><div class="line">    router.delete(Constants.API_DELETE_ALL).handler(<span class="keyword">this</span>::handleDeleteAll);</div><div class="line"></div><div class="line">    vertx.createHttpServer()</div><div class="line">      .requestHandler(router::accept)</div><div class="line">      .listen(PORT, HOST, result -&gt; &#123;</div><div class="line">          <span class="keyword">if</span> (result.succeeded())</div><div class="line">            future.complete();</div><div class="line">          <span class="keyword">else</span></div><div class="line">            future.fail(result.cause());</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    initData();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUpdateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteOne</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">     <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> statusCode, HttpServerResponse response)</span> </span>&#123;</div><div class="line">    response.setStatusCode(statusCode).end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">badRequest</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    context.response().setStatusCode(<span class="number">400</span>).end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notFound</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    context.response().setStatusCode(<span class="number">404</span>).end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceUnavailable</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    context.response().setStatusCode(<span class="number">503</span>).end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Todo <span class="title">wrapObject</span><span class="params">(Todo todo, RoutingContext context)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> id = todo.getId();</div><div class="line">    <span class="keyword">if</span> (id &gt; Todo.getIncId()) &#123;</div><div class="line">      Todo.setIncIdWith(id);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)</div><div class="line">      todo.setIncId();</div><div class="line">    todo.setUrl(context.request().absoluteURI() + <span class="string">"/"</span> + todo.getId());</div><div class="line">    <span class="keyword">return</span> todo;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很熟悉吧？这个<code>Verticle</code>的结构与我们之前的Verticle相类似，这里就不多说了。下面我们来利用我们之前编写的服务接口实现每一个控制器方法。</p>
<p>首先先实现 <code>initData</code> 方法，此方法用于初始化存储结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String serviceType = config().getString(<span class="string">"service.type"</span>, <span class="string">"redis"</span>);</div><div class="line">  LOGGER.info(<span class="string">"Service Type: "</span> + serviceType);</div><div class="line">  <span class="keyword">switch</span> (serviceType) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"jdbc"</span>:</div><div class="line">      service = <span class="keyword">new</span> JdbcTodoService(vertx, config());</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"redis"</span>:</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      RedisOptions config = <span class="keyword">new</span> RedisOptions()</div><div class="line">        .setHost(config().getString(<span class="string">"redis.host"</span>, <span class="string">"127.0.0.1"</span>))</div><div class="line">        .setPort(config().getInteger(<span class="string">"redis.port"</span>, <span class="number">6379</span>));</div><div class="line">      service = <span class="keyword">new</span> RedisTodoService(vertx, config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  service.initData().setHandler(res -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (res.failed()) &#123;</div><div class="line">        LOGGER.error(<span class="string">"Persistence service is not running!"</span>);</div><div class="line">        res.cause().printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们从配置中获取服务的类型，这里我们有两种类型的服务：<code>redis</code>和<code>jdbc</code>，默认是<code>redis</code>。接着我们会根据服务的类型以及对应的配置来创建服务。在这里，我们的配置都是从JSON格式的配置文件中读取，并通过Vert.x Launcher的<code>-conf</code>项加载。后面我们再讲要配置哪些东西。</p>
<p>接着我们给<code>service.initData()</code>方法返回的<code>Future</code>对象绑定了一个<code>Handler</code>，这个<code>Handler</code>将会在<code>Future</code>得到结果的时候被调用。一旦初始化过程失败，错误信息将会显示到终端上。</p>
<p>其它的方法实现也类似，这里就不详细解释了，直接放上代码，非常简洁明了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Wrap the result handler with failure handler (503 Service Unavailable)</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> &lt;T&gt; Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler(RoutingContext context, Consumer&lt;T&gt; consumer) &#123;</div><div class="line">  <span class="keyword">return</span> res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      consumer.accept(res.result());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      serviceUnavailable(context);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">final</span> Todo todo = wrapObject(<span class="keyword">new</span> Todo(context.getBodyAsString()), context);</div><div class="line">    <span class="keyword">final</span> String encoded = Json.encodePrettily(todo);</div><div class="line"></div><div class="line">    service.insert(todo).setHandler(resultHandler(context, res -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (res) &#123;</div><div class="line">        context.response()</div><div class="line">          .setStatusCode(<span class="number">201</span>)</div><div class="line">          .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">          .end(encoded);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serviceUnavailable(context);</div><div class="line">      &#125;</div><div class="line">    &#125;));</div><div class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</div><div class="line">    sendError(<span class="number">400</span>, context.response());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">  <span class="keyword">if</span> (todoID == <span class="keyword">null</span>) &#123;</div><div class="line">    sendError(<span class="number">400</span>, context.response());</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  service.getCertain(todoID).setHandler(resultHandler(context, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (!res.isPresent())</div><div class="line">      notFound(context);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">final</span> String encoded = Json.encodePrettily(res.get());</div><div class="line">      context.response()</div><div class="line">        .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">        .end(encoded);</div><div class="line">    &#125;</div><div class="line">  &#125;));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleGetAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  service.getAll().setHandler(resultHandler(context, res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</div><div class="line">      serviceUnavailable(context);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">final</span> String encoded = Json.encodePrettily(res);</div><div class="line">      context.response()</div><div class="line">        .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">        .end(encoded);</div><div class="line">    &#125;</div><div class="line">  &#125;));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUpdateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    String todoID = context.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">    <span class="keyword">final</span> Todo newTodo = <span class="keyword">new</span> Todo(context.getBodyAsString());</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">    <span class="keyword">if</span> (todoID == <span class="keyword">null</span>) &#123;</div><div class="line">      sendError(<span class="number">400</span>, context.response());</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    service.update(todoID, newTodo)</div><div class="line">      .setHandler(resultHandler(context, res -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>)</div><div class="line">          notFound(context);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">final</span> String encoded = Json.encodePrettily(res);</div><div class="line">          context.response()</div><div class="line">            .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">            .end(encoded);</div><div class="line">        &#125;</div><div class="line">      &#125;));</div><div class="line">  &#125; <span class="keyword">catch</span> (DecodeException e) &#123;</div><div class="line">    badRequest(context);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;Boolean&gt;&gt; deleteResultHandler(RoutingContext context) &#123;</div><div class="line">  <span class="keyword">return</span> res -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">      <span class="keyword">if</span> (res.result()) &#123;</div><div class="line">        context.response().setStatusCode(<span class="number">204</span>).end();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serviceUnavailable(context);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      serviceUnavailable(context);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteOne</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  String todoID = context.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">  service.delete(todoID)</div><div class="line">    .setHandler(deleteResultHandler(context));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeleteAll</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">  service.deleteAll()</div><div class="line">    .setHandler(deleteResultHandler(context));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是和之前的Verticle很相似呢？这里我们还封装了两个<code>Handler</code>生成器：<code>resultHandler</code> 和 <code>deleteResultHandler</code>。这两个生成器封装了一些重复的代码，可以减少代码量。</p>
<p>嗯。。。我们的新Verticle写好了，那么是时候去实现具体的业务逻辑了。这里我们会实现两个版本的业务逻辑，分别对应两种存储：<strong>Redis</strong> 和 <strong>MySQL</strong>。</p>
<h2 id="Vert-x-Redis版本的待办事项服务">Vert.x-Redis版本的待办事项服务</h2><p>之前我们已经实现过一遍Redis版本的服务了，因此你应该对其非常熟悉了。这里我们仅仅解释一个 <code>update</code> 方法，其它的实现都非常类似，代码可以在<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/blob/master/src/main/java/io/vertx/blueprint/todolist/service/RedisTodoService.java" target="_blank" rel="external">GitHub</a>上浏览。</p>
<h3 id="Monadic_Future">Monadic Future</h3><p>回想一下我们之前写的更新待办事项的逻辑，我们会发现它其实是由两个独立的操作组成 - <code>get</code> 和 <code>insert</code>（对于Redis来说）。所以呢，我们可不可以复用 <code>getCertain</code> 和 <code>insert</code> 这两个方法？当然了！因为<code>Future</code>是可组合的，因此我们可以将这两个方法返回的<code>Future</code>组合到一起。是不是非常方便呢？我们来编写此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Todo&gt; <span class="title">update</span><span class="params">(String todoId, Todo newTodo)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.getCertain(todoId).compose(old -&gt; &#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">if</span> (old.isPresent()) &#123;</div><div class="line">      Todo fnTodo = old.get().merge(newTodo);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.insert(fnTodo)</div><div class="line">        .map(r -&gt; r ? fnTodo : <span class="keyword">null</span>); <span class="comment">// (2)</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> Future.succeededFuture(); <span class="comment">// (3)</span></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们调用了<code>getCertain</code>方法，此方法返回一个<code>Future&lt;Optional&lt;Todo&gt;&gt;</code>对象。同时我们使用<code>compose</code>函数将此方法返回的<code>Future</code>与另一个<code>Future</code>进行组合（1），其中<code>compose</code>函数接受一个<code>T =&gt; Future&lt;U&gt;</code>类型的lambda。然后我们接着检查旧的待办事项是否存在，如果存在的话，我们将新的待办事项与旧的待办事项相融合，然后更新待办事项。注意到<code>insert</code>方法返回<code>Future&lt;Boolean&gt;</code>类型的<code>Future</code>，因此我们还需要对此Future的结果做变换，这个变换的过程是通过<code>map</code>函数实现的（2）。<code>map</code>函数接受一个<code>T =&gt; U</code>类型的lambda。如果旧的待办事项不存在，我们返回一个包含null的<code>Future</code>（3）。最后我们返回组合后的<code>Future</code>对象。</p>
<blockquote>
<p><code>Future</code> 的本质</p>
<p>在函数式编程中，<code>Future</code> 实际上是一种 <code>Monad</code>。有关<code>Monad</code>的理论较为复杂，这里就不进行阐述了。你可以简单地把它看作是一个可以进行变换(<code>map</code>)和组合(<code>compose</code>)的包装对象。我们把这种特性叫做 <strong>monadic</strong>。</p>
</blockquote>
<p>下面来实现MySQL版本的待办事项服务。</p>
<h2 id="Vert-x-JDBC版本的待办事项服务">Vert.x-JDBC版本的待办事项服务</h2><h3 id="JDBC_++_异步">JDBC ++ 异步</h3><p>我们使用Vert.x-JDBC和MySQL来实现JDBC版本的待办事项服务。我们知道，数据库操作都是阻塞操作，很可能会占用不少时间。而Vert.x-JDBC提供了一种异步操作数据库的模式，很神奇吧？所以，在传统JDBC代码下我们要执行SQL语句需要这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String SQL = <span class="string">"SELECT * FROM todo"</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line">ResultSet rs = pstmt.executeQuery(SQL);</div></pre></td></tr></table></figure>
<p>而在Vert.x JDBC中，我们可以利用回调获取数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">connection.query(SQL, result -&gt; &#123;</div><div class="line">    <span class="comment">// do something with result...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种异步操作可以有效避免对数据的等待。当数据获取成功时会自动调用回调函数来执行处理数据的逻辑。</p>
<h3 id="添加依赖">添加依赖</h3><p>首先我们需要向<code>build.gradle</code>文件中添加依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'io.vertx:vertx-jdbc-client:3.3.3'</span></div><div class="line">compile <span class="string">'mysql:mysql-connector-java:6.0.2'</span></div></pre></td></tr></table></figure>
<p>其中第二个依赖是MySQL的驱动，如果你想使用其他的数据库，你需要自行替换掉这个依赖。</p>
<h3 id="初始化JDBCClient">初始化JDBCClient</h3><p>在Vert.x JDBC中，我们需要从一个<code>JDBCClient</code>对象中获取数据库连接，因此我们来看一下如何创建<code>JDBCClient</code>实例。在<code>io.vertx.blueprint.todolist.service</code>包下创建<code>JdbcTodoService</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.vertx.blueprint.todolist.service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.blueprint.todolist.entity.Todo;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.vertx.core.Future;</div><div class="line"><span class="keyword">import</span> io.vertx.core.Vertx;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonArray;</div><div class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.jdbc.JDBCClient;</div><div class="line"><span class="keyword">import</span> io.vertx.ext.sql.SQLConnection;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Optional;</div><div class="line"><span class="keyword">import</span> java.util.stream.Collectors;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTodoService</span> <span class="keyword">implements</span> <span class="title">TodoService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vertx vertx;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> JsonObject config;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> JDBCClient client;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JdbcTodoService</span><span class="params">(JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(Vertx.vertx(), config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JdbcTodoService</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.vertx = vertx;</div><div class="line">    <span class="keyword">this</span>.config = config;</div><div class="line">    <span class="keyword">this</span>.client = JDBCClient.createShared(vertx, config);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用<code>JDBCClient.createShared(vertx, config)</code>方法来创建一个<code>JDBCClient</code>实例，其中我们传入一个<code>JsonObject</code>对象作为配置。一般来说，我们需要配置以下的内容：</p>
<ul>
<li><em>url</em> - JDBC URL，比如 <code>jdbc:mysql://localhost/vertx_blueprint</code></li>
<li><em>driver_class</em> - JDBC驱动名称，比如 <code>com.mysql.cj.jdbc.Driver</code></li>
<li><em>user</em> - 数据库用户</li>
<li><em>password</em> - 数据库密码</li>
</ul>
<p>我们将会通过Vert.x Launcher从配置文件中读取此<code>JsonObject</code>。</p>
<p>现在我们已经创建了<code>JDBCClient</code>实例了，下面我们需要在MySQL中建这样一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`todo`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  <span class="string">`title`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`completed`</span> TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`order`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`url`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>我们把要用到的数据库语句都存到服务类中（这里我们就不讨论如何设计表以及写SQL了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_CREATE = <span class="string">"CREATE TABLE IF NOT EXISTS `todo` (\n"</span> +</div><div class="line">  <span class="string">"  `id` int(11) NOT NULL AUTO_INCREMENT,\n"</span> +</div><div class="line">  <span class="string">"  `title` varchar(255) DEFAULT NULL,\n"</span> +</div><div class="line">  <span class="string">"  `completed` tinyint(1) DEFAULT NULL,\n"</span> +</div><div class="line">  <span class="string">"  `order` int(11) DEFAULT NULL,\n"</span> +</div><div class="line">  <span class="string">"  `url` varchar(255) DEFAULT NULL,\n"</span> +</div><div class="line">  <span class="string">"  PRIMARY KEY (`id`) )"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_INSERT = <span class="string">"INSERT INTO `todo` "</span> +</div><div class="line">  <span class="string">"(`id`, `title`, `completed`, `order`, `url`) VALUES (?, ?, ?, ?, ?)"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_QUERY = <span class="string">"SELECT * FROM todo WHERE id = ?"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_QUERY_ALL = <span class="string">"SELECT * FROM todo"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_UPDATE = <span class="string">"UPDATE `todo`\n"</span> +</div><div class="line">  <span class="string">"SET `id` = ?,\n"</span> +</div><div class="line">  <span class="string">"`title` = ?,\n"</span> +</div><div class="line">  <span class="string">"`completed` = ?,\n"</span> +</div><div class="line">  <span class="string">"`order` = ?,\n"</span> +</div><div class="line">  <span class="string">"`url` = ?\n"</span> +</div><div class="line">  <span class="string">"WHERE `id` = ?;"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_DELETE = <span class="string">"DELETE FROM `todo` WHERE `id` = ?"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_DELETE_ALL = <span class="string">"DELETE FROM `todo`"</span>;</div></pre></td></tr></table></figure>
<p>OK！一切工作准备就绪，下面我们来实现我们的JDBC版本的服务～</p>
<h3 id="实现JDBC版本的服务">实现JDBC版本的服务</h3><p>所有的获取连接、获取执行数据的操作都要在<code>Handler</code>中完成。比如我们可以这样获取数据库连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">client.getConnection(conn -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (conn.succeeded()) &#123;</div><div class="line">        <span class="keyword">final</span> SQLConnection connection = conn.result();</div><div class="line">        <span class="comment">// do something...</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// handle failure</span></div><div class="line">      &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>由于每一个数据库操作都需要获取数据库连接，因此我们来包装一个返回<code>Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt;</code>的方法，在此回调中可以直接使用数据库连接，可以减少一些代码量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt; connHandler(Future future, Handler&lt;SQLConnection&gt; handler) &#123;</div><div class="line">  <span class="keyword">return</span> conn -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (conn.succeeded()) &#123;</div><div class="line">      <span class="keyword">final</span> SQLConnection connection = conn.result();</div><div class="line">      handler.handle(connection);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      future.fail(conn.cause());</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取数据库连接以后，我们就可以对数据库进行各种操作了：</p>
<ul>
<li><code>query</code> : 执行查询（raw SQL）</li>
<li><code>queryWithParams</code> : 执行预编译查询（prepared statement）</li>
<li><code>updateWithParams</code> : 执行预编译DDL语句（prepared statement）</li>
<li><code>execute</code>: 执行任意SQL语句</li>
</ul>
<p>所有的方法都是异步的所以每个方法最后都接受一个<code>Handler</code>参数，我们可以在此<code>Handler</code>中获取结果并执行相应逻辑。</p>
<p>现在我们来编写初始化数据库表的<code>initData</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">  Future&lt;Boolean&gt; result = Future.future();</div><div class="line">  client.getConnection(connHandler(result, connection -&gt;</div><div class="line">    connection.execute(SQL_CREATE, create -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (create.succeeded()) &#123;</div><div class="line">        result.complete(<span class="keyword">true</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        result.fail(create.cause());</div><div class="line">      &#125;</div><div class="line">      connection.close();</div><div class="line">    &#125;)));</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此方法仅会在Verticle初始化时被调用，如果<code>todo</code>表不存在的话就创建一下。注意，<strong>最后一定要关闭数据库连接</strong>。</p>
<p>下面我们来实现插入逻辑方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title">insert</span><span class="params">(Todo todo)</span> </span>&#123;</div><div class="line">  Future&lt;Boolean&gt; result = Future.future();</div><div class="line">  client.getConnection(connHandler(result, connection -&gt; &#123;</div><div class="line">    connection.updateWithParams(SQL_INSERT, <span class="keyword">new</span> JsonArray().add(todo.getId())</div><div class="line">      .add(todo.getTitle())</div><div class="line">      .add(todo.isCompleted())</div><div class="line">      .add(todo.getOrder())</div><div class="line">      .add(todo.getUrl()), r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">        result.fail(r.cause());</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        result.complete(<span class="keyword">true</span>);</div><div class="line">      &#125;</div><div class="line">      connection.close();</div><div class="line">    &#125;);</div><div class="line">  &#125;));</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用<code>updateWithParams</code>方法执行插入逻辑，并且传递了一个<code>JsonArray</code>变量作为预编译参数。这一点很重要，使用预编译语句可以有效防止SQL注入。</p>
<p>我们再来实现<code>getCertain</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Future&lt;Optional&lt;Todo&gt;&gt; getCertain(String todoID) &#123;</div><div class="line">  Future&lt;Optional&lt;Todo&gt;&gt; result = Future.future();</div><div class="line">  client.getConnection(connHandler(result, connection -&gt; &#123;</div><div class="line">    connection.queryWithParams(SQL_QUERY, <span class="keyword">new</span> JsonArray().add(todoID), r -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (r.failed()) &#123;</div><div class="line">        result.fail(r.cause());</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        List&lt;JsonObject&gt; list = r.result().getRows();</div><div class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span> || list.isEmpty()) &#123;</div><div class="line">          result.complete(Optional.empty());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          result.complete(Optional.of(<span class="keyword">new</span> Todo(list.get(<span class="number">0</span>))));</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      connection.close();</div><div class="line">    &#125;);</div><div class="line">  &#125;));</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法里，当我们的查询语句执行以后，我们获得到了<code>ResultSet</code>实例作为查询的结果集。我们可以通过<code>getColumnNames</code>方法获取字段名称，通过<code>getResults</code>方法获取结果。这里我们通过<code>getRows</code>方法来获取结果集，结果集的类型为<code>List&lt;JsonObject&gt;</code>。</p>
<p>其余的几个方法：<code>getAll</code>, <code>update</code>, <code>delete</code> 以及 <code>deleteAll</code>都遵循上面的模式，这里就不多说了。你可以在<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/blob/master/src/main/java/io/vertx/blueprint/todolist/service/JdbcTodoService.java" target="_blank" rel="external">GitHub</a>上浏览完整的源代码。</p>
<p>重构完毕，我们来写待办事项服务对应的配置，然后再来运行！</p>
<h2 id="再来运行！">再来运行！</h2><p>首先我们在项目的根目录下创建一个 <code>config</code> 文件夹作为配置文件夹。我们在其中创建一个<code>config_jdbc.json</code>文件作为 <code>jdbc</code> 类型服务的配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"service.type"</span>: <span class="string">"jdbc"</span>,</div><div class="line">  <span class="attr">"url"</span>: <span class="string">"jdbc:mysql://localhost/vertx_blueprint?characterEncoding=UTF-8&amp;useSSL=false"</span>,</div><div class="line">  <span class="attr">"driver_class"</span>: <span class="string">"com.mysql.cj.jdbc.Driver"</span>,</div><div class="line">  <span class="attr">"user"</span>: <span class="string">"vbpdb1"</span>,</div><div class="line">  <span class="attr">"password"</span>: <span class="string">"666666*"</span>,</div><div class="line">  <span class="attr">"max_pool_size"</span>: <span class="number">30</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你需要根据自己的情况替换掉上述配置文件中相应的内容(如 <em>JDBC URL</em>，<em>JDBC 驱动</em> 等)。</p>
<p>再建一个<code>config.json</code>文件作为<code>redis</code>类型服务的配置（其它的项就用默认配置好啦）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"service.type"</span>: <span class="string">"redis"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的构建文件也需要更新咯～这里直接给出最终的<code>build.gradle</code>文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">plugins &#123;</div><div class="line">  id <span class="string">'java'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">version <span class="string">'1.0'</span></div><div class="line"></div><div class="line">ext &#123;</div><div class="line">  vertxVersion = <span class="string">"3.3.3"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">jar &#123;</div><div class="line">  <span class="comment">// by default fat jar</span></div><div class="line">  archiveName = <span class="string">'vertx-blueprint-todo-backend-fat.jar'</span></div><div class="line">  <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</div><div class="line">  manifest &#123;</div><div class="line">    attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></div><div class="line">    attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.todolist.verticles.TodoVerticle'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">repositories</span> &#123;</div><div class="line">  jcenter()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// compileOnly requires Gradle 2.12+</span></div><div class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</div><div class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</div><div class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">  <span class="keyword">options</span>.compilerArgs = [</div><div class="line">    <span class="string">"-proc:only"</span>,</div><div class="line">    <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</div><div class="line">    <span class="string">"-AoutputDirectory=$&#123;destinationDir.absolutePath&#125;"</span></div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">sourceSets</span> &#123;</div><div class="line">  main &#123;</div><div class="line">    java &#123;</div><div class="line">      srcDirs += <span class="string">'src/main/generated'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">compileJava &#123;</div><div class="line">  <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">  <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line"></div><div class="line">  dependsOn annotationProcessing</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-core:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-jdbc-client:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-redis-client:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  compileOnly(<span class="string">"io.vertx:vertx-codegen:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  <span class="keyword">compile</span> <span class="string">'mysql:mysql-connector-java:6.0.2'</span></div><div class="line"></div><div class="line">  testCompile(<span class="string">"io.vertx:vertx-unit:$&#123;vertxVersion&#125;"</span>)</div><div class="line">  testCompile <span class="keyword">group</span>: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.12'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">task</span> wrapper(type: Wrapper) &#123;</div><div class="line">  gradleVersion = <span class="string">'3.0'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好啦好啦，迫不及待了吧？～打开终端，构建我们的应用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle build</div></pre></td></tr></table></figure>
<p>然后我们可以运行Redis版本的待办事项服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar build/libs/vertx-blueprint-todo-backend-fat.jar -conf config/config.json</div></pre></td></tr></table></figure>
<p>我们也可以运行JDBC版本的待办事项服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar build/libs/vertx-blueprint-todo-backend-fat.jar -conf config/config_jdbc.json</div></pre></td></tr></table></figure>
<p>同样地，我们也可以使用<a href="https://github.com/TodoBackend/todo-backend-js-spec" target="_blank" rel="external">todo-backend-js-spec</a>来测试我们的API。由于我们的API设计没有改变，因此测试结果应该不会有变化。</p>
<p>我们也提供了待办事项服务对应的Docker Compose镜像构建文件，可以直接通过Docker来运行我们的待办事项服务。你可以在仓库的根目录下看到<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend/blob/master/docker-compose.yml" target="_blank" rel="external">相应的配置文件</a>，并通过 <code>docker-compose up -- build</code> 命令来构建并运行。</p>
<p><img src="https://github.com/sczyh30/vertx-blueprint-todo-backend/raw/master/docs/img/vbptds-docker-compose-running.png" alt="Docker Compose"></p>
<h1 id="哈哈，成功了！">哈哈，成功了！</h1><p>哈哈，恭喜你完成了整个待办事项服务，是不是很开心？～在整个教程中，你应该学到了很多关于 <code>Vert.x Web</code>、 <code>Vert.x Redis</code> 和 <code>Vert.x JDBC</code> 的开发知识。当然，最重要的是，你会对Vert.x的 <strong>异步开发模式</strong> 有了更深的理解和领悟。</p>
<p>另外，Vert.x 蓝图系列已经发布至Vert.x官网：<a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x Blueprint Tutorials</a>。其中<a href="http://sczyh30.github.io/vertx-blueprint-job-queue/cn/kue-core/index.html" target="_blank" rel="external">第二个Blueprint</a>是关于消息应用的，<a href="http://sczyh30.github.io/vertx-blueprint-microservice/cn/index.html" target="_blank" rel="external">第三个Blueprint</a>是关于微服务的，有兴趣的朋友可以参考后面几篇蓝图教程。</p>
<p>更多关于Vert.x的文章，请参考<a href="http://vertx.io/blog/archives/" target="_blank" rel="external">Blog on Vert.x Website</a>。官网的资料是最全面的 :-)</p>
<h1 id="来自其它框架？">来自其它框架？</h1><p>之前你可能用过其它的框架，比如Spring Boot。这一小节，我将会用类比的方式来介绍Vert.x Web的使用。</p>
<h2 id="来自Spring_Boot/Spring_MVC">来自Spring Boot/Spring MVC</h2><p>在Spring Boot中，我们通常在控制器(Controller)中来配置路由以及处理请求，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@ComponentScan</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> TodoService service;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping</span>(method = RequestMethod.GET, value = <span class="string">"/todos/&#123;id&#125;"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> Todo <span class="title">getCertain</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</div><div class="line">    <span class="keyword">return</span> service.fetch(id);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Spring Boot中，我们使用 <code>@RequestMapping</code> 注解来配置路由，而在Vert.x Web中，我们是通过 <code>Router</code> 对象来配置路由的。并且因为Vert.x Web是异步的，我们会给每个路由绑定一个处理器（<code>Handler</code>）来处理对应的请求。</p>
<p>另外，在Vert.x Web中，我们使用 <code>end</code> 方法来向客户端发送HTTP response。相对地，在Spring Boot中我们直接在每个方法中返回结果作为response。</p>
<h2 id="来自Play_Framework_2">来自Play Framework 2</h2><p>如果之前用过Play Framework 2的话，你一定会非常熟悉异步开发模式。在Play Framework 2中，我们在 <code>routes</code> 文件中定义路由，类似于这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">GET</span>     /todos/:todoId      controllers.<span class="type">TodoController</span>.handleGetCertain(todoId: <span class="type">Int</span>)</div></pre></td></tr></table></figure>
<p>而在Vert.x Web中，我们通过<code>Router</code>对象来配置路由：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">"/todos/:todoId"</span>).handler(<span class="keyword">this</span>::handleGetCertain);</div></pre></td></tr></table></figure>
<p><code>this::handleGetCertain</code>是处理对应请求的方法引用（在Scala里可以把它看作是一个函数）。</p>
<p>Play Framework 2中的异步开发模式是基于<code>Future</code>的。每一个路由处理函数都返回一个<code>Action</code>对象（实质上是一个类型为<code>Request[A] =&gt; Result</code>的函数），我们在<code>Action.apply</code>(或<code>Action.async</code>)闭包中编写我们的处理逻辑，类似于这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleGetCertain</span></span>(todoId: <span class="type">Int</span>): <span class="type">Action</span>[<span class="type">AnyContent</span>] = <span class="type">Action</span>.async &#123;</div><div class="line">    service.getCertain(todoId) map &#123; <span class="comment">// 服务返回的类型是 `Future[Option[Todo]]`</span></div><div class="line">        <span class="keyword">case</span> <span class="type">Some</span>(res) =&gt;</div><div class="line">            <span class="type">Ok</span>(<span class="type">Json</span>.toJson(res))</div><div class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">            <span class="type">NotFound</span>()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在Vert.x Web中，异步开发模式基本上都是基于回调的（当然也可以用Vert.x RxJava）。我们可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateTodo</span><span class="params">(RoutingContext context)</span> </span>&#123;</div><div class="line">    String todoId = context.request().getParam(<span class="string">"todoId"</span>); <span class="comment">// 获取Path Variable</span></div><div class="line">    service.getCertain(todoId).setHandler(r -&gt; &#123; <span class="comment">// 服务返回的类型是 `Future&lt;Optional&lt;Todo&gt;&gt;`</span></div><div class="line">        <span class="keyword">if</span> (r.succeeded) &#123;</div><div class="line">            Optional&lt;Todo&gt; res = r.result;</div><div class="line">            <span class="keyword">if</span> (res.isPresent()) &#123;</div><div class="line">                context.response()</div><div class="line">                    .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</div><div class="line">                    .end(Json.encodePrettily(res));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sendError(<span class="number">404</span>, context.response()); <span class="comment">// NotFound(404)</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sendError(<span class="number">503</span>, context.response());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="想要使用其它持久化存储框架？">想要使用其它持久化存储框架？</h2><p>你可能想在Vert.x中使用其它的持久化存储框架或库，比如MyBatis ORM或者Jedis，这当然可以啦！Vert.x允许开发者整合任何其它的框架和库，但是像MyBatis ORM这种框架都是阻塞型的，可能会阻塞Event Loop线程，因此我们需要利用<code>blockingHandler</code>方法去执行阻塞的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">"/todos/:todoId"</span>).blockingHandler(routingContext -&gt; &#123;</div><div class="line">            String todoID = routingContext.request().getParam(<span class="string">"todoId"</span>);</div><div class="line">            Todo res = service.fetchBlocking(todoID); <span class="comment">// 阻塞型</span></div><div class="line"></div><div class="line">            <span class="comment">// 做一些微小的工作</span></div><div class="line"></div><div class="line">            routingContext.next();</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>Vert.x会使用Worker线程去执行<code>blockingHandler</code>方法(或者Worker Verticles)中的操作，因此不会阻塞Event Loop线程。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于Quorum投票机制的Replica Control算法]]></title>
      <url>http://www.sczyh30.com/posts/Architecture/quorum-based-voting-for-replica-control/</url>
      <content type="html"><![CDATA[<p>在分布式系统中，一份数据可能有多份副本（冗余数据）。为了保证数据读写的正确性，同一时刻一份数据的多份副本只能用于读或用于写，而不能同时被超过两个访问对象并发读写。Quorum机制就可以保证这一点，我们来看一下它的思想。</p>
<p>一个分布式系统中，我们给每个数据副本都赋予一票。假设一共有 <strong>V</strong> 个数据副本，那么总共就有 <strong>V</strong> 个票数。每个操作必须要获得读票数(完成读操作所需要读取的最小副本数，read quorum,  <strong>V(r)</strong> )或写票数(完成写操作所需要读取的最小副本数write quorum,  <strong>V(w)</strong> )才能够对数据进行读或写。票数需要遵循以下规则：</p>
<ol>
<li>$V_{r} + V_{w} &gt; V$</li>
<li>$V_{w} &gt; \frac{V}{2}$</li>
</ol>
<p>第一条规则有两个作用：第一个作用是保证了一个数据不会被同时读写。当请求一个写操作时，它需要的得到 <strong>V(w)</strong> 读票数，而剩下的票数为 <strong>V - V(w) &lt; V(r)</strong>，因此不再允许读操作。请求读操作时也是同理；第二个作用是保证了强一致性。根据 <strong>鸽巢原理</strong>，写数据操作与读新数据操作之间是有重叠的，这就确保至少有一个读操作是可以读到最新数据的。</p>
<p>第二条规则保证了数据的串行化修改，同一个数据不能同时被两个写操作并发修改。</p>
<p>Quorum投票机制非常有用。比如一份数据在5个结点上存有副本，进行一次写操作的时候，必须等待五个结点的写操作都完成，整个写操作才返回（因为可以从任意结点读取）。这样会导致写操作负载太高，而有了Quorum机制以后，我们可以让写操作在至少3个结点上完成就可以返回，另外的结点可以等待后台同步，而读操作V(r)也需要大于 <strong>V-V(w)</strong> 才能确保至少一个读操作可以读到最新数据。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>Weighted Voting for Replicated Data</em>, David K. Gifford, Stanford University and Xerox Palo Alto Research Center</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Netflix Hystrix | 工作流程浅析 && HystrixCircuitBreaker源码分析]]></title>
      <url>http://www.sczyh30.com/posts/Microservice/netflix-hystrix-how-it-works-summary/</url>
      <content type="html"><![CDATA[<p>这篇文章里我们来总结一下Netflix Hystrix的工作流程。这是官方提供的流程图(来自GitHub)：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/hystrix-command-flow-chart.png" alt="Netflix Hystrix Flow Chart"></p>
<h1 id="工作流程">工作流程</h1><p>我们来根据流程图来分析一下工作流程。</p>
<p>首先我们需要创建一个 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code> 实例来代表向其它组件发出的操作请求（指令），然后通过相关的方法执行操作指令。这里有4个方法，前两个对应<code>HystrixCommand</code>，后两个对应<code>HystrixObservableCommand</code>：</p>
<ul>
<li><code>execute()</code>：阻塞型方法，返回单个结果（或者抛出异常）</li>
<li><code>queue()</code>：异步方法，返回一个<code>Future</code>对象，可以从中取出单个结果（或者抛出异常）</li>
<li><code>observe()</code>和<code>toObservable()</code>都返回对应的<code>Observable</code>对象，代表（多个）操作结果。注意<code>observe</code>方法在调用的时候就开始执行对应的指令，而<code>toObservable</code>方法相当于是<code>observe</code>方法的lazy版本，当我们去<code>subscribe</code>的时候，对应的指令才会被执行并产生结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">K             value   = command.execute();</div><div class="line">Future&lt;K&gt;     fValue  = command.queue();</div><div class="line">Observable&lt;K&gt; ohValue = command.observe();         <span class="comment">//hot observable</span></div><div class="line">Observable&lt;K&gt; ocValue = command.toObservable();    <span class="comment">//cold observable</span></div></pre></td></tr></table></figure>
<p>从底层实现来讲，<code>HystrixCommand</code>也是利用<code>Observable</code>实现的（看Hystrix源码的话可以发现里面大量使用了RxJava），尽管它只返回单个结果。<code>HystrixCommand</code>的<code>queue</code>方法实际上是调用了<code>toObservable().toBlocking().toFuture()</code>，而<code>execute</code>方法实际上是调用了<code>queue().get()</code>。</p>
<p>执行操作指令时，Hystrix首先会检查缓存内是否有对应指令的结果，如果有的话，将缓存的结果直接以<code>Observable</code>对象的形式返回。如果没有对应的缓存，Hystrix会检查Circuit Breaker的状态。如果Circuit Breaker的状态为开启状态，Hystrix将不会执行对应指令，而是直接进入失败处理状态（图中8 Fallback）。如果Circuit Breaker的状态为关闭状态，Hystrix会继续进行线程池、任务队列、信号量的检查（图中5），确认是否有足够的资源执行操作指令。如果资源满，Hystrix同样将不会执行对应指令并且直接进入失败处理状态。</p>
<p>如果资源充足，Hystrix将会执行操作指令。操作指令的调用最终都会到这两个方法：</p>
<ul>
<li><code>HystrixCommand.run()</code></li>
<li><code>HystrixObservableCommand.construct()</code></li>
</ul>
<p>如果执行指令的时间超时，执行线程会抛出<code>TimeoutException</code>异常。Hystrix会抛弃结果并直接进入失败处理状态。如果执行指令成功，Hystrix会进行一系列的数据记录，然后返回执行的结果。</p>
<p>同时，Hystrix会根据记录的数据来计算失败比率，一旦失败比率达到某一阈值将自动开启Circuit Breaker。</p>
<p>最后我们再来看一下Hystrix是如何处理失败的。如果我们在Command中实现了<code>HystrixCommand.getFallback()</code>方法（或<code>HystrixObservableCommand.resumeWithFallback()</code>方法，Hystrix会返回对应方法的结果。如果没有实现这些方法的话，从底层看Hystrix将会返回一个空的<code>Observable</code>对象，并且可以通过<code>onError</code>来终止并处理错误。从上层看：</p>
<ul>
<li><code>execute</code>方法将会抛出异常</li>
<li><code>queue</code>方法将会返回一个失败状态的<code>Future</code>对象</li>
<li><code>observe()</code>和<code>toObservable()</code>方法都会返回上述的<code>Observable</code>对象</li>
</ul>
<h1 id="HystrixCircuitBreaker源码分析">HystrixCircuitBreaker源码分析</h1><p>Hystrix中的Circuit Breaker的实现比较明了。整个<code>HystrixCircuitBreaker</code>接口一共有三个方法和三个静态类：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/hystrix-circuit-breaker-class-structure.png" alt="Class Hierarchy of HystrixCircuitBreaker"></p>
<p>其中<code>allowRequest()</code>方法表示是否允许指令执行，<code>isOpen()</code>方法表示断路器是否为开启状态，<code>markSuccess()</code>用于将断路器关闭。</p>
<p><code>Factory</code>静态类相当于Circuit Breaker Factory，用于获取相应的<code>HystrixCircuitBreaker</code>。我们来看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="comment">// String is HystrixCommandKey.name() (we can't use HystrixCommandKey directly as we can't guarantee it implements hashcode/equals correctly)</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, HystrixCircuitBreaker&gt; circuitBreakersByCommand = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HystrixCircuitBreaker&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixCircuitBreaker <span class="title">getInstance</span><span class="params">(HystrixCommandKey key, HystrixCommandGroupKey group, HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</div><div class="line">        <span class="comment">// this should find it for all but the first time</span></div><div class="line">        HystrixCircuitBreaker previouslyCached = circuitBreakersByCommand.get(key.name());</div><div class="line">        <span class="keyword">if</span> (previouslyCached != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> previouslyCached;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// if we get here this is the first time so we need to initialize</span></div><div class="line"></div><div class="line">        <span class="comment">// Create and add to the map ... use putIfAbsent to atomically handle the possible race-condition of</span></div><div class="line">        <span class="comment">// 2 threads hitting this point at the same time and let ConcurrentHashMap provide us our thread-safety</span></div><div class="line">        <span class="comment">// If 2 threads hit here only one will get added and the other will get a non-null response instead.</span></div><div class="line">        HystrixCircuitBreaker cbForCommand = circuitBreakersByCommand.putIfAbsent(key.name(), <span class="keyword">new</span> HystrixCircuitBreakerImpl(key, group, properties, metrics));</div><div class="line">        <span class="keyword">if</span> (cbForCommand == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// this means the putIfAbsent step just created a new one so let's retrieve and return it</span></div><div class="line">            <span class="keyword">return</span> circuitBreakersByCommand.get(key.name());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// this means a race occurred and while attempting to 'put' another one got there before</span></div><div class="line">            <span class="comment">// and we instead retrieved it and will now return it</span></div><div class="line">            <span class="keyword">return</span> cbForCommand;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixCircuitBreaker <span class="title">getInstance</span><span class="params">(HystrixCommandKey key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> circuitBreakersByCommand.get(key.name());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* package */</span><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">        circuitBreakersByCommand.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hystrix在<code>Factory</code>类中维护了一个<code>ConcurrentHashMap</code>用于存储与每一个<code>HystrixCommandKey</code>相对应的<code>HystrixCircuitBreaker</code>。每当我们通过<code>getInstance</code>方法从中获取<code>HystrixCircuitBreaker</code>的时候，Hystrix首先会检查<code>ConcurrentHashMap</code>中有没有对应的缓存的断路器，如果有的话直接返回。如果没有的话就会新创建一个<code>HystrixCircuitBreaker</code>实例，将其添加到缓存中并且返回。</p>
<p><code>HystrixCircuitBreakerImpl</code>静态类是<code>HystrixCircuitBreaker</code>接口的实现。我们可以看到<code>HystrixCircuitBreakerImpl</code>类中有四个成员变量。其中<code>properties</code>是对应<code>HystrixCommand</code>的属性类，<code>metrics</code>是对应<code>HystrixCommand</code>的度量数据类。由于会工作在并发环境下，我们用一个<code>AtomicBoolean</code>类型的变量<code>circuitOpen</code>来代表断路器的状态（默认是<code>false</code>代表关闭，这里没有特意实现Half-Open这个状态），并用一个<code>AtomicLong</code>类型的变量<code>circuitOpenedOrLastTestedTime</code>记录着断路恢复计时器的初始时间，用于Open状态向Close状态的转换。</p>
<p>我们首先来看一下<code>isOpen</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (circuitOpen.get()) &#123;</div><div class="line">        <span class="comment">// if we're open we immediately return true and don't bother attempting to 'close' ourself as that is left to allowSingleTest and a subsequent successful test to close</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// we're closed, so let's see if errors have made us so we should trip the circuit open</span></div><div class="line">    HealthCounts health = metrics.getHealthCounts();</div><div class="line"></div><div class="line">    <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></div><div class="line">    <span class="keyword">if</span> (health.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</div><div class="line">        <span class="comment">// we are not past the minimum volume threshold for the statisticalWindow so we'll return false immediately and not calculate anything</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (health.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// our failure rate is too high, trip the circuit</span></div><div class="line">        <span class="keyword">if</span> (circuitOpen.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">            <span class="comment">// if the previousValue was false then we want to set the currentTime</span></div><div class="line">            circuitOpenedOrLastTestedTime.set(System.currentTimeMillis());</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// How could previousValue be true? If another thread was going through this code at the same time a race-condition could have</span></div><div class="line">            <span class="comment">// caused another thread to set it to true already even though we were in the process of doing the same</span></div><div class="line">            <span class="comment">// In this case, we know the circuit is open, so let the other thread set the currentTime and report back that the circuit is open</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过<code>circuitOpen.get()</code>获取断路器的状态，如果是开启状态(<code>true</code>)则返回<code>true</code>。否则，Hystrix会从Metrics数据中获取<code>HealthCounts</code>对象，然后检查对应的请求总数(<code>totalCount</code>)是否小于属性中的请求容量阈值(<code>circuitBreakerRequestVolumeThreshold</code>)，如果是的话表示断路器可以保持关闭状态，返回<code>false</code>。如果不满足请求总数条件，就再检查错误比率(<code>errorPercentage</code>)是否小于属性中的错误百分比阈值(<code>circuitBreakerErrorThresholdPercentage</code>，默认 <strong>50</strong>)，如果是的话表示断路器可以保持关闭状态，返回 <code>false</code>；如果超过阈值，Hystrix会判定服务的某些地方出现了问题，因此通过CAS操作将断路器设为开启状态，并记录此时的系统时间作为定时器初始时间，最后返回 <code>true</code>。</p>
<p>我们再来看一下判断Open状态下计时器的实现方法<code>allowSingleTest</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowSingleTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> timeCircuitOpenedOrWasLastTested = circuitOpenedOrLastTestedTime.get();</div><div class="line">    <span class="comment">// 1) if the circuit is open</span></div><div class="line">    <span class="comment">// 2) and it's been longer than 'sleepWindow' since we opened the circuit</span></div><div class="line">    <span class="keyword">if</span> (circuitOpen.get() &amp;&amp; System.currentTimeMillis() &gt; timeCircuitOpenedOrWasLastTested + properties.circuitBreakerSleepWindowInMilliseconds().get()) &#123;</div><div class="line">        <span class="comment">// We push the 'circuitOpenedTime' ahead by 'sleepWindow' since we have allowed one request to try.</span></div><div class="line">        <span class="comment">// If it succeeds the circuit will be closed, otherwise another singleTest will be allowed at the end of the 'sleepWindow'.</span></div><div class="line">        <span class="keyword">if</span> (circuitOpenedOrLastTestedTime.compareAndSet(timeCircuitOpenedOrWasLastTested, System.currentTimeMillis())) &#123;</div><div class="line">            <span class="comment">// if this returns true that means we set the time so we'll return true to allow the singleTest</span></div><div class="line">            <span class="comment">// if it returned false it means another thread raced us and allowed the singleTest before we did</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取断路恢复计时器记录的初始时间<code>circuitOpenedOrLastTestedTime</code>，然后判断以下两个条件是否同时满足：</p>
<ul>
<li>断路器的状态为开启状态(<code>circuitOpen.get() == true</code>)</li>
<li>当前时间与计时器初始时间之差大于计时器阈值<code>circuitBreakerSleepWindowInMilliseconds</code>(默认为 <strong>5</strong> 秒)</li>
</ul>
<p>如果同时满足的话，表示可以从<code>Open</code>状态向<code>Close</code>状态转换。Hystrix会通过CAS操作将<code>circuitOpenedOrLastTestedTime</code>设为当前时间，并返回<code>true</code>。如果不同时满足，返回<code>false</code>，代表断路器关闭或者计时器时间未到。</p>
<p>有了这个函数以后，我们再来看一下<code>allowRequest</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceOpen().get()) &#123;</div><div class="line">        <span class="comment">// properties have asked us to force the circuit open so we will allow NO requests</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceClosed().get()) &#123;</div><div class="line">        <span class="comment">// we still want to allow isOpen() to perform it's calculations so we simulate normal behavior</span></div><div class="line">        isOpen();</div><div class="line">        <span class="comment">// properties have asked us to ignore errors so we will ignore the results of isOpen and just allow all traffic through</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> !isOpen() || allowSingleTest();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常直观。首先先读取属性中的强制设定值（可以强制设定状态），如果没有设定的话，就判断断路器是否关闭或者断路恢复计时器是否到达时间，只要满足其中一个条件就返回<code>true</code>，即允许执行操作指令。</p>
<p>最后就是<code>markSuccess</code>方法了，它用于关闭断路器并重置统计数据。代码非常直观，就不多说了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markSuccess</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (circuitOpen.get()) &#123;</div><div class="line">        <span class="keyword">if</span> (circuitOpen.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</div><div class="line">            metrics.resetStream();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hystrix的Circuit Breaker可以用以下的图来总结：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/hystrix-circuit-breaker-1280.png" alt="Hystrix Circuit Breaker"></p>
<p>至于Hystrix在底层执行Command时是如何利用<code>HystrixCircuitBreaker</code>的，可以看<code>AbstractCommand</code>类中<code>toObservable</code>方法和<code>getRunObservableDecoratedForMetricsAndErrorHandling</code>方法的源码，后边再总结。</p>
<hr>
<h1 id="Reference">Reference</h1><ul>
<li><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" target="_blank" rel="external">How it Works - Netflix/Hystrix - Wiki</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[并发编程算法 | Treiber Stack实现lock-free stack]]></title>
      <url>http://www.sczyh30.com/posts/Concurrency/concurrency-treiber-stack/</url>
      <content type="html"><![CDATA[<p>多线程环境下各种数据结构的实现有了很大的变化，每当我们更新某个数据的时候，我们都要考虑其它线程是否对其进行了修改。最简单的一种方法就是加锁，不过加锁会导致性能低下，而且可能阻塞其他线程。因此，我们引入了非阻塞(non-blocking)的算法 —— 通过CAS操作保证操作的原子性，同时我们还引入了 <em>lock-free</em> 的概念，它指的是一个线程出现问题（如阻塞，失败）但不影响其他线程（从总体看程序仍然是在运行的）。这里就来看一下Non-blocking stack的一个实现 —— <strong>Treiber Stack</strong>。</p>
<h1 id="Treiber_Stack">Treiber Stack</h1><p>这里给出的是Treiber Stack的一个简化版的Java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Concurrent stack implementation</div><div class="line"> * Treiber's Algorithm</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&lt;E&gt;&gt; top = <span class="keyword">new</span> AtomicReference&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E elem)</span> </span>&#123;</div><div class="line">        Node&lt;E&gt; newHead = <span class="keyword">new</span> Node&lt;&gt;(elem);</div><div class="line">        Node&lt;E&gt; oldHead;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            oldHead = top.get();</div><div class="line">            newHead.next = oldHead;</div><div class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldHead, newHead));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;E&gt; oldHead;</div><div class="line">        Node&lt;E&gt; newHead;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            oldHead = top.get();</div><div class="line">            <span class="keyword">if</span> (oldHead == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            newHead = oldHead.next;</div><div class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldHead, newHead));</div><div class="line">        <span class="keyword">return</span> oldHead.item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> E item;</div><div class="line">        <span class="keyword">public</span> Node&lt;E&gt; next;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.item = item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用了<code>AtomicReference</code>来实现Treiber Stack。每当我们<code>push</code>进去一个元素的时候，我们首先根据要添加的元素创建一个<code>Node</code>，然后获取原栈顶结点，并将新结点的下一个结点指向原栈顶结点。此时我们使用CAS操作来更改栈顶结点，如果此时的栈顶和之前的相同，代表CAS操作成功，那么就把新插入的元素设为栈顶；如果此时的栈顶和之前的不同（即其他线程改变了栈顶结点），CAS操作失败，那么需要重复上述操作（更新当前的栈顶元素并且重设next），直到成功。<code>pop</code>操作的原理也相似。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>Java Concurrency In Practice</em></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分布式系统基础总结]]></title>
      <url>http://www.sczyh30.com/posts/Distributed-System/distributed-system-base/</url>
      <content type="html"><![CDATA[<p>从大一就一直在搞分布式系统，Hadoop, Spark, Kafka, ZooKeeper之类的都玩过，然而以前只是简单地用用各个开源组件实现，并没有系统地学习其中的原理和算法。最近在跟着MIT 6.824课程学习分布式系统的各种理论原理，这里就来简单总结下分布式系统中的一些基础内容吧~</p>
<h1 id="CAP_Theory">CAP Theory</h1><p>CAP Theory阐述了分布式系统中的一个事实：一致性(Consistency)、可用性(Availability)和分区容错性(Partition Tolerance)不能同时保证。三个只能选择两个</p>
<p><img src="http://book.mixu.net/distsys/images/CAP.png" alt="CAP Theory"></p>
<p>假设有两台机器A、B，两者之间互相同步保持数据的一致性。现在B由于网络原因不能与A通信(Network Partition)，假设某个client向A写入数据，现在有两种选择：</p>
<ul>
<li>A拒绝写入，这样能保证与B的一致性，但是牺牲了可用性</li>
<li>A允许写入，但是这样就不能保证与B的一致性了</li>
</ul>
<p>Network Partition是必然的，网络非常可能出现问题（断线、超时），因此CAP理论一般只能AP或CP，而CA一般较难实现。</p>
<ul>
<li>CP: 要实现一致性，则需要一定的一致性算法，一般是基于多数派表决的，如Paxos和Raft</li>
<li>AP: 要实现可用性，则要有一定的策略决议到底用哪个数据，并且数据一般要进行冗余备份(replication)</li>
</ul>
<p>当然，在上面的例子中，A可以先允许写入，等B的网络恢复以后再同步至B（根据CAP原理这样不能保证强一致性了，但是可以考虑实现最终一致性）。</p>
<h1 id="一致性哈希">一致性哈希</h1><p>分布式Key-Value Store中的key映射问题。</p>
<ul>
<li>传统<code>hash(x) % N</code>算法的弊端：不利于架构的伸缩性</li>
<li>一致性哈希将哈希值映射到一个哈希环上，然后将数据进行哈希处理后映射到哈希环上，再把节点进行哈希处理映射到哈希环上，数据将选择最近的节点存储</li>
<li>伸缩性：节点删除时，原有的数据将会就近迁移，其他数据不用迁移；节点增加时也相似</li>
<li>保证负载均衡：虚拟节点</li>
</ul>
<h1 id="拜占庭将军问题">拜占庭将军问题</h1><p>最复杂的情况：自己发的包被截；对方发的包自己收不到；内部有节点捣乱，造成不一致。</p>
<h1 id="FLP_Impossibility">FLP Impossibility</h1><p><em>Impossibility of Distributed Consensus with One Faulty Process</em> 这篇论文提到：</p>
<blockquote>
<p>No completely asynchronous consensus protocol can tolerate even a single unannounced process death.</p>
</blockquote>
<p>假设节点只有崩溃这一种异常行为，网络是可靠的，并且不考虑异步通信下的时序差异。FLP Impossibility指出在异步网络环境中只要有一个故障节点, 任何Consensus算法都无法保证行为正确。</p>
<h1 id="Lease机制">Lease机制</h1><p>Lease（租约）机制应用非常广泛：</p>
<ul>
<li>可用作授权来进行同步等操作(如Append)</li>
<li>可用作读锁/写锁（分布式锁）</li>
</ul>
<p>租约的一个关键点就是有效期，过了有效期可以续约。如果不可用就收回租约，给另一台服务器权限。</p>
<p>实际应用：</p>
<ul>
<li>GFS: Master grant to ChunckServer</li>
</ul>
<blockquote>
<p>思考：<strong>Lease == Lock?</strong></p>
</blockquote>
<h1 id="Quorum机制">Quorum机制</h1><p>多数表决机制在分布式系统中通常有两个应用场景：</p>
<ol>
<li>Leader Election</li>
<li>Replication (NWR机制)</li>
</ol>
<p>理论基础：鸽巢原理</p>
<h1 id="Consensus问题">Consensus问题</h1><h2 id="Consensus条件">Consensus条件</h2><ul>
<li>Termination: 最终必须决议出结果</li>
<li>Validity:</li>
<li>Integrity</li>
<li>Agreement</li>
</ul>
<h2 id="2PC/3PC">2PC/3PC</h2><p>2PC在proposer和某个voter都挂掉的时候会阻塞（原因：别的节点没有对应voter的消息，只能阻塞等待此voter恢复）</p>
<p>3PC添加了一个  <em>prepare-commit</em> 阶段用于准备提交工作，这里面可以实现事务的回滚。</p>
<p>缺点：效率貌似很低。。。分布式事务用2PC会特别蛋疼</p>
<h1 id="Paxos">Paxos</h1><p>推演：</p>
<ul>
<li>First Accept/Last Accept都不可以（结合时序图）</li>
<li>一个阶段不行，自然想到两个阶段：发起决议以及提交决议</li>
</ul>
<ul>
<li>One Proposer -&gt; One Acceptor 挂了就gg了</li>
<li>One Proposer -&gt; Many Acceptors （规则：先到先投）</li>
<li>Many Proposers -&gt; Many Acceptors (很容易乱。。。)</li>
</ul>
<p>Paxos引入了Log ID (num, value)，共有三个角色，两个阶段。</p>
<ul>
<li>Proposer: 决议发起者，需要等待多数派表决</li>
<li>Acceptor: 决议投票者，对收到的Propose进行表决并返回</li>
<li>Learner: 最水的角色，学习到投票的结果即可</li>
</ul>
<blockquote>
<p>分布式一致性算法(Paxos, Raft, Chubby, Zab)待详细总结。。。</p>
</blockquote>
<h1 id="时序问题">时序问题</h1><h2 id="Lamport_Timestamp">Lamport Timestamp</h2><p>一般我们不关心分布式系统中某个过程的绝对时间，而只关注两个事件之间的相对时间。<br>在一个系统的事件集合E上定义一种偏序关系<code>-&gt;</code>，满足：</p>
<ul>
<li>如果a与b发生在同一个进程中，且a先于b发生，则有<code>a -&gt; b</code></li>
<li>进程间通信，a代表进程Pi发出消息m，b代表另一个进程Pj接收消息m，则有<code>a -&gt; b</code></li>
<li>传递性：若<code>a -&gt; b, b -&gt; c</code>，则<code>a -&gt; c</code></li>
</ul>
<p>定义并发：<code>a -&gt; b</code>与<code>b -&gt; a</code>均不成立则为并发情况</p>
<p>引入Lamport逻辑时钟。一个时钟本质上是一个事件到实数的映射（假设时间是连续的）。对于每一个进程Pi，都有其对应的时钟Ci。</p>
<p>分布式系统中的全局信息实际上是对各个实体信息的叠加（Q：重合怎么办？）</p>
<p>可以看到Lamport Timestamp必须要求两个事件有先后顺序关系，因而在时序图上不好表示concurrent。由此引入Vector Clock。</p>
<h2 id="Vector_Clock">Vector Clock</h2><p>Vector Clock是对Lamport Timestamp的演进。它不仅保存了自身的timestamp，而且还保留了根节点的timestamp。</p>
<p>Vector Clock(Version Vector)只能用于发现数据冲突，但是想要解决数据冲突还要留给用户去定夺（就好比git commit出现conflicts，需要手工解决一样），当然也可以设置某种策略来直接解决冲突（保留最新或集群内多数表决）。</p>
<p>结合时序图理解会更好(图来自维基百科)：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Vector_Clock.svg/725px-Vector_Clock.svg.png" alt=""></p>
<p>可能出现的问题：Vector Clock过多。解决方案：剪枝（如果超过某个阈值就把最初的那个给扔掉；要是现在还依赖最初的那个clock的话可能就会造成一些问题（思考：如何解决？）</p>
<p>对应论文：<em>Dynamo: Amazon’s Highly Available Key-value Store, Section 4.4</em>.</p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://book.mixu.net/distsys/index.html" target="_blank" rel="external">Distributed systems for fun and profit</a></li>
<li><a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf" target="_blank" rel="external">Leslie Lamport. Time, Clocks and Ordering of Events in a Distributed System.</a></li>
<li><a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf" target="_blank" rel="external">Michael J. Fisher, et al. Impossibility of Distributed Consensus with One Faulty Process.</a></li>
<li><a href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">Giuseppe DeCandia, et al. Dynamo: Amazon’s Highly Available Key-value Store.</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用 Docker Compose 编排容器集群]]></title>
      <url>http://www.sczyh30.com/posts/Architecture/service-with-docker-compose/</url>
      <content type="html"><![CDATA[<p><a href="https://docs.docker.com/compose/" target="_blank" rel="external">Docker Compose</a>可以让我们方便、快速地编排容器集群，有利于分布式架构的实现。</p>
<p>假设我们有一个应用以MySQL作为数据存储，如果没有编排工具的话，我们在构建此应用的Docker镜像时必须将MySQL一同打包进镜像中，这样不仅会使镜像体积臃肿，而且不利于分布式架构的实现（假如要做读写分离、主从复制之类的）。而有了Docker Compose，我们就可以创建两个镜像：单独的应用镜像和MySQL镜像。在运行时，分别创建两个容器，并且将两个容器链接(link)在一起，使它们之间可以按照配置相互通信。这样就将我们的单体应用拆分成了多个组件构成的应用（其实这就是微服务的思想），从而更有利于服务间的解耦以及分布式架构的实现。</p>
<p>下面举一个例子，完整实现可见<a href="https://github.com/sczyh30/vertx-blueprint-todo-backend" target="_blank" rel="external">vertx-blueprint-todo-backend | GitHub</a>。现有一服务<code>Vert.x Blueprint Todo Backend</code>已打包成jar包，该服务以Redis作为数据存储。该服务以及Redis监听的地址和端口通过JSON配置文件来提供。我们可以设计两个镜像：服务镜像（通过<code>Dockerfile</code>构建）以及官方Redis镜像，运行时分别创建一个容器实例，然后通过Docker Compose将两个容器组合起来。首先来看一下我们的<code>Dockerfile</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-jre</div><div class="line"></div><div class="line"><span class="keyword">ENV</span> VERTICLE_FILE build/libs/vertx-blueprint-todo-backend-fat.jar</div><div class="line"></div><div class="line"><span class="keyword">ENV</span> VERTICLE_HOME /usr/verticles</div><div class="line"></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">8082</span></div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$VERTICLE_FILE</span> <span class="variable">$VERTICLE_HOME</span>/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> config/config_docker.json <span class="variable">$VERTICLE_HOME</span>/</span></div><div class="line"></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$VERTICLE_HOME</span></span></div><div class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"sh"</span>, <span class="string">"-c"</span>]</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"java -jar vertx-blueprint-todo-backend-fat.jar -conf config_docker.json"</span>]</span></div></pre></td></tr></table></figure>
<p>服务容器运行时对外暴露8082端口。再看一下服务配置文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"service.type"</span>: <span class="string">"redis"</span>,</div><div class="line">  <span class="attr">"http.port"</span>: <span class="number">8082</span>,</div><div class="line">  <span class="attr">"http.address"</span>: <span class="string">"0.0.0.0"</span>,</div><div class="line">  <span class="attr">"redis.host"</span>: <span class="string">"redis"</span>,</div><div class="line">  <span class="attr">"redis.port"</span>: <span class="number">6379</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意我们将Redis的host设为<code>redis</code>，这个<code>redis</code>是对应的访问路径，后面会提到。下面来看Docker Compose的配置文件<code>docker-compose.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="string">"2"</span></div><div class="line"><span class="attr">services:</span></div><div class="line"><span class="attr">  redis:</span></div><div class="line"><span class="attr">    container_name:</span> vertx-todo-backend_redis</div><div class="line"><span class="attr">    image:</span> redis:latest</div><div class="line"><span class="attr">    expose:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"6379"</span></div><div class="line"></div><div class="line"><span class="attr">  vertx-todo-backend:</span></div><div class="line"><span class="attr">    depends_on:</span></div><div class="line"><span class="bullet">      -</span> redis</div><div class="line"><span class="attr">    container_name:</span> vertx-todo-backend_service</div><div class="line"><span class="attr">    build:</span> .</div><div class="line"><span class="attr">    links:</span></div><div class="line"><span class="bullet">      -</span> redis</div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"8082:8082"</span></div></pre></td></tr></table></figure>
<p>其中<code>version: &quot;2&quot;</code>代表对应镜像版本，最新的需要Docker 1.10.0支持。在<code>services</code>中，我们定义了两个<code>service</code>：<code>redis</code>和<code>vertx-todo-backend</code>。</p>
<p>先来看<code>redis</code>中的配置。<code>container_name</code>代表容器名称，<code>image</code>代表对应的镜像，<code>expose</code>代表在集群内暴露的端口号（不对外暴露）。其它容器通过服务名<code>redis</code>访问此镜像。</p>
<p>再来看<code>vertx-todo-backend</code>。我们的服务需要依赖Redis，因此容器的启动顺序应该是<code>redis -&gt; vertx-todo-backend</code>，因此我们配置了<code>depends_on</code>选项，此选项下的所有容器都将会在本容器启动之前启动（注意只是启动，并不是其它容器初始化完成后本容器才启动。如果需要等待其它容器初始化完毕，则需要另写脚本）。<code>build</code>对应着<code>Dockerfile</code>文件的路径，<code>links</code>代表链接的镜像，<code>ports</code>代表对外暴露的端口。</p>
<p>配置好以后，我们在目录下执行<code>docker-compose up --build</code>，一会就可以看到容器集群运行起来了，非常方便。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vbptds-docker-compose-running.png" alt="Docker Compose"></p>
<p>更多的有关Docker Compose的信息，参考<a href="https://docs.docker.com/compose/" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Gradle中使用Annotation Processing Tool | Vert.x Codegen 示例]]></title>
      <url>http://www.sczyh30.com/posts/Develop/gradle-annotation-processing-vertx-codegen/</url>
      <content type="html"><![CDATA[<p>在Maven中，我们可以很方便地利用 <em>Annotation Processing Tool(APT)</em> 来生成代码，配置简洁明了。比如在Maven中配置<a href="https://github.com/vert-x3/vertx-codegen" target="_blank" rel="external">Vert.x Codegen</a>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Configure the execution of the compiler to execute the codegen processor --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-compile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">annotationProcessors</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">annotationProcessor</span>&gt;</span>io.vertx.codegen.CodeGenProcessor<span class="tag">&lt;/<span class="name">annotationProcessor</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">annotationProcessors</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">arg</span>&gt;</span>-AoutputDirectory=$&#123;project.basedir&#125;/src/main<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></div></pre></td></tr></table></figure>
<p>而Gradle就不是那么方便了，官方文档里没有讲，各种插件又不太好使，因此自己摸索了摸索。其实，我们只要搞明白<code>APT</code>的处理过程，一切问题就迎刃而解了。在编译阶段，我们可以通过<code>-processor</code>来配置对应的注解处理器，并将注解处理器的包文件加到<code>CLASSPATH</code>中。因此，我们可以在Gradle中写一个task来处理注解：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</div><div class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</div><div class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">  <span class="keyword">options</span>.compilerArgs = [</div><div class="line">    <span class="string">"-proc:only"</span>,</div><div class="line">    <span class="string">"-processor"</span>, <span class="string">"xxx.yyy.zzzProcessor"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>source</code>代表源代码目录，<code>classpath</code>设为所有的依赖，<code>destinationDir</code>代表输出路径，<code>options.compilerArgs</code>代表<code>javac</code>的配置项。注意编译期依赖可以用<code>compileOnly</code>表示（Gradle 2.12及以上版本支持）。</p>
<p>下面我们来看一个例子：如何在Gradle中使用Vert.x Codegen。首先先写处理注解的task：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123;</div><div class="line">  <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</div><div class="line">  <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span> + <span class="keyword">configurations</span>.compileOnly</div><div class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</div><div class="line">  <span class="keyword">options</span>.compilerArgs = [</div><div class="line">    <span class="string">"-proc:only"</span>,</div><div class="line">    <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</div><div class="line">    <span class="string">"-AoutputDirectory=$&#123;destinationDir.absolutePath&#125;"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意Vert.x Codegen要设定<code>outputDirectory</code>项（输出路径）方可生成代码。</p>
<p>下面我们在 <code>compileJava</code> 中引用 <code>annotationProcessing</code> ：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">compileJava &#123;</div><div class="line">  <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></div><div class="line">  <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></div><div class="line"></div><div class="line">  dependsOn annotationProcessing</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在进行构建的时候，Gradle就可以利用APT来处理注解，生成代码了。如果要引用这些生成的代码，还要把它们加到源码路径中：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sourceSets</span> &#123;</div><div class="line">  main &#123;</div><div class="line">    java &#123;</div><div class="line">      srcDirs += <span class="string">'src/main/generated'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>题外话：安卓开发中也需要处理一些Android SDK中特定的注解，不过Jack发布后一般都有专门的插件，不需要自己写task。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微服务设计模式 | Circuit Breaker Pattern]]></title>
      <url>http://www.sczyh30.com/posts/Microservice/circuit-breaker-pattern/</url>
      <content type="html"><![CDATA[<p>在分布式环境中，我们的应用可能会面临着各种各样的可恢复的异常（比如超时，网络环境异常），此时我们可以利用不断重试的方式来从异常中恢复(Retry Pattern)，使整个集群正常运行。</p>
<p>然而，也有一些异常比较顽固，突然发生，无法预测，而且很难恢复，并且还会导致级联失败（举个例子，假设一个服务集群的负载非常高，如果这时候集群的一部分挂掉了，还占了很大一部分资源，整个集群都有可能遭殃）。如果我们这时还是不断进行重试的话，结果大多都是失败的。因此，此时我们的应用需要立即进入失败状态(fast-fail)，并采取合适的方法进行恢复。</p>
<p><strong>Circuit Breaker Pattern</strong>（熔断器模式）就是这样的一种设计思想。它可以防止一个应用不断地去尝试一个很可能失败的操作。一个Circuit Breaker相当于一个代理，用于监测某个操作对应的失败比率(<code>fail / fail + success</code>)。它会根据得到的数据来决定是否允许执行此操作，或者是立即抛出异常。</p>
<h1 id="Circuit_Breaker原理">Circuit Breaker原理</h1><p>我们可以用状态机来实现Circuit Breaker，它有以下三种状态：</p>
<ul>
<li>关闭(<strong>Closed</strong>)：默认情况下Circuit Breaker是关闭的，此时允许操作执行。Circuit Breaker内部记录着最近失败的次数，如果对应的操作执行失败，次数就会续一次。如果在某个时间段内，失败次数（或者失败比率）达到阈值，Circuit Breaker会转换到开启(<strong>Open</strong>)状态。在开启状态中，Circuit Breaker会启用一个超时计时器，设这个计时器的目的是给集群相应的时间来恢复故障。当计时器时间到的时候，Circuit Breaker会转换到半开启(<strong>Half-Open</strong>)状态。</li>
<li>开启(<strong>Open</strong>)：在此状态下，执行对应的操作将会立即失败并且立即抛出异常。</li>
<li>半开启(<strong>Half-Open</strong>)：在此状态下，Circuit Breaker会允许执行一定数量的操作。如果所有操作全部成功，Circuit Breaker就会假定故障已经恢复，它就会转换到关闭状态，并且重置失败次数。如果其中 <strong>任意一次</strong> 操作失败了，Circuit Breaker就会认为故障仍然存在，所以它会转换到开启状态并再次开启计时器（再给系统一些时间使其从失败中恢复）。</li>
</ul>
<p>Circuit Breaker的状态图：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/circuit-breaker-states.png" alt="Circuit Breaker Pattern States"></p>
<h1 id="简单实现">简单实现</h1><p><em>TODO</em></p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>Cloud Design Patterns</em>, Microsoft</li>
<li><a href="http://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="external">CircuitBreaker | Martin Fowler</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类型系统 | Existential Type | Scala ++ Java ++ Haskell]]></title>
      <url>http://www.sczyh30.com/posts/Functional-Programming/type-system-existential-types-scala-java/</url>
      <content type="html"><![CDATA[<p><strong>Existential type</strong>(存在类型)提供了一种在类型系统上抽象的方式，其中 <strong>existential type</strong> 这个名称源于 <strong>existential quantification</strong> (存在量词，数学符号<code>∃</code>)。可以这样理解：某种形式的类型存在，但是在上下文中不知道它的具体类型。比如我们定义一种类型<code>type T = ∃x {a: x; f: (x =&gt; Int);}</code>，它可以表示这种类型有一个类型为<code>x</code>的成员变量a，一个类型为<code>x =&gt; Int</code>的成员函数f，而类型<code>x</code>是任意的。</p>
<p>这篇文章我们来探讨一下existential type在Java、Scala和Haskell中的运用。</p>
<h1 id="Existential_type_in_Java">Existential type in Java</h1><p>Existential Type在Java如此烂的类型系统中发挥着重要的作用。Java泛型中的 <strong>Wildcards</strong>(占位符)其实就是一种existential type，比如<code>java.util.List&lt;?&gt;</code>。</p>
<p>由于JVM在编译时会对type parameters进行类型擦除，让它们回归为raw types，因此很多人认为existential type就相当于raw types，比如<code>List =:= List&lt;?&gt;</code>，这是不正确的。它们两种类型最大的区别就是existential type是type safe的，而raw types则不是。在将一个具化的泛型扒掉所有的type parameters的时候，后者是不安全的。我们测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Existential</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"Java"</span>, <span class="string">"sucks"</span>));</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</div><div class="line">		List a = list;</div><div class="line">		a.forEach(System.out::println);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span> </span>&#123;</div><div class="line">		List&lt;?&gt; b = list;</div><div class="line">		b.forEach(System.out::println);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		t1();</div><div class="line">		t2();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译一下，编译器会提示t1方法不安全，而t2则无警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">λ javac ./Existential.java -Xlint:unchecked</div><div class="line">./Existential.java:<span class="number">11</span>: 警告: [unchecked] 对作为原始类型Iterable的成员的forEach(Consumer&lt;? <span class="keyword">super</span> T&gt;)的调用未经过检查</div><div class="line">                a.forEach(System.out::println);</div><div class="line">                         ^</div><div class="line">  其中, T是类型变量:</div><div class="line">    T扩展已在接口 Iterable中声明的Object</div><div class="line"><span class="number">1</span> 个警告</div></pre></td></tr></table></figure>
<p>因此我们要避免使用原始类型。(貌似越写越偏了。。那就顺便总结一下Java的Bounded Wildcards吧:)</p>
<p>Java通过 <strong>Bounded Wildcards</strong>（限定通配符）来实现有限的可变性(variance)，比如</p>
<ul>
<li><code>List&lt;? extends Object&gt;</code>（协变, covariance）</li>
<li><code>List&lt;? super User&gt;</code>（逆变, contravariance）</li>
<li><code>List&lt;?&gt;</code>（不可变, invariance）</li>
</ul>
<p>注意我们无法给限定通配符的List添加任何对象，因为它的类型参数无法确定（这即是existential的含义）。我们可以在方法参数中使用Bounded Wildcards来达到协变和逆变的效果，使用时遵循 <strong>PECS原则</strong> (Producer Extends, Consumer Super)。</p>
<p>注：这里的variance其实是一种<strong>use-site variance</strong>，后边有时间探究一下它与<strong>declaration-site variance</strong>的区别。</p>
<h1 id="Existential_type_in_Scala">Existential type in Scala</h1><p>Scala同样兼容Java的这种use-site variance，语法有两种。一种和Java类似，一种是完整表示方法（<code>forSome</code>关键字）。举个例子：</p>
<table>
<thead>
<tr>
<th>简单表示</th>
<th>完整表示</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Seq[_]</code></td>
<td><code>Seq[T] forSome {type T}</code></td>
<td>T可以是Any类型的任意子类</td>
</tr>
<tr>
<td><code>Seq[_ &lt;: A]</code></td>
<td><code>Seq[T] forSome {type T &lt;: A}</code></td>
<td>T可以是A类型的任意子类</td>
</tr>
<tr>
<td><code>Seq[_ &gt;: Z &lt;: A]</code></td>
<td><code>Seq[T] forSome {type T &gt;: Z &lt;: A}</code></td>
<td>T可以是A类型的任意子类，同时需要是Z类型的父类</td>
</tr>
</tbody>
</table>
<h1 id="Existential_type_in_Haskell">Existential type in Haskell</h1><p>在GHC中使用Existential Types需要开启扩展(<code>-XExistentialQuantification</code>)。Haskell中的Existential Type通过<code>forall</code>关键字来实现。但是，<code>forall</code>代表全称量词<code>∀</code>，这似乎和existential type的含义是对立的，是不是很神奇呢？我们将在稍后解释。这里我们先来看一下我们最熟悉的<code>map</code>函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</div></pre></td></tr></table></figure>
<p>我们还可以通过全称量化的方法构造map：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">map</span> :: <span class="keyword">forall</span> a b. (a -&gt; b) -&gt; [a] -&gt; [b]</div></pre></td></tr></table></figure></p>
<p>这两个map的定义是等价的。其实在Haskell中，很多类型的定义都是隐式地使用了<code>forall</code>。</p>
<p>再比如下边的例子定义了可以show的existential type：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&#123;-# LANGUAGE ExistentialQuantification #-&#125;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">ShowObj</span> = forall a. <span class="type">Show</span> a =&gt; <span class="type">S</span> a</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">ShowObj</span> <span class="keyword">where</span></div><div class="line">	show (<span class="type">S</span> a) = show a</div><div class="line"></div><div class="line"><span class="title">li</span> :: [<span class="type">ShowObj</span>]</div><div class="line"><span class="title">li</span>  = [<span class="type">S</span> <span class="number">1</span>, <span class="type">S</span> <span class="string">"Java"</span>, <span class="type">S</span> <span class="string">"sucks"</span>, <span class="type">S</span> <span class="type">True</span>, <span class="type">S</span> ()]</div><div class="line"></div><div class="line"><span class="title">f</span> :: [<span class="type">ShowObj</span>] -&gt; <span class="type">IO</span> ()</div><div class="line"><span class="title">f</span> xs = mapM_ print xs</div><div class="line"></div><div class="line"><span class="title">main</span> = f li</div></pre></td></tr></table></figure>
<p>下面我们来探究一下<code>existential</code>和<code>forall</code>的真正含义。我们可以将类型看作是某些值的集合，比如<code>Bool</code>类型对应集合<code>{True, False, ⊥}</code>，<code>Integer</code>对应数的集合。注意bottom(<code>⊥</code>)属于每一个类型。</p>
<p><code>forall</code>代表这些集合的交集。我们举一些例子：</p>
<ul>
<li><code>forall a. a</code>是所有类型的交集，也就是<code>{⊥}</code></li>
<li><code>[forall a. Show a =&gt; a]</code>代表一种所含元素均为<code>forall a. Show a =&gt; a</code>类型的列表类型，<code>Show</code> Typeclass限定了只能在<code>Show</code>的instance里取交集</li>
</ul>
<p>我们随便定义一个existential datatype(下面我们用<code>∀</code>代替forall，用<code>∃</code>代替exists)：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">T</span> = ∀ a. <span class="type">MkT</span> a</span></div></pre></td></tr></table></figure></p>
<p>其中MkT的含义是产生一个T类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">MkT</span> :: <span class="keyword">forall</span> a. a -&gt; <span class="type">T</span></div><div class="line"><span class="type">MkT</span> :: a -&gt; <span class="type">T</span> <span class="comment">&#123;- 等价 -&#125;</span></div></pre></td></tr></table></figure></p>
<p>那么当我们对MkT进行解构的时候又会发生什么呢？比如进行模式匹配的时候：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">f</span> (<span class="type">MkT</span> x) = ...</div></pre></td></tr></table></figure></p>
<p>此时<code>x</code>的类型可以是任意的，也就是说我们可以用存在量词来表示x：<code>x :: ∃ a. a</code>。我们知道存在这种类型x，但不清楚x的真正类型。这样的定义<strong>同构</strong>于上边我们用全称量词的定义，即这两种定义等价：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">T</span> = ∀ a. <span class="type">MkT</span> a</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">T</span> = <span class="type">MkT</span> (∃ <span class="title">a</span>. <span class="title">a</span>)</span></div></pre></td></tr></table></figure>
<p>而Haskell选择了前者的表达方式(<code>forall</code>)，即在Haskell中existential type通过<code>forall</code>关键字来实现。（为何不用<code>exists</code>？我也不清楚。。）</p>
<p>所以现在再回头来看我们之前定义的<code>ShowObj</code>类型，我们可以把它转化为用存在量词表达的existential type:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">ShowObj</span> = forall a. <span class="type">Show</span> a =&gt; <span class="type">S</span> a</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">ShowObj'</span> = <span class="type">S'</span> (<span class="title">exists</span> <span class="title">a</span>. <span class="type">Show</span> <span class="title">a</span> =&gt; <span class="title">a</span>) &#123;- <span class="type">Haskell</span>里不能这么写 -&#125;</span></div></pre></td></tr></table></figure>
<p>在Haskell各种类库中existential type用的非常多，例如<code>Control.Monad.ST</code>中的<code>runST</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">runST</span> :: <span class="keyword">forall</span> α. (<span class="keyword">forall</span> s. <span class="type">ST</span> s α) -&gt; α</div></pre></td></tr></table></figure></p>
<p>这里先不展开写了，后边有时间多实践实践再说。。。</p>
<h1 id="Heterogeneous_List">Heterogeneous List</h1><p><strong>待填坑</strong>。。Miles Sabin大神的Shapeless库中的 <strong>Heterogeneous List(HList)</strong> 值得一读。。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>Scala Language Specification</em>, 3.2.10</li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types" target="_blank" rel="external">Haskell/Existentially quantified types</a></li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#existentially-quantified-data-constructors" target="_blank" rel="external">GHC Users Guide, 9.4.6. Existentially quantified data constructors</a></li>
<li><a href="http://typelevel.org/blog/2015/02/26/rawtypes.html" target="_blank" rel="external">Typelevel - Existential types are not raw types</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类型系统 | Refinement Type]]></title>
      <url>http://www.sczyh30.com/posts/Functional-Programming/type-system-refinement-types/</url>
      <content type="html"><![CDATA[<p>最近在看某个Slide的时候里了解到了Refinement type这个玩意儿，今天拿来总结总结。</p>
<h1 id="何为Refinement_Type">何为Refinement Type</h1><p>言简意赅的讲：</p>
<blockquote>
<p>Refinement Types = Types + Logical Predicates</p>
</blockquote>
<p>即Refinement Type是由类型和谓词逻辑组合而成的，其中谓词逻辑可以对类型的值域进行约束。也就是说，我们可以在原有类型的基础上给它加个值的限定，并且可以在编译时检测是否符合谓词逻辑限定。</p>
<p>下面我们来玩一下Haskell和Scala中典型的Refinement Type库。</p>
<h1 id="LiquidHaskell">LiquidHaskell</h1><p><a href="https://github.com/ucsd-progsys/liquidhaskell" target="_blank" rel="external">LiquidHaskell</a>是Haskell上一个基于Liquid Types的静态分析器，可以通过Refinement Type进行静态检查。安装的时候注意需要系统环境中有logic solvers(比如<code>z3</code>)。</p>
<p>下边我们来看看如何使用LiquidHaskell：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">module</span> RfT <span class="keyword">where</span></div><div class="line"></div><div class="line"><span class="comment">&#123;-@ zero'' :: &#123;v: Int | v &gt;= 0 &amp;&amp; v &lt; 24 &#125; @-&#125;</span></div><div class="line"><span class="title">zero'</span> :: <span class="type">Int</span></div><div class="line"><span class="title">zero'</span> = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">&#123;-@ zero'' :: &#123;v: Int | v &gt; 5 &#125; @-&#125;</span></div><div class="line"><span class="title">zero''</span> :: <span class="type">Int</span></div><div class="line"><span class="title">zero''</span> = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>我们定义了两个函数<code>zero&#39;</code>和<code>zero&#39;&#39;</code>，这两个函数的值都是0。我们在每个函数的声明前都加了一行谓词逻辑的限定，语法类似于：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&#123;-@ f :: &#123;x: T | predicate &#125; @-&#125;</span></div></pre></td></tr></table></figure></p>
<p>比如<code>{-@ zero&#39;&#39; :: {v: Int | v &gt; 5 } @-}</code>代表<code>zero&#39;&#39;</code>函数有一个类型为Int的参数，而且接受的值必须大于5，这就是谓词逻辑限定。我们运行一下看看结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ liquid --diff rft1.hs</div></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="type">LiquidHaskell</span> <span class="type">Copyright</span> <span class="number">2009</span><span class="number">-15</span> <span class="type">Regents</span> <span class="keyword">of</span> the <span class="type">University</span> <span class="keyword">of</span> <span class="type">California</span>. <span class="type">All</span> <span class="type">Rights</span> <span class="type">Reserved</span>.</div><div class="line"></div><div class="line"></div><div class="line">**** <span class="type">DONE</span>:  <span class="type">Parsed</span> <span class="type">All</span> <span class="type">Specifications</span> ******************************************</div><div class="line"></div><div class="line"></div><div class="line">**** <span class="type">DONE</span>:  <span class="type">Loaded</span> <span class="type">Targets</span> *****************************************************</div><div class="line"></div><div class="line"></div><div class="line">**** <span class="type">DONE</span>:  <span class="type">Extracted</span> <span class="type">Core</span> using <span class="type">GHC</span> *******************************************</div><div class="line"></div><div class="line"></div><div class="line">**** <span class="type">DONE</span>:  generateConstraints ************************************************</div><div class="line"></div><div class="line"><span class="type">Done</span> solving.</div><div class="line"><span class="type">Safe</span></div><div class="line"></div><div class="line">**** <span class="type">DONE</span>:  solve **************************************************************</div><div class="line"></div><div class="line"></div><div class="line">**** <span class="type">DONE</span>:  annotate ***********************************************************</div><div class="line"></div><div class="line"></div><div class="line">**** <span class="type">Checked</span> <span class="type">Binders</span>: <span class="type">None</span> *****************************************************</div><div class="line"></div><div class="line">**** <span class="type">RESULT</span>: <span class="type">UNSAFE</span> ************************************************************</div><div class="line"></div><div class="line"></div><div class="line"> rft1.hs:<span class="number">10</span>:<span class="number">1</span><span class="number">-6</span>: <span class="type">Error</span>: <span class="type">Liquid</span> <span class="type">Type</span> <span class="type">Mismatch</span></div><div class="line">  <span class="type">Inferred</span> <span class="class"><span class="keyword">type</span></span></div><div class="line">    <span class="type">VV</span> : &#123;<span class="type">VV</span> : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | <span class="type">VV</span> == (<span class="number">0</span> : int)&#125;</div><div class="line"></div><div class="line">  not a subtype <span class="keyword">of</span> <span class="type">Required</span> <span class="class"><span class="keyword">type</span></span></div><div class="line">    <span class="type">VV</span> : &#123;<span class="type">VV</span> : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | <span class="type">VV</span> &gt; <span class="number">5</span>&#125;</div><div class="line"></div><div class="line">  <span class="type">In</span> <span class="type">Context</span></div></pre></td></tr></table></figure>
<p>LiquidHaskell成功地检测出了错误 —— <code>zero&#39;&#39;</code>函数不符合谓词逻辑限定。</p>
<p>下边再举个对函数参数和返回值进行refine的例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&#123;- Preconditions -&#125;</span></div><div class="line"></div><div class="line"><span class="comment">&#123;-@ divide :: Int -&gt; &#123;v: Int | v != 0 &#125; -&gt; Int @-&#125;</span></div><div class="line"><span class="title">divide</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></div><div class="line"><span class="title">divide</span> n d = n `div` d</div><div class="line"></div><div class="line"><span class="title">f1</span> :: <span class="type">Int</span></div><div class="line"><span class="title">f1</span> = divide <span class="number">1</span> <span class="number">0</span></div><div class="line"></div><div class="line"><span class="title">f2</span> :: <span class="type">Int</span></div><div class="line"><span class="title">f2</span> = divide <span class="number">1</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment">&#123;- Postconditions -&#125;</span></div><div class="line"><span class="comment">&#123;-@ abs' :: Int -&gt; &#123;v: Int | v &gt;= 0 &#125; @-&#125;</span></div><div class="line"><span class="title">abs'</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></div><div class="line"><span class="title">abs'</span> n | n &gt; <span class="number">0</span> 	   = n</div><div class="line">	   | otherwise = <span class="number">0</span> - n</div></pre></td></tr></table></figure>
<p>验证结果符合我们的期望：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="title">rft1</span>.hs:<span class="number">19</span>:<span class="number">6</span><span class="number">-15</span>: <span class="type">Error</span>: <span class="type">Liquid</span> <span class="type">Type</span> <span class="type">Mismatch</span></div><div class="line"></div><div class="line"><span class="number">19</span> | f1 = divide <span class="number">1</span> <span class="number">0</span></div><div class="line">          ^^^^^^^^^^</div><div class="line"></div><div class="line">  <span class="type">Inferred</span> <span class="class"><span class="keyword">type</span></span></div><div class="line">    <span class="type">VV</span> : &#123;<span class="type">VV</span> : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | <span class="type">VV</span> == ?a&#125;</div><div class="line"></div><div class="line">  not a subtype <span class="keyword">of</span> <span class="type">Required</span> <span class="class"><span class="keyword">type</span></span></div><div class="line">    <span class="type">VV</span> : &#123;<span class="type">VV</span> : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | <span class="type">VV</span> /= <span class="number">0</span>&#125;</div><div class="line"></div><div class="line">  <span class="type">In</span> <span class="type">Context</span></div><div class="line">    ?a := &#123;?a : <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> | ?a == (<span class="number">0</span> : int)&#125;</div></pre></td></tr></table></figure>
<p>可以看到LiquidHaskell可以验证函数的先验条件和后验条件。</p>
<p>至于其中的实现原理，可以参考这篇论文：<a href="http://goto.ucsd.edu/~rjhala/liquid/liquid_types.pdf" target="_blank" rel="external">Liquid Types</a>（数学推导太多，没看懂&gt;_&lt;）</p>
<h1 id="refined(Scala)">refined(Scala)</h1><p><a href="https://github.com/fthomas/refined" target="_blank" rel="external">refined</a>是Scala中一个Refinement Type的实现（貌似也是借鉴的Haskell的库，连名字都抄过来了）。我们在REPL里玩玩，首先导入相关的包：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> eu.timepit.refined._</div><div class="line"><span class="keyword">import</span> eu.timepit.refined.api.<span class="type">Refined</span></div><div class="line"><span class="keyword">import</span> eu.timepit.refined.auto._</div><div class="line"><span class="keyword">import</span> eu.timepit.refined.numeric._</div><div class="line"><span class="keyword">import</span> eu.timepit.refined.boolean._</div><div class="line"><span class="keyword">import</span> eu.timepit.refined.char._</div><div class="line"><span class="keyword">import</span> eu.timepit.refined.collection._</div><div class="line"><span class="keyword">import</span> eu.timepit.refined.generic._</div><div class="line"><span class="keyword">import</span> eu.timepit.refined.string._</div><div class="line"><span class="keyword">import</span> shapeless.&#123; ::, <span class="type">HNil</span> &#125;</div></pre></td></tr></table></figure>
<p>refined这个库直接在类型系统上进行限定，通过一个<code>Refined[T, P]</code>类型(aka <code>T Refined P</code>, T - 类型， P - 谓词逻辑)来表示，比如正整数可以表示为<code>Int Refined Positive</code>，非空字符串可以表示为<code>String Refined NonEmpty</code>。几个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> i1: <span class="type">Int</span> <span class="type">Refined</span> <span class="type">Positive</span> = <span class="number">5</span></div><div class="line">i1: eu.timepit.refined.api.<span class="type">Refined</span>[<span class="type">Int</span>,eu.timepit.refined.numeric.<span class="type">Positive</span>] = <span class="number">5</span></div><div class="line"></div><div class="line">scala&gt; <span class="keyword">val</span> i2: <span class="type">Int</span> <span class="type">Refined</span> <span class="type">Positive</span> = <span class="number">-5</span></div><div class="line">&lt;console&gt;:<span class="number">21</span>: error: <span class="type">Predicate</span> failed: (<span class="number">-5</span> &gt; <span class="number">0</span>).</div><div class="line">       <span class="keyword">val</span> i2: <span class="type">Int</span> <span class="type">Refined</span> <span class="type">Positive</span> = <span class="number">-5</span></div><div class="line"></div><div class="line">scala&gt; <span class="keyword">val</span> i3: <span class="type">String</span> <span class="type">Refined</span> <span class="type">NonEmpty</span> = <span class="string">""</span></div><div class="line">&lt;console&gt;:<span class="number">37</span>: error: <span class="type">Predicate</span> isEmpty() did not fail.</div><div class="line">       <span class="keyword">val</span> i3: <span class="type">String</span> <span class="type">Refined</span> <span class="type">NonEmpty</span> = <span class="string">""</span></div><div class="line">                                         ^</div><div class="line"></div><div class="line">scala&gt; <span class="keyword">val</span> u1: <span class="type">String</span> <span class="type">Refined</span> <span class="type">Url</span> = <span class="string">"htp://example.com"</span></div><div class="line">&lt;console&gt;:<span class="number">37</span>: error: <span class="type">Url</span> predicate failed: unknown protocol: htp</div><div class="line">       <span class="keyword">val</span> u1: <span class="type">String</span> <span class="type">Refined</span> <span class="type">Url</span> = <span class="string">"htp://example.com"</span></div><div class="line">                                    ^</div></pre></td></tr></table></figure></p>
<p>可以看到refined内置不少Predicate，也可以自己自定义Predicate。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs" target="_blank" rel="external">Refinement Types 101 - LiquidHaskell</a></li>
<li><a href="http://refined.timepit.eu" target="_blank" rel="external">refined: simple refinement types for Scala</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Play Framework 2.5 | Web开发总结]]></title>
      <url>http://www.sczyh30.com/posts/Scala/play-framework-2-5-web-summary/</url>
      <content type="html"><![CDATA[<p>Samsara Aquarius已完成，是时候总结一下Play Framework的一些有用的东西和一些坑了～这里对应的Play版本为 <strong>2.5.2</strong>。</p>
<h1 id="Action,_Controller_和_Result">Action, Controller 和 Result</h1><p>在Play的Web开发中，<strong>Action</strong>, <strong>Controller</strong> 和 <strong>Result</strong> 这三个东西最为重要了。我们一个一个来解释：</p>
<h2 id="Result">Result</h2><p><code>Result</code>代表HTTP请求的结果，它包含header和body两部分。Play内部封装了常见的HTTP response状态，可以在这些Status的基础上生成Result，比如<code>200 OK</code>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Generates a ‘200 OK’ result. */</span></div><div class="line"><span class="keyword">val</span> <span class="type">Ok</span> = <span class="keyword">new</span> <span class="type">Status</span>(<span class="type">OK</span>)</div></pre></td></tr></table></figure></p>
<h2 id="Action">Action</h2><p>每个Action相当于一个<code>Request =&gt; Result</code>类型（处理请求并返回结果）的函数，即每个Action都接受一个<code>Request</code>对象（代表HTTP请求），并产生<code>Result</code>对象（代表HTTP回应）。</p>
<p>Play Framework 2底层是基于Netty实现的，因此<code>Action</code>经过处理以后会在Netty通信层执行(Reactor模式)。关于Action的详细实现，后边我还会专门写一篇文章分析。</p>
<h2 id="Controller">Controller</h2><p>在Play中，Controller里的函数用于生成Action。其实Action就相当于处理请求的函数，只不过将普通的函数包装了一层而已（继承关系：<code>Action &lt;:&lt; EssentialAction &lt;:&lt; (RequestHeader =&gt; Accumulator[ByteString, Result])</code>），因此调用这些函数其实就是在调用Action中包装的函数。</p>
<h1 id="Session、Cookie与Flash">Session、Cookie与Flash</h1><p>Play中处理Session、Cookie的语法都比较简洁。比如Cookie的添加与删除：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> res1 = <span class="type">Ok</span>(<span class="string">"Good Scala"</span>) withCookies <span class="type">Cookie</span>(<span class="string">"fuck"</span>, <span class="string">"shit"</span>)</div><div class="line"><span class="keyword">val</span> res2 = res1.discardingCookies(<span class="type">DiscardingCookie</span>(<span class="string">"fuck"</span>))</div></pre></td></tr></table></figure>
<p>Session的使用也类似：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> res2 = <span class="type">Ok</span>(<span class="string">"Good Scala"</span>) withSession <span class="type">Session</span>(<span class="string">"fuck"</span>, <span class="string">"shit"</span>)</div><div class="line"><span class="keyword">val</span> res_rm = res2 withNewSession <span class="comment">// clear session</span></div></pre></td></tr></table></figure>
<p>但是Play里的session有个坑，它没实现expiration的功能，因此需要我们自己在session中加个时间戳，然后自己实现expiration的逻辑。</p>
<p>另外还有个<strong>大坑</strong>！如果需要添加session的话，需要这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Ok</span>(<span class="string">"Good Scala"</span>) withSession (request.session + <span class="type">Session</span>(<span class="string">"fuck"</span>, <span class="string">"shit"</span>))</div></pre></td></tr></table></figure>
<p>因为<code>withSession(s)</code>方法会将<code>s</code>设为当前的session，原先的session将会被抹掉。<br>。所以一定要把原先的session加上，要不然原先的session会丢失。</p>
<p>Flash和Session类似，但Flash只在一个request内有效，多用于request之间数据的传递：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Ok</span>(<span class="string">"Good Scala"</span>) flashing <span class="string">"fuck"</span> -&gt; <span class="string">"shit"</span></div></pre></td></tr></table></figure>
<h1 id="自定义Action">自定义Action</h1><p>比如有一些逻辑中，我们需要验证用户是否登录，如果没有登录就自动跳转到登录界面。如果在每个Action中都写上登录验证逻辑的话会非常不优美，因此我们可以自定义一个<code>AuthenticatedAction</code>，里面包装了权限验证的逻辑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">AuthenticatedAction</span> <span class="keyword">extends</span> <span class="title">ActionBuilder</span>[<span class="type">Request</span>] </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span></span>[<span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>],</div><div class="line">                              block: (<span class="type">Request</span>[<span class="type">A</span>]) =&gt; <span class="type">Future</span>[<span class="type">Result</span>]): <span class="type">Future</span>[<span class="type">Result</span>] = &#123;</div><div class="line">    utils.<span class="type">DateUtils</span>.ensureSession(request)</div><div class="line">    request.session.get(<span class="string">"user_token"</span>) <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(u) =&gt;</div><div class="line">        block(request)</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">        <span class="type">Future</span>.successful(<span class="type">Redirect</span>(routes.<span class="type">UserController</span>.loginIndex()))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们自定义的Action需要实现<code>ActionBuilder[Request]</code>接口，并重写<code>invokeBlock</code>函数。</p>
<h1 id="拦截器">拦截器</h1><p>在Play中使用Filter也非常方便。比如我们想给应用添加安全拦截器，我们可以写一个Filter：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> filters</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.inject.<span class="type">Inject</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> play.api.http.<span class="type">HttpFilters</span></div><div class="line"><span class="keyword">import</span> play.filters.headers.<span class="type">SecurityHeadersFilter</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filters</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">security: <span class="type">SecurityHeadersFilter</span></span>) <span class="keyword">extends</span> <span class="title">HttpFilters</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">filters</span> </span>= <span class="type">Seq</span>(security)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中我们通过依赖注入获取安全拦截器<code>SecurityHeadersFilter</code>实例。然后，我们在<code>application.conf</code>中配置拦截器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">play.http.filters=filters.<span class="type">Filters</span></div></pre></td></tr></table></figure>
<h1 id="依赖注入">依赖注入</h1><p>Play Framework 2.4.0开始又引入了依赖注入（学习Spring大乱炖的节奏）。之前写了一篇总结：<a href="http://www.sczyh30.com/posts/Scala/play-framework-2-5-dependency-injection-di/">Play Framework 2.5 | Dependency Injection总结</a>。</p>
<h1 id="Twirl模板引擎">Twirl模板引擎</h1><p>这次开发还顺便玩了玩Play 2的Twirl模板引擎，用起来还比较顺手～不过现在一般都用前后端分离的架构了，后端模板引擎也用的少了。</p>
<h1 id="微服务架构思考">微服务架构思考</h1><p>用Play做微服务应用是一个不错的选择，那么如何将单体架构重构成微服务架构呢？这里面就有一个主要的问题：如何将各个组件解耦。一种最简单的思路就是用Play实现一个API Gateway作为网关服务(需要多实例部署+负载均衡+高可用)，API Gateway将请求分派到各个组件中，组件之间通过Actor进行通信。可以总结为两点：事件驱动+异步通信。事件驱动可以使整个微服务架构更加灵活，各个组件的耦合度降低，而基于Akka Actor的异步通信可以提高并发性能，提高吞吐量。当然实际生产环境中还要考虑容错、高可用等等的问题，设计起来会更加复杂。</p>
<hr>
<h1 id="TODO">TODO</h1><ul>
<li>Play 2.5 Streaming(Iteratees/Enumerator/Akka Stream)</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scala | Type Lambda]]></title>
      <url>http://www.sczyh30.com/posts/Functional-Programming/scala-type-lambda/</url>
      <content type="html"><![CDATA[<p>这里来总结一下Scala类型系统中的Type Lambda，这是一个神奇的Trick，可以在类型上做有限的类似于Lambda Calculus的运算。</p>
<h1 id="Type_Lambda">Type Lambda</h1><p>为了便于理解，这里就以熟悉的Monad开始。首先定义我们的Monad Typeclass:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">M</span>[_]] </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">M</span>[<span class="type">A</span>]</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;=</span></span>[<span class="type">A</span>, <span class="type">B</span>](m: <span class="type">M</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">M</span>[<span class="type">B</span>]): <span class="type">M</span>[<span class="type">B</span>]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出Monad的kind为<code>(* -&gt; *) -&gt; *</code>。</p>
<p>假如我们想为<code>Either[+A, +B]</code>类型的右投影(Right Projection)实现对应的Monad，这里就会出现一个问题：<code>Either[+A, +B]</code>类型的kind为<code>* -&gt; * -&gt; *</code>，而Monad最多接受kind为<code>* -&gt; *</code>的type constructor，因此如果我们想把Either塞进Monad里，就必须将其kind化为<code>* -&gt; *</code>。是不是很像在类型系统上进行Currying(柯里化)呢？这就是<strong>type lambda</strong>的作用。我们可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">EitherMonad</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Monad</span>[(&#123;type λ[α] </span>= <span class="type">Either</span>[<span class="type">A</span>, α]&#125;)#λ] &#123;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">B</span>](a: <span class="type">B</span>): <span class="type">Either</span>[<span class="type">A</span>, <span class="type">B</span>]</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;=</span></span>[<span class="type">B</span>, <span class="type">C</span>](m: <span class="type">Either</span>[<span class="type">A</span>, <span class="type">B</span>])(f: <span class="type">B</span> =&gt; <span class="type">Either</span>[<span class="type">A</span>, <span class="type">C</span>]): <span class="type">Either</span>[<span class="type">A</span>, <span class="type">C</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们来分析一下此Monad对应的type parameter是什么玩意儿。首先，<code>{type λ[α] = Either[A, α]}</code>这一块是一个<strong>structural type</strong>，在其内部定义了一个类型λ，接受一个类型参数α，此类型与<code>Either[A, α]</code>类型相对应。也就是说这个类型相当于<code>Either[A, _]</code>这个type constructor，它再接受一个类型参数从而构造出完整的Either[A, B]类型(kind为<code>*</code>)。接着我们通过类型投影（<code>#</code>操作符）得到这个λ类型（通过反射），它的kind为<code>* -&gt; *</code>，从而符合Monad类型参数的要求。</p>
<p>这样的trick就是<strong>Type Lambda</strong>，它相当于在类型系统上(对type constructor)进行Currying。我们可以看到它的实现非常巧妙，巧妙地利用了structural type和type projection。</p>
<p>我们类比一下Currying。比如有函数（为了表示方便，这里用Haskell函数表示）：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">f</span> :: (<span class="type">Int</span> a) =&gt; a -&gt; b -&gt; c</div></pre></td></tr></table></figure></p>
<p>我们可以对其进行Currying：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">f</span> :: (<span class="type">Int</span> a) =&gt; a -&gt; (b -&gt; c)</div><div class="line"></div><div class="line"><span class="title">g</span> :: b -&gt; c</div><div class="line"><span class="title">g</span> = f <span class="number">0</span> <span class="comment">&#123;- eta reduction -&#125;</span></div></pre></td></tr></table></figure></p>
<p>同样，在类型系统上我们也可以这么干，比如我们要将kind为<code>* -&gt; * -&gt; *</code>的<code>Either[A, B]</code>化为kind为<code>* -&gt; *</code>的<code>Either[A, _]</code>，这时候我们就可以利用type lambda来进行转化。</p>
<blockquote>
<p><strong>题外话（关于Haskell）</strong>：这样的操作其实属于类型组合(type composition)。Haskell中的<code>Control.Compose</code>模块提供了一系列的用于类型组合的玩意，有兴趣的可以看看Hackage中的<a href="http://hackage.haskell.org/package/TypeCompose-0.6.3/docs/Control-Compose.html" target="_blank" rel="external">文档</a>玩一玩～</p>
</blockquote>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://stackoverflow.com/questions/8736164/what-are-type-lambdas-in-scala-and-what-are-their-benefits" target="_blank" rel="external">What are type lambdas in Scala and what are their benefits?</a></li>
<li><a href="https://wiki.haskell.org/TypeCompose" target="_blank" rel="external">TypeCompose</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Akka Actor | 注意sender的闭包范围]]></title>
      <url>http://www.sczyh30.com/posts/Scala/akka-actor-sender-enclosing/</url>
      <content type="html"><![CDATA[<p>Akka Actor里都有一个sender方法返回此消息的发送方Actor，进行消息回复非常方便。但是在使用sender时，需要注意一点： <strong>不要在可能运行于其它线程的闭包中调用sender方法，也就是说一定要在当前Actor范围内调用sender方法</strong>，否则会出现各种问题。正好写Aquarius的时候用到了Actor，就用它演示一下。假设我们收到请求收藏的消息，并调用相关业务逻辑进行异步操作，并向sender返回操作结果。假如我们这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> go @ <span class="type">FavoriteOn</span>(a, u) =&gt;</div><div class="line">      service ❤ go onComplete &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt;</div><div class="line">          sender ! <span class="type">FAVORITE_PROCESS_SUCCESS</span></div><div class="line">        <span class="keyword">case</span> <span class="type">Failure</span>(ex) =&gt;</div><div class="line">          sender ! <span class="type">FAVORITE_PROCESS_FAIL</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 其他代码略</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这是对应的请求逻辑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> timeout = <span class="type">Timeout</span>(<span class="number">5</span> seconds)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">like</span></span>(aid: <span class="type">Int</span>, uid: <span class="type">Int</span>) = <span class="type">Action</span>.async &#123; <span class="keyword">implicit</span> request =&gt;</div><div class="line">    <span class="comment">// 省略其它逻辑</span></div><div class="line">    (alActor ? <span class="type">FavoriteOn</span>(aid, uid.toInt)).mapTo[<span class="type">ProcessResult</span>] map &#123; reply =&gt;</div><div class="line">      <span class="type">Ok</span>(<span class="type">Json</span>.toJson(reply))</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>我们会发现，发出请求5s后抛出<code>AskTimeoutException</code>异常，表明Actor没有发送回reply：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">play.api.http.<span class="type">HttpErrorHandlerExceptions</span>$$anon$<span class="number">1</span>: <span class="type">Execution</span> exception[[<span class="type">AskTimeoutException</span>: <span class="type">Ask</span> timed out on [<span class="type">Actor</span>[akka:<span class="comment">//application/user/article-favorite-actor#377237056]] after [5000 ms]. Sender[null] sent message of type "message.FavoriteMessageActor$FavoriteOn".]]</span></div><div class="line">	at play.api.http.<span class="type">HttpErrorHandlerExceptions</span>$.throwableToUsefulException(<span class="type">HttpErrorHandler</span>.scala:<span class="number">269</span>)</div><div class="line">	at play.api.http.<span class="type">DefaultHttpErrorHandler</span>.onServerError(<span class="type">HttpErrorHandler</span>.scala:<span class="number">195</span>)</div><div class="line">	at play.core.server.netty.<span class="type">PlayRequestHandler</span>$$anonfun$<span class="number">2</span>$$anonfun$apply$<span class="number">1.</span>applyOrElse(<span class="type">PlayRequestHandler</span>.scala:<span class="number">99</span>)</div><div class="line">	at play.core.server.netty.<span class="type">PlayRequestHandler</span>$$anonfun$<span class="number">2</span>$$anonfun$apply$<span class="number">1.</span>applyOrElse(<span class="type">PlayRequestHandler</span>.scala:<span class="number">98</span>)</div><div class="line">	...</div><div class="line"><span class="type">Caused</span> by: akka.pattern.<span class="type">AskTimeoutException</span>: <span class="type">Ask</span> timed out on [<span class="type">Actor</span>[akka:<span class="comment">//application/user/article-favorite-actor#377237056]] after [5000 ms]. Sender[null] sent message of type "message.FavoriteMessageActor$FavoriteOn".</span></div><div class="line">	at akka.pattern.<span class="type">PromiseActorRef</span>$$anonfun$<span class="number">1.</span>apply$mcV$sp(<span class="type">AskSupport</span>.scala:<span class="number">604</span>)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>在对应Actor中检测sender的path，结果为<code>deadLetters</code>，表明我们此处获得的sender并不是消息发送方。这是因为上面的代码在Future的<code>onComplete</code>闭包中调用了sender方法，而<code>onComplete</code>闭包代码会异步执行（在另一个线程内），从而获得的sender并不是消息接收时对应的sender，行为是未定义，线程不安全的（可能会导致资源争用）。因此我们需要在Actor作用域内获取sender actor：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">val</span> sender = <span class="keyword">super</span>.sender()</div><div class="line">    <span class="keyword">case</span> go @ <span class="type">FavoriteOn</span>(a, u) =&gt;</div><div class="line">      service ❤ go onComplete &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt;</div><div class="line">          sender ! <span class="type">FAVORITE_PROCESS_SUCCESS</span></div><div class="line">        <span class="keyword">case</span> <span class="type">Failure</span>(ex) =&gt;</div><div class="line">          sender ! <span class="type">FAVORITE_PROCESS_FAIL</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 其他代码略</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这样就确保sender是消息接收时对应的发送方Actor，从而可以正常的发送reply。</p>
<p>总结几种典型情况及解决方法：</p>
<ul>
<li>可变状态，如以下代码会导致未定义行为（由于资源争用），因此在Actor中不要使用共享的可变状态（一切都val！），或使用<code>DynamicVariable</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> state = <span class="type">State</span>()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">      <span class="keyword">case</span> _ =&gt;</div><div class="line">        <span class="type">Future</span> &#123; state = newState &#125;</div><div class="line">        otherActor ? message onSuccess &#123; r =&gt; state = r &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Future的<code>onComplete</code>、<code>onSuccess</code>和<code>onFailure</code>。在这些回调中必须正确地引用sender（在Actor作用域内获取或通过<code>self</code>）</li>
</ul>
<p>目前来说，编译器不能在编译期检查出sender的问题，因此写代码的时候一定要头脑清醒，注意sender的闭包范围。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Linux环境下玩转MIDI]]></title>
      <url>http://www.sczyh30.com/posts/Miscellaneous/play-music-on-linux/</url>
      <content type="html"><![CDATA[<p>今天在Ubuntu下搭了各种MIDI环境，为后边玩 <em>Haskell School of Music</em> 中讲的Euterpea音乐库做准备。网上相关的文章比较少，这里就写篇文章记录一下吧。。。</p>
<h1 id="ASLA">ASLA</h1><p>首先介绍一下ASLA(Advanced Linux Sound Architecture)，它为Linux提供了MIDI和音频功能，相当于Linux下音频的基础。Ubuntu应该自带ALSA。</p>
<p><img src="http://tedfelix.com/linux/linux-midi.png" alt=""></p>
<p>查看一下当前系统的内核：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sczyh30@sczyh30-workshop:~$  uname -a</div><div class="line">Linux sczyh30-workshop 3.19.0-49-generic #55-Ubuntu SMP Fri Jan 22 02:10:24 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</div></pre></td></tr></table></figure></p>
<p>由于玩MIDI对时间要求严格，不能卡顿，因此推荐用低延时的内核(Low Latency Kernel)，可以通过<code>sudo apt-get install linux-lowlatency</code>安装然后调整<code>CONFIG_HZ</code>参数。</p>
<p>然后我们来查看一下ALSA设备：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sczyh30@sczyh30-workshop:~$  cat /proc/asound/cards</div><div class="line"> 0 [HDMI           ]: HDA-Intel - HDA Intel HDMI</div><div class="line">                      HDA Intel HDMI at 0xf7b14000 irq 34</div><div class="line"> 1 [PCH            ]: HDA-Intel - HDA Intel PCH</div><div class="line">                      HDA Intel PCH at 0xf7b10000 irq 33</div></pre></td></tr></table></figure></p>
<p>从出现的列表看不出哪个是声卡设备，因此再用<code>aplay</code>命令看一下详细信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sczyh30@sczyh30-workshop:~$  aplay -l</div><div class="line">**** PLAYBACK 硬體裝置清單 ****</div><div class="line">card 0: HDMI [HDA Intel HDMI], device 3: HDMI 0 [HDMI 0]</div><div class="line">  子设备: 1/1</div><div class="line">  子设备 #0: subdevice #0</div><div class="line">card 0: HDMI [HDA Intel HDMI], device 7: HDMI 1 [HDMI 1]</div><div class="line">  子设备: 1/1</div><div class="line">  子设备 #0: subdevice #0</div><div class="line">card 0: HDMI [HDA Intel HDMI], device 8: HDMI 2 [HDMI 2]</div><div class="line">  子设备: 1/1</div><div class="line">  子设备 #0: subdevice #0</div><div class="line">card 1: PCH [HDA Intel PCH], device 0: ALC892 Analog [ALC892 Analog]</div><div class="line">  子设备: 0/1</div><div class="line">  子设备 #0: subdevice #0</div><div class="line">card 1: PCH [HDA Intel PCH], device 1: ALC892 Digital [ALC892 Digital]</div><div class="line">  子设备: 1/1</div><div class="line">  子设备 #0: subdevice #0</div></pre></td></tr></table></figure>
<p>可以看到card 1位置为声卡，在ALSA设备里表示为<code>hw:1</code>，当然card 1处有两个子设备，可以分别用<code>hw:1,0</code>和<code>hw:1,1</code>表示。在下边调用ALSA设备的时候都会用到<code>hw:1</code>。</p>
<p>下面来测试一下ALSA音频功能。首先通过<code>sox</code>命令生成一段音频，然后用<code>aplay</code>播放：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sox -b 16 -n test.wav rate 44100 channels 2 synth 1 sine 440</div><div class="line">aplay -D hw:1 test.wav</div></pre></td></tr></table></figure></p>
<p>正常情况下会听到”滴”的一声，代表设备正常，否则就是设备设置的不对。如果提示设备忙，那么可能是其它程序（比如pulseaudio）占用了。</p>
<h1 id="FluidSynth">FluidSynth</h1><p>下面来玩一下 <strong>FluidSynth</strong> ，它是一个音频合成器。它可以将MIDI数据通过<code>soundfont</code>转化为音频。先安装：<code>sudo apt-get install fluidsynth</code>。</p>
<p>fluidsynth可以用来播放MIDI文件，命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fluidsynth --audio-driver=alsa -o audio.alsa.device=hw:1 /usr/share/sounds/sf2/FluidR3_GM.sf2 song.mid</div></pre></td></tr></table></figure>
<p>当然fluidsynth也可以接受其它程序传输的MIDI数据并转化为音频。这时候fluidsynth将作为一个“音频服务器”。它会等待其它程序与它建立连接，并发送MIDI数据。命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fluidsynth --server --audio-driver=alsa -o audio.alsa.device=hw:1 /usr/share/sounds/sf2/FluidR3_GM.sf2</div></pre></td></tr></table></figure>
<p>此时fluidsynth已开始运行，用<code>aplaymidi -l</code>命令可以看到fluidsynth正在监听的端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sczyh30@sczyh30-workshop:~$ aplaymidi <span class="_">-l</span></div><div class="line"> Port    Client name                      Port name</div><div class="line"> 14:0    Midi Through                     Midi Through Port-0</div><div class="line">128:0    FLUID Synth (26298)              Synth input port (26298:0)</div></pre></td></tr></table></figure></p>
<p>然后就可以往这个端口传输MIDI数据，比如MIDI文件：<code>aplaymidi -p 128:0 song.mid</code>。</p>
<p>再来玩一下VMPK(Virtual MIDI Pinao Keyboard)，它是个MIDI Piano，产生MIDI数据。首先先安装：<code>sudo apt-get install vmpk</code>，然后启动。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/linux-piano-1.png" alt=""></p>
<p>这时候由于没有与音频设备建立连接，按琴键的时候不会有声音。我们需要通过<code>aconnect</code>命令与fluidsynth建立连接。首先查看一下当前的Audio IO：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/linux-vmpk-config-bash.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sczyh30@sczyh30-workshop:~$ aconnect -i</div><div class="line">client 0: <span class="string">'System'</span> [<span class="built_in">type</span>=内核]</div><div class="line">    0 <span class="string">'Timer           '</span></div><div class="line">    1 <span class="string">'Announce        '</span></div><div class="line">client 14: <span class="string">'Midi Through'</span> [<span class="built_in">type</span>=内核]</div><div class="line">    0 <span class="string">'Midi Through Port-0'</span></div><div class="line">client 129: <span class="string">'VMPK Output'</span> [<span class="built_in">type</span>=用户]</div><div class="line">    0 <span class="string">'VMPK Output     '</span></div><div class="line">sczyh30@sczyh30-workshop:~$ aconnect -o</div><div class="line">client 14: <span class="string">'Midi Through'</span> [<span class="built_in">type</span>=内核]</div><div class="line">    0 <span class="string">'Midi Through Port-0'</span></div><div class="line">client 128: <span class="string">'FLUID Synth (26298)'</span> [<span class="built_in">type</span>=用户]</div><div class="line">    0 <span class="string">'Synth input port (26298:0)'</span></div><div class="line">client 130: <span class="string">'VMPK Input'</span> [<span class="built_in">type</span>=用户]</div><div class="line">    0 <span class="string">'VMPK Input      '</span></div></pre></td></tr></table></figure>
<p>我们需要将MIDI转化为Audio，即从<code>VMPK</code>到<code>FLUID Synth</code>。建立连接：<code>aconnect 129:0 128:0</code>，然后再测试一下VMPK，有声音输出了。</p>
<p>FluidSynth也有GUI版本<code>Qsynth</code>，可以很方便地合成声音。</p>
<h1 id="Euterpea依赖">Euterpea依赖</h1><p>Euterpea需要asound：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install libasound2-dev jackd2</div></pre></td></tr></table></figure>
<p>然而现在配置好Euterpea后，无论如何play它都不发声音。。。官网说这玩意只在某些特定的Haskell版本上正常运行，也是醉了。。待调试好后再来补充。。</p>
<blockquote>
<p>【补充】Windows下不用配置就可以很愉快的玩Euterpea了。。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[探索万恶的Slick 3 类型系统 | Prologue]]></title>
      <url>http://www.sczyh30.com/posts/Scala/slick-3-type-system-query-prolouge/</url>
      <content type="html"><![CDATA[<p>这两天在给Samsara Aquarius的各个Service写分页的时候，设计了一个抽象层，想把一些公共的分页逻辑放在这个trait中，但是被Slick的类型系统折磨了一点时间。。今天粗略看了一下相关的源码，结合这几天遇到的问题，总结一下。因此就把这篇文章作为Prologue吧。。。（Slick的版本为3.1.1）</p>
<h1 id="蛋疼的类型参数">蛋疼的类型参数</h1><p>在Slick里面，分页可以通过<code>drop</code>和<code>take</code>函数实现。<code>query.drop(offset).take(n)</code>对应的SQL为<code>LIMIT n, offset</code>。因此在一开始，我设计了一个trait作为分页逻辑的抽象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PageDao</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">page</span></span>(): <span class="type">Future</span>[<span class="type">Int</span>]</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span></span>(offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[_]]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>page</code>函数用于获取总页数，<code>fetchWithPage</code>函数实现分页查询逻辑。</p>
<p>在Slick里，db操作通过<code>db.run(DBIOAction)</code>进行，而每个<code>Query</code>可以通过<code>result</code>函数隐式转换成<code>DBIOAction</code>，因此我们需要给参数中加上Query，以便我们的Service层可以传递不同的Query：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PageDao</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">page</span></span>(query: slick.lifted.<span class="type">Query</span>[_, _, <span class="type">Seq</span>]): <span class="type">Future</span>[<span class="type">Int</span>]</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span></span>(query: slick.lifted.<span class="type">Query</span>[_, _, <span class="type">Seq</span>], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[_]]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Query[+E, U, C[_]]</code>是一个接受3个类型参数的type constructor，这为后边的蛋疼埋下伏笔。。</p>
<p>好了，接下来，由于我们需要在抽象层进行db操作，因此必须获取db对象，这里我选择继承<code>HasDatabaseConfigProvider[JdbcProfile]</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">WithPageProvider</span> <span class="keyword">extends</span> <span class="title">HasDatabaseConfigProvider</span>[<span class="type">JdbcProfile</span>] <span class="keyword">with</span> <span class="title">PageDao</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">import</span> driver.api._</div><div class="line"></div><div class="line">  <span class="keyword">val</span> withQueryByPage =</div><div class="line">    (query: slick.lifted.<span class="type">Query</span>[_, _, _], offset: <span class="type">Int</span>) =&gt;</div><div class="line">      query.drop(offset).take(<span class="type">LIMIT_PAGE</span>)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">page</span></span>(query: slick.lifted.<span class="type">Query</span>[_, _, _]): <span class="type">Future</span>[<span class="type">Int</span>] = &#123;</div><div class="line">    db.run(query.length.result) map &#123; all =&gt;</div><div class="line">      <span class="keyword">val</span> p = all % <span class="type">LIMIT_PAGE</span> == <span class="number">0</span></div><div class="line">      <span class="keyword">if</span> (p) all / <span class="type">LIMIT_PAGE</span></div><div class="line">      <span class="keyword">else</span> (all / <span class="type">LIMIT_PAGE</span>) + <span class="number">1</span></div><div class="line">    &#125; recover &#123;</div><div class="line">      <span class="keyword">case</span> ex: <span class="type">Exception</span> =&gt; <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span></span>(query: slick.lifted.<span class="type">Query</span>[_, _, _], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[_]] = &#123;</div><div class="line">    db.run(withQueryByPage(query, offset).result)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嗯。。逻辑很快写好了，一切似乎都是OK的，下面在业务层中调用一下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span></span>(offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[(<span class="type">Category</span>, <span class="type">Int</span>)]] =</div><div class="line">    <span class="keyword">super</span>.fetchWithPage(categoriesCompiled, offset)</div></pre></td></tr></table></figure>
<p>很快，远方就传来了IDE提示GG的声音。。。提示：<code>Expression of type Future[Seq[_]] doesn&#39;t conform to expected type Future[Seq[(Category, Int)]]</code>。</p>
<p>嗯。。。看来是必须具化Seq的type parameter了。。那么就给trait里的<code>fetchWithPage</code>加个type parameter吧。。下面就陷入了苦逼的Slick类型系统初探过程——Slick在<code>run</code>、<code>result</code>的过程中，如何从一个原始的<code>Query[+E, U, C[_]]</code>转化为最终的<code>Future[Seq[R]]</code>？也就是说Query的这几个type parameters该取什么类型？想解决这个问题，只能看Slick的源码了。。首先从<code>run</code>函数出发，看看Future是怎么产生的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Run an Action asynchronously and return the result as a Future. */</span></div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>[<span class="type">R</span>](a: <span class="type">DBIOAction</span>[<span class="type">R</span>, <span class="type">NoStream</span>, <span class="type">Nothing</span>]): <span class="type">Future</span>[<span class="type">R</span>] = runInternal(a, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p>可以看到，最后返回Future的类型参数是<code>DBIOAction[R, NoStream, Nothing]</code>的第一个类型参数R。接着我们看一下<code>DBIOAction</code>的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">DBIOAction</span>[+<span class="type">R</span>, +<span class="type">S</span> &lt;: <span class="type">NoStream</span>, -<span class="type">E</span> &lt;: <span class="type">Effect</span>] <span class="keyword">extends</span> <span class="title">Dumpable</span></span></div></pre></td></tr></table></figure>
<p>嗯，看到这里，似乎明白了什么。。然后再看一下<code>Query</code>的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">QueryBase</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">Rep</span>[<span class="type">T</span>]</span></div><div class="line"></div><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>[+<span class="type">E</span>, <span class="type">U</span>, <span class="type">C</span>[_]] <span class="keyword">extends</span> <span class="title">QueryBase</span>[<span class="type">C</span>[<span class="type">U</span>]]</span></div></pre></td></tr></table></figure>
<p>可以看到<code>Query[+E, U, C[_]]</code>继承了<code>QueryBase[C[U]]</code>，然而注释里完全没有这三个type parameters的含义，所以就瞎猜。。注释里提到计算结果代表一个集合类型，如<code>Rep[Seq[T]]</code>，而<code>QueryBase[T]</code>又继承了<code>Rep[T]</code>，所以很容易想到<code>Query</code>第三个类型参数为<code>Seq</code>。然而一开始没有看到后边的<code>[C[U]]</code>，又因为DBIOAction中返回类型为第一个类型参数R，因此就错误地把这里的返回类型想成了第一个类型参数E（还是协变的，很迷惑人）。于是把<code>fetchWithPage</code>改成了这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span></span>[<span class="type">R</span>](query: slick.lifted.<span class="type">Query</span>[<span class="type">R</span>, _, <span class="type">Seq</span>], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">R</span>]]</div></pre></td></tr></table></figure>
<p>仍然在报错，这次成了<code>Expression of type Future[Seq[Any]] doesn&#39;t conform to expected type Future[Seq[R]]</code>。</p>
<p>这时候提示就比较明显了，既然第一个类型参数已经限定为<code>R</code>，而返回值还为<code>Future[Seq[Any]]</code>，那么很容易就会联想到当前为<code>_</code>的类型参数有猫腻，即<code>Query[+E, U, C[_]]</code>中的<code>U</code>。这时候再看到后边继承的<code>QueryBase[C[U]]</code>，一切都一目了然了。这里的<code>QueryBase[C[U]]</code>是一个higher-kinded type，既然我们将<code>C</code>设为<code>Seq</code>，那么很容易想到<code>C[U]</code>其实就是对应着<code>Seq[Result]</code>，那么我们的R参数应该放在<code>Query</code>的第二个类型参数U上。改一下发现，一切都正常了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithPage</span></span>[<span class="type">R</span>](query: slick.lifted.<span class="type">Query</span>[_, <span class="type">R</span>, <span class="type">Seq</span>], offset: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">R</span>]] = &#123;</div><div class="line">    db.run(withQueryByPage(query, offset).result)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="寻根溯源">寻根溯源</h1><p>问题解决了，但<code>Query[+E, U, C[_]]</code>里那个<code>+E</code>实在是很迷惑人，于是就继续探究了探究它到底是什么玩意。注释里没写，那就从<code>Query</code>的实现中找吧。。在<code>TableQuery</code>的定义中有：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableQuery</span>[<span class="type">E</span> &lt;: <span class="type">AbstractTable</span>[_]](<span class="params">cons: <span class="type">Tag</span> =&gt; <span class="type">E</span></span>) <span class="keyword">extends</span> <span class="title">Query</span>[<span class="type">E</span>, <span class="type">E</span>#<span class="type">TableElementType</span>, <span class="type">Seq</span>]</span></div><div class="line"></div><div class="line"><span class="comment">/** The driver-independent superclass of all table row objects.*/</span></div><div class="line"><span class="comment">// @tparam T Row type for this table.</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTable</span>[<span class="type">T</span>](<span class="params">val tableTag: <span class="type">Tag</span>, val schemaName: <span class="type">Option</span>[<span class="type">String</span>], val tableName: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Rep</span>[<span class="type">T</span>] </span>&#123;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">TableElementType</span></span></div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>E需要是<code>AbstractTable[_]</code>的子类，而我们在定义表的映射的时候都是继承了<code>Table[_]</code>类，因此可以确定E就是查询的类型所对应的Table类（比如ArticleTable）。</p>
<p>另外一个值的探究的地方就是那个<code>result</code>函数是如何将一个<code>Query</code>转化为<code>DBIOAction</code>的。蛋疼的地方在于这个转换是隐式的（相当于实现了Typeclass Pattern），因此追踪如何转换的比较困难。好在写代码的时候发现，如果不导入<code>driver.api._</code>的话，就会找不到<code>result</code>函数，因此可以从这里入手。跳转到<code>api</code>的源码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> api: <span class="type">API</span> = <span class="keyword">new</span> <span class="type">API</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>那么秘密应该就藏在<code>JdbcProfile#API</code>类里了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">API</span> <span class="keyword">extends</span> <span class="title">LowPriorityAPI</span> <span class="keyword">with</span> <span class="title">super</span>.<span class="title">API</span> <span class="keyword">with</span> <span class="title">ImplicitColumnTypes</span> </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">FastPath</span>[<span class="type">T</span>] </span>= <span class="type">JdbcFastPath</span>[<span class="type">T</span>]</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">SimpleDBIO</span>[+<span class="type">R</span>] </span>= <span class="type">SimpleJdbcAction</span>[<span class="type">R</span>]</div><div class="line">  <span class="keyword">val</span> <span class="type">SimpleDBIO</span> = <span class="type">SimpleJdbcAction</span></div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">jdbcFastPathExtensionMethods</span></span>[<span class="type">T</span>, <span class="type">P</span>](mp: <span class="type">MappedProjection</span>[<span class="type">T</span>, <span class="type">P</span>]) = <span class="keyword">new</span> <span class="type">JdbcFastPathExtensionMethods</span>[<span class="type">T</span>, <span class="type">P</span>](mp)</div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">queryDeleteActionExtensionMethods</span></span>[<span class="type">C</span>[_]](q: <span class="type">Query</span>[_ &lt;: <span class="type">RelationalProfile</span>#<span class="type">Table</span>[_], _, <span class="type">C</span>]): <span class="type">DeleteActionExtensionMethods</span> =</div><div class="line">    createDeleteActionExtensionMethods(deleteCompiler.run(q.toNode).tree, ())</div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">runnableCompiledDeleteActionExtensionMethods</span></span>[<span class="type">RU</span>, <span class="type">C</span>[_]](c: <span class="type">RunnableCompiled</span>[_ &lt;: <span class="type">Query</span>[_, _, <span class="type">C</span>], <span class="type">C</span>[<span class="type">RU</span>]]): <span class="type">DeleteActionExtensionMethods</span> =</div><div class="line">    createDeleteActionExtensionMethods(c.compiledDelete, c.param)</div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">runnableCompiledUpdateActionExtensionMethods</span></span>[<span class="type">RU</span>, <span class="type">C</span>[_]](c: <span class="type">RunnableCompiled</span>[_ &lt;: <span class="type">Query</span>[_, _, <span class="type">C</span>], <span class="type">C</span>[<span class="type">RU</span>]]): <span class="type">UpdateActionExtensionMethods</span>[<span class="type">RU</span>] =</div><div class="line">    createUpdateActionExtensionMethods(c.compiledUpdate, c.param)</div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">jdbcActionExtensionMethods</span></span>[<span class="type">E</span> &lt;: <span class="type">Effect</span>, <span class="type">R</span>, <span class="type">S</span> &lt;: <span class="type">NoStream</span>](a: <span class="type">DBIOAction</span>[<span class="type">R</span>, <span class="type">S</span>, <span class="type">E</span>]): <span class="type">JdbcActionExtensionMethods</span>[<span class="type">E</span>, <span class="type">R</span>, <span class="type">S</span>] =</div><div class="line">    <span class="keyword">new</span> <span class="type">JdbcActionExtensionMethods</span>[<span class="type">E</span>, <span class="type">R</span>, <span class="type">S</span>](a)</div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">actionBasedSQLInterpolation</span></span>(s: <span class="type">StringContext</span>) = <span class="keyword">new</span> <span class="type">ActionBasedSQLInterpolation</span>(s)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面存在这样的继承关系（简化过后的）：<code>JdbcProfile#API &lt;:&lt; RelationalProfile#API &lt;:&lt; BasicProfile#API</code>。</p>
<p>再看RelationalProfile中的API类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">API</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">API</span> <span class="keyword">with</span> <span class="title">ImplicitColumnTypes</span> </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Table</span>[<span class="type">T</span>] </span>= driver.<span class="type">Table</span>[<span class="type">T</span>]</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Sequence</span>[<span class="type">T</span>] </span>= driver.<span class="type">Sequence</span>[<span class="type">T</span>]</div><div class="line">  <span class="keyword">val</span> <span class="type">Sequence</span> = driver.<span class="type">Sequence</span></div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">ColumnType</span>[<span class="type">T</span>] </span>= driver.<span class="type">ColumnType</span>[<span class="type">T</span>]</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">BaseColumnType</span>[<span class="type">T</span>] </span>= driver.<span class="type">BaseColumnType</span>[<span class="type">T</span>]</div><div class="line">  <span class="keyword">val</span> <span class="type">MappedColumnType</span> = driver.<span class="type">MappedColumnType</span></div><div class="line"></div><div class="line">  <span class="meta">@deprecated</span>(<span class="string">"Use an explicit conversion to an Option column with `.?`"</span>, <span class="string">"3.0"</span>)</div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">columnToOptionColumn</span></span>[<span class="type">T</span> : <span class="type">BaseTypedType</span>](c: <span class="type">Rep</span>[<span class="type">T</span>]): <span class="type">Rep</span>[<span class="type">Option</span>[<span class="type">T</span>]] = c.?</div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">valueToConstColumn</span></span>[<span class="type">T</span> : <span class="type">TypedType</span>](v: <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">LiteralColumn</span>[<span class="type">T</span>](v)</div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">columnToOrdered</span></span>[<span class="type">T</span> : <span class="type">TypedType</span>](c: <span class="type">Rep</span>[<span class="type">T</span>]): <span class="type">ColumnOrdered</span>[<span class="type">T</span>] = <span class="type">ColumnOrdered</span>[<span class="type">T</span>](c, <span class="type">Ordering</span>())</div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">tableQueryToTableQueryExtensionMethods</span></span>[<span class="type">T</span> &lt;: <span class="type">RelationalProfile</span>#<span class="type">Table</span>[_], <span class="type">U</span>](q: <span class="type">Query</span>[<span class="type">T</span>, <span class="type">U</span>, <span class="type">Seq</span>] <span class="keyword">with</span> <span class="type">TableQuery</span>[<span class="type">T</span>]) =</div><div class="line">    <span class="keyword">new</span> <span class="type">TableQueryExtensionMethods</span>[<span class="type">T</span>, <span class="type">U</span>](q)</div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableCompiledInsertActionExtensionMethods</span></span>[<span class="type">EU</span>](c: <span class="type">StreamableCompiled</span>[_, _, <span class="type">EU</span>]): <span class="type">InsertActionExtensionMethods</span>[<span class="type">EU</span>] = createInsertActionExtensionMethods[<span class="type">EU</span>](c.compiledInsert.asInstanceOf[<span class="type">CompiledInsert</span>])</div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">queryInsertActionExtensionMethods</span></span>[<span class="type">U</span>, <span class="type">C</span>[_]](q: <span class="type">Query</span>[_, <span class="type">U</span>, <span class="type">C</span>]) = createInsertActionExtensionMethods[<span class="type">U</span>](compileInsert(q.toNode))</div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">schemaActionExtensionMethods</span></span>(sd: <span class="type">SchemaDescription</span>): <span class="type">SchemaActionExtensionMethods</span> = createSchemaActionExtensionMethods(sd)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看BasicProfile中的API类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">API</span> <span class="keyword">extends</span> <span class="title">Aliases</span> <span class="keyword">with</span> <span class="title">ExtensionMethodConversions</span> </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Database</span> </span>= <span class="type">Backend</span>#<span class="type">Database</span></div><div class="line">  <span class="keyword">val</span> <span class="type">Database</span> = backend.<span class="type">Database</span></div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Session</span> </span>= <span class="type">Backend</span>#<span class="type">Session</span></div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">SlickException</span> </span>= slick.<span class="type">SlickException</span></div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> slickDriver: driver.<span class="keyword">type</span> = driver</div><div class="line"></div><div class="line">  <span class="comment">// Work-around for SI-3346</span></div><div class="line">  <span class="meta">@inline</span> <span class="keyword">implicit</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">anyToToShapedValue</span></span>[<span class="type">T</span>](value: <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">ToShapedValue</span>[<span class="type">T</span>](value)</div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">repQueryActionExtensionMethods</span></span>[<span class="type">U</span>](rep: <span class="type">Rep</span>[<span class="type">U</span>]): <span class="type">QueryActionExtensionMethods</span>[<span class="type">U</span>, <span class="type">NoStream</span>] =</div><div class="line">    createQueryActionExtensionMethods[<span class="type">U</span>, <span class="type">NoStream</span>](queryCompiler.run(rep.toNode).tree, ())</div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableQueryActionExtensionMethods</span></span>[<span class="type">U</span>, <span class="type">C</span>[_]](q: <span class="type">Query</span>[_,<span class="type">U</span>, <span class="type">C</span>]): <span class="type">StreamingQueryActionExtensionMethods</span>[<span class="type">C</span>[<span class="type">U</span>], <span class="type">U</span>] =</div><div class="line">    createStreamingQueryActionExtensionMethods[<span class="type">C</span>[<span class="type">U</span>], <span class="type">U</span>](queryCompiler.run(q.toNode).tree, ())</div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">runnableCompiledQueryActionExtensionMethods</span></span>[<span class="type">RU</span>](c: <span class="type">RunnableCompiled</span>[_, <span class="type">RU</span>]): <span class="type">QueryActionExtensionMethods</span>[<span class="type">RU</span>, <span class="type">NoStream</span>] =</div><div class="line">    createQueryActionExtensionMethods[<span class="type">RU</span>, <span class="type">NoStream</span>](c.compiledQuery, c.param)</div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableCompiledQueryActionExtensionMethods</span></span>[<span class="type">RU</span>, <span class="type">EU</span>](c: <span class="type">StreamableCompiled</span>[_, <span class="type">RU</span>, <span class="type">EU</span>]): <span class="type">StreamingQueryActionExtensionMethods</span>[<span class="type">RU</span>, <span class="type">EU</span>] =</div><div class="line">    createStreamingQueryActionExtensionMethods[<span class="type">RU</span>, <span class="type">EU</span>](c.compiledQuery, c.param)</div><div class="line">  <span class="comment">// Applying a CompiledFunction always results in only a RunnableCompiled, not a StreamableCompiled, so we need this:</span></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">streamableAppliedCompiledFunctionActionExtensionMethods</span></span>[<span class="type">R</span>, <span class="type">RU</span>, <span class="type">EU</span>, <span class="type">C</span>[_]](c: <span class="type">AppliedCompiledFunction</span>[_, <span class="type">Query</span>[<span class="type">R</span>, <span class="type">EU</span>, <span class="type">C</span>], <span class="type">RU</span>]): <span class="type">StreamingQueryActionExtensionMethods</span>[<span class="type">RU</span>, <span class="type">EU</span>] =</div><div class="line">    createStreamingQueryActionExtensionMethods[<span class="type">RU</span>, <span class="type">EU</span>](c.compiledQuery, c.param)</div><div class="line">  <span class="comment">// This only works on Scala 2.11 due to SI-3346:</span></div><div class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">recordQueryActionExtensionMethods</span></span>[<span class="type">M</span>, <span class="type">R</span>](q: <span class="type">M</span>)(<span class="keyword">implicit</span> shape: <span class="type">Shape</span>[_ &lt;: <span class="type">FlatShapeLevel</span>, <span class="type">M</span>, <span class="type">R</span>, _]): <span class="type">QueryActionExtensionMethods</span>[<span class="type">R</span>, <span class="type">NoStream</span>] =</div><div class="line">    createQueryActionExtensionMethods[<span class="type">R</span>, <span class="type">NoStream</span>](queryCompiler.run(shape.toNode(q)).tree, ())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此多的implicit转换，可以将Query和CompiledQuery转换成各种QueryActionExtensionMethods。那么我们再来看<code>result</code>的源码，看看它是不是在某个QueryActionExtensionMethods类里：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamingQueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">T</span>](<span class="params">tree: <span class="type">Node</span>, param: <span class="type">Any</span></span>) <span class="keyword">extends</span> <span class="title">QueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">Streaming</span>[<span class="type">T</span>]](<span class="params">tree, param</span>) <span class="keyword">with</span> <span class="title">super</span>.<span class="title">StreamingQueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">T</span>] </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">result</span></span>: <span class="type">StreamingDriverAction</span>[<span class="type">R</span>, <span class="type">T</span>, <span class="type">Effect</span>.<span class="type">Read</span>] = <span class="keyword">super</span>.result.asInstanceOf[<span class="type">StreamingDriverAction</span>[<span class="type">R</span>, <span class="type">T</span>, <span class="type">Effect</span>.<span class="type">Read</span>]]</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然！<code>result</code>方法存在于这个QueryActionExtensionMethods类里，而且Query可以通过上述API隐式转换为QueryActionExtensionMethods。这个类好混乱，继承了两个trait，还没注释（这一点最蛋疼了，直接看源码估计无解）。再往它的父类找：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">QueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">S</span> &lt;: <span class="type">NoStream</span>] </span>&#123;</div><div class="line">    <span class="comment">/** An Action that runs this query. */</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span></span>: <span class="type">DriverAction</span>[<span class="type">R</span>, <span class="type">S</span>, <span class="type">Effect</span>.<span class="type">Read</span>]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">StreamingQueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">T</span>] <span class="keyword">extends</span> <span class="title">QueryActionExtensionMethodsImpl</span>[<span class="type">R</span>, <span class="type">Streaming</span>[<span class="type">T</span>]] </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span></span>: <span class="type">StreamingDriverAction</span>[<span class="type">R</span>, <span class="type">T</span>, <span class="type">Effect</span>.<span class="type">Read</span>]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>它们是最基本的<code>QueryActionExtensionMethods</code>，即查询操作。</p>
<p>到此为止，我们终于搞明白了一个数据库查询过程中从<code>Query</code>经过implicit的<code>result</code>转换成<code>DBIOAction</code>，再进行<code>db.run</code>得到Future异步结果的类型转换的过程。我做了一张图来总结这个过程：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/slick-db-type-convert-query-sczyh30-fixed.png" alt="Slick Query Type Process"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Slick 3总结 | Functional Relational Mapping]]></title>
      <url>http://www.sczyh30.com/posts/Scala/slick-3-summary-functional-relational-mapping/</url>
      <content type="html"><![CDATA[<p>不同于平常的ORM框架，Slick提供了一种函数响应式操作数据库的方式：Functional Relational Mapping。这种函数响应式的操作方式允许我们将数据库的每一个表都看作是一个 <strong>集合</strong>，对数据库的CRUD操作可以转化为对这些“集合”的操作，因此我们可以充分利用各种Monadic的算子而不需要自己编写SQL（当然，需要保证Slick解析的SQL性能好）。并且，Slick是以 <strong>异步</strong> 的方式操作数据库，返回Future，这有助于我们编写异步响应式的程序，比MyBatis等等的同步阻塞ORM框架之流好很多。这里我们就来总结一下Slick中Functional Relational Mapping的使用以及与SQL语句的对应关系（MySQL语法）。后面有时间的话，我还会总结一下Slick中FRM的实现原理。</p>
<h1 id="Functional_Relational_Mapping_⇔_SQL">Functional Relational Mapping ⇔ SQL</h1><p>首先我们需要自己定义对应的映射Table，当然也可以用Generator生成。假设有以下两个表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`article`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">85</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`author`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`cid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`update_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</div><div class="line">  <span class="keyword">KEY</span> <span class="string">`index_title`</span> (<span class="string">`title`</span>),</div><div class="line">  <span class="keyword">KEY</span> <span class="string">`index_cid`</span> (<span class="string">`cid`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`category`</span> (</div><div class="line">  <span class="string">`cid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`abbr`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`cid`</span>),</div><div class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`name_UNIQUE`</span> (<span class="string">`name`</span>),</div><div class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`abbr_UNIQUE`</span> (<span class="string">`abbr`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</div></pre></td></tr></table></figure></p>
<p>它们对应的Table可以简化成下面的两个类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ArticleTable</span>(<span class="params">tag: <span class="type">Tag</span></span>) <span class="keyword">extends</span> <span class="title">Table</span>[<span class="type">Article</span>](<span class="params">tag, "article"</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">*</span> </span>= (id, title, author, url, cid, updateDate) &lt;&gt; (entity.<span class="type">Article</span>.tupled, entity.<span class="type">Article</span>.unapply) <span class="comment">// 投影关系</span></div><div class="line"></div><div class="line">  <span class="keyword">val</span> id: <span class="type">Rep</span>[<span class="type">Int</span>] = column[<span class="type">Int</span>](<span class="string">"id"</span>, <span class="type">O</span>.<span class="type">AutoInc</span>, <span class="type">O</span>.<span class="type">PrimaryKey</span>)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> title: <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"title"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">85</span>, varying = <span class="literal">true</span>))</div><div class="line"></div><div class="line">  <span class="keyword">val</span> author: <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"author"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">45</span>, varying = <span class="literal">true</span>))</div><div class="line"></div><div class="line">  <span class="keyword">val</span> url: <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"url"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">150</span>, varying = <span class="literal">true</span>))</div><div class="line"></div><div class="line">  <span class="keyword">val</span> cid: <span class="type">Rep</span>[<span class="type">Int</span>] = column[<span class="type">Int</span>](<span class="string">"cid"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> updateDate: <span class="type">Rep</span>[java.sql.<span class="type">Date</span>] = column[java.sql.<span class="type">Date</span>](<span class="string">"update_date"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> index1 = index(<span class="string">"index_cid"</span>, cid)</div><div class="line">  <span class="keyword">val</span> index2 = index(<span class="string">"index_title"</span>, title)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CategoryTable</span>(<span class="params">tag: <span class="type">Tag</span></span>) <span class="keyword">extends</span> <span class="title">Table</span>[<span class="type">Category</span>](<span class="params">tag, "category"</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">*</span> </span>= (cid, name, abbr) &lt;&gt; (entity.<span class="type">Category</span>.tupled, entity.<span class="type">Category</span>.unapply)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> cid: <span class="type">Rep</span>[<span class="type">Int</span>] = column[<span class="type">Int</span>](<span class="string">"cid"</span>, <span class="type">O</span>.<span class="type">AutoInc</span>, <span class="type">O</span>.<span class="type">PrimaryKey</span>)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> name: <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"name"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">45</span>, varying = <span class="literal">true</span>))</div><div class="line"></div><div class="line">  <span class="keyword">val</span> abbr: <span class="type">Rep</span>[<span class="type">String</span>] = column[<span class="type">String</span>](<span class="string">"abbr"</span>, <span class="type">O</span>.<span class="type">Length</span>(<span class="number">45</span>, varying = <span class="literal">true</span>))</div><div class="line"></div><div class="line">  <span class="keyword">val</span> index1 = index(<span class="string">"abbr_UNIQUE"</span>, abbr, unique=<span class="literal">true</span>)</div><div class="line">  <span class="keyword">val</span> index2 = index(<span class="string">"name_UNIQUE"</span>, name, unique=<span class="literal">true</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们就可以定义这两个表对应的Slick TableQuery集合：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> articles = <span class="type">TableQuery</span>[<span class="type">ArticleTable</span>]</div><div class="line"><span class="keyword">val</span> categories = <span class="type">TableQuery</span>[<span class="type">CategoryTable</span>]</div></pre></td></tr></table></figure>
<p>下面我们就可以对这两个“集合”进行操作了～</p>
<h2 id="SELECT">SELECT</h2><p>普通的SELECT语句非常简单，比如<code>SELECT * FROM article</code>对应<code>articles.result</code>，即article表中所有的数据。</p>
<p>如果要选择的话可以用<code>map</code>算子映射出对应的投影。</p>
<h2 id="WHERE">WHERE</h2><p>含WHERE的SQL：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> title, <span class="keyword">url</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">10</span></div></pre></td></tr></table></figure></p>
<p><code>WHERE</code>通过<code>filter</code>算子实现，对应FRM：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">articles.map(x =&gt; (x.title, x.url))</div><div class="line">        .filter(_.id === <span class="number">10</span>)</div><div class="line">        .result</div></pre></td></tr></table></figure></p>
<h2 id="ORDER_BY">ORDER BY</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> article <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">DESC</span></div></pre></td></tr></table></figure>
<p><code>ORDER BY</code>通过<code>sortBy</code>算子实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">articles.sortBy(_.id.desc).result</div></pre></td></tr></table></figure></p>
<h2 id="LIMIT(分页)">LIMIT(分页)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> article <span class="keyword">LIMIT</span> <span class="number">10000</span>, <span class="number">10</span></div></pre></td></tr></table></figure>
<p><code>LIMIT</code>通过<code>take</code>算子和<code>drop</code>算子实现。<code>drop(offset)</code>表示忽略前offset条记录，<code>take(n)</code>代表取n条记录。对应FRM：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">articles.drop(<span class="number">10000</span>).take(<span class="number">10</span>).result</div></pre></td></tr></table></figure></p>
<h2 id="聚合函数">聚合函数</h2><p>使用各种聚合函数也非常方便：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">articles.map(_.id).max.result</div><div class="line">articles.map(_.id).min.result</div><div class="line">articles.map(_.id).avg.result</div></pre></td></tr></table></figure></p>
<h2 id="JOIN">JOIN</h2><p>Slick中的连接操作分为Applicative Join和Monadic Join两种。Monadic Join，顾名思义就是用Monad的思想去进行<code>JOIN</code>操作(通过<code>flatMap</code>算子)。</p>
<h3 id="Applicative_Join">Applicative Join</h3><p>Applicative Join通过<code>join</code>和<code>on</code>来进行<code>JOIN</code>操作。</p>
<p>内连接的例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.*, c.name</div><div class="line"><span class="keyword">FROM</span> article <span class="keyword">AS</span> a</div><div class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">category</span> <span class="keyword">as</span> c</div><div class="line"><span class="keyword">ON</span> a.cid = c.cid</div></pre></td></tr></table></figure></p>
<p>对应Applicative Join：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> innerJoin = <span class="keyword">for</span> &#123;</div><div class="line">    (a, c) &lt;- articles join categories on (_.cid === _.cid)</div><div class="line">&#125; <span class="keyword">yield</span> (a, c.name)</div></pre></td></tr></table></figure></p>
<p>左外连接和右外连接也差不多，只不过外连接可能带来NULL项，因此对应的可能出现NULL的位置被包装为<code>Option</code>，例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> leftOuterJoin = <span class="keyword">for</span> &#123;</div><div class="line">    (a, c) &lt;- articles joinLeft categories on (_.cid === _.cid)</div><div class="line">&#125; <span class="keyword">yield</span> (a, c.map(_.name))</div></pre></td></tr></table></figure></p>
<h3 id="Monadic_Join">Monadic Join</h3><p>Monadic Join通过<code>flatMap</code>来进行<code>JOIN</code>操作，这里只举一个内连接的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> monadicInnerJoin = <span class="keyword">for</span> &#123;</div><div class="line">    a &lt;- articles</div><div class="line">    c &lt;- categories <span class="keyword">if</span> c.cid === a.cid</div><div class="line">&#125; <span class="keyword">yield</span> (a, c.name)</div></pre></td></tr></table></figure></p>
<p>注意它会被转化成implicit join(<code>SELECT ... FROM a, b WHERE ...</code>)的形式（貌似是Slick的<a href="http://slick.typesafe.com/doc/3.1.1/queries.html#monadic-joins" target="_blank" rel="external">规则</a>）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.*, c.name</div><div class="line"><span class="keyword">FROM</span> article <span class="keyword">AS</span> a, <span class="keyword">category</span> <span class="keyword">AS</span> c</div><div class="line"><span class="keyword">WHERE</span> a.cid = c.cid</div></pre></td></tr></table></figure></p>
<h2 id="UNION">UNION</h2><p><code>UNION</code>操作比较简单，直接<code>q1 union q2</code>即可。</p>
<h2 id="COUNT">COUNT</h2><p>若需要计算<code>COUNT</code>值，直接使用<code>length</code>算子：<code>articles.filter(_.id &gt; 100).length.result</code></p>
<h1 id="FRM的实现原理">FRM的实现原理</h1><p>Slick实现Functional Relational Mapping的方式比较强悍。粗略地看了下代码，Slick底层应该是将每个Action逐层解析后转化为AST，然后转化为对应的SQL并执行的。后边有时间详细了解一下。。(<strong>待填坑！</strong>)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Play Framework 2.5 | Dependency Injection总结]]></title>
      <url>http://www.sczyh30.com/posts/Scala/play-framework-2-5-dependency-injection-di/</url>
      <content type="html"><![CDATA[<p>最近在将Samsara Aquarius从Play 2.4.6迁移至Play 2.5.0的时候发现，Play 2.5将一些全局对象deprcated了，并强烈建议全面使用依赖注入来代替全局对象，所以就把Aquarius的代码用DI重构了一下。其实从Play 2.4.0开始就引入了依赖注入了(基于<a href="https://jcp.org/en/jsr/detail?id=330" target="_blank" rel="external">JSR 330</a>标准)，只不过还没有很好地推广。这里就来总结一下Play Framework中DI的使用。（本来开发的时候想保持FP风格的，无奈DI更多的是偏OO的风格。。FP与OO杂糅不好把握呀。。）</p>
<h1 id="为何需要引入依赖注入">为何需要引入依赖注入</h1><p>依赖注入(Dependency Injection)在OOP中早已是一个耳熟能详的原则了，其中Spring里用DI都用烂了。简单来说，依赖注入使得我们不需要自己创建对象，而是由容器来帮我们创建。每个组件之间不再是直接相互依赖，而是通过容器进行注入，这降低了组件之间的耦合度。这个容器就像是一个全局的大工厂，专门“生产”对象，而我们只需要进行配置（常见的通过XML文件或通过注解）。</p>
<p>在Play API中有一个<code>Global</code>对象，保存着一些全局的可变状态。另外还有一个Application对象相当于当前正在运行的Play实例。这两个伴生对象经常会在测试和部署的时候引发问题，并且也会影响Play实例的生命周期以及插件系统的工作。因此从Play 2.4开始，开发者对底层的结构做了很大的调整，底层所有的组件（包括Application、Route、Controller）都通过依赖注入进行管理，而不再使用Global和Application对象。后面版本中这两个对象只是从DI中获取实例的引用。从Play 2.5开始，这些全局对象被deprecated。</p>
<p>Play内部的DI组件都用的是 <strong>Google Guice</strong>。只要是符合JSR-330标准的DI组件都可用于Play Framework中。</p>
<h1 id="DI_in_Play_Framework">DI in Play Framework</h1><h2 id="如何使用">如何使用</h2><p>比如我们的B组件需要A组件的实例作为依赖，我们可以这么定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.inject.<span class="type">Inject</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">a: <span class="type">A</span></span>)</span></div></pre></td></tr></table></figure>
<p>注意，<code>@Inject()</code>需要插入在类名之后，构造参数列表之前，后边跟上需要注入的对象列表。</p>
<p>Guice里面的依赖注入有<a href="https://github.com/google/guice/wiki/Injections" target="_blank" rel="external">好几种方式</a>：<strong>构造注入</strong>、<strong>方法注入</strong> 等等。这里采用最常用的构造注入。</p>
<h2 id="生命周期及范围">生命周期及范围</h2><p>依赖注入系统管理着各个注入组件的生命周期和范围。有以下规则：</p>
<ul>
<li>每次从Injector里取出的都是新的对象，即每次需要此组件的时候都会创建新的实例，用Spring IoC的话来说就是Bean的范围是 <strong>Prototype</strong> 。这一点和Spring不同(Spring默认是Singleton)。当然可以通过给待注入的类加上<code>@Singleton</code>注解来实现 <strong>Singleton</strong> 。</li>
<li>遵循懒加载原则，即不用的时候就不创建。如果需要提前创建实例的话可以使用 <strong>Eager Binding</strong> 。</li>
</ul>
<h2 id="ApplicationLifecycle">ApplicationLifecycle</h2><p>有些组件需要在Play结束运行的时候进行一些清理工作，如关闭连接、关闭句柄。Play提供了<code>ApplicationLifecycle</code>类，可以通过<code>addStopHook</code>函数给组件注册回调，在Play结束运行的时候进行清理工作。<code>addStopHook</code>函数有两个版本，常用的是第一个：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStopHook</span></span>(hook: () =&gt; <span class="type">Future</span>[_]): <span class="type">Unit</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStopHook</span></span>(hook: <span class="type">Callable</span>[_ &lt;: <span class="type">CompletionStage</span>[_]]): <span class="type">Unit</span></div></pre></td></tr></table></figure>
<p>底层实现嘛比较直观，默认的实现是<code>DefaultApplicationLifecycle</code>类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Default implementation of the application lifecycle.</div><div class="line"> */</div><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultApplicationLifecycle</span> <span class="keyword">extends</span> <span class="title">ApplicationLifecycle</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mutex = <span class="keyword">new</span> <span class="type">Object</span>()</div><div class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> hooks = <span class="type">List</span>.empty[() =&gt; <span class="type">Future</span>[_]]</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addStopHook</span></span>(hook: () =&gt; <span class="type">Future</span>[_]) = mutex.synchronized &#123;</div><div class="line">    hooks = hook :: hooks</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(): <span class="type">Future</span>[_] = &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Do we care if one hook executes on another hooks redeeming thread? Hopefully not.</span></div><div class="line">    <span class="keyword">import</span> play.api.libs.iteratee.<span class="type">Execution</span>.<span class="type">Implicits</span>.trampoline</div><div class="line"></div><div class="line">    hooks.foldLeft(<span class="type">Future</span>.successful[<span class="type">Any</span>](())) &#123; (future, hook) =&gt;</div><div class="line">      future.flatMap &#123; _ =&gt;</div><div class="line">        hook().recover &#123;</div><div class="line">          <span class="keyword">case</span> e =&gt; <span class="type">Logger</span>.error(<span class="string">"Error executing stop hook"</span>, e)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>DefaultApplicationLifecycle</code>类里维护了一个钩子列表hook用于存储所有注册的回调函数，类型为<code>List[() =&gt; Future[_]]</code>。由于<code>DefaultApplicationLifecycle</code>组件为单例，因此为避免资源争用，将hook变量声明为<code>@volatile</code>，并且注册回调函数时需要加锁。注意回调函数是按注册的顺序进行存储的。在应用结束时，会调用<code>stop</code>函数，通过<code>foldLeft</code>依次调用各个回调函数。</p>
<h1 id="Play_应用重构实例">Play 应用重构实例</h1><p>之前我把部分的Service设计成了Object（脑残了），并且在获取Slick的<code>DatabaseConfig</code>的时候使用了全局变量<code>play.api.Play.current</code>。这里我们来重构一下。</p>
<p>首先把Service重构为单例的类，并且通过DI的方式获取<code>db</code>。可以继承<code>HasDatabaseConfigProvider[JdbcProfile]</code>接口并注入<code>DatabaseConfigProvider</code>，这样Service就可以直接使用<code>HasDatabaseConfigProvider</code>的<code>db</code>对象了。当然如果不想继承<code>HasDatabaseConfigProvider</code>接口的话也可以仅注入<code>DatabaseConfigProvider</code>并自己在类中获取<code>dbConfig</code>和<code>db</code>(其它方式见Play-Slcik的文档)。</p>
<p>代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">protected val dbConfigProvider: <span class="type">DatabaseConfigProvider</span></span>) <span class="keyword">extends</span> <span class="title">HasDatabaseConfigProvider</span>[<span class="type">JdbcProfile</span>] </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">import</span> driver.api._</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> users = <span class="type">TableQuery</span>[<span class="type">UserTable</span>]</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(user: <span class="type">User</span>): <span class="type">Future</span>[<span class="type">Int</span>] = &#123;</div><div class="line">    db.run(users += user) recover &#123;</div><div class="line">      <span class="keyword">case</span> duplicate: com.mysql.jdbc.exceptions.<span class="type">MySQLIntegrityConstraintViolationException</span> =&gt; <span class="type">DB_ADD_DUPLICATE</span></div><div class="line">      <span class="keyword">case</span> _: <span class="type">Exception</span> =&gt; <span class="number">-2</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 其他代码略......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是在Controller里配置DI将Service注入至Controller中。以UserController为例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">service: <span class="type">UserService</span></span>) <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loginIndex</span> </span>= <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request =&gt;</div><div class="line">    request.session.get(<span class="string">"aq_token"</span>) <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(user) =&gt; <span class="type">Redirect</span>(routes.<span class="type">Application</span>.index())</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">Ok</span>(views.html.login(<span class="type">LoginForm</span>.form))</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="comment">// 其他代码略......</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="DI底层调用过程">DI底层调用过程</h2><p>Play API中所有的DI都用的 <strong>Google Guice</strong>。它们最后都是调用了<code>GuiceInjector</code>类的<code>instanceOf</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Play Injector backed by a Guice Injector.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuiceInjector</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">injector: com.google.inject.<span class="type">Injector</span></span>) <span class="keyword">extends</span> <span class="title">PlayInjector</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Get an instance of the given class from the injector.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instanceOf</span></span>[<span class="type">T</span>](<span class="keyword">implicit</span> ct: <span class="type">ClassTag</span>[<span class="type">T</span>]) = instanceOf(ct.runtimeClass.asInstanceOf[<span class="type">Class</span>[<span class="type">T</span>]])</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Get an instance of the given class from the injector.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instanceOf</span></span>[<span class="type">T</span>](clazz: <span class="type">Class</span>[<span class="type">T</span>]) = injector.getInstance(clazz)</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Get an instance bound to the given binding key.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instanceOf</span></span>[<span class="type">T</span>](key: <span class="type">BindingKey</span>[<span class="type">T</span>]) = injector.getInstance(<span class="type">GuiceKey</span>(key))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再往底层调用<code>com.google.inject.internal#getProvider</code>方法获取Provider，最终都会调用到某个种类的Injector的<code>inject</code>、<code>provision</code>、<code>construct</code>方法。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/play-scala-injector-dbg-01.png" alt="Call Stack"></p>
<h1 id="题外话-函数式编程中的DI">题外话-函数式编程中的DI</h1><p>以前用DI的时候一直在想，这玩意在OOP中用途这么广泛，那么在FP里会是什么光景呢？其实在FP里，<strong>Currying</strong> 就可以当做是OOP中的DI。这里先挖个坑，待填坑:)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[FP :: Type Theory | Type, Type Constructor 与 Kind]]></title>
      <url>http://www.sczyh30.com/posts/Functional-Programming/functional-programming-type-and-kind/</url>
      <content type="html"><![CDATA[<p>以前忘了总结了。。正好在这里总结一下 <strong>Type</strong>, <strong>Type Constructor</strong> 与 <strong>Kind</strong> 这几个概念，结合Haskell和Scala。</p>
<blockquote>
<p><strong>TODO</strong>(2016.12): GHC 8.0的kind system(<code>TypeInType</code>); Dependent Type; Lambda Cube</p>
</blockquote>
<h1 id="Type,_Type_Constructor_与_Kind_(Haskell)">Type, Type Constructor 与 Kind (Haskell)</h1><p><em>Types and Programming Languages</em> 里的一张图非常直观地表现了Kind与Type的意义：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/tapl-type-kind.png" alt=""></p>
<p>其中，上图的Term就是值(Value)的意思，比如<code>1</code>、<code>&quot;haha&quot;</code>之类的，都是Term。</p>
<p>而Type，则是 <strong>Value的类型</strong>，比如<code>1</code>的Type是<code>Num</code>(Haskell)，<code>&quot;haha&quot;</code>的Type是<code>String</code>。然后我们引入Type Constructor的概念，它接受一个或多个类型参数(type parameter)并构造出一个新Type，比如<code>Maybe</code>是一个Unary Type Constructor，它接受一个类型参数，可以构造出<code>Maybe Int</code>和<code>Maybe String</code>等等的不同的Type。再比如<code>Either</code>的定义为<code>data Either a b = Left a | Right b</code>，它接受两个类型参数，可以构造出像<code>Either Bool</code>和<code>Either Int Bool</code>这样的Type Constructor。其实，我们也可以把这些Primitive Type看作是一种特殊的Type Constructor，即接受零个类型参数(Nullary Type Constructor)。</p>
<p>有了Type和Type Constructor的概念以后，我们就可以定义Kind了。Kind表示 <strong>Type Constructor的类型</strong> ，在Haskell中有以下定义：</p>
<ul>
<li>Nullary Type Constructor（即普通的Type）的kind为<code>*</code></li>
<li>如果k1和k2是kind，那么<code>k1 -&gt; k2</code>代表一个Type constructor的kind，这个Constructor接受kind为k1的类型参数，返回kind为k2的类型参数。<br>比如<code>Either String</code>的kind为<code>* -&gt; *</code></li>
</ul>
<p>这样，从Value到Type、Type Constructor，再到Kind，每上一个层次都是一个抽象。Type Constructor是Value的类型，Kind又是Type Constructor的类型。</p>
<h1 id="Kind_Polymorphism_(Haskell)">Kind Polymorphism (Haskell)</h1><p>默认情况下，Haskell不允许kind具有多态性(Kind polymorphism)。比如我们的Either的定义如下:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Either</span> a b = <span class="type">Left</span> a | <span class="type">Right</span> b 	<span class="comment">-- Defined in ‘Data.Either’</span></span></div></pre></td></tr></table></figure></p>
<p>a和b的kind是任意的，可以是<code>*</code>，也可以是<code>* -&gt; *</code>。Haskell默认将它们的kind都推导为<code>*</code>，因此下面的定义是不允许的：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">T1</span> = <span class="type">Either</span> []</span></div><div class="line"></div><div class="line">&lt;interactive&gt;:<span class="number">123</span>:<span class="number">18</span>:</div><div class="line">    <span class="type">Expecting</span> one more argument to ‘[]’</div><div class="line">    <span class="type">Expected</span> a <span class="class"><span class="keyword">type</span>, but ‘[]’ has kind ‘* -&gt; *’</span></div><div class="line">    <span class="type">In</span> the <span class="class"><span class="keyword">type</span> ‘[]’</span></div><div class="line">    <span class="type">In</span> the definition <span class="keyword">of</span> <span class="class"><span class="keyword">data</span> constructor ‘<span class="type">Either</span>’</span></div><div class="line">    <span class="type">In</span> the <span class="class"><span class="keyword">data</span> declaration for ‘<span class="type">T1</span>’</span></div></pre></td></tr></table></figure></p>
<p>当然有些时候Haskell也是可以推导出来某些Higher-order kind的，比如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">A</span> t k p = <span class="type">A</span> &#123; <span class="title">s1</span> :: <span class="title">p</span>, <span class="title">s2</span> :: <span class="title">t</span> <span class="title">k</span> &#125;</span></div></pre></td></tr></table></figure></p>
<p>由于<code>s2 :: t k</code>，而k默认被推导为<code>*</code>，因此t的kind就会被推导为<code>* -&gt; *</code>，那么A的kind最终被推导为<code>(* -&gt; *) -&gt; * -&gt; * -&gt; *</code>。</p>
<p>如果要使Haskell支持 <strong>polymorphic kinds</strong> ，可以利用GHC的扩展<code>-XPolyKinds</code>，就不再展开总结了，详情可以参考<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#kind-polymorphism" target="_blank" rel="external">这里</a>。</p>
<h1 id="Data_Kinds/Datatype_promotion_(Haskell)">Data Kinds/Datatype promotion (Haskell)</h1><p>Datatype promotion是GHC的一个扩展(<code>-XDataKinds</code>)，可以将部分的Datatype给自动promote成kind。比如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">Prelude</span>&gt; :k <span class="type">Left</span></div><div class="line"><span class="type">Left</span> :: k -&gt; <span class="type">Either</span> k k1</div><div class="line"><span class="type">Prelude</span>&gt; :k <span class="number">3</span></div><div class="line"><span class="number">3</span> :: <span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">Nat</span></div><div class="line"><span class="type">Prelude</span>&gt; :k <span class="string">""</span></div><div class="line"><span class="string">""</span> :: <span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">Symbol</span></div><div class="line"><span class="type">Prelude</span>&gt; :k <span class="type">Just</span></div><div class="line"><span class="type">Just</span> :: k -&gt; <span class="type">Maybe</span> k</div></pre></td></tr></table></figure></p>
<p>具体的应用还没实践过，等实践过再来总结。。</p>
<h1 id="Scala中的Type和Kind">Scala中的Type和Kind</h1><p>Scala中的Type和Kind用一张图总结：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/scala-type-kind-higher.png" alt=""></p>
<p>我觉得Scala中的Kind比较混乱，至少每次试的时候出的结果总与想象的不对应，或许还没有理解吧。。。举几个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Functor</span>[<span class="type">M</span>[_]]</span></div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">Functor</span></div><div class="line">&lt;console&gt;:<span class="number">11</span>: error: not found: value <span class="type">Functor</span></div><div class="line">       <span class="type">Functor</span></div><div class="line">       ^</div><div class="line"></div><div class="line">scala&gt; :k -v <span class="keyword">new</span> <span class="type">Functor</span></div><div class="line"><span class="type">Functor</span><span class="symbol">'s</span> kind is <span class="type">X</span>[<span class="type">F</span>[<span class="type">A</span>]]</div><div class="line">(* -&gt; *) -&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span> <span class="title">that</span> <span class="title">takes</span> <span class="title">type</span> <span class="title">constructor</span>(<span class="params">s</span>)</span>: a higher-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">List</span></div><div class="line">scala.collection.immutable.<span class="type">List</span><span class="symbol">'s</span> kind is <span class="type">F</span>[+<span class="type">A</span>]</div><div class="line">* -(+)-&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span></span>: a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">List</span>[<span class="type">Int</span>]</div><div class="line">scala.collection.immutable.<span class="type">List</span><span class="symbol">'s</span> kind is <span class="type">F</span>[+<span class="type">A</span>]</div><div class="line">* -(+)-&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span></span>: a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">scala.collection.immutable.<span class="type">List</span><span class="symbol">'s</span> kind is <span class="type">A</span></div><div class="line">*</div><div class="line"><span class="type">This</span> is a proper <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="type">Either</span></div><div class="line">scala.util.<span class="type">Either</span><span class="symbol">'s</span> kind is <span class="type">F</span>[+<span class="type">A1</span>,+<span class="type">A2</span>]</div><div class="line">* -(+)-&gt; * -(+)-&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span></span>: a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; :k -v (<span class="type">Int</span>, <span class="type">String</span>) =&gt; <span class="type">Option</span>[_]</div><div class="line">scala.<span class="type">Function2</span><span class="symbol">'s</span> kind is <span class="type">F</span>[-<span class="type">A1</span>,-<span class="type">A2</span>,+<span class="type">A3</span>]</div><div class="line">* -(-)-&gt; * -(-)-&gt; * -(+)-&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span></span>: a <span class="number">1</span>st-order-kinded <span class="class"><span class="keyword">type</span>.</span></div></pre></td></tr></table></figure>
<p>感觉Scala REPL中的<code>:kind</code>是针对value的而不是type的，非常蛋疼，估计是让JVM的泛型类型擦除搞得Parametric Polymorphism都不爽了。。另外Scala中也分 <strong>1st-order-kinded type</strong> 和 <strong>higher-kinded type</strong> 。所谓higher-kinded type就是类似于<code>A[B[_]]</code>这样的type constructor，比如下面的这个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">T3</span>[<span class="type">Q</span>[<span class="type">A</span>], <span class="title">P</span>[<span class="type">B</span>]]</span></div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">T3</span></span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="keyword">new</span> <span class="type">T3</span></div><div class="line"><span class="type">T3</span><span class="symbol">'s</span> kind is <span class="type">X</span>[<span class="type">F1</span>[<span class="type">A1</span>],<span class="type">F2</span>[<span class="type">A2</span>]]</div><div class="line">(* -&gt; *) -&gt; (* -&gt; *) -&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span> <span class="title">that</span> <span class="title">takes</span> <span class="title">type</span> <span class="title">constructor</span>(<span class="params">s</span>)</span>: a higher-kinded <span class="class"><span class="keyword">type</span>.</span></div><div class="line"></div><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">T4</span>[<span class="type">Tuple2</span>[<span class="type">A</span>, <span class="type">B</span>], <span class="title">P</span>[<span class="type">Option</span>[<span class="type">C</span>]], <span class="title">D</span>, <span class="title">E</span>]</span></div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">T4</span></span></div><div class="line"></div><div class="line">scala&gt; :k -v <span class="keyword">new</span> <span class="type">T4</span></div><div class="line"><span class="type">T4</span><span class="symbol">'s</span> kind is <span class="type">Y</span>[<span class="type">F1</span>[<span class="type">A1</span>,<span class="type">A2</span>],<span class="type">X</span>[<span class="type">F2</span>[<span class="type">A3</span>]],<span class="type">A4</span>,<span class="type">A5</span>]</div><div class="line">(* -&gt; * -&gt; *) -&gt; ((* -&gt; *) -&gt; *) -&gt; * -&gt; * -&gt; *</div><div class="line"><span class="type">This</span> is a <span class="class"><span class="keyword">type</span> <span class="title">constructor</span> <span class="title">that</span> <span class="title">takes</span> <span class="title">type</span> <span class="title">constructor</span>(<span class="params">s</span>)</span>: a higher-kinded <span class="class"><span class="keyword">type</span>.</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><em>Types and Programming Languages</em></li>
<li><em>Generics of a Higher Kind</em>, Martin Odersky</li>
<li><a href="https://wiki.haskell.org/Kind" target="_blank" rel="external">Kind - HaskellWiki</a></li>
<li><a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala" target="_blank" rel="external">What is a higher kinded type in Scala?</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scala | Haskell | Type Class总结]]></title>
      <url>http://www.sczyh30.com/posts/Functional-Programming/typeclass-scala-haskell/</url>
      <content type="html"><![CDATA[<h1 id="Type_class_in_Haskell">Type class in Haskell</h1><p>Type class是Haskell中最重要的概念之一，它可以看做是 <strong>对一系列具有某种性质的type的抽象</strong> (比如<code>Eq</code>, <code>Functor</code>, <code>Monad</code>之类的)。每个type class都定义了一组函数。一个type如果要成为某个type class，就必须成为其实例(<code>instance)</code>并实现type class定义的函数。表面上看起来type class和OOP中的接口(interface)的作用类似，但是type class有着更多的优点，我们将在后面比较type class与interface的特点。</p>
<p>在Haskell中，我们通过<code>class</code>关键字来定义type class。比如<code>Monad</code>的定义如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></div><div class="line">    (&gt;&gt;=)       :: <span class="keyword">forall</span> a b. m a -&gt; (a -&gt; m b) -&gt; m b</div><div class="line">    (&gt;&gt;)        :: <span class="keyword">forall</span> a b. m a -&gt; m b -&gt; m b</div><div class="line"></div><div class="line">    return      :: a -&gt; m a</div><div class="line"></div><div class="line">    fail        :: <span class="type">String</span> -&gt; m a</div></pre></td></tr></table></figure>
<p>其中<code>Applicative m =&gt; Monad m</code>代表类型m(更严谨地说应该是type constructor，因为<code>(m :: * -&gt; *)</code>)同样是<code>Applicative</code>的实例。</p>
<p>我们可以通过<code>instance</code>关键字来实现type class的实例。比如Maybe Monad的实现如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span>  <span class="type">Maybe</span> a  =  <span class="type">Nothing</span> | <span class="type">Just</span> a</span></div><div class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>)</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span>  <span class="type">Monad</span> <span class="type">Maybe</span>  <span class="keyword">where</span></div><div class="line">    (<span class="type">Just</span> x) &gt;&gt;= k      = k x</div><div class="line">    <span class="type">Nothing</span>  &gt;&gt;= _      = <span class="type">Nothing</span></div><div class="line"></div><div class="line">    (&gt;&gt;) = (*&gt;)</div><div class="line"></div><div class="line">    fail _              = <span class="type">Nothing</span></div></pre></td></tr></table></figure>
<p>Haskell引入type class是为了解决 <strong>Ad-hoc polymorphism</strong> 的问题。所谓的Ad-hoc polymorphism可以用一句话概括：</p>
<blockquote>
<p>In programming languages, ad-hoc polymorphism is a kind of polymorphism in which polymorphic functions can be applied to arguments of different types, because a polymorphic function can denote a number of distinct and potentially heterogeneous implementations depending on the type of argument(s) to which it is applied.</p>
</blockquote>
<p>即函数根据不同的参数类型选择不同版本的函数进行调用。Ad-hoc polymorphism在OOP里一般通过函数重载或运算符重载实现，而在Haskell中ad-hoc polymorphism就通过type class实现。比如<code>show</code>函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">show</span> :: <span class="type">Show</span> a =&gt; a -&gt; <span class="type">String</span></div></pre></td></tr></table></figure>
<p>类型<code>a</code>必须是<code>Show</code>的实例，对于不同的类型<code>a</code>，<code>show</code>函数会选择对应的函数实现来进行调用，这就实现了上面所说的ad-hoc polymorphism(编译期):</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">Prelude</span>&gt; show [<span class="number">1.7</span>, <span class="number">6.4</span>]</div><div class="line"><span class="string">"[1.7,6.4]"</span></div><div class="line"><span class="type">Prelude</span>&gt; show <span class="number">2</span></div><div class="line"><span class="string">"2"</span></div><div class="line"><span class="type">Prelude</span>&gt; show $ <span class="type">Just</span> <span class="number">4</span></div><div class="line"><span class="string">"Just 4"</span></div></pre></td></tr></table></figure>
<p>Type class在Haskell中其实是一种语法糖，因此下面我们就来看一下GHC是如何desugar它的。</p>
<h1 id="GHC处理type_class的方式">GHC处理type class的方式</h1><p>我们来看一下GHC处理type class的方式。由于对于某个type，作用域内最多只能有一种某个type class的实例，因此type class可以被GHC处理成一种 <strong>“dictionary-passing style”</strong>。这里参考一下 <em>A History of Haskell</em> 中的例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></div><div class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span></div><div class="line">    (/=) :: a -&gt; a -&gt; <span class="type">Bool</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">Int</span> <span class="keyword">where</span></div><div class="line">  i1 == i2 = eqInt i1 i2</div><div class="line">  i1 /= i2 = not (i1 == i2)</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> (<span class="type">Eq</span> <span class="title">a</span>) =&gt; <span class="type">Eq</span> [a] <span class="keyword">where</span></div><div class="line">  [] == [] = <span class="type">True</span></div><div class="line">  (x:xs) == (y:ys) = (x == y) &amp;&amp; (xs == ys)</div><div class="line">  xs /= ys = not (xs == ys)</div><div class="line"></div><div class="line"><span class="title">member</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></div><div class="line"><span class="title">member</span> x [] = <span class="type">False</span></div><div class="line"><span class="title">member</span> x (y:ys) | x == y = <span class="type">True</span></div><div class="line">                | otherwise = member x ys</div></pre></td></tr></table></figure>
<p>它可以被转化成为以下形式：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Eq</span> a = <span class="type">MkEq</span> (<span class="title">a</span> -&gt; <span class="title">a</span> -&gt; <span class="type">Bool</span>) (<span class="title">a</span> -&gt; <span class="title">a</span> -&gt; <span class="type">Bool</span>)</span></div><div class="line"><span class="title">eq</span> (<span class="type">MkEq</span> e _) = e</div><div class="line"><span class="title">ne</span> (<span class="type">MkEq</span> _ n) = n</div><div class="line"></div><div class="line"><span class="title">dEqInt</span> :: <span class="type">Eq</span> <span class="type">Int</span></div><div class="line"><span class="title">dEqInt</span> = <span class="type">MkEq</span> eqInt (\x y -&gt; not (eqInt x y))</div><div class="line"></div><div class="line"><span class="title">dEqList</span> :: <span class="type">Eq</span> a -&gt; <span class="type">Eq</span> [a]</div><div class="line"><span class="title">dEqList</span> d = <span class="type">MkEq</span> el (\x y -&gt; not (el x y))</div><div class="line">  <span class="keyword">where</span></div><div class="line">    el [] [] = <span class="type">True</span></div><div class="line">    el (x:xs) (y:ys) = eq d x y &amp;&amp; el xs ys</div><div class="line">    el _ _ = <span class="type">False</span></div><div class="line"></div><div class="line"><span class="title">member</span> :: <span class="type">Eq</span> a -&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></div><div class="line"><span class="title">member</span> d x [] = <span class="type">False</span></div><div class="line"><span class="title">member</span> d x (y:ys) | eq d x y = <span class="type">True</span></div><div class="line">                  | otherwise = member d x ys</div></pre></td></tr></table></figure>
<p>我们看到，type class的定义部分被转换成了一个data type，它定义了对应type class的字典(dictionary)，里面记录了type class里的函数。上面的例子中，转换后的<code>eq</code>和<code>ne</code>函数会从这个字典里选择对应的函数。我们再来看一下转换后的<code>member</code>函数。它会接受对应的字典参数，并通过<code>eq</code>函数从字典中提取出对应的判断函数。最后就是对应的instance实现部分了。instance部分被转换成了一个选择函数，返回一个完整的字典。比如<code>dEqList</code>函数会接受一个<code>Eq a</code>类型的字典，返回一个<code>Eq [a]</code>类型的字典。</p>
<p>简单总结一下转换过程：</p>
<ul>
<li><code>class</code> -&gt; data type (dictionary)</li>
<li><code>instance</code> -&gt; selector function</li>
</ul>
<h1 id="Type_class_pattern_in_Scala:_Implicit_Objects">Type class pattern in Scala: Implicit Objects</h1><p>Scala中并没有直接通过关键字支持type class(毕竟还混合了OOP)。Scala中type class成为了一种pattern，可以通过<code>trait</code>加上<code>implicit</code>来实现。</p>
<p>比如要对一组“可加的元素”（即我们熟悉的幺半群<code>Monoid</code>）进行求和(<code>concat</code>)操作，在Haskell里可以这么写(和默认的<code>Monoid</code>实现有差别)：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">class</span> <span class="type">Monoid</span> a <span class="keyword">where</span></div><div class="line">  mempty :: a</div><div class="line">  mappend :: a -&gt; a -&gt; a</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Integer</span> <span class="keyword">where</span></div><div class="line">  mempty = <span class="number">0</span></div><div class="line">  mappend a b = a + b</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">String</span> <span class="keyword">where</span></div><div class="line">  mempty = <span class="string">""</span></div><div class="line">  mappend a b = a ++ b</div><div class="line"></div><div class="line"><span class="title">mconcat</span> :: <span class="type">Monoid</span> a =&gt; [a] -&gt; a</div><div class="line"><span class="title">mconcat</span> xs = foldl mappend mempty xs</div></pre></td></tr></table></figure>
<p>而在Scala中，我们可以通过Implicit Object来实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mempty</span></span>: <span class="type">A</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mappend</span></span>(a: <span class="type">A</span>, b: <span class="type">A</span>): <span class="type">A</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">IntMonoid</span> <span class="keyword">extends</span> <span class="title">Monoid</span>[<span class="type">Int</span>] </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">mempty</span> </span>= <span class="number">0</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">mappend</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = a + b</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">StringMonoid</span> <span class="keyword">extends</span> <span class="title">Monoid</span>[<span class="type">String</span>] </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">mempty</span> </span>= <span class="string">""</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">mappend</span></span>(a: <span class="type">String</span>, b: <span class="type">String</span>) = a + b</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mconcat</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> monoid: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">A</span> = &#123;</div><div class="line">  xs.foldLeft(monoid.mempty)(monoid.mappend)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们定义了一个<code>Monoid</code> trait代表幺半群（性质：封闭、可结合、有幺元），这个trait就对应Haskell中type class的定义。接着我们分别为<code>Int</code>类型和<code>String</code>类型实现了对应的<code>Monoid</code>实例，注意对应的<code>Monoid</code>实例都是<strong>implicit object</strong>。最后我们要实现一个<code>mconcat</code>对一组具有幺半群性质的类型的值进行”求和”计算，这里我们将<code>Monoid</code>实例作为了implicit参数传递进了<code>mconcat</code>方法中，这样根据Scala的类型系统以及implicit匹配过程，当<code>xs</code>的类型是<code>List[Int]</code>的时候，<code>IntMonoid</code>会作为implicit参数传入<code>mconcat</code>方法；而当<code>xs</code>的类型是<code>List[String]</code>的时候，<code>StringMonoid</code>会作为implicit参数传入<code>mconcat</code>方法；如果没有匹配的implicit参数就会编译失败，从而确保了类型安全。是不是很奇妙呢？当然我们也可以用Scala的context bound语法糖省略掉implicit参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mconcat</span></span>[<span class="type">A</span> : <span class="type">Monoid</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">A</span> = &#123;</div><div class="line">  <span class="keyword">val</span> monoid = implicitly[<span class="type">Monoid</span>[<span class="type">A</span>]]</div><div class="line">  xs.foldLeft(monoid.mempty)(monoid.mappend)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Type_class与接口的对比及优点">Type class与接口的对比及优点</h1><p>从上面的代码，我们可以看出，type class和trait/interface作用类似，都是对某一系列类型抽象出特定的行为。那么type class与trait/interface相比有什么优点呢？想象一下，如果用interface的话，每个sub-class都要在其body内实现对应的函数。这样如果要给现有的类实现这个interface的话，就必须要修改原类，在原类中增加对应的实现，这显然不符合Open Closed Principle(对扩展开放，对修改关闭)。所以OOP中提出了诸如 <em>适配器模式</em> 这样的设计模式用于扩展已有的类，但写各种adapter增加了代码的冗杂程度。</p>
<p>而对于type class pattern来说，实现type class实例的代码并不写在类型定义中，而是在外部实现一个对应type class的实例。这样，我们要给现有的类型实现一个type class的话就不需要更改原有类型的定义了，只需要实现对应的type class实例就可以了。这其实就是 <strong>抽象与实现分离</strong>，即类型定义与约束实现是分离的，某个类型并不清楚自己属于某个type class。与接口的方式相比，type class符合Open Closed Principle。</p>
<p>上面我们提到过，编译器会根据一定的机制在 <strong>编译期</strong> 自动寻找需要的type class实例，其中Haskell底层是通过转换成字典的形式让编译器寻找type class实例，而Scala中则是通过传入implicit参数的方式让编译器寻找type class实例，这保证了类型安全。</p>
<p>相比Haskell而言，Scala中的type class pattern更加灵活（托<code>implicit</code>的福），比如:</p>
<ul>
<li>结合context bound语法糖，Scala中可以方便的组合多个type class，如<code>A : Eq : Ord</code></li>
<li>Type class可以有默认实现(default implicit parameter)</li>
<li>Scala中type class实例是具名的(implicit object)，因此同一种类型可以有不同的type class实例，并且可以通过控制作用域(通过<code>import</code>)来选择不同的实例</li>
</ul>
<p>当然type class还有更多的高级玩法，以后实践的多了再慢慢总结。。。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://ropas.snu.ac.kr/~bruno/papers/TypeClasses.pdf" target="_blank" rel="external">Bruno C. d. S. Oliveira, Adriaan Moors, Martin Odersky. <em>Type Classes as Objects and Implicits.</em></a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf" target="_blank" rel="external">Paul Hudak, John Hughes, Simon Peyton Jones, Philip Wadler. <em>A History of Haskell: Being Lazy With Class.</em></a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/haskell-retrospective/ECOOP-July09.pdf" target="_blank" rel="external">Classes, Jim, but not as we know them (ECOOP 2009)</a></li>
<li><a href="https://www.youtube.com/watch?v=hIZxTQP1ifo" target="_blank" rel="external">Edward Kmett - Type Classes vs. the World</a></li>
<li><a href="http://stackoverflow.com/questions/5408861/what-are-type-classes-in-scala-useful-for" target="_blank" rel="external">What are type classes in Scala useful for?</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[并发编程 | ThreadLocal源码深入分析]]></title>
      <url>http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/</url>
      <content type="html"><![CDATA[<p>以前只知道ThreadLocal的大致思路，没有去深入研究。今天读了读源码，果然博大精深～</p>
<p>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为<code>private static</code>类型。</p>
<p>假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用<code>HashMap</code>来实现，Thread作为<code>key</code>，变量作为<code>value</code>。事实上，JDK中确实使用了类似<code>Map</code>的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中<code>ThreadLocal</code>的实现。</p>
<h1 id="初探ThreadLocal">初探ThreadLocal</h1><p>我们从ThreadLocal的几个成员变量入手：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The next hash code to be given out. Updated atomically. Starts at</div><div class="line"> * zero.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</div><div class="line">    <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The difference between successively generated hash codes - turns</div><div class="line"> * implicit sequential thread-local IDs into near-optimally spread</div><div class="line"> * multiplicative hash values for power-of-two-sized tables.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the next hash code.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ThreadLocal通过<code>threadLocalHashCode</code>来标识每一个ThreadLocal的唯一性。<code>threadLocalHashCode</code>通过<code>CAS操作</code>进行更新，每次hash操作的增量为<strong>0x61c88647</strong>(这个数的原理没有探究)。<br>再看<code>set</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Sets the current thread's copy of this thread-local variable</div><div class="line"> * to the specified value.  Most subclasses will have no need to</div><div class="line"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</div><div class="line"> * method to set the values of thread-locals.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</div><div class="line"> *        this thread-local.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到通过<code>Thread.currentThread()</code>方法获取了当前的线程引用，并传给了<code>getMap(Thread)</code>方法获取一个<code>ThreadLocalMap</code>的实例。我们继续跟进<code>getMap(Thread)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到<code>getMap(Thread)</code>方法直接返回Thread实例的成员变量<code>threadLocals</code>。它的定义在Thread内部，访问级别为package级别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line"> * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>到了这里，我们可以看出，每个<code>Thread</code>里面都有一个<code>ThreadLocal.ThreadLocalMap</code>成员变量，也就是说每个线程通过<code>ThreadLocal.ThreadLocalMap</code>与ThreadLocal相绑定，这样可以确保每个线程访问到的thread-local variable都是本线程的。</p>
<p>我们往下继续分析。获取了<code>ThreadLocalMap</code>实例以后，如果它不为空则调用<code>ThreadLocalMap.ThreadLocalMap#set</code>方法设值；若为空则调用<code>ThreadLocal#createMap</code>方法new一个<code>ThreadLocalMap</code>实例并赋给<code>Thread.threadLocals</code>。</p>
<p><code>ThreadLocal#createMap</code>方法的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面我们探究一下<code>ThreadLocalMap</code>的实现。</p>
<h1 id="ThreadLocalMap">ThreadLocalMap</h1><p>ThreadLocalMap是ThreadLocal的静态内部类，它的结构如下：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/threadlocal-map-structure.png" alt="ThreadLocalMap"></p>
<p>可以看到ThreadLocalMap有一个常量和三个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The initial capacity -- MUST be a power of two.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The table, resized as necessary.</div><div class="line"> * table.length MUST always be a power of two.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> Entry[] table;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of entries in the table.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The next size value at which to resize.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></div></pre></td></tr></table></figure></p>
<p>其中<code>INITIAL_CAPACITY</code>代表这个Map的初始容量；1是一个Entry类型的数组，用于存储数据；<code>size</code>代表表中的存储数目；<code>threshold</code>代表需要扩容时对应size的阈值。</p>
<p><code>Entry</code>类是<code>ThreadLocalMap</code>的静态内部类，用于存储数据。它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The entries in this hash map extend WeakReference, using</div><div class="line"> * its main ref field as the key (which is always a</div><div class="line"> * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line"> * == null) mean that the key is no longer referenced, so the</div><div class="line"> * entry can be expunged from table.  Such entries are referred to</div><div class="line"> * as "stale entries" in the code that follows.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Entry</code>类继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。</p>
<p><code>ThreadLocalMap</code>类有两个构造函数，其中常用的是<code>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Construct a new map initially containing (firstKey, firstValue).</div><div class="line"> * ThreadLocalMaps are constructed lazily, so we only create</div><div class="line"> * one when we have at least one entry to put in it.</div><div class="line"> */</div><div class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</div><div class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</div><div class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</div><div class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</div><div class="line">    size = <span class="number">1</span>;</div><div class="line">    setThreshold(INITIAL_CAPACITY);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造函数的第一个参数就是本ThreadLocal实例(<code>this</code>)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。</p>
<p>注意一个细节，计算hash的时候里面采用了<code>hashCode &amp; (size - 1)</code>的算法，这相当于取模运算<code>hashCode % size</code>的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是<strong>2的指数</strong>，因为这可以使得hash发生冲突的次数减小。</p>
<p>接下来我们来看<code>ThreadLocalMap#set</code>方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Set the value associated with key.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key the thread local object</div><div class="line"> * <span class="doctag">@param</span> value the value to be set</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></div><div class="line">    <span class="comment">// least as common to use set() to create new entries as</span></div><div class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></div><div class="line">    <span class="comment">// path would fail more often than not.</span></div><div class="line"></div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            replaceStaleEntry(key, value, i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</div><div class="line">    <span class="keyword">int</span> sz = ++size;</div><div class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">        rehash();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果冲突了，就会通过<code>nextIndex</code>方法再次计算哈希值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Increment i modulo len.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，我们看到<code>ThreadLocalMap</code>解决冲突的方法是<strong>线性探测法</strong>（不断加1），而不是HashMap的<strong>链地址法</strong>，这一点也能从Entry的结构上推断出来。</p>
<p>如果entry里对应的key为<code>null</code>的话，表明此entry为<code>staled entry</code>，就将其替换为当前的key和value：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Replace a stale entry encountered during a set operation</div><div class="line"> * with an entry for the specified key.  The value passed in</div><div class="line"> * the value parameter is stored in the entry, whether or not</div><div class="line"> * an entry already exists for the specified key.</div><div class="line"> *</div><div class="line"> * As a side effect, this method expunges all stale entries in the</div><div class="line"> * "run" containing the stale entry.  (A run is a sequence of entries</div><div class="line"> * between two null slots.)</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  key the key</div><div class="line"> * <span class="doctag">@param</span>  value the value to be associated with key</div><div class="line"> * <span class="doctag">@param</span>  staleSlot index of the first stale entry encountered while</div><div class="line"> *         searching for key.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></div><div class="line">                               <span class="keyword">int</span> staleSlot) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    Entry e;</div><div class="line"></div><div class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></div><div class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></div><div class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></div><div class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></div><div class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">         i = prevIndex(i, len))</div><div class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</div><div class="line">            slotToExpunge = i;</div><div class="line"></div><div class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></div><div class="line">    <span class="comment">// occurs first</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">        <span class="comment">// If we find key, then we need to swap it</span></div><div class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></div><div class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></div><div class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></div><div class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line"></div><div class="line">            tab[i] = tab[staleSlot];</div><div class="line">            tab[staleSlot] = e;</div><div class="line"></div><div class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></div><div class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</div><div class="line">                slotToExpunge = i;</div><div class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If we didn't find stale entry on backward scan, the</span></div><div class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></div><div class="line">        <span class="comment">// first still present in the run.</span></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</div><div class="line">            slotToExpunge = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></div><div class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</div><div class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</div><div class="line"></div><div class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></div><div class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</div><div class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。</p>
<p>若是经历了上面步骤没有命中hash，也没有发现无用的Entry，<code>set</code>方法就会创建一个新的Entry，并会进行<strong>启发式的垃圾清理</strong>，用于清理无用的Entry。主要通过<code>cleanSomeSlots</code>方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Heuristically scan some cells looking for stale entries.</div><div class="line"> * This is invoked when either a new element is added, or</div><div class="line"> * another stale one has been expunged. It performs a</div><div class="line"> * logarithmic number of scans, as a balance between no</div><div class="line"> * scanning (fast but retains garbage) and a number of scans</div><div class="line"> * proportional to number of elements, that would find all</div><div class="line"> * garbage but would cause some insertions to take O(n) time.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> i a position known NOT to hold a stale entry. The</div><div class="line"> * scan starts at the element after i.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> n scan control: &#123;<span class="doctag">@code</span> log2(n)&#125; cells are scanned,</div><div class="line"> * unless a stale entry is found, in which case</div><div class="line"> * &#123;<span class="doctag">@code</span> log2(table.length)-1&#125; additional cells are scanned.</div><div class="line"> * When called from insertions, this parameter is the number</div><div class="line"> * of elements, but when from replaceStaleEntry, it is the</div><div class="line"> * table length. (Note: all this could be changed to be either</div><div class="line"> * more or less aggressive by weighting n instead of just</div><div class="line"> * using straight log n. But this version is simple, fast, and</div><div class="line"> * seems to work well.)</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> true if any stale entries have been removed.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        i = nextIndex(i, len);</div><div class="line">        Entry e = tab[i];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</div><div class="line">            n = len;</div><div class="line">            removed = <span class="keyword">true</span>;</div><div class="line">            i = expungeStaleEntry(i);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> removed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一旦发现一个位置对应的Entry所持有的ThreadLocal弱引用为null，就会把此位置当做staleSlot并调用<code>expungeStaleEntry</code>方法进行整理(rehashing)的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Expunge a stale entry by rehashing any possibly colliding entries</div><div class="line"> * lying between staleSlot and the next null slot.  This also expunges</div><div class="line"> * any other stale entries encountered before the trailing null.  See</div><div class="line"> * Knuth, Section 6.4</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</div><div class="line"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</div><div class="line"> * (all between staleSlot and this slot will have been checked</div><div class="line"> * for expunging).</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="comment">// expunge entry at staleSlot</span></div><div class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</div><div class="line">    tab[staleSlot] = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    <span class="comment">// Rehash until we encounter null</span></div><div class="line">    Entry e;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            e.value = <span class="keyword">null</span>;</div><div class="line">            tab[i] = <span class="keyword">null</span>;</div><div class="line">            size--;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (h != i) &#123;</div><div class="line">                tab[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></div><div class="line">                <span class="comment">// null because multiple entries could have been stale.</span></div><div class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                tab[h] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要没有清理任何的<strong>stale entries</strong>并且size达到阈值的时候（即table已满，所有元素都可用），都会触发<code>rehashing</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Re-pack and/or re-size the table. First scan the entire</div><div class="line"> * table removing stale entries. If this doesn't sufficiently</div><div class="line"> * shrink the size of the table, double the table size.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</div><div class="line">    expungeStaleEntries();</div><div class="line"></div><div class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></div><div class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</div><div class="line">        resize();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Expunge all stale entries in the table.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        Entry e = tab[j];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</div><div class="line">            expungeStaleEntry(j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>rehash操作会执行一次全表的扫描清理工作，并在size大于等于threshold的四分之三时进行resize，即扩容一倍。因此<code>ThreadLocalMap</code>的加载因子一样为<strong>0.75</strong>。</p>
<p>我们继续看<code>getEntry</code>的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Get the entry associated with key.  This method</div><div class="line"> * itself handles only the fast path: a direct hit of existing</div><div class="line"> * key. It otherwise relays to getEntryAfterMiss.  This is</div><div class="line"> * designed to maximize performance for direct hits, in part</div><div class="line"> * by making this method readily inlinable.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  key the thread local object</div><div class="line"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</div><div class="line">    Entry e = table[i];</div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Version of getEntry method for use when key is not found in</div><div class="line"> * its direct hash slot.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  key the thread local object</div><div class="line"> * <span class="doctag">@param</span>  i the table index for key's hash code</div><div class="line"> * <span class="doctag">@param</span>  e the entry at table[i]</div><div class="line"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="keyword">if</span> (k == key)</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</div><div class="line">            expungeStaleEntry(i);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            i = nextIndex(i, len);</div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用<code>getEntryAfterMiss</code>方法，根据线性探测法继续查找，直到找到或对应entry为<code>null</code>，并返回。</p>
<p>ThreadLocal的get方法就是调用了<code>ThreadLocalMap</code>的getEntry方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>remove</code>方法的思想类似，直接放源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Remove the entry for key.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</div><div class="line">            e.clear();</div><div class="line">            expungeStaleEntry(i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>remove的时候同样也会调用<code>expungeStaleEntry</code>方法执行清理工作。</p>
<h1 id="总结">总结</h1><p>每个Thread里都含有一个ThreadLocalMap的成员变量，这种机制将ThreadLocal和线程巧妙地绑定在了一起，即可以保证无用的ThreadLocal被及时回收，不会造成内存泄露，又可以提升性能。假如我们把ThreadLocalMap做成一个<code>Map&lt;t extends Thread, ?&gt;</code>类型的Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而JDK里的这种利用ThreadLocal作为key，再将ThreadLocalMap与线程相绑定的实现，完美地解决了这个问题。</p>
<p>总结一下什么时候无用的Entry会被清理：</p>
<ul>
<li>Thread结束的时候</li>
<li>插入元素时，发现<strong>staled entry</strong>，则会进行替换并清理</li>
<li>插入元素时，<code>ThreadLocalMap</code>的<code>size</code>达到<code>threshold</code>，并且没有任何<strong>staled entries</strong>的时候，会调用<code>rehash</code>方法清理并扩容</li>
<li>调用<code>ThreadLocalMap</code>的<code>remove</code>方法或<code>set(null)</code>时</li>
</ul>
<p>尽管不会造成内存泄露，但是可以看到无用的Entry只会在以上四种情况下才会被清理，这就可能导致一些Entry虽然无用但还占内存的情况。因此，我们在使用完ThreadLocal后一定要<code>remove</code>一下，保证及时回收掉无用的Entry。</p>
<p>【场景】当应用线程池的时候，由于线程池的线程一般会复用，Thread不结束，这时候用完更需要<code>remove</code>了。</p>
<p>总的来说，对于多线程资源共享的问题，同步机制采用了“<strong>以时间换空间</strong>”的方式，而ThreadLocal采用了“<strong>以空间换时间</strong>”的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<h1 id="应用">应用</h1><p>应用太多了。。。各大框架都有应用，比如Spring。Spring对一些Bean中的成员变量采用ThreadLocal进行处理，让它们可以成为线程安全的。举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.context.request;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestContextHolder</span>  </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsfPresent =</div><div class="line">			ClassUtils.isPresent(<span class="string">"javax.faces.context.FacesContext"</span>, RequestContextHolder.class.getClassLoader());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder =</div><div class="line">			<span class="keyword">new</span> NamedThreadLocal&lt;RequestAttributes&gt;(<span class="string">"Request attributes"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder =</div><div class="line">			<span class="keyword">new</span> NamedInheritableThreadLocal&lt;RequestAttributes&gt;(<span class="string">"Request context"</span>);</div><div class="line"></div><div class="line">            <span class="comment">//......下面省略</span></div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>再比如Spring MVC中的Controller默认是<strong>singleton</strong>的，因此如果Controller或其对应的Service里存在非静态成员变量的话，并发访问就会出现race condition问题，这也可以通过<strong>ThreadLocal</strong>解决。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[并发编程 | JDK 1.8中的CompletableFuture | FRP风格]]></title>
      <url>http://www.sczyh30.com/posts/Java/java-8-completable-future/</url>
      <content type="html"><![CDATA[<p><code>Future</code>对象代表一个尚未完成异步操作的结果。从JDK 1.5以来，JUC包一直提供着最基本的<code>Future</code>，不过它太鸡肋了，除了<code>get</code>、<code>cancel</code>、<code>isDone</code>和<code>isCancelled</code>方法之外就没有其他的操作了，这样很不方便。好在JDK 1.8中引入了具有FRP风格的<code>CompletableFuture</code>，它类似于Scala中的<code>Future</code>。<code>CompletableFuture</code>属于Monad， 因此支持一系列的函数式的组合、运算操作，非常方便，可以写出很FRP风格的代码而摆脱callback hell。</p>
<p>下面我们来结合FRP的思想，总结一下这些操作（<em>有的时候为了方便表示，我会用Haskell或Scala的语法来表示类型，毕竟Java的类型系统太渣</em>）：</p>
<h1 id="构造CompletableFuture对象">构造CompletableFuture对象</h1><p>CompletableFuture类通过工厂模式创建<code>CompletableFuture</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,</span></span></div><div class="line">                                                   Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable,</span></span></div><div class="line">                                               Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们的异步操作不需要返回值，那么可以通过<code>runAsync</code>方法提供一个Runnable创建一个<code>CompletableFuture&lt;Void&gt;</code>对象。如果我们的异步操作需要返回值，那么可以通过<code>supplyAsync</code>方法提供一个<code>Supplier&lt;U&gt;</code>对象来创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; longTask(param));</div></pre></td></tr></table></figure>
<p>如果不提供<code>Executor</code>的话，默认使用<code>ForkJoinPool.commonPool()</code>作为线程池。</p>
<p>后缀为<code>Async</code>的方法代表异步执行。</p>
<h1 id="变换(fmap)">变换(fmap)</h1><p>假如我们要通过CompletableFuture来异步获取一组数据，并对数据进行一些处理（变换），我们可以使用<code>thenApply</code>和<code>thenApplyAsync</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> uniApplyStage(<span class="keyword">null</span>, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> uniApplyStage(asyncPool, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它其实就是<code>fmap</code>函数，用Haskell表示原型为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 对比一下fmap</span></div><div class="line"><span class="title">fmap</span> :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</div><div class="line"></div><div class="line"><span class="title">thenApply</span> :: (a -&gt; b) -&gt; <span class="type">CompletableFuture</span> a -&gt; <span class="type">CompletableFuture</span> b</div></pre></td></tr></table></figure>
<p>它们不仅可以变换数据的值，也可以变换数据的类型，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CompletableFuture&lt;Double&gt; f = CompletableFuture.supplyAsync(() -&gt; <span class="string">"4"</span>)</div><div class="line">                .thenApply(Integer::parseInt)</div><div class="line">                .thenApply(r -&gt; r * r * Math.PI);</div></pre></td></tr></table></figure>
<p>fmap以后，数据流的类型进行了以下变换：<code>String -&gt; Integer -&gt; Double</code>。</p>
<h1 id="组合(bind)">组合(bind)</h1><p>有的时候，我们需要在异步操作完成的时候对异步操作的结果进行一些操作，并且操作仍然返回<code>CompletableFuture</code>类型。我们可以利用<code>thenCompose</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> uniComposeStage(<span class="keyword">null</span>, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> uniComposeStage(asyncPool, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(</span></span></div><div class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</div><div class="line">    Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> uniComposeStage(screenExecutor(executor), fn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出它其实对应了Monad里的<code>bind</code>操作(Java和Scala中为<code>flatMap</code>)，用Haskell表示原型为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(&gt;&gt;=) :: <span class="type">Monad</span> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</div><div class="line"></div><div class="line"><span class="title">thenCompose</span> :: <span class="type">CompletableFuture</span> a -&gt; (a -&gt; <span class="type">CompletableFuture</span> b) -&gt; <span class="type">CompletableFuture</span> b</div></pre></td></tr></table></figure>
<p><code>thenCompose</code>是一个非常重要的操作，它对于构建异步的pipeline非常有用。举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskWorkI</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;List&lt;Integer&gt;&gt; longTask(Integer i) &#123;</div><div class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pc = <span class="number">0</span>; pc &lt; i; pc++)</div><div class="line">                list.add(pc);</div><div class="line">            <span class="keyword">return</span> Optional.of(list);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> Optional.empty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Long&gt; <span class="title">getResultFuture</span><span class="params">(Optional&lt;List&lt;Integer&gt;&gt; op)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (op.isPresent())</div><div class="line">                <span class="keyword">return</span> op.get().stream()</div><div class="line">                        .map(Integer::toUnsignedLong)</div><div class="line">                        .reduce(<span class="number">0L</span>, (x, y) -&gt; x + y);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> -<span class="number">1L</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        CompletableFuture&lt;Long&gt; f = CompletableFuture.supplyAsync(() -&gt; longTask(<span class="number">1000000</span>))</div><div class="line">                .thenComposeAsync(TaskWorkI::getResultFuture);</div><div class="line">        Long result = f.get();</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="超级变换(liftM2)">超级变换(liftM2)</h1><p><code>CompletableFuture</code>类里面还有个<code>thenCombine</code>操作，它的原型看起来非常晕：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(</span></span></div><div class="line">    CompletionStage&lt;? extends U&gt; other,</div><div class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> biApplyStage(<span class="keyword">null</span>, other, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(</span></span></div><div class="line">    CompletionStage&lt;? extends U&gt; other,</div><div class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn) &#123;</div><div class="line">    <span class="keyword">return</span> biApplyStage(asyncPool, other, fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(</span></span></div><div class="line">    CompletionStage&lt;? extends U&gt; other,</div><div class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn, Executor executor) &#123;</div><div class="line">    <span class="keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java类型系统过于坑爹，我们用Haskell表示其原型就一目了然了：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">thenCombine</span> :: <span class="type">CompletableFuture</span> a -&gt; <span class="type">CompletableFuture</span> b -&gt; (a -&gt; b -&gt; c) -&gt; <span class="type">CompletableFuture</span> c</div></pre></td></tr></table></figure>
<p>把参数调调位置，可以发现<code>thenCombine</code>其实类似于Haskell中的<code>liftM2</code>操作：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">liftM2</span> :: <span class="type">Monad</span> m =&gt; (a1 -&gt; a2 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m r</div><div class="line"></div><div class="line"><span class="title">thenCombine</span> :: <span class="type">CompletableFuture</span> m =&gt; (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c</div></pre></td></tr></table></figure>
<h1 id="简单示例">简单示例</h1><p>下面我们用一个简单的例子来说明<code>CompletableFuture</code>的使用。假设我们需要获取一篇文章(Article)的信息、对应分类(Category)信息以及对应的评论数，而且从数据库中query的操作是异步的（每个DB操作都返回一个<code>CompletableFuture</code>），我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleWithCategory</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Article article;</div><div class="line">    <span class="keyword">private</span> Category category;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArticleWithCategory</span><span class="params">(Article article, Category category)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.article = article;</div><div class="line">        <span class="keyword">this</span>.category = category;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwcWithCount</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArticleWithCategory awc;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwcWithCount</span><span class="params">(ArticleWithCategory awc, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.awc = awc;</div><div class="line">        <span class="keyword">this</span>.count = count;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;ArticleWithCategory&gt; <span class="title">fetchAWC</span><span class="params">(<span class="keyword">int</span> aid)</span> </span>&#123;</div><div class="line">    <span class="comment">// 从数据库中异步获取文章信息与分类信息</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Integer&gt; <span class="title">getCount</span><span class="params">(<span class="keyword">int</span> aid)</span> </span>&#123;</div><div class="line">    <span class="comment">// 从数据库中异步获取评论数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;AwcWithCount&gt; <span class="title">fetchWithAWCC</span><span class="params">(<span class="keyword">int</span> aid)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> fetchAWC(aid).thenCompose(x -&gt; <span class="comment">// flatMap</span></div><div class="line">            getCount(aid).thenApply(y -&gt; <span class="comment">// map</span></div><div class="line">                <span class="keyword">new</span> AwcWithCount(x, y)</div><div class="line">    ));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这其实和Scala中的Slick的各种组合特别相似：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWithAWCC</span></span>(aid: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Option</span>[(<span class="type">Article</span>, <span class="type">Category</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    db.run((<span class="keyword">for</span> &#123;</div><div class="line">        a &lt;- articles <span class="keyword">if</span> _.aid === aid</div><div class="line">        c &lt;- categories <span class="keyword">if</span> _.cid === a.cid</div><div class="line">    &#125; <span class="keyword">yield</span>(a, c)).result.headOption) flatMap &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Some</span>(a, c) =&gt;</div><div class="line">            db.run(comments.filter(_.aid === aid).length) map &#123; <span class="keyword">case</span> res =&gt;</div><div class="line">                <span class="type">Some</span>(a, c, res)</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">            <span class="type">Future</span>(<span class="type">None</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Rx中同样也提供了类似的组合操作，而且更为丰富。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scala | 利用Curry-Howard Isomorphism实现union type]]></title>
      <url>http://www.sczyh30.com/posts/Scala/scala-fp-union-curry-howard-isomorphism/</url>
      <content type="html"><![CDATA[<p>所谓的联合类型(union type)，在逻辑上是“或”的意思，如<code>A or B or C</code>。</p>
<p>假设我们想实现这样一个函数size，它可以计算一个联合类型对象（Int与String）的长度。我们期望size函数只接受Int类型或String类型（以及它们的子类型，如Null和Nothing）的对象，而不接受任何其他类型的对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(x: <span class="type">Int</span> ∨ <span class="type">String</span>) = x <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i</div><div class="line">  <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.length</div><div class="line">&#125;</div><div class="line"></div><div class="line">size(<span class="number">24</span>) == <span class="number">24</span>   <span class="comment">// OK</span></div><div class="line">size(<span class="string">"fuck"</span>) == <span class="number">4</span> <span class="comment">// OK</span></div><div class="line">size(<span class="number">1.0</span>)        <span class="comment">// 编译错误</span></div></pre></td></tr></table></figure></p>
<p>Scala中的<code>Either</code>类型可以提供一种不支持子类型的联合类型。举个例子，用<code>Either</code>实现size函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(x: <span class="type">Either</span>[<span class="type">Int</span>, <span class="type">String</span>]) = x <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Left</span>(i) =&gt; i</div><div class="line">  <span class="keyword">case</span> <span class="type">Right</span>(s) =&gt; s.length</div><div class="line">&#125;</div><div class="line"></div><div class="line">size(<span class="type">Left</span>(<span class="number">24</span>)) == <span class="number">24</span>    <span class="comment">// OK</span></div><div class="line">size(<span class="type">Right</span>(<span class="string">"fuck"</span>)) == <span class="number">4</span> <span class="comment">// OK</span></div><div class="line">size(<span class="type">Left</span>(<span class="string">"lv"</span>)) <span class="comment">// error: type mismatch</span></div></pre></td></tr></table></figure></p>
<p>我们可以观察出一个问题，那就是要使用Either类型就不可避免要把对象包装成Either类型（<code>Left</code>或<code>Right</code>），这是不方便的。我们需要一些奇技淫巧来实现一个原生类型版本(unboxed)的size函数，这就是下面要介绍的<strong>Curry-Howard Isomorphism</strong>（柯里-霍华德同构）。</p>
<h1 id="Curry-Howard_Isomorphism">Curry-Howard Isomorphism</h1><p><a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" target="_blank" rel="external">Curry-Howard Isomorphism</a> 通过命题表示了计算机程序与数理逻辑之间的直接联系(逻辑上的等价关系)，即我们可以利用数理逻辑中的某些东西来去表示程序中的特定逻辑。比如在Curry-Howard 同构中，有以下的等价关系：</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>类型系统(Scala)</th>
<th>命题逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>联合类型（并，析取）</td>
<td>A ∨ B（∨为自定义的析取类型）</td>
<td>A ∨ B</td>
</tr>
<tr>
<td>交集类型（交，合取）</td>
<td>A with B</td>
<td>A ∧ B</td>
</tr>
<tr>
<td>子类型（蕴含）</td>
<td>A &lt;: B</td>
<td>A ⇒ B</td>
</tr>
</tbody>
</table>
<p>因此联合类型可以表示为析取式，如<code>P ∨ Q ∨ R</code>。</p>
<p>那么如何根据Curry-Howard 同构实现一个析取类型呢？我们可以先利用<strong>德摩根定律</strong>(De Morgan’s laws)做一个转化。已知德摩根定律：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(A ∨ B) ⇔ ¬(¬A ∧ ¬B)</div></pre></td></tr></table></figure></p>
<p>用Scala代码就可以表示为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="type">A</span> ∨ <span class="type">B</span>) =:= ¬[¬[<span class="type">A</span>] <span class="keyword">with</span> ¬[<span class="type">B</span>]]</div></pre></td></tr></table></figure></p>
<p>这样，问题就转化成了如何实现一个否定类型(¬)。我们从另一个角度去利用Curry-Howard 同构。在类型系统理论中，存在以下等价关系：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>Scala Type</th>
<th>对应命题逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum Type</td>
<td>A ∨ B（∨为自定义的析取类型）</td>
<td>析取(A ∨ B)</td>
</tr>
<tr>
<td>Product Type</td>
<td>(A, B)</td>
<td>合取(A ∧ B)</td>
</tr>
<tr>
<td>Function Type</td>
<td>Function1[A, B]</td>
<td>蕴含(A ⇒ B)</td>
</tr>
</tbody>
</table>
<p>再根据以下的等价关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(A ⇒ False) ⇔ ¬A</div></pre></td></tr></table></figure></p>
<p>我们就可以写出Scala中对应的类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">A</span> =&gt; <span class="type">Nothing</span></div></pre></td></tr></table></figure></p>
<p>这样我们就可以定义两个类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬</span>[<span class="type">A</span>] </span>= <span class="type">A</span> =&gt; <span class="type">Nothing</span></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">∨</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= ¬[¬[<span class="type">T</span>] <span class="keyword">with</span> ¬[<span class="type">U</span>]]</div></pre></td></tr></table></figure></p>
<p>在REPL里测试一下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">¬</span>[<span class="type">A</span>] </span>= <span class="type">A</span> =&gt; <span class="type">Nothing</span></div><div class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">$u00AC</span></span></div><div class="line"></div><div class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">∨</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= ¬[¬[<span class="type">T</span>] <span class="keyword">with</span> ¬[<span class="type">U</span>]]</div><div class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">$u2228</span></span></div><div class="line"></div><div class="line">scala&gt; implicitly[<span class="type">Int</span> &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div><div class="line">&lt;console&gt;:<span class="number">13</span>: error: <span class="type">Cannot</span> prove that <span class="type">Int</span> &lt;:&lt; ∨[<span class="type">Int</span>,<span class="type">String</span>].</div><div class="line">       implicitly[<span class="type">Int</span> &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div></pre></td></tr></table></figure></p>
<p>嗯？哪里出问题了？我们来分析一下<code>(Int ∨ String)</code>这个类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; :k ∨[<span class="type">Int</span>, <span class="type">String</span>]</div><div class="line">scala.<span class="type">Function1</span><span class="symbol">'s</span> kind is <span class="type">F</span>[-<span class="type">A1</span>,+<span class="type">A2</span>]</div></pre></td></tr></table></figure></p>
<p>原来(Int ∨ String)的类型是函数类型，也就是说我们创造的Union Type是函数类型，那Int类型自然不是(Int ∨ String)的子类型了，因为它连函数类型都不是。我们需要将<code>&lt;:&lt;</code>操作符左边的类型转化成函数类型，比如双重否定类型（逻辑上相当于原类型，但其类型为函数类型）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬¬</span>[<span class="type">A</span>] </span>= ¬[¬[<span class="type">A</span>]]</div></pre></td></tr></table></figure>
<p>再测试一下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">¬¬</span>[<span class="type">A</span>] </span>= ¬[¬[<span class="type">A</span>]]</div><div class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">$u00AC$u00AC</span></span></div><div class="line"></div><div class="line">scala&gt; implicitly[¬¬[<span class="type">Int</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div><div class="line">res2: &lt;:&lt;[¬¬[<span class="type">Int</span>],∨[<span class="type">Int</span>,<span class="type">String</span>]] = &lt;function1&gt;</div><div class="line"></div><div class="line">scala&gt; implicitly[¬¬[<span class="type">String</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div><div class="line">res3: &lt;:&lt;[¬¬[<span class="type">String</span>],∨[<span class="type">Int</span>,<span class="type">String</span>]] = &lt;function1&gt;</div><div class="line"></div><div class="line">scala&gt; implicitly[¬¬[<span class="type">Double</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div><div class="line">&lt;console&gt;:<span class="number">14</span>: error: <span class="type">Cannot</span> prove that ¬¬[<span class="type">Double</span>] &lt;:&lt; ∨[<span class="type">Int</span>,<span class="type">String</span>].</div><div class="line">       implicitly[¬¬[<span class="type">Double</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>)]</div></pre></td></tr></table></figure>
<p>成功了！<code>¬¬[Int]</code>和<code>¬¬[String]</code>都是<code>∨[Int,String]</code>的子类型。把Int换成Double，无法通过编译。下面我们就可以利用隐式转换实现我们的size函数了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>[<span class="type">T</span>](t: <span class="type">T</span>)(<span class="keyword">implicit</span> ev: (¬¬[<span class="type">T</span>] &lt;:&lt; (<span class="type">Int</span> ∨ <span class="type">String</span>))) = t <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i</div><div class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.length</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试一下，结果very good～</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">scala&gt; size(<span class="number">24</span>)</div><div class="line">res5: <span class="type">Int</span> = <span class="number">24</span></div><div class="line"></div><div class="line">scala&gt; size(<span class="string">"Scala"</span>)</div><div class="line">res6: <span class="type">Int</span> = <span class="number">5</span></div><div class="line"></div><div class="line">scala&gt; size(<span class="number">6.666</span>)</div><div class="line">&lt;console&gt;:<span class="number">15</span>: error: <span class="type">Cannot</span> prove that ¬¬[<span class="type">Double</span>] &lt;:&lt; ∨[<span class="type">Int</span>,<span class="type">String</span>].</div><div class="line">       size(<span class="number">6.666</span>)</div><div class="line">           ^</div></pre></td></tr></table></figure>
<p>最后还可以用type lambda来简化函数的参数，省掉<code>implicit</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">|∨|</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= &#123; <span class="class"><span class="keyword">type</span> <span class="title">λ</span>[<span class="type">X</span>] </span>= ¬¬[<span class="type">X</span>] &lt;:&lt; (<span class="type">T</span> ∨ <span class="type">U</span>) &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>[<span class="type">T</span>: (<span class="type">Int</span> |∨| <span class="type">String</span>)#λ](t: <span class="type">T</span>) =</div><div class="line">  t <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i</div><div class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.length</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>所以我们union type及size函数的最终实现为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬</span>[<span class="type">A</span>] </span>= <span class="type">A</span> ⇒ <span class="type">Nothing</span></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">∨</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= ¬[¬[<span class="type">T</span>] <span class="keyword">with</span> ¬[<span class="type">U</span>]]</div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">¬¬</span>[<span class="type">A</span>] </span>= ¬[¬[<span class="type">A</span>]]</div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">|∨|</span>[<span class="type">T</span>, <span class="type">U</span>] </span>= &#123; <span class="class"><span class="keyword">type</span> <span class="title">λ</span>[<span class="type">X</span>] </span>= ¬¬[<span class="type">X</span>] &lt;:&lt; (<span class="type">T</span> ∨ <span class="type">U</span>) &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>[<span class="type">T</span> : (<span class="type">Int</span> |∨| <span class="type">String</span>)#λ](t : <span class="type">T</span>) = t <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> i : <span class="type">Int</span> ⇒ i</div><div class="line">    <span class="keyword">case</span> s : <span class="type">String</span> ⇒ s.length</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结一下，整个过程的本质都是在进行类型推导和证明，因此我们可以将Curry-Howard Isomorphism理解为<strong>类型证明即程序</strong>。</p>
<p>其实类型系统还有很多好玩的东西，比如<strong>dependent type</strong>。。后边可以用Scala玩玩~</p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/" target="_blank" rel="external">Unboxed union types in Scala via the Curry-Howard isomorphism, Miles Sabin</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scala | for-comprehension底层转换 | withFilter解析]]></title>
      <url>http://www.sczyh30.com/posts/Scala/scala-for-comprehensions-detail/</url>
      <content type="html"><![CDATA[<p>Scala中的for-comprehension是一种方便的语法糖，它实际上是几种操作<code>map</code>、<code>flatMap</code>和<code>filter</code>的组合。for-comprehension的EBNF表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Expr1          ::=  ‘for’ (‘(’ Enumerators ‘)’ | ‘&#123;’ Enumerators ‘&#125;’)</div><div class="line">                       &#123;nl&#125; [‘yield’] Expr</div><div class="line">Enumerators    ::=  Generator &#123;semi Generator&#125;</div><div class="line">Generator      ::=  Pattern1 ‘&lt;-’ Expr &#123;[semi] Guard | semi Pattern1 ‘=’ Expr&#125;</div><div class="line">Guard          ::=  ‘if’ PostfixExpr</div></pre></td></tr></table></figure>
<p>Scala中的for-comprehension与Haskell中的do-notation类似，都是对操作组合过程的简化，操作的对象都是Monad。这里就类比Haskell中的do-notation来总结Scala中的for-comprehension转换规则。</p>
<h1 id="First_step">First step</h1><p>第一步Scala会处理generator中的<strong>refutable pattern</strong>。所谓的refutable pattern就是模式匹配中可能失败的情况，而irrefutable pattern就是模式匹配中一定会匹配成功的情况（如variables）。对于每个可能匹配失败的generator <code>p &lt;- e</code>，Scala会将其转化为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p &lt;- e.withFilter &#123; <span class="keyword">case</span> p =&gt; <span class="literal">true</span>; <span class="keyword">case</span> _ =&gt; <span class="literal">false</span> &#125;</div></pre></td></tr></table></figure>
<p>比如<code>for (1 &lt;- List(1, 2)) &quot;ha&quot;</code>这段表达式的转化结果为:（直接在REPL里通过宏查看AST）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; reify( <span class="keyword">for</span> (<span class="number">1</span> &lt;- <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="string">"ha"</span> )</div><div class="line">res1: reflect.runtime.universe.<span class="type">Expr</span>[<span class="type">Unit</span>] =</div><div class="line"><span class="type">Expr</span>[<span class="type">Unit</span>](<span class="type">List</span>.apply(<span class="number">1</span>, <span class="number">2</span>).withFilter(((check$ifrefutable$<span class="number">1</span>) =&gt; check$ifrefutable$<span class="number">1</span>: <span class="meta">@unchecked</span> <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="literal">true</span></div><div class="line">  <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></div><div class="line">&#125;)).foreach(((x$<span class="number">1</span>) =&gt; x$<span class="number">1</span>: <span class="meta">@unchecked</span> <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"ha"</span></div><div class="line">&#125;)))</div></pre></td></tr></table></figure>
<h1 id="单个generator的for-comprehension">单个generator的for-comprehension</h1><p>只有一个generator的for-comprehension：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1)</div><div class="line">    <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>它会被转化为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1 map &#123;x =&gt; e2&#125;</div></pre></td></tr></table></figure>
<p>我们通过Quasiquotes获取AST来验证：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> e1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">e1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(x: <span class="type">Int</span>) = x * <span class="number">2</span></div><div class="line">f1: (x: <span class="type">Int</span>)<span class="type">Int</span></div><div class="line"></div><div class="line">scala&gt; <span class="string">q" for (x &lt;- e1) yield f1 _ "</span></div><div class="line">res2: reflect.runtime.universe.<span class="type">Tree</span> = e1.map(((x) =&gt; (f1: (() =&gt; &lt;empty&gt;))))</div></pre></td></tr></table></figure>
<p>在Haskell中原表达式等价于：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">do</span></div><div class="line">    x &lt;- e1</div><div class="line">    return e2</div></pre></td></tr></table></figure>
<p>转换为非do-notation：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">e1</span> &gt;&gt;=</div><div class="line">     \x -&gt; return e2</div></pre></td></tr></table></figure>
<p>根据Monad Laws - Right Unit转化：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(\x -&gt; e2) &lt;$&gt; e1</div></pre></td></tr></table></figure>
<h1 id="多个generator的for-comprehension">多个generator的for-comprehension</h1><p>多个generator其实就是<code>map</code>和<code>flatMap</code>(<code>fmap</code>和<code>&gt;&gt;=</code>)的组合，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1; y &lt;- e2)</div><div class="line">    <span class="keyword">yield</span> e3</div></pre></td></tr></table></figure>
<p>会转化为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1.flatMap(x =&gt; <span class="keyword">for</span> (y &lt;- e2) <span class="keyword">yield</span> e3)</div></pre></td></tr></table></figure>
<p>即</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">e1 flatMap &#123; x =&gt;</div><div class="line">    e2 map &#123; y =&gt; e3 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>REPL里验证：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">q"for(x &lt;- e1; y &lt;- e2) yield x + y"</span></div><div class="line">res3: reflect.runtime.universe.<span class="type">Tree</span> = e1.flatMap(((x) =&gt; e2.map(((y) =&gt; x.$plus(y)))))</div></pre></td></tr></table></figure>
<p>举例(Scala):<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> e1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> e2 = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> f1 = <span class="keyword">for</span>(x &lt;- e1; y &lt;- e2)</div><div class="line">  <span class="keyword">yield</span> x + y <span class="comment">// List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> f2 = e1 flatMap &#123; x =&gt;</div><div class="line">  e2 map &#123; y =&gt; x + y &#125;</div><div class="line">&#125; <span class="comment">// List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span></div></pre></td></tr></table></figure></p>
<p>在Haskell中原表达式等价于：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">do</span></div><div class="line">    x &lt;- e1</div><div class="line">    y &lt;- e2</div><div class="line">    return e3</div></pre></td></tr></table></figure>
<p>转换为非do-notation：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">e1</span> &gt;&gt;=</div><div class="line">     \x -&gt; e2 &gt;&gt;=</div><div class="line">         \y -&gt; return e3</div></pre></td></tr></table></figure>
<p>根据Monad Laws - Right Unit转化：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">e1</span> &gt;&gt;=</div><div class="line">    \x -&gt; fmap (\y -&gt; e3) e2</div></pre></td></tr></table></figure>
<p>举例(Haskell)：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- result: [5,6,7,6,7,8,7,8,9]</span></div><div class="line"><span class="title">f2</span> :: (<span class="type">Num</span> a) =&gt; [a]</div><div class="line"><span class="title">f2</span> = <span class="keyword">do</span></div><div class="line">    x &lt;- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">    y &lt;- [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">    return (x + y)</div><div class="line"></div><div class="line"><span class="title">f3</span> :: (<span class="type">Num</span> a) =&gt; [a]</div><div class="line"><span class="title">f3</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &gt;&gt;=</div><div class="line">     \x -&gt; [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] &gt;&gt;=</div><div class="line">          \y -&gt; return (x + y)</div><div class="line"></div><div class="line"><span class="title">f4</span> :: (<span class="type">Num</span> a) =&gt; [a]</div><div class="line"><span class="title">f4</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &gt;&gt;=</div><div class="line">     \x -&gt; fmap (\y -&gt; x + y) [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<h1 id="for-loop">for-loop</h1><p>Scala中，for表达式也有支持side effects的版本(for-loop)，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(x &lt;- e1; y &lt;- e2)</div><div class="line">    println(x * y)</div></pre></td></tr></table></figure>
<p>它的转化和含yield的差不多，只不过它用含副作用的<code>foreach</code>操作替代了<code>map</code>和<code>flatMap</code>算子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">e1 foreach &#123;</div><div class="line">    x =&gt; e2 foreach &#123;</div><div class="line">        y =&gt; println(x * y)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="含条件的for表达式">含条件的for表达式</h1><p>Scala支持含有条件判断(if guard)的for表达式，其中<code>if guard</code>对应<code>withFilter</code>算子。</p>
<p>转换规则：<code>p &lt;- e if g</code> 会转换为 <code>p &lt;- e.withFilter(p =&gt; g)</code>。</p>
<p>比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1 <span class="keyword">if</span> p)</div><div class="line">    <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>会转化为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1 withFilter &#123;x =&gt; p&#125;)</div><div class="line">    <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>即：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1 withFilter &#123;x =&gt; f&#125; map &#123;x =&gt; e2&#125;</div></pre></td></tr></table></figure>
<p>REPL里验证：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; reify( <span class="keyword">for</span>(x &lt;- e1 <span class="keyword">if</span> x &gt; <span class="number">2</span>) <span class="keyword">yield</span> f1 _ )</div><div class="line">res20: reflect.runtime.universe.<span class="type">Expr</span>[<span class="type">List</span>[<span class="type">Int</span> =&gt; <span class="type">Int</span>]] =</div><div class="line"><span class="type">Expr</span>[<span class="type">List</span>[<span class="type">Int</span> =&gt; <span class="type">Int</span>]]($read.e1.withFilter(((x) =&gt; x.$greater(<span class="number">2</span>))).map(((x) =&gt; &#123;</div><div class="line">  ((x) =&gt; $read.f1(x))</div><div class="line">&#125;))(<span class="type">List</span>.canBuildFrom))</div><div class="line"></div><div class="line">scala&gt; <span class="string">q" for(x &lt;- e1 if x &gt; 2) yield f1 _ "</span></div><div class="line">res21: reflect.runtime.universe.<span class="type">Tree</span> = e1.withFilter(((x) =&gt; x.$greater(<span class="number">2</span>))).map(((x) =&gt; (f1: (() =&gt; &lt;empty&gt;))))</div></pre></td></tr></table></figure>
<h1 id="含有value_definition的for表达式">含有value definition的for表达式</h1><p>这种情况下generator中含有value definition，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p &lt;- e</div><div class="line">p1 = e1</div></pre></td></tr></table></figure>
<p>这种转换要稍微啰嗦一点。对于 <code>p &lt;- e; p1 = e1</code> 这样的generator，Scala会将其转换为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(p, p1) &lt;- <span class="keyword">for</span> (x<span class="meta">@p</span>&lt;- e) <span class="keyword">yield</span> &#123;</div><div class="line">  <span class="keyword">val</span> x1<span class="meta">@p</span>1 = e1</div><div class="line">  (x, x1)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到展开的结果是多了一次for-comprehension，也就是多了一层<code>map</code>，这可能会带来一些效率问题。</p>
<p>在REPL里验证：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">"+"</span>, <span class="string">"1"</span>, <span class="string">"s"</span>)</div><div class="line">list: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(+, <span class="number">1</span>, s)</div><div class="line"></div><div class="line">scala&gt; reify ( <span class="keyword">for</span>(p &lt;- list; x = p; y = p) <span class="keyword">yield</span> y )</div><div class="line">res29: reflect.runtime.universe.<span class="type">Expr</span>[<span class="type">List</span>[<span class="type">String</span>]] =</div><div class="line"><span class="type">Expr</span>[<span class="type">List</span>[<span class="type">String</span>]]($read.list.map(((p) =&gt; &#123;</div><div class="line">  <span class="keyword">val</span> x = p;</div><div class="line">  <span class="keyword">val</span> y = p;</div><div class="line">  <span class="type">Tuple3</span>.apply(p, x, y)</div><div class="line">&#125;))(<span class="type">List</span>.canBuildFrom).map(((x$<span class="number">1</span>) =&gt; x$<span class="number">1</span>: <span class="meta">@unchecked</span> <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Tuple3</span>((p @ _), (x @ _), (y @ _)) =&gt; y</div><div class="line">&#125;))(<span class="type">List</span>.canBuildFrom))</div></pre></td></tr></table></figure>
<h1 id="withFilter">withFilter</h1><p>最后再来谈一下上面出现的<code>withFilter</code>函数，它于Scala 2.8引入，是<code>filter</code>的lazy版本。那么为什么要引入<code>withFilter</code>呢？为何不能直接用<code>filter</code>呢？我们先来看两段代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span></div><div class="line"><span class="keyword">for</span> (x &lt;- <span class="type">List</span>.range(<span class="number">1</span>, <span class="number">10</span>); <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; !found)</div><div class="line">  <span class="keyword">if</span> (x == <span class="number">5</span>) found = <span class="literal">true</span> <span class="keyword">else</span> println(x)</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span></div><div class="line"><span class="keyword">for</span> (x &lt;- <span class="type">Stream</span>.range(<span class="number">1</span>, <span class="number">10</span>); <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; !found)</div><div class="line">  <span class="keyword">if</span> (x == <span class="number">5</span>) found = <span class="literal">true</span> <span class="keyword">else</span> println(x)</div></pre></td></tr></table></figure>
<p>其中，<code>Stream</code>是<code>List</code>的lazy版本，只在需要的时候求值。按照上面总结的for-comprehension转换规则，我们可以将上面的代码转换为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span></div><div class="line"><span class="type">List</span>.range(<span class="number">1</span>,<span class="number">10</span>).f(_ % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; !found).foreach(x =&gt; <span class="keyword">if</span> (x == <span class="number">5</span>) found = <span class="literal">true</span> <span class="keyword">else</span> println(x))</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span></div><div class="line"><span class="type">Stream</span>.range(<span class="number">1</span>,<span class="number">10</span>).f(_ % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; !found).foreach(x =&gt; <span class="keyword">if</span> (x == <span class="number">5</span>) found = <span class="literal">true</span> <span class="keyword">else</span> println(x))</div></pre></td></tr></table></figure>
<p>这里我们暂时用<code>f</code>来代表某个filter函数。如果令<code>f = filter</code>的话，上面两段程序的运行结果分别是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// List</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Stream</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>可以看到<code>Stream</code>在对每个元素filter的时候，都会重新计算filter对应的<code>predicate</code>，所以上面的代码中<code>found</code>改变会对filter有影响；而<code>List</code>在filter元素的时候，对应的<code>predicate</code>是已经计算好的，不会再变更，因此<code>found</code>改变对filter没有影响。想必大家已经看出问题了，我们在使用for-comprehension的时候，总是希望if guard里的条件是按需求值的(on-demand)，而不是一开始就计算好的，因此把if guard转换成<code>filter</code>函数的话语义会有问题。所以，为了保持<code>filter</code>的语义不变，同时确保for-comprehension语义正确，Scala 2.8引入了<code>withFilter</code>函数作为<code>filter</code>的lazy实现，它的<code>predicate</code>是on-demand的。这样，for-comprehension中的guard就可以转换成<code>withFilter</code>函数，从而实现正确的语义。</p>
<p><code>withFilter</code>的实现也非常简单，既然需要on-demand evaluation，那么就把predicate函数保存下来，到需要的时候再调用。<code>withFilter</code>函数会生成一个<code>WithFilter</code>对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">withFilter</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">FilterMonadic</span>[<span class="type">A</span>, <span class="type">Repr</span>] = <span class="keyword">new</span> <span class="type">WithFilter</span>(p)</div><div class="line"></div><div class="line"><span class="comment">/** A class supporting filtered operations. Instances of this class are</span></div><div class="line"> *  returned by method `withFilter`.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithFilter</span>(<span class="params">p: <span class="type">A</span> =&gt; <span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">FilterMonadic</span>[<span class="type">A</span>, <span class="type">Repr</span>] </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>, <span class="type">That</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>)(<span class="keyword">implicit</span> bf: <span class="type">CanBuildFrom</span>[<span class="type">Repr</span>, <span class="type">B</span>, <span class="type">That</span>]): <span class="type">That</span> = &#123;</div><div class="line">    <span class="keyword">val</span> b = bf(repr)</div><div class="line">    <span class="keyword">for</span> (x &lt;- self)</div><div class="line">      <span class="keyword">if</span> (p(x)) b += f(x)</div><div class="line">    b.result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>, <span class="type">That</span>](f: <span class="type">A</span> =&gt; <span class="type">GenTraversableOnce</span>[<span class="type">B</span>])(<span class="keyword">implicit</span> bf: <span class="type">CanBuildFrom</span>[<span class="type">Repr</span>, <span class="type">B</span>, <span class="type">That</span>]): <span class="type">That</span> = &#123;</div><div class="line">    <span class="keyword">val</span> b = bf(repr)</div><div class="line">    <span class="keyword">for</span> (x &lt;- self)</div><div class="line">      <span class="keyword">if</span> (p(x)) b ++= f(x).seq</div><div class="line">    b.result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>](f: <span class="type">A</span> =&gt; <span class="type">U</span>): <span class="type">Unit</span> =</div><div class="line">    <span class="keyword">for</span> (x &lt;- self)</div><div class="line">      <span class="keyword">if</span> (p(x)) f(x)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withFilter</span></span>(q: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">WithFilter</span> =</div><div class="line">    <span class="keyword">new</span> <span class="type">WithFilter</span>(x =&gt; p(x) &amp;&amp; q(x))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>WithFilter</code>里只允许<code>map</code>, <code>flatMap</code>, <code>foreach</code>和<code>withFilter</code>这四种操作，其中<code>map</code>和<code>flatMap</code>会得到原来的集合类型。</p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>Scala Language Specification</em>, 6.19</li>
<li><a href="http://docs.scala-lang.org/tutorials/FAQ/yield" target="_blank" rel="external">How does yield work? - Scala Documentation</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快速排序实现及优化 | DualPivotQuicksort]]></title>
      <url>http://www.sczyh30.com/posts/Algorithm/algorithm-quicksort/</url>
      <content type="html"><![CDATA[<h1 id="快速排序的基本实现">快速排序的基本实现</h1><p>快速排序算法是一种基于交换的高效的排序算法，它采用了<strong>分治法</strong>的思想：</p>
<ol>
<li>从数列中取出一个数作为基准数（枢轴，pivot）。</li>
<li>将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。</li>
<li>再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。</li>
</ol>
<p>快排最重要的一步就是划分了。划分的过程用通俗的语言讲就是“挖坑”和“填坑”。</p>
<p>举个例子，首先给一组数组：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>36</td>
<td>9</td>
<td>-7</td>
<td>45</td>
<td>23</td>
<td>61</td>
<td>15</td>
</tr>
</tbody>
</table>
<p>为了方便起见，我们选择第一个元素36作为基准数，这样就腾出了第一个位置（挖坑），下面首先自右向左寻找比基准数小的元素填至第一个位置（填坑）：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>9</td>
<td>-7</td>
<td>45</td>
<td>23</td>
<td>61</td>
<td></td>
<td>36</td>
</tr>
</tbody>
</table>
<p>第七个位置被腾出，然后再自左向右寻找比基准元素大的元素填在空位处：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>9</td>
<td>-7</td>
<td></td>
<td>23</td>
<td>61</td>
<td>45</td>
<td>36</td>
</tr>
</tbody>
</table>
<p>再重复上面的动作，直到第一趟划分完毕。此时[a0,a3]都是小于基准值a4的，[a5,a6]都是大于基准值a4的：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>pivot</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>9</td>
<td>-7</td>
<td>23</td>
<td>36</td>
<td>61</td>
<td>45</td>
<td>36</td>
</tr>
</tbody>
</table>
<p>然后再对两个子序列递归地进行上述的过程，最终可得到有序序列。</p>
<p>总结一下这个划分的过程：</p>
<ol>
<li>设两个指示i=left，j=right；设arr[left]为基准数</li>
<li>从后向前寻找比基准元素大的元素，填至空位处</li>
<li>从前向后寻找比基准元素小的元素，填至空位处</li>
<li>重复执行2、3步，直到两指示相等，将基准元素填至指示的位置，本次划分结束</li>
</ol>
<p>用代码表示为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = left, j = right;</div><div class="line">    <span class="keyword">int</span> tmp = arr[left];</div><div class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; tmp)</div><div class="line">            j--;</div><div class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</div><div class="line">            arr[i] = arr[j];</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; tmp)</div><div class="line">            i++;</div><div class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</div><div class="line">            arr[j] = arr[i];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    arr[i] = tmp;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(left &gt; right)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> j = partition(arr, left, right);</div><div class="line">    quick_sort(arr, left, j - <span class="number">1</span>);</div><div class="line">    quick_sort(arr, j + <span class="number">1</span>, right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然用Haskell写是最简单的了:)</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">qs</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</div><div class="line"><span class="title">qs</span> [] = []</div><div class="line"><span class="title">qs</span> (x:xs) =</div><div class="line">    <span class="keyword">let</span> s = qs $ filter (&lt;= x) xs</div><div class="line">        l = qs $ filter (&gt; x)  xs</div><div class="line">    <span class="keyword">in</span> s ++ [x] ++ l</div></pre></td></tr></table></figure>
<p>另一种实现划分的思路是先从左到右扫描一个比基准数大的元素，再从右到左扫描一个比基准数小的元素（左右两个指针i、j滑动），然后交换这两个元素，重复操作直到两指针相遇，然后将基准元素arr[left]与左子序列最后的元素arr[j]进行交换即可，用代码描述为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = left, j = right + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> temp = arr[left];</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (arr[i] &lt; temp &amp;&amp; i &lt; right) &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (arr[j] &gt; temp &amp;&amp; j &lt; left) &#123;</div><div class="line">            j++</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &gt;= j)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        swap(arr[i], arr[j]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    swap(arr[left], arr[j]);</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>快速排序算法的平均时间复杂度为 $O(NlogN)$。快排的最差情况为序列完全有序，此时快排退化为冒泡排序，时间复杂度为 $O(n^2)$ 。</p>
<h1 id="快速排序的改进和优化">快速排序的改进和优化</h1><p>快速排序也有不足之处，比如<strong>对于元素较少或接近有序的数组来说，快速排序平均性能比插入排序差</strong>。这是因为小数组信息熵相对来说比较小（特别是经过一系列的快速排序调用以后），而插入排序在数据接近有序的情况下时间复杂度接近 $O(N)$，再加上快速排序递归调用也会有一些性能损耗。因此，针对小数组，我们可以加个判断，<strong>对小数组使用插入排序</strong>。Java标准库自带的排序<code>DualPivotQuicksort</code>就是这么干的，<code>INSERTION_SORT_THRESHOLD</code> = 47。</p>
<p>另外一个改进快速排序性能的方法就是使用<strong>双枢轴</strong>，即将数组三切分(大于枢轴，等于枢轴，小于枢轴），可以证明这样是熵最优的并且更高效。为什么这样划分呢？因为统计表明对大规模数组进行排序时，数据重复的情况比较多，因此使用双枢轴可以有效避免相等元素之间的比较。以Java标准库为例，JDK 1.8中的<code>DualPivotQuicksort</code>实现了一种 <strong>快速三向切分</strong> 的快速排序，它通过将相等元素聚集起来的方式使熵最优（原理：<strong>将相等元素聚集起来</strong>，不必再切分这些元素）。</p>
<p><img src="http://img.blog.csdn.net/20160220202246946" alt="快速三向切分"></p>
<p>还有一个优化的杀手锏就是 <strong>改进划分的策略</strong>，这里<code>DualPivotQuicksort</code>使用了一种称为 <strong>五取样划分</strong> 的策略对数组进行划分，类似于<a href="https://en.wikipedia.org/wiki/Median_of_medians" target="_blank" rel="external">BFPRT算法</a>。</p>
<p>总结一下，快排的改进主要有三种方法：小数组使用插入排序、双枢轴（快速三向切分）、划分策略优化（五取样划分）。经过优化后的快速排序算法时间复杂度可以介于 $O(N)$ 到 $O(NlogN)$ 之间，性能更优。具体实现可以看<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/e2117e30fb39/src/share/classes/java/util/DualPivotQuicksort.java" target="_blank" rel="external">DualPivotQuicksort的源码</a>，实现的很复杂，非常奇妙。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[POSIX I/O模型之阻塞、非阻塞、同步、异步浅析]]></title>
      <url>http://www.sczyh30.com/posts/Network/network-io-model/</url>
      <content type="html"><![CDATA[<p>服务端编程常需要接触I/O。最近对I/O模型有了进一步的认识，这里就总结一下POSIX I/O模型，并简略总结一下Java中的Network I/O模型。常见的POSIX I/O模型有四种：</p>
<ul>
<li>同步阻塞I/O（Synchrohous, blocking I/O）</li>
<li>同步非阻塞I/O（Synchrohous, non-blocking I/O）</li>
<li>I/O多路复用（I/O Multiplexing），较为典型的有<code>select</code>和<code>epoll</code>模型</li>
<li>异步I/O（Asynchronous I/O）</li>
</ul>
<h1 id="通俗解释">通俗解释</h1><p>在详细解释各个I/O模型之前，我们先来通俗地解释一下各个I/O模型，便于理解。</p>
<ul>
<li>同步阻塞I/O：去餐厅吃饭，等餐的时候需要在取餐处一直等着，不能干其他事情。</li>
<li>同步非阻塞I/O：去餐厅吃饭，等餐的时候可以干别的事，但需要不断去窗口询问饭是否准备好了（轮询）。</li>
<li>异步I/O：去餐厅吃饭，等餐的时候只需要坐着等人送来即可。</li>
</ul>
<p>下面我们来详细解释一下各个I/O模型，为了简单起见这里采用UDP协议作为示例。</p>
<h1 id="Blocking_I/O">Blocking I/O</h1><p>首先对于一个从socket读取数据的操作，通常将其分为两个阶段：</p>
<ol>
<li>等待远程数据就绪。网卡会将数据报文传给协议栈，封装处理之后拷贝到内核缓冲区中</li>
<li>将数据从内核缓冲区拷贝到进程中</li>
</ol>
<p>最简单的模型就是blocking I/O模型了。进行<code>recvfrom</code>系统调用（读取数据）以后，调用者进程会被阻塞，直到内核接收到数据并拷贝到进程中才返回。进行<code>recvfrom</code>系统调用后，内核首先会等待数据就绪，这通常需要一段时间。当数据就绪并到达内核缓冲区后，内核就会将数据拷贝至用户内存空间，并且返回结果，此时调用者进程才会解除阻塞状态，恢复执行。Blocking I/O不会浪费CPU时间片，但是只能处理一个连接，对于多个连接的情况就需要用到下面要提到的的I/O多路复用了。</p>
<p>可以看出，blocking I/O会阻塞上面两个阶段：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-blocking-io.png" alt="Synchrohous, blocking IO"></p>
<h1 id="Non-blocking_I/O">Non-blocking I/O</h1><p>与blocking I/O不同，non-blocking I/O的意思是在读取数据(<code>recvfrom</code>)时，如果数据没有就绪则立刻返回一个错误，而不会被阻塞住，这样我们还可以继续进行其它的操作。为了读取到数据，我们需要不断调用<code>recvfrom</code>进行轮询操作，一旦数据准备好了，内核就会将数据拷贝至用户内存空间，并且返回读取成功的结果。这种模型的弊端就是轮询操作会占用时间片，浪费CPU资源。可以看出，non-blocking I/O会阻塞上面的阶段(2)：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-non-blocking-io.png" alt="Non-blocking IO"></p>
<h1 id="I/O_multiplexing">I/O multiplexing</h1><p>I/O多路复用(multiplexing)是网络编程中最常用的模型，像我们最常用的<code>select</code>、<code>epoll</code>都属于这种模型。以<code>select</code>为例：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-io-multiplexing.png" alt="IO Multiplexing"></p>
<p>看起来它与blocking I/O很相似，两个阶段都阻塞。但它与blocking I/O的一个重要区别就是它可以等待多个文件描述符就绪，即可以处理多个连接。这里的<code>select</code>相当于一个“代理”，调用<code>select</code>以后进程会被<code>select</code>阻塞，这时候在内核空间内<code>select</code>会监听指定的的多个文件描述符(如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于<code>select</code>可以监听多个socket，我们可以用它来处理多个连接。</p>
<p>在<code>select</code>模型中每个socket一般都设置成non-blocking，虽然阶段(1)仍然是阻塞状态，但是它是被<code>select</code>调用阻塞的，而不是直接被I/O阻塞的。<code>select</code>底层通过轮询机制来判断每个socket读写是否就绪。</p>
<p>当然<code>select</code>也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了<code>epoll</code>作为<code>select</code>的改进版本，具体的区别和改进后面会另开一篇总结。</p>
<h1 id="Asynchronous_I/O">Asynchronous I/O</h1><p>Asynchronous I/O的过程：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-asynchronous-io.png" alt="Asynchronous IO"></p>
<p>这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(<code>aio_read</code>)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p>
<p>异步I/O在网络编程中几乎用不到，在File I/O中可能会用到。</p>
<h1 id="Java中的Network_I/O模型">Java中的Network I/O模型</h1><p>Java原生的Network I/O模型分为以下几种：</p>
<ul>
<li>BIO(如<code>ServerSocket</code>)</li>
<li>NIO(JDK 1.4引入，如<code>ServerSocketChannel</code>)</li>
<li>NIO.2(AIO, JDK 1.7引入，如<code>AsynchronousServerSocketChannel</code>)</li>
</ul>
<p>其中BIO对应传统的同步阻塞I/O，而NIO对应I/O多路复用(<code>select</code>模型，Reactor模式)，NIO.2则对应异步IO模型（依然是基于I/O多路复用，和POSIX的asynchronous I/O模型不同）。在Linux下，NIO和NIO.2底层都是通过<code>epoll</code>实现的。</p>
<p>Netty的I/O模型也类似，分为OIO和NIO两种。</p>
<h1 id="总结">总结</h1><p>我们来总结一下阻塞、非阻塞，同步和异步这两组概念。</p>
<p>先来说阻塞和非阻塞。阻塞调用会一直等待远程数据就绪再返回，即上面的阶段(1)会阻塞调用者，直到读取结束。而非阻塞无论在什么情况下都会立即返回。</p>
<p>接下来是同步和异步。POSIX标准里是这样定义同步和异步的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked.</li>
</ul>
<p>同步方法会一直阻塞进程，直到I/O操作结束，注意这里相当于上面的(1)(2)两个阶段都会阻塞调用者。而异步方法不会阻塞调用者进程，即使是从内核空间的缓冲区将数据拷贝到进程中这一操作也不会阻塞进程，拷贝完毕后内核会通知进程数据拷贝结束。</p>
<p>下面的这张图很好地总结了之前讲的这几种POSIX I/O模型（来自<em>Unix Network Programming</em>）：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/io-modelposix-io-model-comparison.png" alt="IO模型比较"></p>
<hr>
<h1 id="References">References</h1><ul>
<li><em>UNIX Network Programming (3rd edition), Volume 1</em></li>
<li><a href="https://segmentfault.com/a/1190000003063859?_ea=292572" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP 相关知识总结目录]]></title>
      <url>http://www.sczyh30.com/posts/Network/tcp-series/</url>
      <content type="html"><![CDATA[<p>寒假翻了翻 TCP/IP Illustrated, Volume 1 的第二版，将里面的一些新知识与上个暑假总结的第一版的相关知识结合起来，针对TCP部分重新做了个总结~目前已经大体总结完毕，这里列个目录方便查阅：</p>
<ul>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-connection/">TCP连接的建立和终止</a></li>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-retransmission/">TCP 超时与重传机制</a></li>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-flow-control/">TCP 流量控制 &amp;&amp; 滑动窗口机制</a></li>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-congestion-control/">TCP 拥塞控制</a></li>
<li><a href="http://www.sczyh30.com/posts/Network/tcp-keepalive-heartbeat/">TCP Keepalive机制 &amp;&amp; 心跳检测</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP Keepalive && Heartbeat]]></title>
      <url>http://www.sczyh30.com/posts/Network/tcp-keepalive-heartbeat/</url>
      <content type="html"><![CDATA[<p>在默认情况下，在建立TCP连接之后，空闲时刻客户端和服务端不会互相发送数据包确认连接。假如有一端发生异常而掉线（如死机、防火墙拦截包、服务器爆炸），另一端若不进行连接确认，则会一直消耗资源。</p>
<p>为了保证连接的有效性，可以检测到对方端非正常的断开，我们通常利用两种机制来实现：</p>
<ul>
<li>利用TCP协议的Keepalive</li>
<li>在应用层实现心跳检测(Heart Beat)</li>
</ul>
<h1 id="TCP_Keepalive">TCP Keepalive</h1><p>TCP Keepalive通过定时发送Keepalive探测包来探测连接的对端是否存活。</p>
<p>交互过程：</p>
<p>在收到对端的确认报文后，设置keepalive timer。当长时间两端无交互并且保活定时器超时的时候，本段会发送keepalive probe等待对端确认。若对端在一定时间内确认（具体的规则貌似比较繁琐），keepalive timer重置；否则，长时间未响应，连接终止。</p>
<p>TCP Keepalive默认是关闭的，因为它会消耗额外的资源，并且可能会关闭正常的连接。（它也非TCP标准，详情可见The Host Requirements RFC [RFC1122]）</p>
<p>在Linux Kernal中可以调整以下几个数值来设置Keepalive的属性：</p>
<table>
<thead>
<tr>
<th>sysctl variables</th>
<th>net.ipv4.tcp_keepalive_time</th>
<th>net.ipv4.tcp_keepalive_intvl</th>
<th>net.ipv4.tcp_keepalive_probes</th>
</tr>
</thead>
<tbody>
<tr>
<td>default</td>
<td>7200s</td>
<td>75s</td>
<td>9</td>
</tr>
</tbody>
</table>
<h1 id="Heart_Beat">Heart Beat</h1><p>很多应用层协议都有心跳检测机制，客户端每隔一段时间就会向服务端发送一个数据包，通知服务端自己<strong>可以正常工作</strong>，同时传递一些数据。</p>
<p>两种方式的特点：</p>
<ul>
<li>TCP Keepalive是TCP协议自带的实现，使用简单，其发送的数据包与应用层心跳检测包相比更小，但其功能也简单，仅提供检测连接功能</li>
<li>应用层心跳包不依赖于传输层协议，无论传输层协议是TCP还是UDP都可以用</li>
<li>应用层心跳包可以定制，可以应对更复杂的情况或传输一些额外信息</li>
<li>Keepalive仅代表连接保持着，而心跳包往往还代表客户端可正常工作</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP 拥塞控制]]></title>
      <url>http://www.sczyh30.com/posts/Network/tcp-congestion-control/</url>
      <content type="html"><![CDATA[<p>TCP拥塞控制这一块东西比较多~这里只总结重要的。</p>
<p>TCP的拥塞控制主要依赖于 <strong>拥塞窗口</strong>(congestion window, cwnd) 和 <strong>慢启动阈值</strong>(slow start threshold, ssthresh)。<code>cwnd</code>是发送端根据网络的拥塞程度所预设的一个窗口大小，而<code>ssthresh</code>则是慢启动窗口的阈值，<code>cwnd</code>超过此阈值则转变控制策略。</p>
<p>TCP拥塞控制的主要算法有 <strong>慢启动</strong>(Slow Start)、<strong>拥塞避免</strong>(Congestion Avoidance)、<strong>快速重传</strong>(Fast Retransmit)、<strong>快速恢复</strong>(Fast Recovery)等。</p>
<h2 id="Slow_Start">Slow Start</h2><p>如果TCP连接一建立就向服务器大量发包，很容易导致拥塞。因此，新建立的连接不能一开始就大量发送数据包，而是应该根据网络状况，逐步地增加每次发送数据包的量，这就是慢启动。慢启动通常在新建立TCP连接或由于RTO而丢包时执行。</p>
<p>具体来说，新建TCP连接时，cwnd需初始化为一个或几个最大发送报文段大小(send maximum segment size, SMSS)。具体规则（IW为初始窗口大小）：</p>
<blockquote>
<p>IW = 1*(SMSS) (if SMSS &lt;= 2190 bytes)</p>
<p>IW = 2*(SMSS) and not more than 2 segments (if SMSS &gt; 2190 bytes)</p>
<p>IW = 3*(SMSS) and not more than 3 segments (if 2190 ≥ SMSS &gt; 1095 bytes)</p>
<p>IW = 4*(SMSS) and not more than 4 segments (otherwise)</p>
</blockquote>
<p>发送端按照cwnd大小发送数据，每当数据被确认时，cwnd就以2为倍数进行指数级增长，即 $cwnd<em>{n}=2*cwnd</em>{n-1}$</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">开始 ---&gt; cwnd = 1*SMSS  </div><div class="line"></div><div class="line">经过一个RTT ---&gt; cwnd = 2*SMSS  </div><div class="line"></div><div class="line">经过两个RTT ---&gt; cwnd = 2^2=4*SMSS  </div><div class="line"></div><div class="line">经过三个RTT ---&gt; cwnd = 2^3=8*SMSS</div></pre></td></tr></table></figure>
<p>如果带宽为W，那么经过 $RTT log_{2}W$ 时间就可以占满带宽。</p>
<p>显然，慢启动并不慢，cwnd会飞速增长。但是cwnd不能无限制地进行指数增长。当cwnd值超过慢启动阈值(ssthresh)时，慢启动过程结束，进入拥塞避免阶段。拥塞避免算法将在下面总结。</p>
<h2 id="Congestion_Avoidance">Congestion Avoidance</h2><p>当cwnd值超过ssthresh值时，慢启动过程结束，进入拥塞避免阶段。在拥塞避免阶段，cwnd将不再呈指数增长，而是呈线性增长。一般来说：</p>
<ul>
<li>收到一个ACK时，cwnd = cwnd + 1/cwnd</li>
<li>当每过一个RTT时，cwnd = cwnd + 1</li>
</ul>
<p>这样放缓了拥塞窗口的增长速率，避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p>
<h2 id="拥塞状态">拥塞状态</h2><p>在慢启动阶段与拥塞避免阶段，只要判断发送方出现丢包，就会进行相应的控制。有两种情况：</p>
<p><strong>（1)</strong> 等待RTO超时，重传数据包，此时TCP反应强烈：</p>
<ol>
<li>将ssthresh降低为此时cwnd的一半</li>
<li>将cwnd重新设为初始值(IW)</li>
<li>重新进入慢启动阶段</li>
</ol>
<p>原则：加法增大、乘法减小。</p>
<p><strong>（2)</strong> 连续收到3个duplicate ACK时，重传数据包，无须等待RTO。此情况即为下面的快速重传。</p>
<h2 id="Fast_Retransmit">Fast Retransmit</h2><p>TCP在收到一个乱序的报文段时，会立即发送一个重复的ACK，并且此ACK不可被延迟。</p>
<p>如果连续收到3个或3个以上重复的ACK，TCP会判定此报文段丢失，需要重新传递，而无需等待RTO。这就叫做快速重传。</p>
<p><em>注：快速重传始于BSD 4.3 Tahoe，但Tahoe的TCP实现没有包含快速恢复阶段，快速重传后会退回至慢启动阶段。</em></p>
<h2 id="Fast_Recovery">Fast Recovery</h2><p>快速恢复是指快速重传后直接进入拥塞避免阶段而非慢启动阶段。总结一下快速恢复的步骤（以SMSS为单位）：</p>
<ol>
<li>​当收到3个重复的ACK时，将ssthresh设置为cwnd的一半(ssthresh = cwnd/2)，然后将cwnd的值设为ssthresh加3(cwnd = ssthresh + 3)，然后快速重传丢失的报文段</li>
<li>每次收到重复的ACK时，cwnd增加1(cwnd += 1)，并发送1个packet(如果允许的话)</li>
<li>当收到新的ACK时，将cwnd设置为第一步中ssthresh的值(cwnd = ssthresh)，代表恢复过程结束</li>
</ol>
<p>快速恢复后将进入拥塞避免阶段。</p>
<p><em>注：快速恢复始于BSD 4.3 Reno。</em></p>
<h2 id="NewReno">NewReno</h2><p>快速恢复存在的一个问题是它只能针对一个packet重传而不能针对多个packet，这样会RTO到吐。因此后来标准提出了NewReno作为Reno的补充。NewReno可以解决一个窗口内多个packet丢失的情况（Partial ACK），即NewReno算法需要处理完该窗口内所有packet的ACK后方可结束恢复状态。这是一种激进的优化，适合不支持SACK的情况。（通过recovery变量实现）</p>
<h2 id="SACK">SACK</h2><p>SACK维持一个名为pipe的变量，代表流量的估计值。发包的时间由pipe决定。具体细节可见 <a href="https://tools.ietf.org/html/rfc2018" target="_blank" rel="external">RFC 2018</a>。</p>
<p>SACK可能会出现pipe计算不精确的情况，这样会使算法退化回Tahoe。Forward Acknowledgment (FACK)是对SACK的改进，它可以精确地计算pipe值。</p>
<h2 id="其它">其它</h2><p>更多的拥塞控制算法见<a href="http://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm" target="_blank" rel="external">TCP Congestion Avoidance Algorithm</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP 流量控制]]></title>
      <url>http://www.sczyh30.com/posts/Network/tcp-flow-control/</url>
      <content type="html"><![CDATA[<p>TCP 流量控制通过滑动窗口机制实现。</p>
<p><em>TODO: 待详细总结。。。</em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP Retransmission]]></title>
      <url>http://www.sczyh30.com/posts/Network/tcp-retransmission/</url>
      <content type="html"><![CDATA[<p>TCP协议需保证所有的数据包都可以到达，因此必须要有重传机制。</p>
<ul>
<li>RTT: Round Trip Time</li>
<li>RTO: Retransmission Timeout（重传超时时间）</li>
</ul>
<h1 id="RTO_Algorithm">RTO Algorithm</h1><p>如何计算RTO：</p>
<ul>
<li>经典算法</li>
<li>Karn’s Algorithm</li>
<li>标准算法(Jacobson/Karels Algorithm, 目前Linux内核在用)</li>
</ul>
<p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。</p>
<h1 id="重传机制">重传机制</h1><h2 id="超时重传">超时重传</h2><p>通过重传计时器(retransmission timer)实现。</p>
<h2 id="快速重传">快速重传</h2><p>TCP在收到一个乱序的报文段时，会立即发送一个重复的ACK，并且此ACK不可被延迟。</p>
<p>如果连续收到3个或3个以上重复的ACK，TCP会判定此报文段丢失，需要重新传递，而无需等待RTO。这就叫做快速重传。</p>
<h2 id="SACK_&amp;&amp;_Duplicate_SACK">SACK &amp;&amp; Duplicate SACK</h2><p>Selective Acknowledgment (SACK)是 TCP 的一项可选特性，可以提高某些网络中所有可用带宽的使用效率。普通 TCP（即未提供 SACK 特性）应答是严格累积的 — 对 N 的应答意味着字节 N 和所有之前的字节都已经收到。SACK 要解决的问题普通累积式应答的 “全有或全无” 性质。</p>
<p>例如，即使包 2（假设从 0 到 9 的序列）是在传送过程中惟一丢失的包，接收方也只能对包 1 发出一个普通的 ACK，因为这是连续接收到的包中的最后一个。另一方面，SACK 接收方可以发出包 1 的 ACK 和包 3 到包 9 的 SACK 选项。这样，发送端就可以根据回传的SACK来知道哪些数据到了，哪些数据丢失了，进而可以优化Fast Retransmit。SACK需要两端的协议都支持，在目前的Linux Kernal中默认为开启状态。</p>
<h1 id="low-rate_DoS_attacks">low-rate DoS attacks</h1><p>应用层应用：Slowloris (HTTP slow headers)</p>
<p>防范：随机化RTO</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络相关知识总结]]></title>
      <url>http://www.sczyh30.com/posts/Network/network-basis/</url>
      <content type="html"><![CDATA[<p>本文将不断更新~</p>
<h1 id="网络模型">网络模型</h1><p><strong>OSI七层模型</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p>数据链路层对应的数据为Frame，网络层对应的数据为Packet，传输层对应的数据为Segment。</p>
<p>网络数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/osi-seven-layer.png" alt="The standard seven-layer OSI model"></p>
<p><strong>TCP/IP四层模型</strong>：链路层、网络层(IP/ICMP/IGMP)、传输层(TCP/UDP)、应用层(如Telnet/HTTP/FTP)</p>
<h1 id="IPv4_and_IPv6_Headers">IPv4 and IPv6 Headers</h1><p>IPv4 Datagram分为首部(Header)和数据两部分。IPv4 Header由固定部分(Basic)和选项部分(Options)组成，其中固定部分的大小为20 bytes。IPv4 Header最大为60 bytes。</p>
<p>总结几个重要的field:</p>
<ul>
<li>ToS(Type of Service)：DS Field(Differentiated Services Field) + ECN(Explicit Congestion Notification, 显式拥塞通知)</li>
<li>TTL(Time-to-Live)：数据报可以经过的最多路由数，指示了数据报的生存时间</li>
</ul>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/ipv4-header.png" alt="The IPv4 Datagram"></p>
<p>与IPv4 Header不同，IPv6 Header具有固定的大小(40 bytes)，并且没有选项部分。但是IPv6 Header可以有扩展首部(extension headers)，其作用与Options类似。Next Header字段用于指示extension headers。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/ipv6-header.png" alt="The IPv6 Header"></p>
<h1 id="大端、小端与网络字节序">大端、小端与网络字节序</h1><p>大小端是面向多字节定义的字节存储顺序。</p>
<p>大端（Big-Endian）就是最高有效字节（MSB）在前，内存存储体现上，数据的高位更加靠近低地址。</p>
<p>小端(Little-Endian)就是最低有效字节（LSB）在前，内存存储体现上，数据的低位更加靠近低地址。</p>
<p>比如对字<code>0x01234567</code>，最高有效字节为0x01，最低有效字节为0x67，那么其对应的大端存储顺序为<code>01 23 45 67</code>，小端存储顺序为<code>67 45 23 01</code>。</p>
<p>对于IP数据报来说，RFC标准要求数据在网络中传输时都要求以大端字节序传输，因此网络字节序就对应Big-Endian字节序。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP连接的建立和终止]]></title>
      <url>http://www.sczyh30.com/posts/Network/tcp-connection/</url>
      <content type="html"><![CDATA[<p>这篇文章将总结TCP首部及连接的相关知识。</p>
<p>TCP(Transmission Control Protocol)提供一种<strong>面向连接的、可靠的字节流服务</strong>。TCP连接是<strong>全双工</strong>的，即数据在两个方向上能够同时传递。</p>
<h1 id="TCP_Header">TCP Header</h1><p>TCP报文由首部和数据组成，数据部分是可选的。TCP报文被封装在IP数据报中，结构如下图所示：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/tcp-segment.PNG" alt="IP Datagram"></p>
<p>TCP Header由固定部分(Basic)和选项部分(Options)组成，其中固定部分的大小为20 bytes。TCP Header最大为60 bytes。</p>
<p>TCP Header的结构如下图所示：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/tcp-header.PNG" alt="TCP Header"></p>
<p>挑几个重要的说：</p>
<ul>
<li>Sequence Number(序号，Seq)：用来标识从TCP发送端到接收端发送的数据字节流，它表示这个报文段中的第一个数据字节，也用于解决packet乱序问题</li>
<li>Acknowledgment Number(确认序号)：包含发送确认的一端所期望收到的下一个序列号</li>
<li>CWR：阻塞窗口减小(Congestion Window Reduced)，通常是发送端减小了其发包速率</li>
<li>ECE：ECN Echo</li>
<li>URG：紧急指针(Urgent Pointer)有效</li>
<li>PSH：该标志置位时，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理</li>
<li>ACK：确认序号(Acknowledgment Number)有效</li>
<li>RST：重置连接（通常由于连接错误）</li>
<li>SYN：同步序号(Sequence Number)，用来发起一个连接</li>
<li>FIN：发送端完成发送任务</li>
<li>Window Size：滑动窗口大小，用于流量控制</li>
</ul>
<h1 id="TCP连接的建立和终止">TCP连接的建立和终止</h1><h2 id="三次握手">三次握手</h2><p>TCP three-way handshake（三次握手）的过程：</p>
<ol>
<li>第一次握手(SYN)：客户端首先发送一个SYN包到服务器，初始序号Seq=ISN(client)=a。客户端进入<strong>SYN_SENT</strong>状态。</li>
<li>第二次握手(SYN + ACK)：服务端收到客户端发来的SYN包后，需要确认客户端的SYN包，将确认序号ACK设为客户端的ISN加1(ACK=a+1)作为确认，同时发回包含服务器的初始序号Seq=ISN(server)=b，即SYN+ACK包。服务端进入<strong>SYN_RECV</strong>状态。</li>
<li>第三次握手(ACK)：客户端收到服务端发来的SYN+ACK包后，将确认序号设为服务端的ISN加1作为确认，向服务端发送确认包(ACK=b+1)。此包发送完毕，客户端与服务端进入<strong>ESTABLISHED</strong>状态，完成三次握手，建立连接。</li>
</ol>
<p>【思考】为什么需要三次握手而不是两次握手？</p>
<h2 id="四次挥手">四次挥手</h2><p>由于TCP连接是全双工的，因此每个方向的连接必须单独地进行关闭，于是TCP连接的断开需要进行“四次挥手”（两端分别进行FIN+ACK和ACK两次挥手）。</p>
<p>TCP连接断开的过程：</p>
<ol>
<li>客户端发起请求，向服务端发送一个FIN(Seq=c, ACK=d)，用来关闭从客户端到服务端的传输。客户端的状态变为FIN_WAIT_1。此时客户端仍然可以接收数据。如果这之前发出的数据中存在没有ACK的，客户端仍然会重发这些数据。</li>
<li>服务端收到客户端的FIN包，然后向客户端发回一个ACK包(ACK=c+1)作为确认。</li>
<li>同时，服务端向客户端发送一个FIN(Seq=d, ACK=c+1)，用来关闭从服务端到客户端的传输。服务端的状态变为LAST_ACK。</li>
<li>客户端收到服务端的FIN包，然后向服务端发回一个ACK包(ACK=d+1)作为确认。四次挥手结束，连接断开(CLOSED)。</li>
</ol>
<p>注意：<strong>TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSED状态</strong>，原因：</p>
<ul>
<li>TIME_WAIT确保有足够的时间让对端收到了ACK（如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL）</li>
<li>有足够的时间让这个连接不会跟后面的连接混在一起（部分路由器会缓存数据包导致连接重用）</li>
</ul>
<h2 id="总结">总结</h2><p>用下面两幅图总结TCP连接的建立与终止：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/tcp-connection-overview.PNG" alt=""></p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/tcp-state.PNG" alt=""></p>
<p>最后来一张TCP状态转换图，可以很好地概括整个TCP连接的建立和终止的过程及状态的变化。图来自 <em>TCP/IP Illustrated, Volume 1 : The Protocols(2nd Edition)</em> 。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/tcp-finite-state-machine.png" alt="The TCP state transition diagram"></p>
<hr>
<h1 id="Reference">Reference</h1><ul>
<li><em>TCP/IP Illustrated, Volume 1 : The Protocols(2nd Edition), Kevin.R.Fall</em></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入探究JVM | klass-oop对象模型研究]]></title>
      <url>http://www.sczyh30.com/posts/Java/jvm-klass-oop/</url>
      <content type="html"><![CDATA[<p>最近对JVM兴趣大增（其实是想回归C艹的怀抱了）~</p>
<p>当我们在写Java代码的时候，我们会面对着无数个接口，类，对象和方法。但我们有木有想过，Java中的这些对象、类和方法，在HotSpot JVM中的结构又是怎么样呢？HotSpot JVM底层都是C++实现的，那么Java的对象模型与C++对象模型之间又有什么关系呢？今天就来分析一下HotSpot JVM中的对象模型：<strong>oop-klass model</strong>，它们的源码位于<code>openjdk-8/openjdk/hotspot/src/share/vm/oops</code>文件夹内。</p>
<p><strong>注：本文对应的OpenJDK版本为openjdk-8u76-b02。对于不同的版本(openjdk-7, openjdk-8, openjdk-9)，其对应的HotSpot JVM的对象模型有些许差别（7和8的差别比较大）</strong></p>
<hr>
<h1 id="oop-klass_model概述">oop-klass model概述</h1><p>HotSpot JVM并没有根据Java实例对象直接通过虚拟机映射到新建的C++对象，而是设计了一个oop-klass model。</p>
<p>当时第一次看到oop，我的第一反应就是Object-oriented programming，其实这里的<code>oop</code>指的是 <em>Ordinary Object Pointer</em>（普通对象指针），它用来表示对象的实例信息，看起来像个指针实际上是藏在指针里的对象。而<code>klass</code>则包含 <strong>元数据和方法信息</strong>，用来描述Java类。</p>
<p>那么为何要设计这样一个一分为二的对象模型呢？这是因为HotSopt JVM的设计者不想让每个对象中都含有一个vtable（虚函数表），所以就把对象模型拆成klass和oop，其中oop中不含有任何虚函数，而klass就含有虚函数表，可以进行method dispatch。这个模型其实是参照的 <strong>Strongtalk VM</strong> 底层的对象模型。</p>
<h1 id="体系总览">体系总览</h1><p>在<code>oopsHierarchy.hpp</code>里定义了oop和klass各自的体系。<br>这是oop的体系：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">class</span> oopDesc*                            oop;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">class</span>   instanceOopDesc*            instanceOop;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">class</span>   arrayOopDesc*                    arrayOop;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">class</span>     objArrayOopDesc*            objArrayOop;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">class</span>     typeArrayOopDesc*            typeArrayOop;</div></pre></td></tr></table></figure></p>
<p>注意由于Java 8引入了Metaspace，OpenJDK 1.8里对象模型的实现与1.7有很大的不同。原先存于PermGen的数据都移至Metaspace，因此它们的C++类型都继承于<code>MetaspaceObj</code>类(定义见<code>vm/memory/allocation.hpp</code>)，表示元空间的数据。</p>
<p>这是元数据的体系：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The metadata hierarchy is separate from the oop hierarchy</span></div><div class="line"></div><div class="line"><span class="comment">//      class MetaspaceObj</span></div><div class="line"><span class="keyword">class</span>   ConstMethod;</div><div class="line"><span class="keyword">class</span>   ConstantPoolCache;</div><div class="line"><span class="keyword">class</span>   MethodData;</div><div class="line"><span class="comment">//      class Metadata</span></div><div class="line"><span class="keyword">class</span>   Method;</div><div class="line"><span class="keyword">class</span>   ConstantPool;</div><div class="line"><span class="comment">//      class CHeapObj</span></div><div class="line"><span class="keyword">class</span>   CompiledICHolder;</div></pre></td></tr></table></figure></p>
<p>这是klass的体系：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The klass hierarchy is separate from the oop hierarchy.</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Klass;</div><div class="line"><span class="keyword">class</span>   InstanceKlass;</div><div class="line"><span class="keyword">class</span>     InstanceMirrorKlass;</div><div class="line"><span class="keyword">class</span>     InstanceClassLoaderKlass;</div><div class="line"><span class="keyword">class</span>     InstanceRefKlass;</div><div class="line"><span class="keyword">class</span>   ArrayKlass;</div><div class="line"><span class="keyword">class</span>     ObjArrayKlass;</div><div class="line"><span class="keyword">class</span>     TypeArrayKlass;</div></pre></td></tr></table></figure></p>
<p>注意klass代表元数据，继承自<code>Metadata</code>类，因此像<code>Method</code>、<code>ConstantPool</code>都会以成员变量（或指针）的形式存在于klass体系中。</p>
<p>以下是JDK 1.7中的类在JDK 1.8中的存在形式：</p>
<ul>
<li><code>klassOop</code>-&gt;<code>Klass*</code></li>
<li><code>klassKlass</code>不再需要</li>
<li><code>methodOop</code>-&gt;<code>Method*</code></li>
<li><code>methodDataOop</code>-&gt; <code>MethodData*</code></li>
<li><code>constMethodOop</code> -&gt; <code>ConstMethod*</code></li>
<li><code>constantPoolOop</code> -&gt; <code>ConstantPool*</code></li>
<li><code>constantPoolCacheOop</code> -&gt; <code>ConstantPoolCache*</code></li>
</ul>
<h1 id="klass">klass</h1><p>一个Klass对象代表一个类的元数据（相当于<code>java.lang.Class</code>对象）。它提供：</p>
<ul>
<li>language level class object (method dictionary etc.)</li>
<li>provide vm dispatch behavior for the object</li>
</ul>
<p>所有的函数都被整合到一个C++类中。</p>
<p>Klass对象的继承关系：<code>xxxKlass &lt;:&lt; Klass &lt;:&lt; Metadata &lt;:&lt; MetaspaceObj</code></p>
<p>klass对象的布局如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  Klass layout:</span></div><div class="line"><span class="comment">//    [C++ vtbl ptr  ] (contained in Metadata)</span></div><div class="line"><span class="comment">//    [layout_helper ]</span></div><div class="line"><span class="comment">//    [super_check_offset   ] for fast subtype checks</span></div><div class="line"><span class="comment">//    [name          ]</span></div><div class="line"><span class="comment">//    [secondary_super_cache] for fast subtype checks</span></div><div class="line"><span class="comment">//    [secondary_supers     ] array of 2ndary supertypes</span></div><div class="line"><span class="comment">//    [primary_supers 0]</span></div><div class="line"><span class="comment">//    [primary_supers 1]</span></div><div class="line"><span class="comment">//    [primary_supers 2]</span></div><div class="line"><span class="comment">//    ...</span></div><div class="line"><span class="comment">//    [primary_supers 7]</span></div><div class="line"><span class="comment">//    [java_mirror   ]</span></div><div class="line"><span class="comment">//    [super         ]</span></div><div class="line"><span class="comment">//    [subklass      ] first subclass</span></div><div class="line"><span class="comment">//    [next_sibling  ] link to chain additional subklasses</span></div><div class="line"><span class="comment">//    [next_link     ]</span></div><div class="line"><span class="comment">//    [class_loader_data]</span></div><div class="line"><span class="comment">//    [modifier_flags]</span></div><div class="line"><span class="comment">//    [access_flags  ]</span></div><div class="line"><span class="comment">//    [last_biased_lock_bulk_revocation_time] (64 bits)</span></div><div class="line"><span class="comment">//    [prototype_header]</span></div><div class="line"><span class="comment">//    [biased_lock_revocation_count]</span></div><div class="line"><span class="comment">//    [_modified_oops]</span></div><div class="line"><span class="comment">//    [_accumulated_modified_oops]</span></div><div class="line"><span class="comment">//    [trace_id]</span></div></pre></td></tr></table></figure></p>
<h1 id="oop">oop</h1><p><code>oop</code>类型其实是<code>oopDesc*</code>。在Java程序运行的过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的oop对象。各种oop类的共同基类为<code>oopDesc</code>类。</p>
<p>JVM内部，一个Java对象在内存中的布局可以连续分成两部分：<code>instanceOopDesc</code>和实例数据。<code>instanceOopDesc</code>和<code>arrayOopDesc</code>又称为对象头。</p>
<p><code>instanceOopDesc</code>对象头包含两部分信息：<strong>Mark Word</strong> 和 <strong>元数据指针</strong>(<code>Klass*</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> markOop  _mark;</div><div class="line">  <span class="keyword">union</span> _metadata &#123;</div><div class="line">    Klass*      _klass;</div><div class="line">    narrowKlass _compressed_klass;</div><div class="line">  &#125; _metadata;</div></pre></td></tr></table></figure>
<p>分别来看一下：</p>
<ul>
<li><strong>Mark Word</strong>：instanceOopDesc中的<code>_mark</code>成员，允许压缩。它用于存储对象的运行时记录信息，如哈希值、GC分代年龄(Age)、锁状态标志（偏向锁、轻量级锁、重量级锁）、线程持有的锁、偏向线程ID、偏向时间戳等</li>
<li><strong>元数据指针</strong>：instanceOopDesc中的<code>_metadata</code>成员，它是联合体，可以表示未压缩的Klass指针(<code>_klass</code>)和压缩的Klass指针。对应的klass指针指向一个存储类的元数据的Klass对象</li>
</ul>
<p>下面我们来分析一下，执行<code>new A()</code>的时候，JVM native层里发生了什么。首先，如果这个类没有被加载过，JVM就会进行类的加载，并在JVM内部创建一个<strong>instanceKlass</strong>对象表示这个类的运行时元数据（相当于Java层的<code>Class</code>对象）。到初始化的时候（执行<code>invokespecial A::&lt;init&gt;</code>），JVM就会创建一个<strong>instanceOopDesc</strong>对象表示这个对象的实例，然后进行Mark Word的填充，将元数据指针指向<code>Klass</code>对象，并填充实例变量。</p>
<p>根据对JVM的理解，我们可以想到，元数据—— <strong>instanceKlass</strong> 对象会存在元空间（方法区），而对象实例—— <strong>instanceOopDesc</strong> 会存在Java堆。Java虚拟机栈中会存有这个对象实例的引用。</p>
<hr>
<h1 id="参考文档">参考文档</h1><ul>
<li><a href="http://openjdk.java.net/groups/hotspot/docs/StorageManagement.html" target="_blank" rel="external">HotSpot Docs - Storage Management</a></li>
<li><a href="https://code.google.com/archive/p/strongtalk/wikis/VMTypesForSmalltalkObjects.wiki" target="_blank" rel="external">Strongtalk - VMTypesForSmalltalkObjects.wiki（讲述了”oop”的历史）</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Inside The C++ Object Model 学习笔记(III)]]></title>
      <url>http://www.sczyh30.com/posts/C-C/inside-cpp-object-model-summary-3/</url>
      <content type="html"><![CDATA[<p>这篇将总结C++的函数语义学相关的内容( <em>Inside The C++ Object Model, Chapter 4</em> )。</p>
<h1 id="Nonstatic_Member_Function">Nonstatic Member Function</h1><p>非静态成员函数和普通函数的等价形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">compute</span><span class="params">(<span class="keyword">const</span> Strategy* sp)</span></span>;</div><div class="line"><span class="keyword">float</span> Strategy::compute() <span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<p>一般来说，非静态成员函数在经过编译时会被转化为非成员函数，转化步骤如下：</p>
<ol>
<li>改写函数原型,参数变为<code>this</code>指针。</li>
<li>将所有成员变量的存取操作都转化为经this指针的操作。</li>
<li>将此函数重写为一个外部函数并导出，名称进行 <strong>Name Mangling</strong>。最后函数的调用形式也随之改变：<code>obj.magnitude()</code>转化为类似于<code>magnitude_7Point3dFv(&amp;obj)</code>这种名称</li>
</ol>
<h1 id="Deep_in_Virtual_Function">Deep in Virtual Function</h1><h2 id="单继承下的虚函数">单继承下的虚函数</h2><p>对于普通的类，每个类只含一个虚函数表(<code>vtbl</code>)，其中虚函数表记录了基本信息(<code>type_info</code>)及各函数的地址。每个对象在编译时都会被安插虚函数指针(<code>vptr</code>)指向虚函数表。</p>
<p>对于以下类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Scala &#123;</div><div class="line">protected:</div><div class="line">	int type;</div><div class="line">public:</div><div class="line">	explicit Scala(int type): type(type) &#123;&#125;</div><div class="line">	virtual ~Scala() &#123;&#125;</div><div class="line">	virtual void f() = 0; // pure virtual function</div><div class="line">	virtual int g() &#123;</div><div class="line">		return this-&gt;type;</div><div class="line">	&#125;</div><div class="line">	virtual void h() &#123;</div><div class="line">		std::cout &lt;&lt; "FUCK 0" &lt;&lt; std::endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Scalaz : public Scala &#123;</div><div class="line">protected:</div><div class="line">	int s2;</div><div class="line">public:</div><div class="line">	explicit Scalaz(int s2, int type): s2(s2), Scala(type) &#123;&#125;</div><div class="line">	virtual ~Scalaz() &#123;&#125;</div><div class="line">	void f() &#123;</div><div class="line">		std::cout &lt;&lt; "Scalaz" &lt;&lt; std::endl;</div><div class="line">	&#125;</div><div class="line">	void h() &#123;</div><div class="line">		std::cout &lt;&lt; "FUCK =&gt; 1" &lt;&lt; std::endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中的<code>Scala</code>类和<code>Scalaz</code>类的模型如下所示：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/vtable-isppom.PNG" alt="Object Model"></p>
<p><strong>注意</strong>：不同的C++编译器对<code>vtable</code>的实现不同，<code>vtbl</code>的初始偏移量可能是0，也可能是-8之类的。如果编译器开启了RTTI，则<code>vtbl</code>里会包含<code>type_info</code>。</p>
<p>现在如果调用<code>ptr-&gt;g()</code>，我们并不知道ptr所指对象的具体类型，但是有两点很清楚：</p>
<ul>
<li>无论ptr对应哪种对象，我们总是可以通过ptr找到对应对象的vtable</li>
<li>无论ptr对应哪种对象，g函数的地址总是在<strong>slot 3</strong>位置</li>
</ul>
<p>因此此调用可以转化为：<code>(*ptr-&gt;vptr[3])(ptr)</code></p>
<p>用gdb查看运行时的vtbl(命令：<code>i vtbl 对象名</code>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vtable for &apos;Scala&apos; @ 0x400d70 (subobject @ 0x603010):</div><div class="line">[0]: 0x400bf0 &lt;Scalaz::~Scalaz()&gt;</div><div class="line">[1]: 0x400c2a &lt;Scalaz::~Scalaz()&gt;</div><div class="line">[2]: 0x400c50 &lt;Scalaz::f()&gt;</div><div class="line">[3]: 0x400b7a &lt;Scala::g()&gt;</div><div class="line">[4]: 0x400c7a &lt;Scalaz::h()&gt;</div></pre></td></tr></table></figure>
<h2 id="纯虚函数为什么等于0">纯虚函数为什么等于0</h2><p>在C++标准中，通过使虚函数=0来定义纯虚函数，其含义是在vtbl对应的地方填上0。关于为什么设计纯虚函数，以及纯虚函数为什么为0， <em>The Design and Evolution of C++</em> 中的描述是：</p>
<blockquote>
<p><em>The curious =0 syntax was chosen over the obvious alternative of introducing a new keyword pure or abstract because at the time I saw no chance of getting a new keyword accepted. Had I suggested pure, Release 2.0 would have shipped without abstract classes. Given a choice between a nicer syntax and abstract classes, I chose abstract classes. Rather than risking delay and incurring the certain fights over pure, I used the tradition C and C++ convention of using 0 to represent “not there.” The =0 syntax fits with my view that a function body is the initializer for a function also with the (simplistic, but usually adequate) view of the set of virtual functions being implemented as a vector of function pointers.</em></p>
</blockquote>
<p><strong>另外一点</strong>：在MSVC中，NULL = 0；而在GCC的实现中，<code>NULL</code>的内部实现是<code>__null</code>而不是<strong>0</strong>。因此在定义纯虚函数的时候不要用NULL代替0，也不能用C++ 11的<code>nullptr</code>。</p>
<h2 id="普通多继承下的虚函数">普通多继承下的虚函数</h2><p>假设派生类直接继承了n个类，则派生类中就会有n个<code>vptr</code>。多继承下的派生类拥有一个主要的<code>vptr</code>和 n-1 个次要的<code>vptr</code>。多重继承最左端的基类，在派生类中作为主要实体，其对应的<code>vtbl</code>为主要的<code>vtbl</code>。</p>
<p>假设现在有下面的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base1 &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Base1</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">virtual</span> ~Base1() &#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> Base1 *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> ...&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">float</span> b1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base2 &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Base2</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">virtual</span> ~Base2() &#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> Base2 *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> ...&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">float</span> b2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">virtual</span> ~Derived() &#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> Derived *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> ...&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">		<span class="keyword">float</span> d;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在上面的继承关系中，<code>Base1</code>就作为主要实体。</p>
<p>例如，有以下调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Base1 *b1 = <span class="keyword">new</span> Derived();</div><div class="line">Base2 *b2 = <span class="keyword">new</span> Derived();</div><div class="line">...</div><div class="line"><span class="keyword">delete</span> b1;</div><div class="line"><span class="keyword">delete</span> b2;</div></pre></td></tr></table></figure>
<p>这两个指针所指对象对应的<code>vtbl</code>是不同的，里面涉及多继承指针转换的问题：</p>
<ul>
<li><code>b1</code>不需要调整<code>this</code>指针（最左边的类）</li>
<li><code>b2</code>需要调整<code>this</code>指针</li>
</ul>
<p>对<code>b2</code>来说，构造函数必须调整对象地址，使其指向Base2 sub-object（当然析构函数也是）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Derived *__temp = <span class="keyword">new</span> Derived();</div><div class="line">Base2 *b2 = __temp ? __temp + <span class="keyword">sizeof</span>(Base1) : <span class="number">0</span>;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ 11 STL | functional 标准库]]></title>
      <url>http://www.sczyh30.com/posts/C-C/cpp-stl-functional/</url>
      <content type="html"><![CDATA[<p>最近正好用到了这个，就顺便总结下吧。</p>
<p>C++ 11引入了函数对象标准库<code>&lt;functional&gt;</code>，里面包含各种内建的函数对象以及相关的操作函数，非常方便。这里总结一下<code>std::function</code>和<code>std::bind</code>的相关用法。</p>
<h1 id="Callable_type">Callable type</h1><p>Callable type指可以像调用函数一样被调用的对象或函数，包括：</p>
<ul>
<li><code>std::function</code></li>
<li><code>std::bind</code></li>
<li><code>std::result_of</code></li>
<li><code>std::thread::thread</code></li>
<li><code>std::call_once</code></li>
<li><code>std::async</code></li>
<li><code>std::packaged_task</code></li>
<li><code>std::reference_wrapper</code></li>
</ul>
<p>根据C++ 17 Standard，所有Callable type都可以通过<code>std::invoke</code>方法进行<a href="http://en.cppreference.com/w/cpp/utility/functional/invoke" target="_blank" rel="external">显式调用</a>。</p>
<h1 id="std::function">std::function</h1><p><code>std::function</code>类模板是一种通用的函数包装器，它可以容纳所有可以调用的对象（<a href="http://en.cppreference.com/w/cpp/concept/Callable" target="_blank" rel="external">Callable</a>），包括<strong>函数</strong>、<strong>函数指针</strong>、<strong>Lambda表达式</strong>、<strong>bind表达式</strong>、成员函数及成员变量或者其他函数对象。通过std::function可以储存、拷贝或调用Callable对象。它的模板参数如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> R, <span class="keyword">class</span>... Args &gt;</div><div class="line"><span class="keyword">class</span> function&lt;R(Args...)&gt;</div></pre></td></tr></table></figure></p>
<p>使用时，模板参数与要存储的函数参数一致即可，下面是一些例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;functional&gt;</div><div class="line"></div><div class="line">double f(int x, char y, double z) &#123;</div><div class="line">    return x + y + z;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void print_num(int num) &#123;</div><div class="line">    std::cout &lt;&lt; num &lt;&lt; std::endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Dog &#123;</div><div class="line">    int id;</div><div class="line">    explicit Dog(int id): id(id) &#123;&#125;</div><div class="line">    void print_add(int i) const &#123;</div><div class="line">        std::cout &lt;&lt; id + i &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class PrintString &#123;</div><div class="line">public:</div><div class="line">    void operator()(std::string&amp;&amp; s) const &#123;</div><div class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char **argv) &#123;</div><div class="line">    // common function</div><div class="line">    std::function&lt;void(int)&gt; func_display_num = print_num;</div><div class="line">    func_display_num(9);</div><div class="line">    // common function</div><div class="line">    std::function&lt;double(int, char, double)&gt; func_display = f;</div><div class="line">    std::cout &lt;&lt; func_display(3, 'a', 1.7) &lt;&lt; "\n";</div><div class="line">    // lambda expression</div><div class="line">    std::function&lt;void(const char*)&gt; lbd_dsp_str = [](const char *s) &#123;std::cout &lt;&lt; s &lt;&lt; std::endl;&#125;;   </div><div class="line">    lbd_dsp_str("Scala");</div><div class="line">    // bind expression</div><div class="line">    auto func_num_bind = std::bind(&amp;f, std::placeholders::_1, 'c', 2.4);</div><div class="line">    std::cout &lt;&lt; func_num_bind(24) &lt;&lt; "\n";</div><div class="line">    // function object</div><div class="line">    std::function&lt;void(std::string&amp;&amp;)&gt; func_obj_print = PrintString();</div><div class="line">    func_obj_print("C++ 17 Nice!");</div><div class="line">    // member function</div><div class="line">    const Dog dog(2424);</div><div class="line">    std::function&lt;void(const Dog&amp;, int)&gt; func_mem_display_num = &amp;Dog::print_add;</div><div class="line">    func_mem_display_num(dog, 24);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意声明时可用<code>auto</code>进行自动类型推导，这样可以节约时间，不过这样会牺牲代码的可读性，因此需要根据情况合理使用<code>auto</code>。</p>
<h1 id="std::bind">std::bind</h1><p>顾名思义，<code>std::bind</code>函数用来绑定函数的某些参数并生成一个新的<code>function</code>对象。<br><code>bind</code>用于实现偏函数（Partial Function），相当于实现了函数式编程中的 <strong>Currying</strong>（柯里化）。<br>比如有一函数的定义为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_muti</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; b, <span class="keyword">const</span> <span class="keyword">char</span>* c, <span class="keyword">double</span> d, <span class="keyword">char</span> e)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">", "</span> &lt;&lt; b &lt;&lt; <span class="string">", "</span> &lt;&lt; c &lt;&lt; <span class="string">", "</span> &lt;&lt; d &lt;&lt; <span class="string">", "</span> &lt;&lt; e &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在将此函数的一些参数绑定上值，其余部分用占位符对象（std::placeholders）表示。占位符是有序号的，代表调用此函数对象时参数在参数列表中的位置。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(&amp;func_muti, <span class="number">24</span>, <span class="built_in">std</span>::placeholders::_1, <span class="string">"Haha"</span>, <span class="built_in">std</span>::placeholders::_2, <span class="string">'P'</span>);  </div><div class="line">f(<span class="string">"Hehe"</span>, <span class="number">24.24</span>);</div></pre></td></tr></table></figure></p>
<p>调用这个函数对象相当于调用以下函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; b, <span class="keyword">double</span> d)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"24"</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; b &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="string">"Haha"</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; d &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="string">'P'</span> &lt;&lt; <span class="string">"\n"</span>;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Modern C++ | 移动语义与完美转发 | Universal Reference]]></title>
      <url>http://www.sczyh30.com/posts/C-C/cpp-move-semantic/</url>
      <content type="html"><![CDATA[<p>简单总结一下C++ 11/14中的移动语义和完美转发～</p>
<h1 id="lvalue_&amp;&amp;_rvalue">lvalue &amp;&amp; rvalue</h1><p>表达式可以分为<code>lvalue</code>（左值）和<code>rvalue</code>（右值）两种。</p>
<p>左值与右值的区别是左值具名，<strong>可以取址</strong> 并访问；而右值不具名，通常是临时的变量，不可取址，仅在当前作用域有效，可以被移动。</p>
<p>对于函数及运算符，如果返回类型是左值引用类型(<code>A&amp;</code>)，那么返回值是左值；若返回类型是原对象类型(<code>A</code>)，那么返回值就是右值。</p>
<p>举一些例子来说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">24</span>);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"nice"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = <span class="string">"Scala"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line">vec.push_back(<span class="number">24</span>);</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; m = <span class="number">666</span>;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Value category</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>rvalue</td>
</tr>
<tr>
<td>i</td>
<td>lvalue</td>
</tr>
<tr>
<td>a+b</td>
<td>rvalue</td>
</tr>
<tr>
<td>&amp;a</td>
<td>rvalue</td>
</tr>
<tr>
<td>*p</td>
<td>lvalue</td>
</tr>
<tr>
<td>++i</td>
<td>lvalue(前缀自增运算符直接在原变量上自增)</td>
</tr>
<tr>
<td>i++</td>
<td>rvalue(后缀自增运算符先拷贝一份变量，自增后再重新赋值给原变量)</td>
</tr>
<tr>
<td>std::string(“oye”)</td>
<td>rvalue</td>
</tr>
<tr>
<td>str1+str2</td>
<td>rvalue(重载的<code>+</code>运算符返回的是一个临时的<code>std::string</code>对象而不是引用)</td>
</tr>
<tr>
<td>vec[0]</td>
<td>lvalue(重载的<code>[]</code>运算符返回类型为<code>int&amp;</code>)</td>
</tr>
<tr>
<td>m</td>
<td>lvalue(引用了一个右值，但本身是左值)</td>
</tr>
</tbody>
</table>
<p>当然C++中表达式的分类还可以根据是否可移动及是否具名再细分。如果用<code>m</code>表示可移动(movable)，用<code>i</code>表示具名(has identity)，那么表达式类型可以进一步细分为：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/value-categories-in-modern-cpp.png" alt="Value categories since C++ 11"></p>
<p>根据上面的分类，我们传统意义上讲的lvalue指的是具名并且不可被移动的值，而rvalue指的是可被移动的值。</p>
<p>更详细的信息可参考<a href="http://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="external">Value categories</a>。</p>
<h1 id="Universal_reference">Universal reference</h1><p>C++ 11中引入了右值引用(rvalue reference)用于表示移动语义（绑定了右值）。在C++ 11中，类型<code>T</code>的右值引用表示为<code>T&amp;&amp;</code>。然而并不是所有的形如<code>T&amp;&amp;</code>的类型都为rvalue reference。形如<code>T&amp;&amp;</code>的类型有两种情况：一种是普通的rvalue reference，另一种则被称为 <strong>universal reference</strong>，它既可能表示lvalue reference，也可能表示rvalue reference。那么如何区分这两种引用呢？根据 <em>Effective Modern C++, Item 24</em> 总结一下：</p>
<ul>
<li>如果一个函数模板参数的类型为<code>T&amp;&amp;</code>，其中<code>T</code>是需要推导的类型，那么此处的<code>T&amp;&amp;</code>指代universal reference。若不严格满足<code>T&amp;&amp;</code>类型或没有发生类型推导，则<code>T&amp;&amp;</code>指代rvalue reference。比如下面的<code>param</code>参数即为universal reference：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</div></pre></td></tr></table></figure>
<p>上面有两个要点：类型为<code>T&amp;&amp;</code>和参与类型推导。也就是说<code>T&amp;&amp;</code>加上cv qualifiers就不是universal reference了，比如下面的<code>param</code>参数为rvalue reference而不是universal reference：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;&amp; param)</span></span>;</div></pre></td></tr></table></figure>
<p>另外一点就是要参与类型推导。比如以下<code>vector</code>类中的<code>push_back</code>函数，虽然参数类型为<code>T&amp;&amp;</code>，但是并未参与类型推导。因为<code>vector</code>模板实例化的时候，<code>T</code>的类型是已经推导出来的(如<code>std::vector&lt;T&gt;, T = int</code>)，因此参数仍然为rvalue reference:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Allocator = allocator&lt;T&gt;&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">vector</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">void</span> push_back(T&amp;&amp; x);</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而<code>emplace_back</code>模板函数则需要进行类型推导，因此对应的参数<code>Args&amp;&amp;</code>为universal reference(为方便起见，将此处的parameter pack看作是一个type parameter)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Allocator = allocator&lt;T&gt;&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">vector</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</div><div class="line">	<span class="keyword">void</span> emplace_back(Args&amp;&amp;... args);</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>如果一个对象的类型被定义为<code>auto&amp;&amp;</code>，则此对象为universal reference，比如<code>auto&amp;&amp; f = g()</code></li>
</ul>
<p>那么如何确定universal reference的引用类型呢？有如下规则：如果universal reference是通过rvalue初始化的，那么它就对应一个rvalue reference；如果universal reference是通过lvalue初始化的，那么它就对应一个lvalue reference。</p>
<p>确定了universal reference的引用类型后，编译器需要推导出<code>T&amp;&amp;</code>中的<code>T</code>的真实类型：若传入的参数是一个左值，则<code>T</code>会被推导为左值引用；而如果传入的参数是一个右值，则<code>T</code>会被推导为原生类型（非引用类型）。这里面会涉及到编译器的 <strong>reference collapsing</strong> 规则，下面来总结一下。</p>
<h1 id="Reference_collapsing">Reference collapsing</h1><p>考虑以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</div><div class="line"></div><div class="line">A a;</div><div class="line">f(a); <span class="comment">// T = A&amp;</span></div></pre></td></tr></table></figure>
<p>根据上面总结的规则，<code>T = A&amp;, T&amp;&amp; = A&amp;</code>。然而将<code>T&amp;&amp;</code>展开后我们发现这玩意像是一个reference to reference：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A&amp; &amp;&amp; param)</span></span>;</div></pre></td></tr></table></figure>
<p>如果我们直接表示这样的多层引用，编译器会报错；而这里编译器却允许在一定的情况下进行隐含的多层引用推导，这就是 <strong>reference collapsing</strong> (引用折叠)。C++中有两种引用（左值引用和右值引用），因此引用折叠就有四种组合。引用折叠的规则：</p>
<blockquote>
<p><strong>如果两个引用中至少其中一个引用是左值引用，那么折叠结果就是左值引用；否则折叠结果就是右值引用。</strong></p>
</blockquote>
<p>直观表示：</p>
<ul>
<li><code>T&amp; &amp;</code> = <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;</code> = <code>T&amp;</code></li>
<li><code>T&amp; &amp;&amp;</code> = <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;&amp;</code> = <code>T&amp;&amp;</code></li>
</ul>
<h1 id="Move_semantic">Move semantic</h1><p>移动语义的意义：<strong>资源所有权的转让</strong>。即进行数据复制的时候，将动态申请的内存空间的所有权直接转让出去，不用再另开辟空间进行大量的数据拷贝，既节省空间又提高效率。</p>
<p>被移动的数据交出了所有权，为了不出现析构两次同一数据区，要将交出所有权的数据的指向动态申请内存去的指针赋值为<code>nullptr</code>，即空指针。对空指针执行<code>delete[]</code>是合法的。</p>
<p>我们可以用标准库中的<code>std::move</code>函数来表示一个对象可以被移动，即交出资源所有权。它可以将传入的参数转化为右值引用（严格来说应该是xvalue，即具名但可被移动的值）。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">f(<span class="keyword">int</span>&amp;&amp; a);</div><div class="line">f(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> s = <span class="number">4</span>;</div><div class="line">f(s); <span class="comment">// invoke f(&amp;)</span></div><div class="line">f(<span class="built_in">std</span>::move(s));<span class="comment">// invoke f(&amp;&amp;)</span></div></pre></td></tr></table></figure>
<p>再比如对于只允许移动的对象(独占资源，如<code>unique_ptr</code>)，可以通过<code>std::move</code>与move ctor来转移资源的所有权：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> p1 = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"+1s"</span>);</div><div class="line"><span class="keyword">auto</span> p2 = <span class="built_in">std</span>::move(p1); <span class="comment">// p1管理的资源的所有权交给p2</span></div></pre></td></tr></table></figure>
<p>注意<code>std::move</code>的本质，它其实就是一个转换函数，将给定的类型转化为右值引用，而并不是真正地“移动”了资源(组委会一直在吐槽<code>move</code>这个名，应该叫<code>rval</code>比较合适)。我们来看一下其实现(gcc 5.3.0)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</div><div class="line">	<span class="keyword">constexpr</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></div><div class="line">	<span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></div><div class="line">	&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>move</code>函数的实现非常简单：通过<code>type_traits</code>中的<code>remove_reference</code>函数清除<code>_Tp</code>类型中的引用，然后再加上<code>&amp;&amp;</code>并转换(此处<code>_Tp&amp;&amp;</code>即为一个universal reference)。</p>
<h1 id="Perfect_forwarding">Perfect forwarding</h1><p>有的时候，我们需要将一个函数某一组参数原封不动地传递给另一个函数。这里不仅需要参数的值不变，而且需要参数的类型属性(左值/右值，cv qualifiers)保持不变，这叫做 <strong>Perfect Forwarding</strong>（完美转发）。</p>
<p>从C++ 11开始，perfect forwarding可以通过<code>std::forward</code>函数实现，其原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C++ 14 definition</span></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</div><div class="line"><span class="function"><span class="keyword">constexpr</span> T&amp;&amp; <span class="title">forward</span><span class="params">( <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp; t )</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</div><div class="line"><span class="function"><span class="keyword">constexpr</span> T&amp;&amp; <span class="title">forward</span><span class="params">( <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp; t )</span></span>;</div></pre></td></tr></table></figure>
<p>写个例子，实现C++ 14标准中的<code>make_unique</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> &amp;&amp; n) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue constructor -&gt; n="</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">	A(<span class="keyword">int</span>&amp; n) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue constructor -&gt; n="</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; make_unique1(U&amp;&amp; u) &#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;U&gt;(u)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">24</span>;</div><div class="line">	<span class="keyword">auto</span> p1 = make_unique1&lt;A&gt;(<span class="number">666</span>); <span class="comment">// rvalue forwarding</span></div><div class="line">	<span class="keyword">auto</span> p2 = make_unique1&lt;A&gt;(i); <span class="comment">// lvalue forwarding</span></div><div class="line">	<span class="keyword">auto</span> p3 = make_unique1&lt;A&gt;(<span class="built_in">std</span>::move(i)); <span class="comment">// rvalue forwarding</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rvalue constructor -&gt; n=666</div><div class="line">lvalue constructor -&gt; n=24</div><div class="line">rvalue constructor -&gt; n=24</div></pre></td></tr></table></figure>
<p>可以看到，参数在传递时都保留了参数原本的属性。</p>
<p>看一下<code>forward</code>函数的实现(gcc 5.3.0)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</div><div class="line">  <span class="keyword">constexpr</span> _<span class="function">Tp&amp;&amp;</span></div><div class="line">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></div><div class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</div><div class="line">  <span class="keyword">constexpr</span> _<span class="function">Tp&amp;&amp;</span></div><div class="line">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">"template argument"</span></div><div class="line">    <span class="string">" substituting _Tp is an lvalue reference type"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>forward</code>函数底层也是利用了<code>type_traits</code>中的<code>remove_reference</code>以及universal reference和reference collapsing。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><em>Effective Modern C++</em></li>
<li><a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers" target="_blank" rel="external">Universal References in C++ 11 — Scott Meyers</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Inside The C++ Object Model 学习笔记(I)]]></title>
      <url>http://www.sczyh30.com/posts/C-C/inside-cpp-object-model-summary-1/</url>
      <content type="html"><![CDATA[<p>最近一直在看 <em>Inside The C++ Object Model</em>, 希望从这本书中了解一下底层对象模型的设计，也为以后研究JVM的对象模型做铺垫。</p>
<p>注：由于这本书比较老，最新也就是C++ 98标准。因此这些总结都是基于C++ 98标准的。如果有C++ 11中新增的特性或新的优化（貌似析构函数那一部分变了挺多），我会单独指出。</p>
<p>这篇将总结C++的构造函数语义学相关的内容( <em>Inside The C++ Object Model, Chapter 2</em> )。第二章主要讲述了构造函数的相关模型及事项。</p>
<h1 id="Implicit_Default_Constructor（C++_98）">Implicit Default Constructor（C++ 98）</h1><p>在我们没有声明默认构造函数的时候，编译器有可能会为我们自动生成默认构造函数。不过，并非在所有情况下，编译器都自动生成default constructor。当且仅当以下四种情况下，编译器会自动为一个类生成default constructor：</p>
<ol>
<li>此类有一个显式地实现了默认构造函数（explicit default constructor）的对象成员变量</li>
<li>此类的父类显式地实现了默认构造函数</li>
<li>此类中存在虚函数</li>
<li>此类间接继承了虚基类</li>
</ol>
<p><strong>注：</strong> C++ 11标准增加了移动构造函数（move constructor），有关移动构造函数相关的东西可以看C++ 11标准。</p>
<h1 id="Copy_Constructor（C++_98）">Copy Constructor（C++ 98）</h1><h2 id="No_Bitwise_copy">No Bitwise copy</h2><p>编译器不能简单地拷贝对象，因为编译器需要保证<code>vptr</code>和<code>vtbl</code>的正确性。复制的时候要注意正确赋值。比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class A &#123; // virtual base class</div><div class="line">    public:</div><div class="line">        explicit A() &#123;&#125;</div><div class="line">        explicit A(int i):i(i) &#123;&#125;</div><div class="line">        virtual ~A() &#123;&#125; // virtual deconstructor</div><div class="line">        virtual int test() &#123;</div><div class="line">            return this-&gt;i;</div><div class="line">        &#125;</div><div class="line">    protected:</div><div class="line">        int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class B : public virtual A &#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">class C : public virtual A &#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">class D : public b, public C &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果在赋值的时候将sub object赋值给base object，编译器为了确保<code>vptr</code>和<code>vtbl</code>的一致性，会对其截断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A a = D&#123;&#125;;</div></pre></td></tr></table></figure>
<h2 id="Return_Value_Initialization_(Traditional_C++)">Return Value Initialization (Traditional C++)</h2><p>注：C++ 11以后引入了Copy Elision可以省掉copy的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Test <span class="title">genTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Test test;</div><div class="line"></div><div class="line">    <span class="comment">// do something to wrap the object ...</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> test;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过编译器解析后被转化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">genTest</span><span class="params">(Test&amp; __temp)</span> </span>&#123;</div><div class="line">    Test test;</div><div class="line">    <span class="comment">// &lt;init&gt;</span></div><div class="line">    test.Test::Test();</div><div class="line"></div><div class="line">    <span class="comment">// do something to wrap the object ...</span></div><div class="line"></div><div class="line">    <span class="comment">// copy constructor invocation</span></div><div class="line">    __temp.Test::Test(test);</div><div class="line"></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在如果执行<code>Test t = genTest()</code>这条语句的话，它会被编译器转化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Test t;</div><div class="line">genTest(t);</div></pre></td></tr></table></figure>
<h2 id="RVO_(Copy_Elision)">RVO (Copy Elision)</h2><p>C++ 11将Copy Elision优化加入C++标准中：</p>
<blockquote>
<p>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function’s return value</p>
</blockquote>
<p>调用消耗：<code>copy &gt; move &gt; RVO</code></p>
<h2 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h2><p>老生常谈的东西了，对于指针变量（或数组），必须执行按地址拷贝，这是默认生成的拷贝构造函数不能提供的。因此如果成员变量里有指针型或数组型变量，那么必须自己实现拷贝构造函数，用 <code>memcpy</code> 或 <code>memcopy</code> 进行按地址拷贝。</p>
<h1 id="Move_Constructor（C++_11）">Move Constructor（C++ 11）</h1><p>待总结…</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><em>Inside The C++ Object Model</em></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en" target="_blank" rel="external">RVO V.S. std::move</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[消息队列中间件 | RabbitMQ 总结]]></title>
      <url>http://www.sczyh30.com/posts/Architecture/rabbitmq-summary/</url>
      <content type="html"><![CDATA[<p>最近学习架构设计的时候经常看见基于消息的架构。这里就来总结一下一个常见的高性能消息队列中间件——RabbitMQ，它支持各种各样的消息队列协议(如JMS和AMQP)，并且消息传递比较可靠，并发效率也比较高（RabbitMQ的实现语言是大名鼎鼎的Erlang，天生支持高并发）。这里就来总结一下RabbitMQ的基本使用，以及消息队列和消息架构的一些注意事项。</p>
<h1 id="生产者-消费者模型">生产者-消费者模型</h1><h2 id="Intro">Intro</h2><p>最简单的消息队列模型应该就是 <strong>生产者-消费者模型</strong> 了。简单的一对一模型如下图：</p>
<p><img src="http://www.rabbitmq.com/img/tutorials/python-one.png" alt=""></p>
<p>其中P代表生产者（Producer），C代表消费者（Consumer）,中间部分代表消息队列（Message Queue）。</p>
<p>下面我们用RabbitMQ来实现，首先是生产者一端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_q1"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//步骤一：建立连接</span></div><div class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</div><div class="line">        factory.setHost(<span class="string">"localhost"</span>);</div><div class="line">        <span class="comment">//factory.setPort(6666);</span></div><div class="line">        Connection connection = factory.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line">        <span class="comment">//步骤二：定义消息队列</span></div><div class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        String message = <span class="string">"[Message Producer] 66666"</span>;</div><div class="line">        <span class="comment">//步骤三：发布消息</span></div><div class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</div><div class="line">        System.out.println(<span class="string">"[MessageQueue] Message sent =&gt; message="</span> + message);</div><div class="line">        <span class="comment">//关闭连接</span></div><div class="line">        channel.close();</div><div class="line">        connection.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消费者一端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_q1"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//步骤一：建立连接</span></div><div class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</div><div class="line">        factory.setHost(<span class="string">"localhost"</span>);</div><div class="line">        Connection connection = factory.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line">        <span class="comment">//步骤二：创建一个消费者对象，并利用handleDelivery回调函数接受消息</span></div><div class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</div><div class="line">                System.out.println(<span class="string">"[Message Recv] =&gt; "</span> + msg);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//步骤三：将消费者端与消息队列绑定</span></div><div class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，无论是消费者端还是生产者端，首先要建立通信连接（<code>ConnectionFactory -&gt; Connection -&gt; Channel</code>）。</p>
<p>这只是最简单的一种情况，后边将介绍更普遍、更复杂的情况。</p>
<h2 id="定义消息队列">定义消息队列</h2><p>定义消息队列可以用<code>Channel</code>接口的<code>queueDeclare</code>方法，它有两个重载版本。含参的<code>queueDeclare</code>方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Declare a queue</div><div class="line">     * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Queue.Declare</div><div class="line">     * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Queue.DeclareOk</div><div class="line">     * <span class="doctag">@param</span> queue the name of the queue</div><div class="line">     * <span class="doctag">@param</span> durable true if we are declaring a durable queue (the queue will survive a server restart)</div><div class="line">     * <span class="doctag">@param</span> exclusive true if we are declaring an exclusive queue (restricted to this connection)</div><div class="line">     * <span class="doctag">@param</span> autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)</div><div class="line">     * <span class="doctag">@param</span> arguments other properties (construction arguments) for the queue</div><div class="line">     * <span class="doctag">@return</span> a declaration-confirm method to indicate the queue was successfully declared</div><div class="line">     * <span class="doctag">@throws</span> java.io.IOException if an error is encountered</div><div class="line">     */</div><div class="line">    Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete,</span></span></div><div class="line">                                 Map&lt;String, Object&gt; arguments) <span class="keyword">throws</span> IOException;</div></pre></td></tr></table></figure>
<p>可以看到，它接受五个参数。第一个参数对应消息队列名称，第二个参数对应消息队列是否可以持久化，第三个参数对应消息队列是否仅限于当前连接，第四个参数对应消息队列是否在不用的情况下自动删除，第五个参数对应消息队列其他的一些设置。</p>
<p>另外还有一个无参的<code>queueDeclare</code>方法，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> com.rabbitmq.client.AMQP.Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">return</span> queueDeclare(<span class="string">""</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">null</span>); <span class="comment">// 默认不可持久化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：Producer端和Consumer端的消息队列定义需要保持一致。</p>
</blockquote>
<h2 id="Envelope对象">Envelope对象</h2><p>Envelope对象封装了AMQP通信需要的数据，如deliveryTag, redeliver flag, exchange, routingKey等。其构造函数注释中有这几个变量的解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Construct an &#123;<span class="doctag">@link</span> Envelope&#125; with the specified construction parameters</div><div class="line">    * <span class="doctag">@param</span> deliveryTag the delivery tag</div><div class="line">    * <span class="doctag">@param</span> redeliver true if this is a redelivery following a failed ack</div><div class="line">    * <span class="doctag">@param</span> exchange the exchange used for the current operation</div><div class="line">    * <span class="doctag">@param</span> routingKey the associated routing key</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Envelope</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> redeliver, String exchange, String routingKey)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>._deliveryTag = deliveryTag;</div><div class="line">       <span class="keyword">this</span>._redeliver = redeliver;</div><div class="line">       <span class="keyword">this</span>._exchange = exchange;</div><div class="line">       <span class="keyword">this</span>._routingKey = routingKey;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="消息分发机制(Dispatch)">消息分发机制(Dispatch)</h2><p>RabbitMQ采用 <strong>轮询分发机制</strong>（Round-robin dispatching），每个消费者将接收到数量相近的消息。</p>
<p>扩展：如果想控制每次给消费者端传递的消息数量（流量控制），可以通过<code>Channel</code>的<code>basicQos</code>方法，它有三个重载版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Request specific "quality of service" settings.</div><div class="line">     *</div><div class="line">     * These settings impose limits on the amount of data the server</div><div class="line">     * will deliver to consumers before requiring acknowledgements.</div><div class="line">     * Thus they provide a means of consumer-initiated flow control.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchSize, <span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span></span></div><div class="line">    <span class="keyword">throws</span> IOException &#123;</div><div class="line">    exnWrappingRpc(<span class="keyword">new</span> Basic.Qos(prefetchSize, prefetchCount, global));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Public API - &#123;<span class="doctag">@inheritDoc</span>&#125; */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        basicQos(<span class="number">0</span>, prefetchCount, global);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Public API - &#123;<span class="doctag">@inheritDoc</span>&#125; */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount)</span></span></div><div class="line">    <span class="keyword">throws</span> IOException &#123;</div><div class="line">    basicQos(<span class="number">0</span>, prefetchCount, <span class="keyword">false</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中:</p>
<ul>
<li><code>prefetchSize</code>表示服务器给消费者端传递数据大小的上限，0为不限</li>
<li><code>prefetchCount</code>表示服务器给消费者端传递数据数量的上限，0为不限</li>
<li><code>global</code>标志位表示此设置是否应用于整个<code>Channel</code>而不是每个<code>Consumer</code></li>
</ul>
<h2 id="消息确认机制(Acknowledge)">消息确认机制(Acknowledge)</h2><p>设想一下这种场景：消费者端处理一个耗时任务时被强制结束任务，此时任务还没有完成，但是消息却已从消息队列中发送了出去。如果没有一定的消息确认机制，那么我们将丢失掉此消息及后面一堆发送至此消费者但还未经处理的消息。</p>
<p>RabbitMQ支持消息确认机制。如果消费者已处理完任务，那么它将向Broker发送ACK消息，告知某条消息已被成功处理，可以从队列中移除。如果消费者端没有发送回ACK消息，那么Broker会认为消息处理失败，会将此消息及后续消息分发给其他消费者端进行处理(redeliver flag置为true)。</p>
<p>这种确认机制和TCP/IP协议确立连接类似。不同的是，TCP/IP确立连接需要经过三次握手，而RabbitMQ只需要一次ACK。</p>
<blockquote>
<p><strong>注意：RabbitMQ当且仅当检测到ACK消息未发出且消费者端的连接终止时才会将消息重新分发给其他消费者端，因此不需要担心消息处理时间过长而被重新分发的情况。</strong></p>
</blockquote>
<p>我们可以通过设置<code>basicConsume</code>方法的<code>autoAck</code>标志位来设置其消息确认机制。<code>basicConsume</code>方法的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">basicConsume</span><span class="params">(String queue, <span class="keyword">boolean</span> autoAck, Consumer callback)</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure>
<p>当<code>autoAck</code>为true时，不启用显式消息确认机制，消息分发出去即为确认完毕。<code>autoAck</code>为false时，启用上述的消息确认机制。</p>
<p>消费者端发送ACK消息可以通过在回调函数中调用Channel的<code>basicAck</code>方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<p>其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Acknowledge one or several received</div><div class="line">     * messages. Supply the deliveryTag from the &#123;<span class="doctag">@link</span> com.rabbitmq.client.AMQP.Basic.GetOk&#125;</div><div class="line">     * or &#123;<span class="doctag">@link</span> com.rabbitmq.client.AMQP.Basic.Deliver&#125; method</div><div class="line">     * containing the received message being acknowledged.</div><div class="line">     * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Basic.Ack</div><div class="line">     * <span class="doctag">@param</span> deliveryTag the tag from the received &#123;<span class="doctag">@link</span> com.rabbitmq.client.AMQP.Basic.GetOk&#125; or &#123;<span class="doctag">@link</span> com.rabbitmq.client.AMQP.Basic.Deliver&#125;</div><div class="line">     * <span class="doctag">@param</span> multiple true to acknowledge all messages up to and</div><div class="line">     * including the supplied delivery tag; false to acknowledge just</div><div class="line">     * the supplied delivery tag.</div><div class="line">     * <span class="doctag">@throws</span> java.io.IOException if an error is encountered</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>WARNING</strong>：使用的时候千万不要忘了调用<code>basicAck</code>方法！必要的时候可以对Consumer类再做一层封装。</p>
</blockquote>
<h2 id="简单的消息持久化(Message_durability)">简单的消息持久化(Message durability)</h2><p>RabbitMQ的消息确认机制保证了即使消费者端挂了，我们的消息也可以被顺利处理。然而，如果碰上意外情况，Broker（RabbitMQ Server）挂了（比如意外重启），这种情况下不做任何设置的话，我们的信息仍然会丢失。好在，RabbitMQ同样提供了消息持久化的功能。</p>
<p>首先，我们需要保证我们的消息队列可以持久化，方法上面已经提到过，就是将<code>queueDeclare</code>方法的<code>durable</code>标志位设为true。</p>
<p>然后，我们需要在发布消息的时候通过设置<code>basicPublish</code>方法的<code>props</code>参数为<code>PERSISTENT_TEXT_PLAIN</code>来实现消息可持久化，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">channel.basicPublish(<span class="string">""</span>, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,</div><div class="line">                message.getBytes(<span class="string">"UTF-8"</span>));</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：尽管设置了消息可持久化，但这并不能完全保证消息就一定可以存储到磁盘里。RabbitMQ存在一段时间，接受了一个消息但还没来得及存储。并且，RabbitMQ不一定对所有消息都做fsync（即同步内存中的消息到硬盘），有些消息可能只是被缓存而不会被持久化。因此，<strong>这种消息持久化机制是不可靠的</strong>，特别是对大型项目。如果需要可靠的消息持久化，可以使用 <strong>publisher confirm</strong>。</p>
</blockquote>
<h1 id="Exchange">Exchange</h1><p>在RabbitMQ中，producer并不是直接将消息发送到message queue中，而是将它传递给一种叫exchage的结构。顾名思义，exchange用于交换消息，它接受publisher发送的消息，并按照一定的策略传递给下层的消息队列，最后传递到对应的subscriber中。Exchange有好几种：<code>direct</code>, <code>topic</code>, <code>headers</code>, <code>fanout</code>等，分别对应不同的消息分发策略。</p>
<p>在消费者一端，我们需要通过<code>queueBind</code>函数将消息队列绑定到对应的exchange上；如果没有绑定，则RabbitMQ会给其指定一个匿名exchage（即上面生产者-消费者模型中的exchange）。</p>
<h1 id="发布/订阅模型">发布/订阅模型</h1><p>发布-订阅模型也是一种典型的消息模型，它相当于一个“一对多”模型，也就是说publisher可以向多个subscriber发送消息。我们可以用下面的图来表示这种模型：</p>
<p><img src="http://www.rabbitmq.com/img/tutorials/exchanges.png" alt=""></p>
<p>在RabbitMQ中，我们可以通过exchange来实现发布-订阅模型。我们需要在订阅者一端将期望接收消息的队列绑定到我们定义的exchange上（最简单的<code>fanout</code>广播类型即可），然后在发布者端将消息发布至定义的exchange上即可。</p>
<h1 id="路由与模式匹配">路由与模式匹配</h1><p>RabbitMQ还支持路由模式，即像路由那样根据path来分派消息，只要在<code>queueBind</code>函数中指定感兴趣的<code>routingKey</code>即可。路由模式下我们一般使用<code>direct</code>类型的exchange，它会将与队列binding key匹配的消息分发到指定的队列中。</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt=""></p>
<p>当然如果我们需要根据path的模式来匹配的话，我们可以使用<code>topic</code>类型的exchange，它可以用于匹配多种pattern下的path并且分发消息。</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/python-five.png" alt=""></p>
<h1 id="RPC">RPC</h1><p>消息队列可以用来实现RPC。我们可以利用消息队列的API封装一个RPC代理类，调用端在通过RPC Proxy调用方法时，调用端会将调用方法的元数据（名称，参数等）包装成一条消息，然后通过相应的消息队列发送至集群的另一节点中，被调用者接收到此消息，将其解码后在本地进行方法调用(LPC)。如果需要返回结果，那么被调用端在方法调用完毕后将结果包装成消息，通过消息队列再发送回调用端即可。这就是用消息队列实现RPC的一般思路。</p>
<p>在RabbitMQ中，实现RPC的思路比较简单：使用两个队列，分别处理调用请求及调用回复即可：</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/python-six.png" alt=""></p>
<p>注意RPC的调用时间可能会比较长（受到网络、本地调用执行时间等因素影响），因此可能会阻塞执行线程，这也是RPC为人诟病的一点。我们可以对其稍加改造，改成异步模式，这样会使整个系统更加灵活。</p>
<h1 id="与其他消息队列的对比">与其他消息队列的对比</h1><blockquote>
<p>TODO: 待分析；后面有时间研究研究ZeroMQ和Kafka的设计及实现。</p>
</blockquote>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="https://www.rabbitmq.com/documentation.html" target="_blank" rel="external">Documentation - RabbitMQ</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[不动点组合子 | Y Combinator]]></title>
      <url>http://www.sczyh30.com/posts/Functional-Programming/y-combinator/</url>
      <content type="html"><![CDATA[<p>在现代编程语言中，函数都是具名的，而在传统的Lambda Calculus中，函数都是没有名字的。这样就出现了一个问题 —— 如何在Lambda Calculus中实现递归函数，即匿名递归函数。Haskell B. Curry发现了一种不动点组合子 —— Y Combinator，用于解决匿名递归函数实现的问题。</p>
<h1 id="Fixed-point_combinator">Fixed-point combinator</h1><p>我们先来看看不动点组合子的定义。不动点组合子(fixed-point combinator)是一个满足以下等式的高阶函数$y$：</p>
<p>$$\forall f, \ y \ f = f \ (y \ f)$$</p>
<p>如果令 $x = f \ x$，那么这其实就是一个求解函数不动点的问题：</p>
<p>$$x = f \ x$$</p>
<h1 id="Y_Combinator">Y Combinator</h1><p>那么不动点组合子有什么用呢？假设我们想要求阶乘，我们通常会用递归来实现：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">factorial</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></div><div class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">0</span></div><div class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>在上面的例子中，<code>factorial</code>函数体里面引用了自身。用pseudo lambda calculus可以表示为：</p>
<p>$$f = \lambda n. \ if \ (n == 0) \ 0 \ else \ n * f(n - 1)$$</p>
<p>但是Lambda演算中函数是没有名字的，所以这个地方是没法在函数体内调用f的。那怎么处理呢？我们可以通过某种“黑魔法”实现间接递归 —— 把自己算出来。我们不妨假设一个函数<code>self</code>代表一个“Lambda Calculus中真正的”递归函数，则上式可以改写为：</p>
<p>$$f = \lambda n. \ if \ (n == 0) \ 0 \ else \ n * self(n - 1)$$</p>
<p>我们现在把<code>self</code>函数参数化，设此函数为<code>G</code>：</p>
<p>$$G = \lambda n \ \lambda g. \ if \ (n == 0) \ 0 \ else \ n * g(n - 1)$$</p>
<p>应用 $\beta-reduction$，我们会发现：</p>
<p>$$G \ f = \lambda n. \ if \ (n == 0) \ 0 \ else \ n * f(n - 1)$$</p>
<p>即 $G \ f = f$。</p>
<p>然而这还不够，这里就需要引入不动点组合子了。假设不动点组合子 $Y = \lambda \ f. f (Y \ f)$，且 $f = Y \ G$，那么 $Y G = G (Y \ G) = G \ f = f$，这就表示出<code>f</code>来了！</p>
<p>所以我们需要找到一个与 $Y$ 等效的闭合Lambda表达式，其中最著名的就是Curry发现的 <strong>Y Combinator</strong>:</p>
<p>$$Y = \lambda f. (\lambda x . f \ (x \ x)) (\lambda x. f \ (x \ x))$$</p>
<p>通过 $\beta-reduction$ 验证：</p>
<p>$$Y \ g = \lambda f. (\lambda x . f \ (x \ x)) (\lambda x. f \ (x \ x)) \ g$$</p>
<p>$$= (\lambda x. g \ (x \ x)) (\lambda x. g \ (x \ x)$$</p>
<p>$$= g \ ((\lambda x. g \ (x \ x) \ (\lambda x. g \ (x \ x))$$</p>
<p>$$= g \ (Y \ g)$$</p>
<p>一颗赛艇！至于Y Combinator是如何推出来的，可以参考 <a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank" rel="external">康托尔、哥德尔、图灵——永恒的金色对角线</a> 这篇文章，写的非常完美。</p>
<h1 id="Haskell实现">Haskell实现</h1><p>我们先尝试直接用函数表示：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">fix</span> f = (\x -&gt; f (x x)) (\x -&gt; f (x x))</div></pre></td></tr></table></figure>
<p>GHC会提示错误：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;interactive&gt;:<span class="number">6</span>:<span class="number">25</span>:</div><div class="line">    <span class="type">Occurs</span> check: cannot construct the infinite <span class="class"><span class="keyword">type</span>: r0 ~ r0 -&gt; t</span></div><div class="line">    <span class="type">Expected</span> <span class="class"><span class="keyword">type</span>: r0 -&gt; t</span></div><div class="line">      <span class="type">Actual</span> <span class="class"><span class="keyword">type</span>: (<span class="title">r0</span> -&gt; <span class="title">t</span>) -&gt; t</span></div><div class="line">    <span class="type">Relevant</span> bindings include</div><div class="line">      x :: (r0 -&gt; t) -&gt; t (bound at &lt;interactive&gt;:<span class="number">6</span>:<span class="number">15</span>)</div><div class="line">      f :: t -&gt; t (bound at &lt;interactive&gt;:<span class="number">6</span>:<span class="number">9</span>)</div><div class="line">      fix :: (t -&gt; t) -&gt; t (bound at &lt;interactive&gt;:<span class="number">6</span>:<span class="number">5</span>)</div><div class="line">    <span class="type">In</span> the first argument <span class="keyword">of</span> ‘x’, namely ‘x’</div><div class="line">    <span class="type">In</span> the first argument <span class="keyword">of</span> ‘f’, namely ‘(x x)’</div></pre></td></tr></table></figure>
<p>这里的问题在于<code>x</code>的类型是infinite type，无法在Haskell表示出来(Hindley–Milner类型系统的限制)。参考Reddit上的解决方案，我们需要绕个弯，定义一个<code>Mu</code>算子来绕过类型检查：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Mu</span> a = <span class="type">Mu</span> (<span class="type">Mu</span> <span class="title">a</span> -&gt; <span class="title">a</span>)</span></div><div class="line"></div><div class="line"><span class="title">y</span> f -&gt; (\h -&gt; h $ <span class="type">Mu</span> h) (\x -&gt; f . (\(<span class="type">Mu</span> g) -&gt; g) x $ x)</div></pre></td></tr></table></figure>
<p>当然还有个更加贴近Y Combinator原本意思的实现：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Mu</span> f = <span class="type">Mu</span> &#123;<span class="title">unMu</span> :: <span class="title">f</span> (<span class="type">Mu</span> <span class="title">f</span>)&#125;</span></div><div class="line"><span class="title">unfold</span> = unMu</div><div class="line"><span class="title">fold</span>   = <span class="type">Mu</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">X'</span> b a = &#123;<span class="title">unX</span> :: <span class="title">a</span> -&gt; <span class="title">b</span>&#125;</span></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="type">X</span> a = <span class="type">Mu</span> (<span class="type">X</span>' <span class="title">a</span>)</span></div><div class="line"></div><div class="line"><span class="title">unfold'</span> = unX  . unfold</div><div class="line"><span class="title">fold'</span>   = fold . <span class="type">X'</span></div><div class="line"><span class="title">y</span> f = (\x -&gt; f (unfold' x x)) $ fold' (\x -&gt; f (unfold' x x))</div></pre></td></tr></table></figure>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank" rel="external">康托尔、哥德尔、图灵——永恒的金色对角线</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fixed-point_combinator" target="_blank" rel="external">Fixed-point combinator in Wikipedia</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/3a78zh/implementing_a_ycombinator_in_haskell/" target="_blank" rel="external">Implementing a YCombinator in Haskell</a></li>
<li><a href="http://jozefg.bitbucket.org/posts/2013-11-09-iso-recursive-types.html" target="_blank" rel="external">Fixpoints and Iso-recursive Types</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Haskell学习笔记 | 范畴论与Haskell（基础篇）]]></title>
      <url>http://www.sczyh30.com/posts/Functional-Programming/haskell-category-basic/</url>
      <content type="html"><![CDATA[<p>最近入了Haskell的坑了。俗话说得好，一入FP深似海，从此Monad皆是自函子范畴上的幺半群。。。本篇文章主要总结范畴论基础。。。</p>
<h1 id="Category">Category</h1><p>一个<strong>范畴</strong> $C$ 由以下三部分组成：</p>
<ul>
<li>一些<strong>对象</strong>(object)构成的类 $ob(C)$</li>
<li>范畴 $C$ 中对象之间的映射，称为 <strong>态射</strong>(morphism)。对于范畴 $C$ 中任意两个object $A$、$B$，所有的 $A \to B$ 态射的集合用 $hom(A, B)$ 表示，其中 $A$ 称为domain，$B$称为codomain</li>
<li>态射的复合运算($\circ$)，用于将多个态射进行复合。比如 $f: \ A \to B$, $g: \ B \to C$，则$g \circ f: \ A \to C$</li>
</ul>
<p>对范畴中的每一个object $X$，都存在对应的幺元 $id_{X}: X \to X$ ，并且满足关系：</p>
<p>$$ id(B) \circ f = f = f \circ id(A) $$</p>
<p>同时，复合运算是可结合的，比如 $ (h \circ g) \circ f = h \circ (g \circ f) $。</p>
<p>在Haskell中，对应的是：</p>
<ul>
<li>object对应着某个具体的函数（<em>类型？</em>）（这是我的理解，也有很多人认为对象对应着某一类值的集合，即类型。我的理解是<strong>type和type constructor都可以看作是function</strong>）</li>
<li>态射对应着函数之间的映射，这种映射产生新的函数。比如 $f :: (a \to b) \to a \to b$</li>
<li>态射的复合运算代表着函数的复合（复合函数），比如 <code>h = f . g</code></li>
</ul>
<h1 id="Functor">Functor</h1><p>在范畴论中，morphism是object与object之间的映射。那么肯定还有category与category之间的映射，这称为函子（Functor）。</p>
<p>既然是范畴之间的映射，那么函子F的作用就有两个：</p>
<ul>
<li>将范畴C的object($X$)映射到范畴D的object ($F(X)$)</li>
<li>将范畴C的morphism($f: \ X \to Y$)映射到范畴D的morphism($F(f) : \ F(x) \to F(Y)$)</li>
</ul>
<p>并且需要满足两个条件：</p>
<ul>
<li>单位态射关系：$\forall X \in C, F(id_{X}) = id_{F(X)}$</li>
<li>分配率：$\forall f:X \to Y, g: Y \to Z \in C, F(g \circ f) = F(g) \circ F(f)$</li>
</ul>
<p>一般的函子都是协变函子(covariant functor)。将函子中的某个范畴 $C$ 替换为其对偶范畴 $C^{OP}$ 即可得到逆变函子(contravariant functor): $F \ : \ C^{OP} \to D$。</p>
<p>将范畴映射到自身的函子称为自函子(endofunctor)，即把范畴C的对象和态射映射到自身。自函子反映了范畴内部的自相似性。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/catagory-functor-wk1.png" alt="Functor"></p>
<p>在Haskell中，Functor是一个 <strong>typeclass</strong>，它是这样定义的:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></div><div class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</div></pre></td></tr></table></figure></p>
<p>其中f是一个 <strong>type constructor</strong>，它接收一个concrete type（实际类型）以构造出一个concrete type，其kind为<code>* -&gt; *</code>。</p>
<p>如果这里的object对应Haskell里的类型的话，那么type constructor相当于morphism，它就是自函子的一部分，即一个范畴的object与另一个范畴的object的映射。</p>
<p>类型与类型的映射一般都是简单类型与复杂类型之间的相互转化，比如<code>int -&gt; Maybe int</code>。而另一部分，即态射与态射之间的映射，其实就是高阶函数（函数与函数之间的映射，因为态射本身就对应Haskell中的函数），在Haskell的Functor里面对应的就是fmap，它将态射<code>a -&gt; b</code>映射为另一个态射<code>f a -&gt; f b</code>:</p>
<p>$$(a \to b) \to f \ a \to f \ b$$</p>
<h1 id="Bifunctor">Bifunctor</h1><p>Bifunctor(二元函子)与普通的Functor区别之处在于Bifunctor的domain为两个范畴的积，比如 $F: \ C_{1} \times C_{2} \to D$。</p>
<h1 id="Hom-functor">Hom-functor</h1><p>对于一个范畴 $C$，其 <strong>hom-functor</strong> 的定义为：$Hom(-,-) : \ C^{OP} \times C \to Set$，它是一个bifunctor。</p>
<p>从hom-functor中衍生出的两个函子：</p>
<ul>
<li>covariant hom-functor: $Hom(A, -): \ C \to Set$，通常称为 <strong>copresheaf</strong></li>
<li>contravariant hom-functor: $Hom(-, A): \ C^{OP} \to Set$，通常称为 <strong>presheaf</strong></li>
</ul>
<h1 id="Representable_functor">Representable functor</h1><p>若函子 $F: \ C \to Set$ <a href="https://ncatlab.org/nlab/show/natural+isomorphism" target="_blank" rel="external">自然同构</a>于 $Hom(A, -)$，其中 $A \in C$，则 $F$ 就是一个Representable functor。</p>
<p>相似地，若函子 $F: \ C^{OP} \to Set$ 自然同构于 $Hom(-, A)$，其中 $A \in C$，则 $F$ 就是一个Corepresentable functor。</p>
<blockquote>
<p>注：Forgetful functors to $Set$ are very often representable.</p>
</blockquote>
<h1 id="Adjoint_functor">Adjoint functor</h1><p>若有两个函子 $F: \ D \to C$ 以及 $G : \ C \to D$ 满足以下自然同构关系：</p>
<p>$$Hom_{C}(F(-), -) \cong Hom_{D}(-, G(-))$$</p>
<p>即对于 $\forall X \in C, Y \in D$，满足：</p>
<p>$$Hom_{C}(F(Y), X) \cong Hom_{D}(Y, G(X))$$</p>
<p>那么这两个函子就是一对伴随函子(<a href="https://ncatlab.org/nlab/show/adjoint+functor" target="_blank" rel="external">adjoint functor</a>)，并称F是G的左伴随函子，记为 $F \dashv G$。</p>
<ul>
<li>常见的一对伴随函子：Forgetful Functor/Free Functor。$Forget : \ C \to Set$，$Free : \ Set \to C$，$Free \dashv Forget$。</li>
</ul>
<h1 id="Natural_Transformation">Natural Transformation</h1><p>再抽象一层，自然变换(Natural Transformation)是Functor之间的映射关系。</p>
<p>假设 $F$ 和 $G$ 是范畴 $C$ 到范畴 $D$ 的函子 $C \to D$，则 $F$ 到 $G$的自然变换 $\tau : F \to G$ 是一个作用于 $C$ 中任意对象 $X$ 的 D-morphism ：$\tau_{X} : F X \to G X$，且满足以下naturality condition(用交换图表示)：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/natural-transformation-condition.png" alt="Natural Transformation"></p>
<h1 id="Monad">Monad</h1><p>这里先总结一下Monad的范畴论定义。Monad由三元组 $&lt;T, \eta, \mu&gt;$ 构成。其中:</p>
<ul>
<li>$T$ 为范畴 $X$ 上的自函子： $T: X \to X$</li>
<li>$\eta$ 为单位自函子 $id_{X}$ 到函子 $T$ 的自然变换：$\eta: id_{X} \to T$</li>
<li>$\mu$ 为函子 $T$ 的张量积 $T \circ T$ 到函子 $T$ 的自然变换：$\mu: T \circ T \to T$</li>
</ul>
<p>同时它需要满足以下coherence condition：</p>
<ul>
<li>$\mu \circ T \mu = \mu \circ \mu T$ (即自然变换 $T^{3} \to T$)</li>
<li>$\mu \circ T \eta = \mu \circ \eta T = 1_{T}$ (即自然变换 $T \to T$)</li>
</ul>
<p>用交换图表示如下：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/Monad_multiplication_explicit_wiki.png" alt="Monad coherence condition"></p>
<blockquote>
<p>注1：此处函子的张量积 $\otimes$ 可以看作为<strong>组合</strong>(composition)。</p>
<p>注2：注意结合 <strong>Monoidal Category</strong> 理解；注意里面的Monoid与抽象代数中幺半群的区别。</p>
</blockquote>
<h1 id="TODO">TODO</h1><ul>
<li>Monoidal Category/Monoidal Functor</li>
<li>Monad的来源、推导</li>
<li>Kleisli范畴下Monad的定义</li>
<li>Free Monad</li>
<li>Yoneda Lemma</li>
<li>Yoneda Embedding/Profunctor</li>
<li>Day Convolution</li>
<li>Kan Extensions</li>
<li>Universal Construction</li>
</ul>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li>Jiri Adamek, Horst Herrlich, George Strecker. <em>Abstract and Concrete Categories: The Joy of Cats.</em></li>
<li>Saunders Mac Lane. <em>Categories for the Working Mathematician.</em></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Category_theory" target="_blank" rel="external">Haskell/Category theory - Wikibooks</a></li>
<li><a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-issue" target="_blank" rel="external">A monad is just a monoid in the category of endofunctors, what’s the issue? - StackOverflow</a></li>
<li><a href="https://ncatlab.org/nlab/show/hom-functor" target="_blank" rel="external">hom-functor - nLab</a></li>
<li><a href="http://www.haskell.org/haskellwiki/Typeclassopedia" target="_blank" rel="external">Typeclassopedia - Haskell Wiki</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 事件分发机制总结]]></title>
      <url>http://www.sczyh30.com/posts/Android/android-event-dispatcher/</url>
      <content type="html"><![CDATA[<h1 id="事件构成">事件构成</h1><p>在Android中，事件主要包括点按、长按、拖拽、滑动等，点按又包括单击和双击，另外还包括单指操作和多指操作。所有这些都构成了Android中的事件响应。总的来说，所有的事件都由如下三个部分作为基础：</p>
<ul>
<li>按下（ACTION_DOWN）</li>
<li>移动（ACTION_MOVE）</li>
<li>抬起（ACTION_UP）</li>
</ul>
<p>所有的操作事件首先必须执行的是按下操作（ACTION_DOWN）。</p>
<h1 id="Android事件分发机制">Android事件分发机制</h1><p>Android事件分发是先传递到<code>ViewGroup</code>，再由<code>ViewGroup</code>传递到<code>View</code>的。</p>
<h2 id="对于View：">对于View：</h2><p>大体流程：触摸动作发生 =&gt; 调用<code>dispatchTouchEvent</code>方法 =&gt; 首先调用<code>onTouch</code>方法</p>
<p>若同时满足：绑定了<code>OnClickListener</code>、控件可用(<code>enabled</code>)、<code>onTouch</code>方法返回<code>true</code>，则<code>dispatchTouchEvent</code>方法将直接返回<code>true</code>，不会调用<code>onTouchEvent</code>方法。</p>
<p>这是最新的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="comment">// If the event should be handled by accessibility focus first.</span></div><div class="line">        <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</div><div class="line">            <span class="comment">// We don't have focus or no virtual descendant has it, do not handle the event.</span></div><div class="line">            <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// We have focus and got the event, then use normal event dispatch.</span></div><div class="line">            event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">            mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</div><div class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            <span class="comment">// Defensive cleanup for new gesture</span></div><div class="line">            stopNestedScroll();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">                result = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">                result = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></div><div class="line">        <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span></div><div class="line">        <span class="comment">// of the gesture.</span></div><div class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</div><div class="line">                actionMasked == MotionEvent.ACTION_CANCEL ||</div><div class="line">                (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</div><div class="line">            stopNestedScroll();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>否则，将会继续调用<code>onTouchEvent</code>方法。并且可以推断，<code>onClick</code>方法也是在<code>onTouchEvent</code>方法中调用的。</p>
<h2 id="对于ViewGroup">对于ViewGroup</h2><ol>
<li>Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View的。</li>
<li>在ViewGroup中可以通过<code>onInterceptTouchEvent</code>方法对事件传递进行拦截，<code>onInterceptTouchEvent</code>方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</li>
<li>子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。</li>
</ol>
<h1 id="总结">总结</h1><ol>
<li>Android中事件<strong>按照从上到下的顺序进行层级传递</strong>，事件处理从Activity开始到ViewGroup再到View</li>
<li>事件传递方法包括<code>dispatchTouchEvent</code>、<code>onTouchEvent</code>、<code>onInterceptTouchEvent</code>，其中前两个是<code>View</code>和<code>ViewGroup</code>都有的，最后一个是只有ViewGroup才有的方法。这三个方法的作用分别是负责事件分发、事件处理、事件拦截</li>
<li><code>onTouch</code>事件要先于<code>onClick</code>事件执行，<code>onTouch</code>在事件分发方法<code>dispatchTouchEvent</code>中调用，而<code>onClick</code>在事件处理方法<code>onTouchEvent</code>中被调用，<code>onTouchEvent</code>要后于<code>dispatchTouchEvent</code>方法的调用</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android View 视图绘制总结]]></title>
      <url>http://www.sczyh30.com/posts/Develop/android-view-draw-notes/</url>
      <content type="html"><![CDATA[<h1 id="LayoutInflater的作用">LayoutInflater的作用</h1><p><code>LayoutInflater</code>用于将xml文件（layout布局文件）解析成View。对最外层的layout来说，<code>layout_height</code>和<code>layout_width</code>都是没有用的。在进行<code>setContentView</code>时，系统会自动在外边加一个<code>FrameLayout</code>。</p>
<h1 id="View的绘制">View的绘制</h1><p>三个主要阶段：<code>onMeasure()</code>、<code>onLayout()</code>和<code>onDraw()</code>。</p>
<ul>
<li><code>onMeasure</code>：测量视图大小</li>
<li><code>onLayout</code>：给视图布局，即确定视图位置</li>
<li><code>onDraw</code>：对图像进行绘制（在Canvas对象上进行）</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android MVP架构重构实践]]></title>
      <url>http://www.sczyh30.com/posts/Android/android-refactor-mvp/</url>
      <content type="html"><![CDATA[<p>我们之前的架构就是普通的MVC架构。由于各种layout文件职责单一，因此Activity经常也作为Controller层，这样可能会堆出一个几千行的Activity，看起来就很爽。。因此，这次总结项目时便计划用更好的MVP架构和MVVM架构来重构项目。</p>
<p>为了简便起见，就拿<code>LoginActivity</code>来练手吧，这还属于逻辑比较简单的。。这是原登录逻辑的大概代码（省略了大量逻辑）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.et_username)</div><div class="line">    EditText etUserName;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.et_password)</div><div class="line">    EditText etPassword;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String mUserName = <span class="string">""</span>;</div><div class="line">    <span class="keyword">private</span> String mPassword = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> R.layout.activity_login;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (item.getItemId()) &#123;</div><div class="line">            <span class="keyword">case</span> android.R.id.home:</div><div class="line">                onBackPressed();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasBackButton</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getActionBarTitle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> R.string.login;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@OnClick</span>(&#123;R.id.btn_login, R.id.iv_qq_login, R.id.iv_wx_login, R.id.iv_sina_login&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> id = v.getId();</div><div class="line">        <span class="keyword">switch</span> (id) &#123;</div><div class="line">            <span class="keyword">case</span> R.id.btn_login:</div><div class="line">                handleLogin();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.iv_qq_login:</div><div class="line">                qqLogin();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.iv_wx_login:</div><div class="line">                wxLogin();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.iv_sina_login:</div><div class="line">                sinaLogin();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">okForLogin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!DeviceUtil.hasInternet()) &#123;</div><div class="line">            ToastUtil.toast(R.string.tip_no_internet);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        ....</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BaseJsonHttpResponseHandler mHandler = <span class="keyword">new</span> BaseJsonHttpResponseHandler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">int</span> statusCode, Header[] headers, String rawJsonResponse, Object response)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(response != <span class="keyword">null</span>) &#123;</div><div class="line">                handleLoginResult((LoginResult)response);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Header[] headers, Throwable throwable, String rawJsonData, Object errorResponse)</span> </span>&#123;</div><div class="line">            ToastUtil.toast(<span class="string">"网络出现错误，请重试。("</span> + statusCode + <span class="string">")"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">parseResponse</span><span class="params">(String rawJsonData, <span class="keyword">boolean</span> isFailure)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            <span class="keyword">return</span> JsonUtil.resolveLoginResult(rawJsonData);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinish</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.onFinish();</div><div class="line">            hideWaitDialog();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLogin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!okForLogin())</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        mUserName = etUserName.getText().toString();</div><div class="line">        mPassword = etPassword.getText().toString();</div><div class="line"></div><div class="line">        hideKeyboard();</div><div class="line">        showWaitDialog(R.string.progress_login).show();</div><div class="line">        SamsaraAPI.login(mUserName, mPassword, mHandler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLoginResult</span><span class="params">(LoginResult result)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(result.getDataResult().isOK()) &#123;</div><div class="line">            ...</div><div class="line">            AppContext.getContext().saveUserInfo(result.getUser());</div><div class="line">            hideWaitDialog();</div><div class="line">            handleLoginSuccess();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            AppContext.getContext().cleanLoginInfo();</div><div class="line">            ToastUtil.showToast(<span class="string">"错误："</span> + result.getDataResult().getErrorMsg());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLoginSuccess</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        ToastUtil.toast(<span class="string">"登录成功"</span>);</div><div class="line">        finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">qqLogin</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wxLogin</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sinaLogin</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果登录逻辑很复杂（比如有很多种三方登录逻辑），那么Activity可能会比较臃肿。这时候就要减轻Activity的职责，把代码重构成MVP架构。这个时候Activity作为View层，而把主要业务逻辑放至Presenter层。Presenter层与View层的交互是通过接口实现的。<br><img src="http://img.blog.csdn.net/20151025002219889" alt="重构后的架构"><br>IBaseLoginService接口为普通登录接口，IThirdLoginService接口继承普通登录接口，也扩展作为三方扩展登录接口，登录逻辑的具体实现在LoginServiceImpl类里。<br>我们把登录接口设计成这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseLoginService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password, LoginResultCallback callback)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IThirdLoginService</span> <span class="keyword">extends</span> <span class="title">IBaseLoginService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wxLogin</span><span class="params">(String username, String password, LoginResultCallback callback)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qqLogin</span><span class="params">(String username, String password, LoginResultCallback callback)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">weiboLogin</span><span class="params">(String username, String password, LoginResultCallback callback)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们同时设计了登录的回调接口，用于处理登录成功或失败的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginResultCallback</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoginSuccess</span><span class="params">(LoginResult result)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> error_code)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们在LoginServiceImpl类里实现登录逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title">IThirdLoginService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">final</span> String username, <span class="keyword">final</span> String password, <span class="keyword">final</span> LoginResultCallback callback)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> BaseJsonHttpResponseHandler mHandler = <span class="keyword">new</span> BaseJsonHttpResponseHandler() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">int</span> statusCode, Header[] headers, String rawJsonResponse, Object response)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(response != <span class="keyword">null</span>) &#123;</div><div class="line">                    callback.onLoginSuccess((LoginResult)response);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Header[] headers, Throwable throwable, String rawJsonData, Object errorResponse)</span> </span>&#123;</div><div class="line">                callback.onFailure(statusCode);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">parseResponse</span><span class="params">(String rawJsonData, <span class="keyword">boolean</span> isFailure)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                <span class="keyword">return</span> JsonUtil.resolveLoginResult(rawJsonData);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                SamsaraAPI.login(username, password, mHandler);</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span>此处省略第三方登录逻辑</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wxLogin</span><span class="params">(String username, String password, LoginResultCallback callback)</span> </span>&#123;</div><div class="line">        LogUtil.toast(<span class="string">"微信API 接口未开放"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">qqLogin</span><span class="params">(String username, String password, LoginResultCallback callback)</span> </span>&#123;</div><div class="line">        LogUtil.toast(<span class="string">"QQ API 接口未开放"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weiboLogin</span><span class="params">(String username, String password, LoginResultCallback callback)</span> </span>&#123;</div><div class="line">        LogUtil.toast(<span class="string">"微博API 接口未开放"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，这里对网络的处理用了AsyncHttpClient库，以后也可以替换成Volley；SamsaraAPI是为此App设计的API类。到这里，如果后边三个三方实现比较臃肿的话，整个登录业务逻辑类就显得比较臃肿了，我思考了一下，再把三方逻辑的实现单列一个类，需要的时候继承？不过用继承也不是很好的方法，可以考虑用组合或者装饰模式来实现（此处留待想到更好的设计模式）。</p>
<p><strong>Addition</strong>：如果在登录之前需要对登录数据及环境进行处理，且处理逻辑比较多的话，我们可以借助AOP的思想，利用代理模式，将这些通用逻辑（横切面）与特定业务逻辑（纵面）分开，更好地解除耦合。如日志、数据校验之类的逻辑都属于通用逻辑；当然另一种方法就是封装成各种Util类，我这里采用了后一种方法。</p>
<p><img src="http://pic001.cnblogs.com/images/2012/1/2012040113391482.jpg" alt="MVC与MVP架构（图片来源于网络）"></p>
<p>接下来就是View层接口了。前边提到过，<strong>Presenter与View是通过接口进行交互的</strong>，因此这个View接口如何设计也至关重要。我这里考虑的是，对于我们的一个业务逻辑：</p>
<ul>
<li>此逻辑需要获取什么数据？</li>
<li>此逻辑进行时需要有什么表现？（比如进度条对话框）</li>
<li>逻辑执行的结果以及对UI的反馈？</li>
</ul>
<p>比如，对于登录逻辑，我们需要从UI中获取用户名和密码；登录请求发出后需要等待服务器响应，这段时间应该会显示等待对话框；登录响应后，返回登录成功或失败的信息，对应更新UI和数据，因此我设计成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBasicLoginView</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleLoginSuccess</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showWaiting</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hideWaiting</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">okForLogin</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后就是Presenter的设计了，Presenter与LoginService和LoginView使用组合模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> IThirdLoginService loginService;</div><div class="line">    <span class="keyword">private</span> IBasicLoginView loginView;</div><div class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginPresenter</span><span class="params">(IBasicLoginView loginView)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.loginView = loginView;</div><div class="line">        <span class="keyword">this</span>.loginService = <span class="keyword">new</span> LoginServiceImpl();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!loginView.okForLogin())</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        loginView.showWaiting();</div><div class="line">        loginService.login(loginView.getUsername(), loginView.getPassword(),</div><div class="line">                <span class="keyword">new</span> LoginResultCallback() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginSuccess</span><span class="params">(<span class="keyword">final</span> LoginResult result)</span> </span>&#123;</div><div class="line">                mHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        handleLoginResult(result);</div><div class="line">                        loginView.hideWaiting();</div><div class="line">                        loginView.handleLoginSuccess();</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> error_code)</span> </span>&#123;</div><div class="line">                ToastUtil.toast(<span class="string">"网络出现错误，请重试。("</span> + error_code + <span class="string">")"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLoginResult</span><span class="params">(LoginResult result)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">qqLogin</span><span class="params">()</span> </span>&#123;</div><div class="line">        loginService.qqLogin(<span class="string">""</span>, <span class="string">""</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wxLogin</span><span class="params">()</span> </span>&#123;</div><div class="line">        loginService.wxLogin(<span class="string">""</span>, <span class="string">""</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sinaLogin</span><span class="params">()</span> </span>&#123;</div><div class="line">        loginService.weiboLogin(<span class="string">""</span>, <span class="string">""</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后实现Activity：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> <span class="keyword">implements</span> <span class="title">IBasicLoginView</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.et_username)</div><div class="line">    EditText etUserName;</div><div class="line">    <span class="meta">@Bind</span>(R.id.et_password)</div><div class="line">    EditText etPassword;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> LoginPresenter presenter = <span class="keyword">new</span> LoginPresenter(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> R.layout.activity_login;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (item.getItemId()) &#123;</div><div class="line">            <span class="keyword">case</span> android.R.id.home:</div><div class="line">                onBackPressed();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasBackButton</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getActionBarTitle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> R.string.login;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@OnClick</span>(&#123;R.id.btn_login, R.id.iv_qq_login, R.id.iv_wx_login, R.id.iv_sina_login&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> id = v.getId();</div><div class="line">        <span class="keyword">switch</span> (id) &#123;</div><div class="line">            <span class="keyword">case</span> R.id.btn_login:</div><div class="line">                presenter.login();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.iv_qq_login:</div><div class="line">                presenter.qqLogin();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.iv_wx_login:</div><div class="line">                presenter.wxLogin();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.iv_sina_login:</div><div class="line">                presenter.sinaLogin();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">okForLogin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!DeviceUtil.hasInternet()) &#123;</div><div class="line">            ToastUtil.toast(R.string.tip_no_internet);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> etUserName.getText().toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> etPassword.getText().toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWaiting</span><span class="params">()</span> </span>&#123;</div><div class="line">        hideKeyboard();</div><div class="line">        showWaitDialog(R.string.progress_login).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideWaiting</span><span class="params">()</span> </span>&#123;</div><div class="line">        hideWaitDialog();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoginSuccess</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        ToastUtil.toast(<span class="string">"登录成功"</span>);</div><div class="line">        finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于这只是练手，原Activity逻辑也不算也别复杂（五百行左右），因此对架构进行重构后并没有看出开发上有什么便捷之处，但以后可能会有更为复杂的逻辑，若不进行适当的重构，Activity可能会超过1000行，特别臃肿，不利于扩展和调BUG。因此，使用MVP/MVVM架构，在一个大项目中是必不可少的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ STL之哈希表 | unordered_map]]></title>
      <url>http://www.sczyh30.com/posts/C-C/cpp-stl-hashmap/</url>
      <content type="html"><![CDATA[<p>C++ STL中，哈希表对应的容器是<code>unordered_map</code>（since C++ 11）。<br>根据C++ 11标准的推荐，用<code>unordered_map</code>代替<code>hash_map</code>。</p>
<h1 id="Prolouge">Prolouge</h1><p>先来回顾一下数据结构中哈希表相关的知识。<br>哈希表是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。<br>哈希表的一个重要问题就是如何解决映射冲突的问题。常用的有两种：<strong>开放地址法</strong> 和 <strong>链地址法</strong>。</p>
<h1 id="与map的区别">与map的区别</h1><p>STL中，map对应的数据结构是<strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 <strong>O(logN)</strong>。而unordered_map对应 <strong>哈希表</strong>，哈希表的特点就是查找效率高，时间复杂度为常数级别 <strong>O(1)</strong>， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用unordered_map容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用map容器。</p>
<h1 id="基本使用">基本使用</h1><p>unordered_map的用法和map大同小异，一个简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="built_in">map</span>;</div><div class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">1</span>, <span class="string">"Scala"</span>));</div><div class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">2</span>, <span class="string">"Haskell"</span>));</div><div class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">3</span>, <span class="string">"C++"</span>));</div><div class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">6</span>, <span class="string">"Java"</span>));</div><div class="line">    <span class="built_in">map</span>.insert(<span class="built_in">std</span>::make_pair(<span class="number">14</span>, <span class="string">"Erlang"</span>));</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator it;</div><div class="line">    <span class="keyword">if</span> ((it = <span class="built_in">map</span>.find(<span class="number">6</span>)) != <span class="built_in">map</span>.end()) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="使用自定义类">使用自定义类</h1><p>要使用哈希表，必须要有对应的计算散列值的算法以及判断两个值（或对象）是否相等的方法。<br>在Java中，Object类里有两个重要方法：<code>hashCode</code>和<code>equals</code>方法。其中<code>hashCode</code>方法便是为散列存储结构服务的，用来计算散列值；而<code>equals</code>方法则是用来判断两对象是否等价。由于所有的类都继承自<code>java.lang.Object</code>类，因此所有类相当于都拥有了这两个方法。</p>
<p>而在C++中没有自动声明这类函数，STL只为C++常用类提供了散列函数，因此如果想在<code>unordered_map</code>中使用自定义的类，则必须为此类提供一个哈希函数和一个判断对象是否相等的函数（e.g. 重载==运算符）。下面是一个简单示例（扒自数据结构上机作业的部分代码）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">using std::string;</div><div class="line">using std::cin;</div><div class="line">using std::cout;</div><div class="line">using std::endl;</div><div class="line">using std::unordered_map;</div><div class="line"></div><div class="line">class Person &#123;</div><div class="line">//private:</div><div class="line">//    string phone;</div><div class="line">//    string name;</div><div class="line">public:</div><div class="line">    string phone;</div><div class="line">    string name;</div><div class="line">    string address;</div><div class="line"></div><div class="line">    explicit Person() &#123;&#125;</div><div class="line">    explicit Person(string name, string phone, string address): name(name), phone(phone), address(address) &#123;&#125;</div><div class="line"></div><div class="line">    // overload operator==</div><div class="line">    bool operator==(const Person&amp; p) &#123;</div><div class="line">        return this-&gt;phone == p.phone &amp;&amp; this-&gt;name == p.name</div><div class="line">            &amp;&amp; this-&gt;address == p.address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    inline friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Person&amp; p) &#123;</div><div class="line">        os &lt;&lt; "[Person] -&gt; (" &lt;&lt; p.name &lt;&lt; ", " &lt;&lt; p.phone &lt;&lt; ", "</div><div class="line">           &lt;&lt; p.address &lt;&lt; ")";</div><div class="line">        return os;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// declare hash&lt;Person&gt;</div><div class="line">namespace std &#123;</div><div class="line"> template &lt;&gt;</div><div class="line"> struct hash&lt;Person&gt; &#123;</div><div class="line">     std::size_t operator()(const Person&amp; p) const &#123;</div><div class="line">      using std::size_t;</div><div class="line">      using std::hash;</div><div class="line">      using std::string;</div><div class="line">      // Compute individual hash values for first,</div><div class="line">      // second and third and combine them using XOR</div><div class="line">      // and bit shifting:</div><div class="line">      return ((hash&lt;string&gt;()(p.phone)</div><div class="line">        ^ (hash&lt;string&gt;()(p.name) &lt;&lt; 1)) &gt;&gt; 1)</div><div class="line">        ^ (hash&lt;string&gt;()(p.address) &lt;&lt; 1);</div><div class="line">     &#125;</div><div class="line"> &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">unordered_map&lt;string, Person&gt; phoneMap;</div><div class="line"></div><div class="line">void selectByPhone() &#123;</div><div class="line">    string phone;</div><div class="line">    cout &lt;&lt; "Input the phone number: "; cin &gt;&gt; phone;</div><div class="line">    unordered_map&lt;string, Person&gt;::iterator it;</div><div class="line">    int size = phoneMap.size();</div><div class="line">    for(int pc = 0; pc &lt; size; pc++) &#123;</div><div class="line">        if((it = phoneMap.find(phone)) != phoneMap.end()) &#123;</div><div class="line">            cout &lt;&lt; "\033[32mQuery result: " &lt;&lt; it-&gt;second &lt;&lt; "\033[0m" &lt;&lt; endl;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; "\033[33mQuery result : target_not_found\033[0m" &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于哈希值如何计算，前面我写过一篇文章专门介绍这个：<a href="http://www.sczyh30.com/posts/Java/java-hashcode-equal">hashCode方法及equals方法的规范</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android应用性能优化总结]]></title>
      <url>http://www.sczyh30.com/posts/Android/android-performance-1/</url>
      <content type="html"><![CDATA[<p>在移动端内存非常宝贵，我们要尽可能地去优化内存以达到最佳性能，并努力地去避免OOM问题。这篇文章总结一些最常见的Android性能优化的一些事项~</p>
<hr>
<h1 id="图片加载">图片加载</h1><p>在移动端，图片的加载往往是最消耗内存的，OOM也经常会发生在加载图片时。以下是加载图片的几个注意事项：</p>
<ul>
<li>按需要的大小加载。缩略图加载成原图的精细度并不会提升视觉上的效果，但会额外占用不少内存。</li>
<li>图片的缓存使用<code>LruCache</code>，并且合理地设置缓存大小</li>
<li>可以用一些高效的图片加载库，比如Facebook的Fresco</li>
</ul>
<h1 id="注意一些额外的内存消耗">注意一些额外的内存消耗</h1><ul>
<li>应特别注意HashMap这个数据结构，必要的时候可以用<code>SparseArray</code>等等的数据结构代替以节省内存</li>
<li>需要频繁修改字符串的地方考虑用<code>StringBuilder</code>代替<code>String</code></li>
<li>避免创建无用的实例</li>
</ul>
<h1 id="有限度地使用Service">有限度地使用Service</h1><p>当我们启动一个<code>Service</code>时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p>
<p>因此，控制好Service的生命周期是很重要的。切忌一个无用的Service跑在后台，这会非常影响性能。如果一个逻辑只需要进行一次，那么可以用<code>IntentService</code>代替。</p>
<h1 id="Handler必须为静态内部类">Handler必须为静态内部类</h1><p>首先复习一下Java几种内部类的语言规范，Java中的<strong>inner class</strong>（内部类）定义在一个类的内部，它有一个<strong>指向外部类的引用</strong>。这就有可能导致一个问题，其外部类的生命周期已经结束，而由于inner class持有外部类的引用，并且inner class与其它对象还有引用关联，因此GC进行可达性分析时发现内部类与外部类仍有引用关系，因此不会cause GC，从而导致内存泄露。<br>而<strong>static nested class</strong>（静态内部类）虽定义在类的内部，但是它<strong>不持有外部类的引用</strong>，只能访问外部类的静态实例和方法。</p>
<p>在安卓开发中，一个典型的例子是<code>Handler</code>的使用，它会有这样的问题：</p>
<blockquote>
<p>In Android, Handler classes should be static or leaks might occur. Messages enqueued on the application thread’s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class.</p>
</blockquote>
<p>这句话的主旨就是，<code>Handler</code>类必须声明为静态（内部）类（static nested class），否则可能会发生内存泄露。因为，进入<code>MessageQueue</code>的<code>Message</code>会持有它们目标<code>Handler</code>的引用；这就可能出现一种情况，一个消息还在排队，而此时目标<code>Handler</code>类所对应的外部类的生命周期已到<code>onDestroy</code>，即将被GC，但由于目标<code>Handler</code>类仍持有其外部类的引用，使得外部类不能被回收，从而导致内存泄露。这一点说明了<strong>Handler类型的对象，生命周期是未知的</strong>。</p>
<p>然而如果声明为static，又会有许多不方便的地方，比如很多逻辑需要访问外部类的非静态变量和非静态方法。此时，我们应该使用外部类的<strong>弱引用</strong>（WeakReference），举例表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;DeviceUserFragment&gt; mFragment;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(DeviceUserFragment fragment)</span> </span>&#123;</div><div class="line">            mFragment = <span class="keyword">new</span> WeakReference&lt;&gt;(fragment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">            Object object = msg.obj;</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> HWServiceConfig.GET_DEVICE_USER_INFO:</div><div class="line">                    mFragment.get().mInfo = (DataUserInfo)object;</div><div class="line">                    mFragment.get().isInfoOK = <span class="keyword">true</span>;</div><div class="line">                    mFragment.get().updateUI();</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里顺便复习一下JVM中的四种引用的知识吧（直接扒的以前自己的文章）：</p>
<ul>
<li><strong>StrongReference</strong>（强引用）是最普通的引用类型，只要强引用存在，GC就不会进行垃圾回收。</li>
<li><strong>SoftReference</strong>（软引用）用来描述一些有用但是非必需的对象。如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM就会把这个软引用加入到与之关联的引用队列中。软引用可用来实现内存敏感的高速缓存。</li>
<li><strong>WeakReference</strong>（弱引用）是一种生命周期比软引用更短的引用。当GC扫描启动时，只要扫描到只具有弱引用的对象，<strong>无论内存是否够用都会执行GC</strong>；但由于GC线程优先级很低，因此并不一定能迅速发现这些弱引用对象。弱引用也可以和一个引用队列联合使用。</li>
<li><strong>PhantomReference</strong>（虚引用）不同于其余三种引用，虚引用不会影响对象的生命周期，也无法通过虚引用获得对象的一个实例；如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动，它必须和引用队列联合使用。</li>
</ul>
<p>明白了弱引用的生命周期，此处想必就很好理解了。构造一个外部类的弱引用，然后通过<code>get</code>方法获得其实例进行操作即可，既避免了内存泄露，又可以自由地调用外部类的方法。</p>
<p><strong>WeakReference</strong> 和 <strong>SoftReference</strong> 在其他很多地方也都有运用，以后再补充~</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践 - 郭霖的专栏</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android异步消息处理机制总结]]></title>
      <url>http://www.sczyh30.com/posts/Android/android-aysnc-message/</url>
      <content type="html"><![CDATA[<p>本次项目完成，对安卓的异步消息处理机制有了更深的了解，在这里总结一下。</p>
<h1 id="Prolouge">Prolouge</h1><p>先来回顾一下基础，Android中的异步消息处理主要由<code>Message</code>, <code>Handler</code>, <code>MessageQueue</code>和<code>Looper</code>四部分组成。</p>
<h2 id="Message">Message</h2><p><code>Message</code>主要作为线程之间传递的信息，它可以携带一些数据。它的<code>what</code>字段（一般用来表示消息类型）、<code>arg0</code>、<code>arg1</code>字段可以携带一些整型数据，<code>obj</code>字段可以携带一个对象，并且可以用<code>setData</code>方法传输一个<code>Bundle</code>对象。</p>
<p><code>Message</code>的创建方法有两种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Message msg0 = <span class="keyword">new</span> Message(); <span class="comment">//调用Message的构造方法</span></div><div class="line">Message msg1 = Message.obtain(); <span class="comment">//从消息池中获取</span></div><div class="line">Message message = mHandler.obtainMessage(); <span class="comment">//或者这样从消息池中获取</span></div></pre></td></tr></table></figure>
<p>其中，<code>Handler</code>的<code>obtainMessage</code>方法也是调用了<code>obtain</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns a new &#123;<span class="doctag">@link</span> android.os.Message Message&#125; from the global message pool. More efficient than</div><div class="line">     * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).</div><div class="line">     *  If you don't want that facility, just call Message.obtain() instead.</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两种方法的本质区别是，<code>obtain</code>方法直接从消息池中获取<code>Message</code>对象，这样很多时候可以避免创建新对象，减少内存开销，从<code>obtain</code>方法的源码中就能看出这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Return a new Message instance from the global pool. Allows us to</div><div class="line">     * avoid allocating new objects in many cases.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</div><div class="line">                Message m = sPool;</div><div class="line">                sPool = m.next;</div><div class="line">                m.next = <span class="keyword">null</span>;</div><div class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></div><div class="line">                sPoolSize--;</div><div class="line">                <span class="keyword">return</span> m;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>因此，获取<code>Message</code>时尽量使用<code>obtain</code>方法。</p>
<h2 id="Handler">Handler</h2><p><code>Handler</code>用于发送和处理信息，相当于生产者和消费者。<code>Handler</code>通过<code>sendMessage</code>方法将Message传入<code>MessageQueue</code>消息队列，经<code>Looper</code>轮询后将<code>Message</code>传递至<code>handleMessage</code>方法中。</p>
<p>最常见的一个应用就是需要在子线程中处理UI，这时候就需要借助<code>Handler</code>实现。</p>
<h2 id="MessageQueue">MessageQueue</h2><p><code>MessageQueue</code>，顾名思义就是消息队列，它用来存放<code>Handler</code>发送的消息，直到消息被处理。每个线程中只能有一个消息队列。</p>
<h2 id="Looper">Looper</h2><p><code>Looper</code>相当于<code>MessageQueue</code>的监视器。首先调用<code>Looper.loop()</code>方法进入无限循环状态，每当一个新的<code>Message</code>进入<code>MessageQueue</code>，<code>Looper</code>就会轮询，将此<code>Message</code>传递给<code>handleMessage</code>方法。每个线程中只能有一个<code>Looper</code>对象。</p>
<h1 id="底层实现">底层实现</h1><p>一个标准的异步处理流程应该是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">      <span class="keyword">public</span> Handler mHandler;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">          Looper.prepare();</div><div class="line"></div><div class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                  <span class="comment">// process incoming messages here</span></div><div class="line">              &#125;</div><div class="line">          &#125;;</div><div class="line"></div><div class="line">          Looper.loop();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>我们从<code>Handler</code>的构造函数开始分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们直接在子线程中创建<code>Handler</code>，会抛出异常，提示 “Can’t create handler inside thread that has not called Looper.prepare()”，也就是要调用<code>Looper.prepare()</code>方法。根据源码，这是因为子线程的Looper为空所致，而观察<code>prepare</code>方法的源码可知，此方法的作用就是创建一个<code>Looper</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而主线程也没有调用<code>Looper.prepare()</code>，为什么没有崩溃呢？显然是系统自动地帮我们调用了这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SamplingProfilerIntegration.start();</div><div class="line"></div><div class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></div><div class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></div><div class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></div><div class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        Environment.initForCurrentUser();</div><div class="line"></div><div class="line">        <span class="comment">// Set the reporter for event logging in libcore</span></div><div class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</div><div class="line"></div><div class="line">        Security.addProvider(<span class="keyword">new</span> AndroidKeyStoreProvider());</div><div class="line"></div><div class="line">        <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></div><div class="line">        <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</div><div class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</div><div class="line"></div><div class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line"></div><div class="line">        Looper.prepareMainLooper();</div><div class="line"></div><div class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">        thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            sMainThreadHandler = thread.getHandler();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Looper.loop();</div><div class="line"></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中的<code>Looper.prepareMainLooper()</code>方法最后调用了<code>Looper.prepare()</code>方法，创建了主线程的Looper。而子线程则不会主动创建Looper，必须自己调用方法创建。</p>
<p>创建完了Handler，下一步就是创建Message然后<code>sendMessage</code>了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">            delayMillis = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>sendMessage</code>的结果是将此Message入队。注意到MessageQueue中只保存了当前待处理的一个对象，而不是一个集合；出队则是由<code>Looper.loop()</code>进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">            Printer logging = me.mLogging;</div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.recycleUnchecked();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>出队的逻辑为<code>queue.next()</code>，其逻辑为：如果MessageQueue的待处理消息对象不为空，那么就出队并让下一个消息入队，否则阻塞。消息出队后经由<code>dispatchMessage</code>方法回调，以便在<code>handleMessage</code>中接收到Message并进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这就是一个完整的异步消息处理机制，用网上的一幅图总结：</p>
<p><img src="http://img.blog.csdn.net/20151023143204457" alt="消息处理机制（图片来自网络）"></p>
<h1 id="AsyncTask">AsyncTask</h1><p>当然从Android 1.5开始，谷歌就引入了一个更方便使用的<code>AsyncTask</code>类用于处理异步任务，非常轻量级，通过实现其回调函数来实现相应逻辑。比如我写了一个异步读取缓存的Task：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Void</span>, <span class="title">User</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;Context&gt; mContext;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CacheTask</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">            mContext = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> User <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</div><div class="line">            Serializable object = XmlCacheManager.readObject(mContext.get(), <span class="string">"user"</span>);</div><div class="line">            <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (User) object;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(User info)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.onPostExecute(info);</div><div class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">                mContext.get().mInfo = info;</div><div class="line">                mContext.get().mErrorLayout.setType(AppConstant.HIDE_ERROR_LAYOUT);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mContext.get().mErrorLayout.setType(AppConstant.NETWORK_ERROR_LAYOUT);</div><div class="line">            &#125;</div><div class="line">            mContext.get().updateUI();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在此逻辑中，<code>doInBackground</code>方法用于执行具体的缓存读取，而<code>onPostExecute</code>方法用于通知UI更新任务的结果（即更新UI）。其实AsyncTask底层也是利用上边的异步消息机制实现的，只不过它封装地非常好，免去了开发者自己写Message和Handler的环节，减少编码量。</p>
<p>粗略看了一下AsyncTask的源码，发现其的底层实现用了各种JUC的东西，以后有时间再研究研究它的源码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C/C++结构体字节对齐]]></title>
      <url>http://www.sczyh30.com/posts/Summary/struct_sizeof/</url>
      <content type="html"><![CDATA[<p>最近在群里看到不少人在讨论结构体字节对齐的问题，就顺便看了看，总结一下。</p>
<p>在C中，计算一个结构体的大小不是简单地将其各成员所占空间的大小相加，而是有特定的规则 - <strong>字节对齐</strong>。使用字节对齐的原因有两个，第一是某些平台只能在特定地址访问特定的数据，二是提高数据存取的速度（尽量减少存取次数）。C99标准并没有明确规定内存字节对齐的细节，具体细则应由编译器决定。</p>
<p>这里首先引入<strong>对齐参数</strong>这一概念，这是结构体字节对齐的一个参考量，对于每种变量的对齐参数，不同编译器实现不同，这里参考网上列出GCC和MSVC两种编译器对应的对齐参数（均为32位）：</p>
<table>
<thead>
<tr>
<th>编译器</th>
<th>对应量</th>
<th>char</th>
<th>bool(cpp)</th>
<th>short</th>
<th>int</th>
<th>float</th>
<th>double</th>
<th>指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>VC++2015</td>
<td>所占空间</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>VC++2015</td>
<td>对齐参数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>gcc 4.8.2(linux)</td>
<td>所占空间</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>gcc 4.8.2(linux)</td>
<td>对齐参数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>编译器还可以设置默认对齐参数，用预编译语句<code>#pragma pack(n)</code>表示，在Windows（32位）下n可取1,2,4,8，默认为8；在Linux（32位）下可取1,2,4，默认为4。</p>
<p>最后，每个变量实际的对齐参数为每个成员变量的对齐参数和编译器的默认对齐参数中较小的一个，比如一个float型变量的对齐参数为4，编译器设定的<code>#pragma pack(8)</code>，则此变量实际的对齐参数就为4；对于结构体变量，它的自身对齐参数就为它里面各个变量最终对齐参数的最大值。</p>
<p>结构体字节对齐的原则主要有两点：</p>
<ol>
<li><strong>结构体的每一个成员相对结构体首地址的偏移量应该是对其参数的整数倍，如果不满足则补足前面的字节使其满足</strong></li>
<li><strong>结构体的最终大小应该是其对应参数的整数倍</strong></li>
</ol>
<p>下面用例子来说明(C++)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node1 &#123;</div><div class="line">&#125; S1;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node2 &#123;  </div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">char</span> b;</div><div class="line">    <span class="keyword">short</span> c;</div><div class="line">&#125; S2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node3 &#123;</div><div class="line">    <span class="keyword">char</span> a;</div><div class="line">    <span class="keyword">int</span> b;</div><div class="line">    <span class="keyword">short</span> c;</div><div class="line">&#125; S3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node4 &#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">short</span> b;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c; <span class="comment">//静态变量单独存放在静态数据区</span></div><div class="line">&#125; S4;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node5 &#123;</div><div class="line">    <span class="keyword">bool</span> a;</div><div class="line">    S1 b;</div><div class="line">    <span class="keyword">short</span> c;</div><div class="line">&#125; S5;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node6 &#123;</div><div class="line">    <span class="keyword">bool</span> a;</div><div class="line">    S2 b;</div><div class="line">    <span class="keyword">int</span> c;</div><div class="line">&#125; S6;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node7 &#123;</div><div class="line">    <span class="keyword">bool</span> a;</div><div class="line">    S2 b;</div><div class="line">    <span class="keyword">double</span> d;</div><div class="line">    <span class="keyword">int</span> c;</div><div class="line">&#125; S7;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node8 &#123;</div><div class="line">    <span class="keyword">bool</span> a;</div><div class="line">    S2 b;</div><div class="line">    <span class="keyword">char</span>* c;</div><div class="line">&#125; S8;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>node1</code>为一个空结构体，在C中空结构体的大小为0字节，在C++中空结构体的大小为1字节。</li>
<li><code>node2</code>的内存结构：（4 — 1 — 1（补） — 2），总大小为8字节。</li>
<li><code>node3</code>的内存结构：（1 — 3（补） — 4 — 4），总大小为12字节。</li>
<li><code>node4</code>的内存结构：（4 — 2 — 2（补）），总大小为8字节，注意静态变量被分配到静态数据区，不在sizeof计算的范围内。</li>
<li><code>node5</code>的内存结构：（1 — 1 — 2），总大小为4字节。</li>
<li><code>node6</code>的内存结构：（1 — 3（补） — 8 — 4），总大小为16字节，注意结构体变量的对齐参数的计算。</li>
<li><code>node7</code>的内存结构：（1 — 3（补）— 8  — 4（补） — 8 — 4 — 4（补）），总大小为32字节。</li>
<li><code>node8</code>的内存结构：（1 — 3（补） — 8 — 4），总大小为16字节。</li>
</ul>
<p>详细分析一下<code>node7</code>，其余的也类似：</p>
<ul>
<li><code>#pragma pack(n)</code>为8</li>
<li>对于<code>a</code>变量，其对齐参数为1，此时offset=0，可以被1整除，因此为其分配1字节空间；</li>
<li>对于<code>b</code>变量，其对齐参数为4（s2结构体的成员变量最大对齐参数为int =&gt; 4），此时offset=1，不能被4整除，因此填充3字节后为其分配8字节空间；</li>
<li>对于<code>d</code>变量，其对齐参数为8，此时offset=12，不能被8整除，因此填充4字节后为其分配8字节空间。</li>
<li>对于<code>c</code>变量，其对齐参数为4，此时offset=24，可以被4整除，因此为其分配4字节空间。</li>
<li>此时所有变量都分配完，但此时offset=28，不能被最大对齐参数8整除，因此填充4字节使其可以被8整除。所以最后node7的大小为32字节。</li>
</ul>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/struct-sizeof-bq.png" alt="node7 内存分配"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hashCode方法及equals方法的规范]]></title>
      <url>http://www.sczyh30.com/posts/Java/java-hashcode-equal/</url>
      <content type="html"><![CDATA[<p>在Java中，<code>hashCode</code>方法和<code>equals</code>方法都是java.lang.Object类的方法，在 <em>The Java Language Specification, Java SE 8 Edition</em> 中定义如下：</p>
<ul>
<li>The method <code>equals</code> defines a notion of object equality, which is based on value,<br>not reference, comparison.</li>
<li>The method <code>hashCode</code> is very useful, together with the method <code>equals</code> , in<br>hashtables such as <code>java.util.HashMap</code> .</li>
</ul>
<p>简而言之，<code>equals</code>法是判断两个对象是否等价的方法，而<code>hashCode</code>则是为散列数据结构服务的计算散列值的方法。下面分别对这两个方法进行讨论。</p>
<h1 id="equals方法">equals方法</h1><h2 id="重写规则">重写规则</h2><p>equals方法注重<strong>两个对象在逻辑上是否相等</strong>。重写equals方法看似比较简单，但实际编写的时候还是要考虑具体类的意义。<br>一般来说，以下几种情况不需要重写equals方法：</p>
<ul>
<li>一个类的每个实例在本质上都是独立的、不同的，比如Thread类</li>
<li>不需要equals方法，也就是判断对象相等的逻辑是没有必要的</li>
<li>父类已重写equals方法，并且子类的判断逻辑与父类相符</li>
<li>一个类的访问权限为private或package-private，并且可以确定equals方法不会被调用</li>
</ul>
<p>那么，另外的情况通常需要重写equals方法。一般来说，equals方法遵循离散数学中的<strong>等价关系</strong>（equivalence relation）。从OOP的角度来说，等价关系三原则如下（离散数学终于派上用场了！虽然还没学到这里。。）：</p>
<ul>
<li>自反性（Reflexive）：<strong>一个对象与自身相等</strong>，即$x = x$。对任何非空对象x， x.equals(x)必定为true</li>
<li>对称性（Symmetric）：<strong>对象之间的等价关系是可交换的</strong>，即$a=b \Leftrightarrow b=a$。对任何非空对象x、y， x.equals(y)为true，当且仅当y.equals(x)为true</li>
<li>传递性（Transitive）：$(a=b)\wedge(b=c) \Rightarrow (a=c)$。对任何非空对象x、y、z， 若x.equals(y)为true且y.equals(z)为true，则x.equals(z)为true</li>
</ul>
<p>除了遵循这三原则之外，还要遵循：</p>
<ul>
<li>一致性（Consistent）：对任何非空对象x、y，只要所比较的信息未变，则连续调用x.equals(y)总是得到一致的结果。这要求了equals所依赖的值必须是可靠的</li>
<li>对任何非空对象x， x.equals(null)必定为false</li>
</ul>
<p>所以，根据上面的原则，equals函数的一个比较好的实践如下：</p>
<h3 id="判断传入的对象与自身是否为同一对象">判断传入的对象与自身是否为同一对象</h3><p><strong>首先先判断传入的对象与自身是否为同一对象</strong>，如果是的话直接返回<code>true</code>。这相当于一种性能优化，尤其是在各种比较操作代价高昂的时候，这种优化非常有效。</p>
<h3 id="判断对象是否为正确的类型">判断对象是否为正确的类型</h3><p>若此方法接受子类，即子类判断等价的逻辑与父类相同，则可以用<code>instanceof</code>操作符；若逻辑不同，即仅接受当前类型，则可以用<code>getClass</code>方法获取Class对象来判断。注意使用getClass方法时必须保证非空，而用instanceof操作符则不用非空（null instanceof o的值为false）。</p>
<h3 id="将类型转换为相应的类型">将类型转换为相应的类型</h3><p>由于前面已经做过校验，因此这里做类型转换的时候不应当抛出ClassCastException异常。</p>
<h3 id="编写相关的判断逻辑">编写相关的判断逻辑</h3><p>一个简单的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fucker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fucker</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Fucker))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        Fucker fucker = (Fucker) o;</div><div class="line">        <span class="keyword">return</span> id == fucker.id &amp;&amp; !(name != <span class="keyword">null</span> ? !name.equals(fucker.name) : fucker.name != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = id;</div><div class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="注意事项">注意事项</h3><p>几个注意事项：</p>
<ul>
<li>我们无法在扩展一个可实例化的类的同时，即增加新的成员变量，同时又保留原先的equals约定</li>
<li>注意不要写错equals方法的参数类型，标准的应该是<code>public boolean equals(Object o)</code>，若写错就变成重载而不是重写了</li>
<li>不要让equals变得太“智能”而使其性能下降</li>
<li>如果重写了equals方法，则一定要重写hashCode方法（具体见下面）</li>
</ul>
<h2 id="老生常谈的equals和==">老生常谈的equals和==</h2><p>上面提到过，<code>equals</code>方法用来判断<strong>两个对象在逻辑上是否相等</strong>，而<code>==</code>用来判断两个引用对象是否指向同一个对象（是否为同一个对象）。</p>
<p>用烂了的例子，注意常量池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">String str1 = <span class="string">"Fucking Scala"</span>;</div><div class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"Fucking Scala"</span>);</div><div class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"Fucking Scala"</span>);</div><div class="line">String str4 = <span class="string">"Fucking Scala"</span>;</div><div class="line">System.out.println(str1 == str2); <span class="comment">// false</span></div><div class="line">System.out.println(str2 == str3); <span class="comment">// false</span></div><div class="line">System.out.println(str2.equals(str3)); <span class="comment">// true</span></div><div class="line">System.out.println(str1 == str4); <span class="comment">// true</span></div><div class="line">str4 = <span class="string">"Fuck again!"</span>;</div><div class="line">String str5 = <span class="string">"Fuck again!"</span>;</div><div class="line">System.out.println(str1 == str4); <span class="comment">// false</span></div><div class="line">System.out.println(str4 == str5); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h1 id="hashCode方法">hashCode方法</h1><p><strong>如果重写了equals方法，则一定要重写hashCode方法</strong>。</p>
<p>重写hashCode方法的原则如下：</p>
<ul>
<li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数</li>
<li>如果两个对象通过equals方法比较得到的结果是相等的，那么对这两个对象进行hashCode得到的值应该相同</li>
<li>两个不同的对象，hashCode的结果可能是相同的，这就是哈希表中的冲突。为了保证哈希表的效率，哈希算法应尽可能的避免冲突</li>
</ul>
<p>关于相应的哈希算法，一个简单的算法如下:</p>
<ul>
<li>永远不要让哈希算法返回一个常值，这时哈希表将退化成链表，查找时间复杂度也从 $O(1)$ 退化到 $O(N)$</li>
<li>如果参数是boolean型，计算<code>(f ? 1 : 0)</code></li>
<li>如果参数是byte, char, short或者int型，计算<code>(int) f</code></li>
<li>如果参数是long型，计算<code>(int) (f ^ (f &gt;&gt;&gt; 32))</code></li>
<li>如果参数是float型，计算<code>Float.floatToIntBits(f)</code></li>
<li>如果参数是double型，计算<code>Double.doubleToLongBits(f)</code>得到long类型的值，再根据公式计算出相应的hash值</li>
<li>如果参数是Object型，那么应计算其有用的成员变量的hash值，并按照下面的公式计算最终的hash值</li>
<li>如果参数是个数组，那么把数组中的每个值都当做单独的值，分别按照上面的方法单独计算hash值，最后按照下面的公式计算最终的hash值</li>
</ul>
<p>组合公式：<code>result = 31 * result + c</code></p>
<p>比如，String类的hashCode方法如下（JDK 1.8）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = hash;</div><div class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">char</span> val[] = value;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</div><div class="line">                h = <span class="number">31</span> * h + val[i];</div><div class="line">            &#125;</div><div class="line">            hash = h;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> h;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>举个自定义类的hashCode例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> height;</div><div class="line">    <span class="keyword">private</span> String note;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        Duck duck = (Duck) o;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (id != duck.id) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (Double.compare(duck.weight, weight) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (Float.compare(duck.height, height) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> ? !name.equals(duck.name) : duck.name != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> !(note != <span class="keyword">null</span> ? !note.equals(duck.note) : duck.note != <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result;</div><div class="line">        <span class="keyword">long</span> temp;</div><div class="line">        result = id;</div><div class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</div><div class="line">        temp = Double.doubleToLongBits(weight);</div><div class="line">        result = <span class="number">31</span> * result + (<span class="keyword">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</div><div class="line">        result = <span class="number">31</span> * result + (height != +<span class="number">0.0f</span> ? Float.floatToIntBits(height) : <span class="number">0</span>);</div><div class="line">        result = <span class="number">31</span> * result + (note != <span class="keyword">null</span> ? note.hashCode() : <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想找到一个不冲突的哈希算法不是非常容易，具体的属于数据结构部分知识，这里就不再赘述了。</p>
<hr>
<h1 id="其他语言">其他语言</h1><h2 id="C♯">C♯</h2><p>C#与Java大同小异，规则都可以参考上面的。方法名稍微改了改，分别为<code>Equals</code>方法和<code>GetHashCode</code>方法。</p>
<h2 id="C++">C++</h2><p>C++不像Java那样所有的类都继承一个共同的根基类，因此在写自定义的类时，需要自己写这两个方法。<br>在C++里，一般通过重载<code>==</code>运算符来实现判断两对象等价的逻辑，而实现计算散列值的函数则需要特化<code>std::hash</code>模板结构体，并且重载<code>()</code>运算符。</p>
<p>如果用不到散列数据结构的话，则无需定义对应的散列函数。</p>
<p>【2015-10 Update】C++示例可见<a href="http://www.sczyh30.com/posts/C-C/cpp-stl-hashmap/">C++ STL之哈希表|unordered_map</a>。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><em>The Java Language Specification, Java SE 8 Edition</em></li>
<li><em>Effective Java (2nd Edition)</em></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础技术细节总结 - 语言规范]]></title>
      <url>http://www.sczyh30.com/posts/Java/java-basic-summary-01/</url>
      <content type="html"><![CDATA[<p>开发莫忘基础，写业务写多了很多基础内容容易忘。这里将寻根溯源，总结Java语言规范和基础类中的一些细节问题。所有关于Java语言规范的细节问题，都可以参考  <em>The Java® Language Specification, Java SE 8 Edition</em>(JLS8) .</p>
<p>本文将不断补充。。</p>
<h2 id="小数化为整数">小数化为整数</h2><ul>
<li><code>Math.floor(x)</code>返回小于等于x的最接近整数，返回类型为double;</li>
<li><code>Math.round(x)</code>相当于四舍五入，返回值为long或int;</li>
<li><code>Math.ceil(x)</code>返回大于等于x的最接近整数，返回类型为double。</li>
</ul>
<h2 id="静态块与构造块">静态块与构造块</h2><p><strong>静态块</strong>：用static申明，JVM加载类时执行，仅执行一次且优先于主函数。<br><strong>构造块</strong>：类中直接用{}定义，每一次创建对象时执行，相当于往构造器最前面加上构造块的内容（很像往每个构造器那里插了内联函数，构造块就相当于内联函数）。</p>
<p>执行顺序优先级：<strong>静态块 &gt; 构造块 &gt; 构造方法</strong></p>
<p>有继承关系时，执行顺序通常是：父类静态块=&gt;子类静态块=&gt;父类构造块=&gt;父类构造方法=&gt;子类构造块=&gt;子类构造方法<br>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Derived();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            System.out.println(<span class="string">"fucking =&gt; Base::static"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"fucking =&gt; Base::before"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Base::Base&lt;init&gt;"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            System.out.println(<span class="string">"fucking =&gt; Derived::static"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"fucking =&gt; Derived::before"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Derived</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>();</div><div class="line">            System.out.println(<span class="string">"Derived::Derived&lt;init&gt;"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fucking =&gt; Base::<span class="keyword">static</span></div><div class="line">fucking =&gt; Derived::<span class="keyword">static</span></div><div class="line">fucking =&gt; Base::before</div><div class="line">Base::Base&lt;init&gt;</div><div class="line">fucking =&gt; Derived::before</div><div class="line">Derived::Derived&lt;init&gt;</div></pre></td></tr></table></figure>
<h2 id="运算符规则_-_加法规则">运算符规则 - 加法规则</h2><p>代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b1 = <span class="number">1</span>, b2 = <span class="number">2</span>, b3, b6;</div><div class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4 = <span class="number">4</span>, b5 = <span class="number">6</span>;</div><div class="line">b6 = b4 + b5;</div><div class="line">b3 = (b1 + b2);</div><div class="line">System.out.println(b3 + b6);</div></pre></td></tr></table></figure>
<p>结果：第四行编译错误。</p>
<p>表达式的数据类型自动提升, 关于类型的自动提升，注意下面的规则。</p>
<ol>
<li>所有的<code>byte</code>,<code>short</code>,<code>char</code>型的值将被提升为<code>int</code>型</li>
<li>如果有一个操作数是<code>long</code>型，计算结果是<code>long</code>型</li>
<li>如果有一个操作数是<code>float</code>型，计算结果是<code>float</code>型</li>
<li>如果有一个操作数是<code>double</code>型，计算结果是<code>double</code>型</li>
</ol>
<p>而声明为<code>final</code>的变量会被JVM优化，因此第三句在编译时就会优化为<code>b6 = 10</code>，不会出现问题。</p>
<h2 id="float_x_与“零值”比较的if语句">float x 与“零值”比较的if语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (fabs(x) &lt; <span class="number">0.00001f</span>)</div></pre></td></tr></table></figure>
<p>float类型的还有double类型的，这些小数类型在趋近于0的时候不会直接等于零，一般都是无限趋近于0。因此不能用==来判断。应该用<code>|x-0| &lt; err</code>来判断，这里|x-0|表示绝对值，err表示限定误差，用程序表示就是<code>fabs(x) &lt; 0.00001f</code>。</p>
<h2 id="关于try和finally">关于try和finally</h2><p>1.首先执行到<code>try</code>里的<code>return</code>，但是有<code>finally</code>语句还要执行，于是先执行<code>return</code>后面的语句，例如（<code>x++</code>），把要返回的值保存到局部变量。<br>2.执行<code>finally</code>语句的内容，其中有<code>return</code>语句，这时就会忽略try中的<code>return</code>，直接返回。</p>
<p>返回值问题。可以认为<code>try</code>（或者<code>catch</code>）中的<code>return</code>语句的返回值放入线程栈的顶部：如果返回值是基本类型则顶部存放的就是值，如果返回值是引用类型，则顶部存放的是引用。finally中的<code>return</code>语句可以修改引用所对应的对象，无法修改基本类型。但不管是基本类型还是引用类型，都可以被<code>finally</code>返回的“具体值”具体值覆盖。</p>
<h2 id="三目运算符的类型转换问题">三目运算符的类型转换问题</h2><p>三目运算符里的类型必须一致，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">int</span> i = <span class="number">40</span>;</div><div class="line">String as_e1 = String.valueOf(i &lt; <span class="number">50</span> ? <span class="number">233</span> : <span class="number">666</span>);</div><div class="line">String as_e2 = String.valueOf(i &lt; <span class="number">50</span> ? <span class="number">233</span> : <span class="number">666.0</span>);</div><div class="line">assertEquals(<span class="keyword">true</span>, as_e1.equals(as_e2));</div></pre></td></tr></table></figure>
<p>结果是测试不通过，这里就涉及到三元操作符的转换规则：</p>
<ol>
<li>如果两个操作数无法转换，则不进行转换，返回<code>Object</code>对象</li>
<li>如果两个操作数是正常的类型，那么按照正常情况进行类型转换，比如<code>int =&gt; long =&gt; float =&gt; double</code></li>
<li>如果两个操作数都是字面量数字，那么返回范围较大的类型</li>
</ol>
<h2 id="Java中自增操作符的一些陷阱">Java中自增操作符的一些陷阱</h2><p>观察下面的一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoIncTraps</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            count = count++;</div><div class="line">        &#125;</div><div class="line">        System.out.println(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码的打印结果是<code>0</code>，也就是说自增在这里并没有什么卵用，这和C++是不一样的。反编译一下看一下字节码（main函数部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></div><div class="line">   L0</div><div class="line">    LINENUMBER 6 L0</div><div class="line">    ICONST_0</div><div class="line">    ISTORE 1</div><div class="line">   L1</div><div class="line">    LINENUMBER 7 L1</div><div class="line">    ICONST_0</div><div class="line">    ISTORE 2</div><div class="line">   L2</div><div class="line">   FRAME APPEND [I I]</div><div class="line">    ILOAD 2</div><div class="line">    BIPUSH 10</div><div class="line">    IF_ICMPGE L3</div><div class="line">   L4</div><div class="line">    LINENUMBER 8 L4</div><div class="line">    ILOAD 1</div><div class="line">    IINC 1 1</div><div class="line">    ISTORE 1</div><div class="line">   L5</div><div class="line">    LINENUMBER 7 L5</div><div class="line">    IINC 2 1</div><div class="line">    GOTO L2</div><div class="line">   L3</div><div class="line">    LINENUMBER 10 L3</div><div class="line">   FRAME CHOP 1</div><div class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</div><div class="line">    ILOAD <span class="number">1</span></div><div class="line">    INVOKEVIRTUAL java/io/PrintStream.println (I)V</div><div class="line">   L6</div><div class="line">    LINENUMBER <span class="number">11</span> L6</div><div class="line">    RETURN</div></pre></td></tr></table></figure>
<p>这里相当于创建了一个局部变量存放<code>count++</code>，但没有返回，因此<code>count</code>相当于没变。看了字节码后可能没感觉，写一下编译器处理后的代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoIncTraps</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutoIncTraps</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> var3 = count + <span class="number">1</span>;</div><div class="line">            count = count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下这里<code>count</code>的处理流程：</p>
<ol>
<li>JVM把count值（其值是0）拷贝到临时变量区。</li>
<li>count值加1，这时候count的值是1。</li>
<li>返回临时变量区的值，注意这个值是0，没有修改过。</li>
<li>返回值赋值给count，此时count值被重置成0。</li>
</ol>
<p>单纯看这一个的字节码比较抽象，来看一下这三句的字节码，比较一下更容易理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">count = ++count;</div><div class="line">count = count++;</div><div class="line">count++;</div></pre></td></tr></table></figure>
<p>字节码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> L4</div><div class="line"> LINENUMBER <span class="number">9</span> L4</div><div class="line"> IINC <span class="number">1</span> <span class="number">1</span></div><div class="line"> ILOAD <span class="number">1</span></div><div class="line"> ISTORE <span class="number">1</span></div><div class="line">L5</div><div class="line"> LINENUMBER <span class="number">10</span> L5</div><div class="line"> ILOAD <span class="number">1</span></div><div class="line"> IINC <span class="number">1</span> <span class="number">1</span></div><div class="line"> ISTORE <span class="number">1</span></div><div class="line">L6</div><div class="line"> LINENUMBER <span class="number">11</span> L6</div><div class="line"> IINC <span class="number">1</span> <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>另外，<strong>自增操作不是原子操作</strong>，在后边总结并发编程的时候会涉及到。</p>
<h2 id="instanceof操作符的注意事项">instanceof操作符的注意事项</h2><p><code>instanceof</code>操作符左右两边的操作数必须有继承或派生关系，否则不会编译成功。因此，<code>instanceof</code>操作符只能用于对象，不能用于基本类型（不会自动拆包）。</p>
<p>下面是一些典型的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FuckingIOF</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        list.add(<span class="string">"String"</span> <span class="keyword">instanceof</span> Object);</div><div class="line">        list.add(<span class="keyword">new</span> String() <span class="keyword">instanceof</span> Object);</div><div class="line">        list.add(<span class="keyword">new</span> Object() <span class="keyword">instanceof</span> String);</div><div class="line">        <span class="comment">//list.add('a' instanceof Character); //此句会编译错误</span></div><div class="line">        list.add(<span class="keyword">null</span> <span class="keyword">instanceof</span> String);</div><div class="line">        list.add((String)<span class="keyword">null</span> <span class="keyword">instanceof</span> String);</div><div class="line">        list.add(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);</div><div class="line">        list.add(<span class="keyword">new</span> Generic&lt;String&gt;().isDataInstance(<span class="string">""</span>));</div><div class="line">        list.forEach(System.out::println);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDataInstance</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t <span class="keyword">instanceof</span> Date;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果和分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">true</span> =&gt; String是Object的子类</div><div class="line"><span class="keyword">true</span> =&gt; 同上</div><div class="line"><span class="keyword">false</span> =&gt; 同上</div><div class="line"><span class="keyword">false</span> =&gt; Java语言规范规定<span class="keyword">null</span> <span class="keyword">instanceof</span> ? 都是<span class="keyword">false</span></div><div class="line"><span class="keyword">false</span> =&gt; 同上，无论怎么转换还是<span class="keyword">null</span></div><div class="line"><span class="keyword">false</span> =&gt; 同上</div><div class="line"><span class="keyword">false</span> =&gt; 由于Java泛型在编译时会进行类型擦除，因此这里相当于Object <span class="keyword">instanceof</span> Date了</div></pre></td></tr></table></figure>
<h2 id="诡异的NaN类型">诡异的NaN类型</h2><p>根据 <em>JLS8 4.2.3</em>，对<code>NaN</code>有以下规定：</p>
<ul>
<li>The numerical comparison operators &lt; , &lt;= , &gt; , and &gt;= return false if either or both operands are NaN (§15.20.1).</li>
<li>The equality operator == returns false if either operand is NaN.</li>
<li>In particular, (x<y) =="!(x">=y) will be false if x or y is NaN.</y)></li>
<li>The inequality operator != returns true if either operand is NaN (§15.21.1).</li>
<li>In particular, x!=x is true if and only if x is NaN.</li>
</ul>
<p>注意到<code>Double.NaN == Double.NaN</code>返回<strong>false</strong>，这其实是遵循了IEEE 754 standard。<strong>NaN</strong> 代表一个非正常的数（比如除以0得到的数），其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A constant holding a Not-a-Number (NaN) value of type</div><div class="line"> * &#123;<span class="doctag">@code</span> double&#125;. It is equivalent to the value returned by</div><div class="line"> * &#123;<span class="doctag">@code</span> Double.longBitsToDouble(0x7ff8000000000000L)&#125;.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN = <span class="number">0.0</span>d / <span class="number">0.0</span>;</div></pre></td></tr></table></figure>
<h2 id="Integer类的静态缓存_&amp;&amp;_valueOf和parseInt的对比">Integer类的静态缓存 &amp;&amp; valueOf和parseInt的对比</h2><p>这个问题是在StackOverflow上看到的。以下三个表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.out.println(Integer.valueOf(<span class="string">"127"</span>) == Integer.valueOf(<span class="string">"127"</span>));</div><div class="line">System.out.println(Integer.valueOf(<span class="string">"128"</span>) == Integer.valueOf(<span class="string">"128"</span>));</div><div class="line">System.out.println(Integer.parseInt(<span class="string">"128"</span>) == Integer.valueOf(<span class="string">"128"</span>));</div></pre></td></tr></table></figure>
<p>结果分别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>为什么是这样的结果呢？我们看一下valueOf方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</div><div class="line">    <span class="keyword">return</span> Integer.valueOf(parseInt(s, <span class="number">10</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>valueOf</code>方法是在<code>parseInt</code>方法的基础上加了一个读取缓存的过程。我们再看一下IntegerCache类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Cache to support the object identity semantics of autoboxing for values between</div><div class="line"> * -128 and 127 (inclusive) as required by JLS.</div><div class="line"> *</div><div class="line"> * The cache is initialized on first usage.  The size of the cache</div><div class="line"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</div><div class="line"> * During VM initialization, java.lang.Integer.IntegerCache.high property</div><div class="line"> * may be set and saved in the private system properties in the</div><div class="line"> * sun.misc.VM class.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="comment">// high value may be configured by property</span></div><div class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">        String integerCacheHighPropValue =</div><div class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">                i = Math.max(i, <span class="number">127</span>);</div><div class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</div><div class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        high = h;</div><div class="line"></div><div class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> j = low;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line"></div><div class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></div><div class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来JVM会缓存一部分的Integer对象（默认范围为<code>-128 - 127</code>），在通过<code>valueOf</code>获取Integer对象时，如果是缓存范围内的就直接返回缓存的Integer对象，否则就会new一个Integer对象。返回的上限可通过JVM的参数<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>设置，而且不能小于127（参照JLS 5.1.7）。这样我们就可以解释<code>Integer.valueOf(&quot;127&quot;) == Integer.valueOf(&quot;127&quot;)</code>为什么是true了，因为它们获取的都是同一个缓存对象，而默认情况下<code>Integer.valueOf(&quot;128&quot;) == Integer.valueOf(&quot;128&quot;)</code>等效于<code>new Integer(128) == new Integer(128)</code>,结果自然是false。</p>
<p>我们再来看一下<code>parseInt</code>方法的原型，它返回一个原生int值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException</span></div></pre></td></tr></table></figure>
<p>由于一个原生值与一个包装值比较时，包装类型会自动拆包，因此<code>Integer.parseInt(&quot;128&quot;) == Integer.valueOf(&quot;128&quot;)</code>就等效于<code>128 == 128</code>，结果自然是true。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gdb用法总结]]></title>
      <url>http://www.sczyh30.com/posts/Develop/gdb-simple/</url>
      <content type="html"><![CDATA[<p>以前写C++时，遇到需要调试的程序都是放在VS下进行debug，方便快捷。但是某些时候需要在Linux下进行debug，这时候显然不能用VS了，所以要祭出我们的法宝——gdb。<br>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。<br>这里总结一下gdb的一些常用命令和简单使用方法，为以后调试Hotspot JVM以及Golang编译的程序做准备。（顺便吐槽一下Golang，都出到1.5版本了官方还不发布一个调试器，还得借助gdb。。）</p>
<hr>
<p>放上一段简单的程序(klass.cpp):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Bean &#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        T object;</div><div class="line">        <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Bean</span><span class="params">()</span> </span>&#123;&#125;;</div><div class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Bean</span><span class="params">(T obj,<span class="built_in">string</span> name)</span></span>;</div><div class="line">        <span class="function">T&amp; <span class="title">getObject</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Bean&lt;T&gt;&amp; bean);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> BeanFactory &#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        Bean&lt;T&gt; bean;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">virtual</span> Bean&lt;T&gt; getBean() = <span class="number">0</span>;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="built_in">string</span> s)</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> ApplicationContext : <span class="keyword">public</span> BeanFactory&lt;T&gt; &#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        Bean&lt;T&gt; bean;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ApplicationContext</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ApplicationContext</span><span class="params">(Bean&lt;T&gt; bean)</span></span>;</div><div class="line">        ApplicationContext(<span class="keyword">const</span> BeanFactory&lt;T&gt;&amp; b) = <span class="keyword">delete</span>;</div><div class="line">        <span class="keyword">virtual</span> Bean&lt;T&gt; getBean();</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Bean&lt;T&gt;::Bean(T obj,<span class="built_in">string</span> name):object(obj),name(name)&#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T&amp; Bean&lt;T&gt;::getObject() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;object;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Bean&lt;T&gt;::<span class="keyword">operator</span>==(<span class="keyword">const</span> Bean&lt;T&gt;&amp; bean) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;object == bean.getObject;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">ApplicationContext&lt;T&gt;::ApplicationContext() &#123;</div><div class="line">    <span class="keyword">this</span>-&gt;bean = <span class="literal">nullptr</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">ApplicationContext&lt;T&gt;::ApplicationContext(Bean&lt;T&gt; bean) &#123;</div><div class="line">    <span class="keyword">this</span>-&gt;bean = bean;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Bean&lt;T&gt; ApplicationContext&lt;T&gt;::getBean() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bean;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> ApplicationContext&lt;T&gt;::debug(<span class="built_in">string</span> s) &#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"debug:"</span>&lt;&lt;bean.getName()&lt;&lt;<span class="string">" + "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Bean&lt;<span class="built_in">string</span>&gt; bean(<span class="string">"Scala"</span>,<span class="string">"fucking"</span>);</div><div class="line">    BeanFactory&lt;<span class="built_in">string</span>&gt; *context = <span class="keyword">new</span> ApplicationContext&lt;<span class="built_in">string</span>&gt;(bean);</div><div class="line">    context-&gt;debug(<span class="string">"hahaha"</span>);</div><div class="line">    context-&gt;debug(bean.getObject());</div><div class="line">    <span class="keyword">delete</span> context;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译：<code>g++ klass.cpp -o klass -g -std=c++11</code><br><strong>注意</strong>：需要调试的时候，最好在用g++编译的时候加上-g参数，以便将源代码信息编译到可执行文件中。当然玩逆向的话就看汇编代码吧→_→<br>进入gdb，然后使用<code>file &lt;filename&gt;</code>命令加载文件。<br>然后可使用<code>r</code>命令(run)执行可执行文件。若没下断点，则相当于正常执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">debug:fucking + hahaha</div><div class="line">debug:fucking + Scala</div></pre></td></tr></table></figure></p>
<p>下面在main函数处下一个断点(Breakpoint)：<code>b main</code><br>反馈：<code>Breakpoint 1 at 0x400e61: file klass.cpp, line 75.</code>表示断点地址在0x400e61处<br>然后我们再次使用<code>r</code>命令执行，程序将停在断点处：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Breakpoint 1, main () at klass.cpp:75</div><div class="line">75      int main() &#123;</div></pre></td></tr></table></figure></p>
<p>此界面中可以查看汇编代码、表达式、历史记录、内存使用、寄存器值、源代码（如果有的话）、堆栈信息和线程信息<br><img src="http://7xkkgd.com1.z0.glb.clouddn.com/gdb-simple-01.jpg" alt="gdb"><br>接着使用<code>s</code>命令(step into)步入执行下面的语句，遇到函数调用则步入此函数。在生成Bean对象实例的时候步入Bean的构造函数：<br><img src="http://7xkkgd.com1.z0.glb.clouddn.com/gdb-simple-02.jpg" alt="Bean的构造函数信息"><br>顺着下去，可以观察完整的过程。这里只是总结gdb的使用，就不再阐述了。<br>下面是关于断点的一些用法：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>b &lt;行号&gt;</td>
<td>在此行号处下断点</td>
<td>b 75</td>
</tr>
<tr>
<td>b &lt;函数名称&gt;</td>
<td>在此函数处下断点</td>
<td>b service</td>
</tr>
<tr>
<td>b *&lt;函数名称&gt;</td>
<td>在此函数的入口点（prolog）处下断点</td>
<td>b *main</td>
</tr>
<tr>
<td>b *&lt;函数地址&gt;</td>
<td>在此函数地址处下断点</td>
<td>b *0x400e61</td>
</tr>
<tr>
<td>d &lt;编号&gt;</td>
<td>删除指定编号的断点或删除所有断点</td>
<td>d</td>
</tr>
</tbody>
</table>
<p>查看某个变量可以用<code>p &lt;变量名&gt;</code>命令，比如查看bean的详细信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; p bean         </div><div class="line">$1 = &#123;             </div><div class="line">  object = &quot;Scala&quot;,</div><div class="line">  name = &quot;fucking&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续执行可以用<code>c</code>命令，若下面还有断点则中断到下一个断点。<br>若需要看本行代码对应的汇编代码可用<code>display /i $pc</code>命令，这样就能在Outputs一栏显示出当前汇编代码，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">debug:fucking + hahaha</div><div class="line"></div><div class="line">Breakpoint 4, main () at klass.cpp:79</div><div class="line">79              context-&gt;debug(bean.getObject());</div><div class="line">1: x/i $pc</div><div class="line">=&gt; 0x400f8f &lt;main()+313&gt;:       mov    -0x48(%rbp),%rax</div></pre></td></tr></table></figure></p>
<p>若想逐行汇编代码步入执行，可以用<code>si</code>命令。<br>下面总结一下step命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td>step into(单步跟踪进入）</td>
</tr>
<tr>
<td>n</td>
<td>step over（单步跟踪）</td>
</tr>
<tr>
<td>si</td>
<td>逐行汇编代码步入</td>
</tr>
<tr>
<td>ni</td>
<td>逐行汇编代码步出</td>
</tr>
</tbody>
</table>
<p>还有一个非常有用的命令就是<code>i &lt;信息&gt;</code>，用于显示对应信息，简单总结一下常用的：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>i args</td>
<td>显示当前栈帧上的变量信息</td>
</tr>
<tr>
<td>i address &lt;name&gt;</td>
<td>显示对应对象、方法或变量name的地址</td>
</tr>
<tr>
<td>i breakpoints（缩写<code>i b</code>）</td>
<td>显示当前的所有断点</td>
</tr>
<tr>
<td>i variables</td>
<td>显示当前所有的静态变量和全局变量</td>
</tr>
<tr>
<td>i vtbl &lt;object&gt;</td>
<td>显示object对象的虚函数表(vtable)</td>
</tr>
<tr>
<td>i frame（缩写<code>i f</code></td>
<td>显示栈帧信息</td>
</tr>
<tr>
<td>i registers(缩写<code>i r</code>）</td>
<td>显示寄存器信息</td>
</tr>
</tbody>
</table>
<p>比如查看context对象的虚函数表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; i vtbl context</div><div class="line">warning: RTTI symbol not found for class &apos;ApplicationContext&lt;std::string&gt;&apos;</div><div class="line">vtable for &apos;BeanFactory&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;&apos; @ 0x401530 (subobject @ 0x603070):</div><div class="line">[0]: 0x40139a &lt;ApplicationContext&lt;std::string&gt;::getBean()&gt;</div><div class="line">[1]: 0x4013c8 &lt;ApplicationContext&lt;std::string&gt;::debug(std::string)&gt;</div></pre></td></tr></table></figure></p>
<p>最后退出当然是命令<code>q</code>咯~</p>
<p>后面将用gdb调试HotSpot JVM以便更深入地了解JVM的运行原理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[缓存算法（页面置换算法）总结]]></title>
      <url>http://www.sczyh30.com/posts/Algorithm/algorithm-cache/</url>
      <content type="html"><![CDATA[<p>首先解释一下，缓存算法和内存页面置换算法(Page Replacement Algorithm)的核心思想是一样的，都是给定一个有限的空间，设计一个算法来更新和访问里面的数据，所以把它们放在一起讨论总结。下面提到缓存算法的同时，也指代页面置换算法。</p>
<p>常见的缓存算法有FIFO、Least Recently Used (<strong>LRU</strong>)、Least Frequently Used (<strong>LFU</strong>)。</p>
<hr>
<h1 id="FIFO">FIFO</h1><p>FIFO算法是一种比较容易实现的算法。它的思想是先进先出（FIFO，队列），这是最简单、最公平的一种思想，即<strong>如果一个数据是最先进入的，那么可以认为在将来它被访问的可能性很小。空间满的时候，最先进入的数据会被最早置换（淘汰）掉</strong>。</p>
<p>FIFO算法的描述：设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：</p>
<ol>
<li>set(key,value)：将记录(key,value)插入该结构。当缓存满时，将最先进入缓存的数据置换掉。</li>
<li>get(key)：返回key对应的value值。</li>
</ol>
<p>实现：维护一个FIFO队列，按照时间顺序将各数据（已分配页面）链接起来组成队列，并将置换指针指向队列的队首。再进行置换时，只需把置换指针所指的数据（页面）顺次换出，并把新加入的数据插到队尾即可。</p>
<p>缺点：判断一个页面置换算法优劣的指标就是缺页率，而FIFO算法的一个显著的缺点是，在某些特定的时刻，缺页率反而会随着分配页面的增加而增加，这称为<strong>Belady现象</strong>。产生Belady现象现象的原因是，FIFO置换算法与进程访问内存的动态特征是不相容的，被置换的内存页面往往是被频繁访问的，或者没有给进程分配足够的页面，因此FIFO算法会使一些页面频繁地被替换和重新申请内存，从而导致缺页率增加。因此，现在不再使用FIFO算法。</p>
<h1 id="LRU">LRU</h1><p>LRU（The Least Recently Used，最近最久未使用算法）是一种常见的缓存算法，在很多分布式缓存系统（如Redis, Memcached）中都有广泛使用。</p>
<p>LRU算法的思想是：<strong>如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）</strong>。</p>
<p>LRU算法的描述： 设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：</p>
<ol>
<li>set(key,value)：将记录(key,value)插入该结构。当缓存满时，将最久未使用的数据置换掉。</li>
<li>get(key)：返回key对应的value值。</li>
</ol>
<p>实现：最朴素的思想就是用数组+时间戳的方式，不过这样做效率较低。因此，我们可以用双向链表（LinkedList）+哈希表（HashMap）实现（链表用来表示位置，哈希表用来存储和查找），在Java里有对应的数据结构<strong>LinkedHashMap</strong>。</p>
<p>LeetCode上有关于LRU的一道题（<a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="external">LeetCode #146</a>）：</p>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.</p>
<ul>
<li><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</li>
<li><code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</li>
</ul>
<p>这里我用了双向链表+哈希表实现的。</p>
<p>C++ code(72 ms):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_LIST_SIZE 10</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> LRUCache &#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">class</span> Node &#123;</div><div class="line">            <span class="keyword">public</span>:</div><div class="line">                <span class="keyword">int</span> key;</div><div class="line">                <span class="keyword">int</span> value;</div><div class="line">                Node* pre;</div><div class="line">                Node* next;</div><div class="line">                Node(<span class="keyword">int</span> key,<span class="keyword">int</span> value,Node* pre,Node* next) &#123;</div><div class="line">                    <span class="keyword">this</span>-&gt;key = key;</div><div class="line">                    <span class="keyword">this</span>-&gt;value = value;</div><div class="line">                    <span class="keyword">this</span>-&gt;pre = pre;</div><div class="line">                    <span class="keyword">this</span>-&gt;next = next;</div><div class="line">                &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">        <span class="keyword">int</span> size;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node*&gt; mp;</div><div class="line">        Node* cacheHead;</div><div class="line">        Node* cacheTail;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(Node* cur)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(count == <span class="number">1</span> || cur == cacheHead) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(cur == cacheTail) &#123;</div><div class="line">                cacheTail = cur-&gt;pre;</div><div class="line">            &#125;</div><div class="line">            cur-&gt;pre-&gt;next = cur-&gt;next;</div><div class="line">            <span class="keyword">if</span>(cur-&gt;next != <span class="literal">nullptr</span>) &#123;</div><div class="line">                cur-&gt;next-&gt;pre = cur-&gt;pre;</div><div class="line">            &#125;</div><div class="line">            cur-&gt;next = cacheHead;</div><div class="line">            cur-&gt;pre = <span class="literal">nullptr</span>;</div><div class="line">            cacheHead-&gt;pre = cur;</div><div class="line">            cacheHead = cur;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        LRUCache() &#123;</div><div class="line">            <span class="keyword">this</span>-&gt;size = DEFAULT_LIST_SIZE;</div><div class="line">            <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">this</span>-&gt;cacheHead = <span class="literal">nullptr</span>;</div><div class="line">            <span class="keyword">this</span>-&gt;cacheTail = <span class="literal">nullptr</span>;</div><div class="line">        &#125;</div><div class="line">        LRUCache(<span class="keyword">int</span> capacity):size(capacity) &#123;</div><div class="line">            <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">this</span>-&gt;cacheHead = <span class="literal">nullptr</span>;</div><div class="line">            <span class="keyword">this</span>-&gt;cacheTail = <span class="literal">nullptr</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(cacheHead == <span class="literal">nullptr</span>) &#123;</div><div class="line">                cacheHead = <span class="keyword">new</span> Node(key,value,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</div><div class="line">                mp[key] = cacheHead;</div><div class="line">                cacheTail = cacheHead;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node*&gt;::iterator it = mp.find(key);</div><div class="line">                <span class="keyword">if</span>(it == mp.end()) &#123;</div><div class="line">                    <span class="keyword">if</span>(count == size) &#123;</div><div class="line">                        <span class="keyword">if</span>(cacheHead == cacheTail &amp;&amp; cacheHead != <span class="literal">nullptr</span>) &#123;</div><div class="line">                            mp.erase(cacheHead-&gt;key);</div><div class="line">                            cacheHead-&gt;key = key;</div><div class="line">                            cacheHead-&gt;value = value;</div><div class="line">                            mp[key] = cacheHead;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            Node *p = cacheTail;</div><div class="line">                            cacheTail-&gt;pre-&gt;next = cacheTail-&gt;next;</div><div class="line">                            cacheTail = cacheTail-&gt;pre;</div><div class="line">                            mp.erase(p-&gt;key);</div><div class="line">                            p-&gt;key = key;</div><div class="line">                            p-&gt;value = value;</div><div class="line">                            p-&gt;next = cacheHead;</div><div class="line">                            p-&gt;pre = cacheHead-&gt;pre;</div><div class="line">                            cacheHead-&gt;pre = p;</div><div class="line">                            cacheHead = p;</div><div class="line">                            mp[cacheHead-&gt;key] = cacheHead;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        Node* p = <span class="keyword">new</span> Node(key,value,<span class="literal">nullptr</span>,cacheHead);</div><div class="line">                        cacheHead-&gt;pre = p;</div><div class="line">                        cacheHead = p;</div><div class="line">                        mp[cacheHead-&gt;key] = cacheHead;</div><div class="line">                        count++;    </div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    Node *p = it-&gt;second;</div><div class="line">                    p-&gt;value = value;</div><div class="line">                    pushFront(p);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(cacheHead == <span class="literal">nullptr</span>)</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node*&gt;::iterator it = mp.find(key);</div><div class="line">            <span class="keyword">if</span>(it == mp.end()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                Node* p = it-&gt;second;</div><div class="line">                pushFront(p);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> cacheHead-&gt;value;</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="LFU算法">LFU算法</h1><p>LFU（Least Frequently Used ，最近最少使用算法）也是一种常见的缓存算法。</p>
<p>顾名思义，LFU算法的思想是：<strong>如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰</strong>。</p>
<p>LFU算法的描述：<br>设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：</p>
<ol>
<li>set(key,value)：将记录(key,value)插入该结构。当缓存满时，将访问频率最低的数据置换掉。</li>
<li>get(key)：返回key对应的value值。</li>
</ol>
<p>算法实现策略：考虑到LFU会淘汰访问频率最小的数据，我们需要一种合适的方法按大小顺序维护数据访问的频率。LFU算法本质上可以看做是一个top K问题(K = 1)，即选出频率最小的元素，因此我们很容易想到可以用二项堆来选择频率最小的元素，这样的实现比较高效。最终实现策略为小顶堆+哈希表。</p>
<h1 id="OPT算法">OPT算法</h1><p>最佳页面置换算法（OPT，Bélády’s Algorithm）是一种理论上最佳的页面置换算法。它的思想是，试图淘汰掉以后永远也用不到的页面，如果没有则淘汰最久以后再用到的页面。因为这种算法必须知道进程访问页面的序列，而这是无法实现的，因此仅有理论意义。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Web开发笔记 - 前端总结 (性能篇)]]></title>
      <url>http://www.sczyh30.com/posts/Web/web-frontend-02/</url>
      <content type="html"><![CDATA[<p>从一个用户的角度来说，网站的性能就是用户在浏览器上访问网页的直观感受，加载网页的快慢，加载资源的快慢。通过对前端的性能优化，可以使浏览器尽快地显示内容，对用户更为友好。所以，为了给用户更好的体验，Web前端性能优化是非常有必要的。</p>
<p><img src="http://img.blog.csdn.net/20150901115247287" alt="浏览器请求和响应的过程"></p>
<hr>
<h1 id="CSS、JS代码优化">CSS、JS代码优化</h1><ul>
<li>避免使用CSS表达式，虽然功能强大但是效率低下。</li>
<li>避免使用CSS3的<code>@import</code>，性能非常低。可以在Sass中使用<code>@import</code>，预编译后会将引用的文件合并到一个文件中，不会影响性能。</li>
<li>使用前端构建工具（比如Grunt的<code>grunt-contrib-unglify</code>）<strong>压缩精简CSS、JS代码</strong>（混淆），消除重复、无用代码，并且合并代码，尽量减少HTTP请求次数。</li>
</ul>
<h1 id="减少DNS查询">减少DNS查询</h1><p>DNS查询会消耗一定时间。使用 <strong>DNS缓存</strong> 可有效减少DNS查询（只要对应的解析地址不要常变动就好）。</p>
<h1 id="使用CDN">使用CDN</h1><p>CDN的本质也是缓存，并且由于CDN部署在网络运营商的机房，而这些机房又为用户提供网络服务。所以CDN是将数据缓存在离用户最近的地方，让用户以最快的速度获取资源。一般地，CDN用来缓存静态资源，如图片、CSS、JS脚本、静态网页等等的访问频率较高而变化频率低的静态资源。</p>
<h1 id="使用浏览器缓存">使用浏览器缓存</h1><p>对不经常变化的资源，在HTTP头中添加<code>Expire</code>或<code>Cache-Control</code>，可以设定浏览器缓存。</p>
<h1 id="减少HTTP请求">减少HTTP请求</h1><ul>
<li><strong>合并CSS、JS文件</strong>（用构建工具）</li>
<li>合并图片文件（利用CSS Sprites），将几个相关的图片合成一张图片，使用的时候通过CSS偏移定位出图片的精确位置即可（比如小按钮）。注意响应式页面下图片的位置。</li>
</ul>
<h1 id="必要的时候启用压缩">必要的时候启用压缩</h1><p>在服务端进行压缩，在浏览器端进行解压缩，可以减少传输的数据量。对HTML、CSS、JS文件启用<strong>gzip压缩</strong>可达到较好的效果，但是注意压缩会消耗一定的服务器资源，在PV量大而服务器资源不充裕时应谨慎使用。</p>
<h1 id="CSS与JS在网页中的位置">CSS与JS在网页中的位置</h1><p>浏览器在获取完所有的CSS资源后才对整个页面进行渲染，因此将CSS放在页面的<strong>最上面</strong>是最合适的。</p>
<p>而加载JS有可能会阻塞整个页面（可以添加async来达到异步加载的效果），因此JS最好放在<strong>页面的底部</strong>。当然如果页面解析需要用到JS（比如用AngularJS开发的SPA），那么就应该放在相应的位置，确保页面正常加载。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Web开发笔记 - 前端总结(开发篇)]]></title>
      <url>http://www.sczyh30.com/posts/Web/web-frontend-01/</url>
      <content type="html"><![CDATA[<p>终于从老家回来咯~有时间总结总结啦~这是Web前端开发篇~</p>
<p><strong>此笔记会不断补充</strong>。部分不重要的就不放上来了。</p>
<hr>
<h1 id="CSS相关">CSS相关</h1><h2 id="CSS_Position">CSS Position</h2><p>四种定位：<code>static</code>, <code>relative</code>, <code>absolute</code>, <code>fixed</code></p>
<ul>
<li><strong>static</strong> position是HTML元素的默认值，即没有定位，元素出现在正常的流中。静态定位的元素不会受到top, bottom, left, right影响。</li>
<li><strong>fixed</strong> position是固定位置，常用于实现固定层效果。</li>
<li><strong>relative</strong> position相对于其正常位置，而 <strong>absolute</strong> position的元素的位置相对于最近的已定位父元素。</li>
</ul>
<h2 id="CSS_Float_&amp;&amp;_The_inline-block_Value">CSS Float &amp;&amp; The inline-block Value</h2><p>CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。常用于各区域的水平方向并排化。</p>
<p>横向导航栏也可用 <strong>inline-block</strong>，可以更好地解决图片的排列问题，或者元素需要多个display属性时。两者各有利弊，需要根据业务需求考虑。</p>
<h2 id="元素显示与隐藏">元素显示与隐藏</h2><p>元素显示与隐藏使用<code>visibility</code>或<code>display</code>属性控制。</p>
<p>顺便提一下<code>display</code>属性，其可以控制显示方式为<strong>块级元素和内联元素</strong>。区别显而易见，块级元素（如div）占用了全部宽度，在前后都是换行符，而内联元素（如span）相当于内嵌，不强制换行。</p>
<p>而<strong>inline-block</strong>兼具inline和block的特性，可占有全部宽度而不换行。比起float，inline-block不需要再为after指定clear。当需要控制元素的垂直对齐跟水平排列时，可以使用inline-block。（可代替float）</p>
<h2 id="改变元素的明暗度">改变元素的明暗度</h2><p>改变元素的明暗度可以通过设置一个遮罩层，并改变其透明度来实现。CSS3的<code>opacity</code>属性用来设置元素的不透明级别。</p>
<p>至于IE9 below。。。看着办吧。。</p>
<p>应用：毛玻璃效果（Login界面）、购物导航（hover辅助）、配合HTML5和JS的各种cool效果。</p>
<h2 id="CSS_Box_Model">CSS Box Model</h2><ul>
<li>Margin - 清除边框区域。Margin没有背景颜色，它是完全透明的</li>
<li>Border - 边框周围的填充和内容。边框是受到盒子的背景颜色影响</li>
<li>Padding - 清除内容周围的区域。会受到框中填充的背景颜色影响</li>
<li>Content - 盒子的内容，显示文本和图像</li>
</ul>
<p><img src="http://www.runoob.com/images/box-model.gif" alt="CSS Box Model"></p>
<h2 id="超出元素的部分隐藏">超出元素的部分隐藏</h2><p>使用<code>overflow : hidden</code></p>
<h2 id="CSS3_transition/transform">CSS3 transition/transform</h2><p>CSS 3可以直接写过渡(transition)而不需要JQuery等库的帮助，而transform则是做2D、3D转换。</p>
<p>用示例总结：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line"><span class="attribute">width</span>: <span class="number">233px</span>;</div><div class="line"><span class="attribute">height</span>: <span class="number">233px</span>;</div><div class="line"><span class="attribute">background</span>: green;</div><div class="line"><span class="attribute">transition</span>:width <span class="number">2s</span> linear, height <span class="number">2s</span>;</div><div class="line"><span class="attribute">-moz-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -moz-transform <span class="number">2s</span>; <span class="comment">/* Firefox 4 */</span></div><div class="line"><span class="attribute">-webkit-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span> linear, -webkit-transform <span class="number">2s</span>; <span class="comment">/* Safari and Chrome */</span></div><div class="line"><span class="attribute">-o-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -o-transform <span class="number">2s</span>; <span class="comment">/* Opera */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line"><span class="attribute">width</span>:<span class="number">233px</span>;</div><div class="line"><span class="attribute">height</span>:<span class="number">233px</span>;</div><div class="line"><span class="attribute">transform</span>:<span class="built_in">rotate</span>(180deg);  <span class="comment">/*旋转180度*/</span></div><div class="line"><span class="attribute">-moz-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Firefox 4 */</span></div><div class="line"><span class="attribute">-webkit-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Safari and Chrome */</span></div><div class="line"><span class="attribute">-o-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Opera */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PS:有些东西用JS比CSS 3方便很多，不过还是了解一下的好~况且CSS3动画性能应该比JS要高一些</p>
<hr>
<h2 id="CSS_Enhancer">CSS Enhancer</h2><p>只用过Sass，Less.js木有用过不了解。<br>Sass是一个基于Ruby的CSS预处理器，相当于CSS的一个增强版吧。Compass则相当于一个Sass框架，提供了许多mixin的功能。<br>在Terminal里开<strong>compass watch</strong>可以实时编译sass/scss文件<br>总结一下Sass的特性</p>
<h3 id="可定义变量">可定义变量</h3><p>Sass中可以定义变量，方便统一修改和维护重复、相同的值。</p>
<h3 id="模块化思想">模块化思想</h3><p>Sass中可以导入其它sass/scss文件，但与CSS 3中的<strong>@import</strong>意义不同，Sass改写了<strong>@import</strong>的意义，Sass中的import在预编译时会将所有模块合并，因此性能优于CSS3的import。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$headline-font</span>: 微软雅黑,Arial,sans-serif;</div><div class="line"></div><div class="line">@<span class="keyword">import</span> <span class="string">"compass/reset"</span> //这一句用来覆盖掉浏览器的默认样式</div><div class="line"></div><div class="line">.mian-sec &#123;</div><div class="line">    <span class="attribute">font-family</span>: <span class="variable">$headline-font</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="嵌套">嵌套</h3><p>Sass中可以进行选择器的嵌套表示层级关系，更加简便、直观。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">nav</span> &#123;</div><div class="line">  <span class="selector-tag">ul</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="selector-tag">li</span> &#123; <span class="attribute">display</span>: inline-block; &#125;</div><div class="line"></div><div class="line">  <span class="selector-tag">a</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</div><div class="line">    <span class="attribute">text-decoration</span>: none;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>顺便再总结一下CSS3中的f4cking 组合选择符：</p>
<ul>
<li>后代选取器(以空格分隔)</li>
<li>子元素选择器(以大于号分隔）</li>
<li>相邻兄弟选择器（以加号分隔）</li>
<li>普通兄弟选择器（以破折号分隔）</li>
</ul>
<p>写的时候都能晕了有木有。。所以有Sass真是方便的多。</p>
<h3 id="mixin">mixin</h3><p>Sass中可用mixin定义一些代码片段（相当于function），且可传参数，方便日后根据需求调用，这使得写CSS3浏览器兼容时更加便捷。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> box-sizing (<span class="variable">$sizing</span>) &#123;</div><div class="line">    -webkit-<span class="attribute">box-sizing</span>:<span class="variable">$sizing</span>;     </div><div class="line">       -moz-<span class="attribute">box-sizing</span>:<span class="variable">$sizing</span>;</div><div class="line">            <span class="attribute">box-sizing</span>:<span class="variable">$sizing</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box-border</span>&#123;</div><div class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ccc</span>;</div><div class="line">    @<span class="keyword">include</span> box-sizing(<span class="number">2px</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="扩展/继承">扩展/继承</h3><p>Sass可通过<strong>@extend</strong>来实现代码组合声明，使代码更加简洁优美。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.message</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.success</span> &#123;</div><div class="line">  @<span class="keyword">extend</span> .message;</div><div class="line">  <span class="attribute">border-color</span>: green;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.error</span> &#123;</div><div class="line">  @<span class="keyword">extend</span> .message;</div><div class="line">  <span class="attribute">border-color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="其它">其它</h3><p>Sass中可以进行简单的加减乘除运算。并且Sass提供了许多操作颜色的内建函数，让调色更方便。</p>
<p>Sass可以用命令行编译，也可以用GUI工具编译~用Sublime的话推荐配合使用神器Koala，鹅厂出品，非常方便。<br>用WebStorm的话都支持自动编译sass/scss文件的，还是InteliJ大法好！</p>
<hr>
<h1 id="Bootstrap相关">Bootstrap相关</h1><p>写UI个人比较喜欢用Bootstrap及其各种变种（比如Flat-UI），其实主要还是因为懒（总感觉Bootstrap特别适合给不熟悉前端设计的后端开发者使用。。）</p>
<h2 id="重中之重-Bootstrap_Grid_System">重中之重-Bootstrap Grid System</h2><p>Bootstrap采用<strong>移动设备优先</strong>的原则。</p>
<p>Bootstrap网格系统具有响应式的特点，可随着设备大小进行分栏，响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。12个总格位主要有1<em>12、2</em>6、8+4、3<em>4、12</em>1这几种分栏方式。</p>
<p>网格系统有四种尺寸:</p>
<ul>
<li><strong>xs</strong> (for phones &lt;768px)</li>
<li><strong>sm</strong> (for tablets &gt;=768px)</li>
<li><strong>md</strong> (for desktops &gt;=992px)</li>
<li><strong>lg</strong>(for larger desktops &gt;=1200px)</li>
</ul>
<p>可以一次使用多种尺寸来构建自适应的页面。</p>
<p>网格系统的结构：</p>
<p>First,create a row . Then, add the desired number of columns (tags with appropriate .col-<em>-</em> classes). Note that numbers in .col-<em>-</em> should always add up to 12 for each row.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-*-*"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>比如分三栏：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4"</span>&gt;</span>Fucking Scala<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4"</span>&gt;</span>Fucking Scala<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4"</span>&gt;</span>Fucking Scala<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>另外需要注意响应式的列重置、偏移列及嵌套列问题。<br>别的暂时没什么好总结的了，查查手册应该就可以解决。重要的是响应式页面的设计。</p>
<hr>
<h1 id="JQuery相关">JQuery相关</h1><p>项目中用的比较多，内容太多，慢慢填坑。</p>
<hr>
<h1 id="MVC、MVVM框架">MVC、MVVM框架</h1><p>目前常用的MVC/MVP/MVVM/MVW框架主要有BackboneJS（第一代前端MVC框架，仅作了解），EmberJS（MVC框架，和AngularJS思想相似，仅作了解）以及目前特别常用的MVVM框架AngularJS。这里仅总结AngularJS（目前版本为1.4.4，为什么要写版本？因为这货不一定哪一次更新就会deprecate很多旧特性。。）</p>
<p>有的人不明白AngularJS的用途，认为“万事皆可用AngularJS”，这样就没有领悟AngularJS的精髓。AngularJS最适合开发RESTful风格的SPA（国内各种云服务的Dashboard以及Gmail、Twitter都应用了AngularJS)，而如果开发非应用型网站则要看业务需求，用AngularJS不一定是最佳选择。</p>
<p>这里内容也太多，先总结思想吧。</p>
<p>AngularJS的一大特点是bi-directional data binding，即<strong>数据双向绑定</strong>。它和JQuery的思维有着天壤之别。JQuery的思想是先构建好一个页面，再通过各种DOM操作编写动作；而用AngularJS写页面时，对DOM的直接操作是完全没有必要，也是不被提倡的。在AngularJS中用声明式的数据绑定就可以很好地实现JQuery中命令式的功能。并且，我们心中要对整个页面的结构有个把握，页面分成几个组件，每个组件由不同的控制器负责，数据模型应合理设计。有重复的逻辑是否可以抽象出来，提供一个统一的函数，配合回调达到功能的可扩展化。</p>
<p>总之，AngularJS提供了一种类似于后端的思考方式，可以更好地对网页组件进行解耦，方便日后的开发和维护。后面会详细总结AngularJS的开发。</p>
<hr>
<h1 id="模板引擎">模板引擎</h1><p>主要是EJS和Jade。Jade的语法，只能说，诡异！！！所以用Node.js构建博客时页面模板引擎果断用了EJS（其实我也不知道哪个性能好些，反正EJS没有那么诡异。。）<br>待填坑 &gt;_&lt;</p>
<hr>
<h1 id="ReactJS">ReactJS</h1><p>ReactJS是一个View层组件，专门负责View层的开发。很喜欢它的<strong>Virtual DOM</strong>的设计，优化了性能。（比原生DOM性能快，当然也不支持所有的DOM操作）</p>
<p>这个也没有太多实践（毕竟是View层），以后可以试试React Native构建Hybrid App，写个个人博客的管理器还是可以的~</p>
<hr>
<h1 id="构建工具">构建工具</h1><p>前端构建工具主要有流式构建工具Gulp.js及Grunt，用于压缩、合并依赖文件。前端构建工具貌似一直在改进，变化很快（后端也是，比如Java项目构建，从Maven到Gradle），不过万变不离其宗，核心流程是没有变的。<br>两者用起来比较接近，主要就是package.json + Gruntfile.js(gulp.js)的配置。<br>以Grunt为例，先<code>npm init</code>生成package.json文件，该文件主要配置项目基本信息及工具插件依赖，以让 Node.js 知道下载哪些插件，重点是<strong>devDependencies</strong>字段。<br>至于其使用，麻烦诶。。就简单用了用，不是专业写前端的话一般懒得用。。</p>
<hr>
<h1 id="依赖包管理">依赖包管理</h1><p>主要用过<strong>bower</strong>和<strong>npm</strong>，很方便。</p>
<p>Bower节省了时间，相当于建立了一个本地仓库（类似于Maven的.m2仓库），并且bower.json可以很容易地展现各种依赖关系。给依赖库升级也更加方便了，一句<code>bower update &lt;package-name&gt;</code>完事。Bower的优点是约束比较松散，使用很简单，缺点就是不提供构建工具，需要配合Glup.js或Grunt。</p>
<p>配合Grunt的一些<a href="http://bower.io/docs/tools/" target="_blank" rel="external">插件</a></p>
<ul>
<li>grunt-bower-concat</li>
<li>grunt-wiredep</li>
<li>grunt-bower-requirejs</li>
<li>grunt-bower-task</li>
<li>grunt-preen</li>
</ul>
<p>配合Glup.js的一些插件</p>
<ul>
<li>gulp-google-cdn（国内呵呵）</li>
<li>main-bower-files</li>
<li>preen</li>
<li>gulp-bower-normalize</li>
</ul>
<p><strong>npm</strong> 和<strong>Browserify</strong>配合相当于间接给浏览器提供了npm的功能（Browserify本身不是模块管理器，只是让服务器端的CommonJS格式的模块可以运行在浏览器端）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode | 链表相关算法总结]]></title>
      <url>http://www.sczyh30.com/posts/Algorithm/algorithm-linkedlist-leetcode/</url>
      <content type="html"><![CDATA[<p>这里总结一下常见的与链表有关的算法。</p>
<h1 id="链表成环的各种问题">链表成环的各种问题</h1><h2 id="判断一个单链表是否存在环">判断一个单链表是否存在环</h2><p>这个思路比较简单，用 <strong>两个指针代表快、慢指针</strong>，然后从头指针开始，快指针一次前进两个结点，慢指针一次前进一个结点，则如果两个指针相遇（相等），则一定有环。若两指针不相遇，则fast指针遇到空指针后便结束循环。</p>
<ul>
<li><p><strong>扩展</strong>：这种快、慢指针的思路还可用于找到无环链表的中间元素，当快指针到尾部时，慢指针正好到中间元素的位置。可用于链表的归并排序。</p>
</li>
<li><p><strong>扩展</strong>：这种两个指针的思路还可以用于寻找链表的第k个结点，思路同上。</p>
</li>
</ul>
<p>对应：<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">LeetCode 141 - Linked List Cycle</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">        ListNode *fast = head;</div><div class="line">        ListNode *slow = head;</div><div class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            fast = fast-&gt;next-&gt;next;</div><div class="line">            <span class="keyword">if</span>(fast == slow)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="若存在环，求环的长度">若存在环，求环的长度</h2><p>此处有定理I： <strong>两指针（fast和slow）从第一次碰撞点出发到第二次碰撞所走的长度即为环的长度。</strong></p>
<p><img src="http://img.blog.csdn.net/20151024011135661" alt="链表成环的情况"></p>
<h2 id="若存在环，求环的入口（连接点）">若存在环，求环的入口（连接点）</h2><p>此处有定理II：<strong>第一次碰撞点到环的入口的距离，等于头指针到环的入口的距离。因此，分别从头指针和碰撞点遍历链表，第一次相遇的点即为换的入口（连接点）。</strong></p>
<p>证明如下：<br>设单链表的总长度为L，头结点到环入口的距离为a，环入口到快慢指针相遇的结点距离为x，环的长度为r，慢指针总共走了s步，则快指针走了2s步。并且，快指针要追赶上慢指针，在环内的圈数n &gt;= 1；因此我们可以列出式子：</p>
<p>$$s = a + x$$<br>$$2s = a + nr + x$$<br>$$=&gt; a = nr - x = (n-1)r + y$$</p>
<p>由上式可知成立。<br>对应：<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">LeetCode 142 - Linked List Cycle II</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">        ListNode *fast = head;</div><div class="line">        ListNode *slow = head;</div><div class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</div><div class="line">            fast = fast-&gt;next-&gt;next;</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            <span class="keyword">if</span>(fast == slow) &#123;</div><div class="line">                ListNode *q = head;</div><div class="line">                <span class="keyword">while</span>(q != slow) &#123;</div><div class="line">                    q = q-&gt;next;</div><div class="line">                    slow = slow-&gt;next;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> q;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="链表相交的各种问题">链表相交的各种问题</h1><h2 id="如何判断链表相交，若相交则找到第一个交点">如何判断链表相交，若相交则找到第一个交点</h2><p><strong>Question</strong>：给出两个单向链表的头指针，而两个链表都可能带环，判断这两个链表是否相交，并且给出他们相交的第一个节点。</p>
<p>思路：</p>
<p>首先根据上边的算法判断链表是否成环。</p>
<p><strong>第一种情况：两个链表都不成环</strong><br>思路1：将其中一个链表首尾相连，判断另一个链表是否存在环，如果存在，则两个链表相交，且找出来的环入口点即为相交的第一个点。<br>思路2：若如果两个不成环的链表相交，那么两个链表从相交点到尾结点都是相同的结点。首先先遍历两个链表，记录下两个链表的长度（长链表a，短链表b）。然后先让长链表移动a-b长度，然后两链表开始同步前进，相遇的第一个点即为环的第一个交点。</p>
<pre>
    A:          a1 → a2
                       ↘
                         c1 → c2 → c3
                       ↗            
    B:     b1 → b2 → b3
</pre>

<p>对应：<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">LeetCode 160 - Intersection of Two Linked Lists</a></p>
<p><strong>第二种情况：两个链表都成环</strong></p>
<p><strong>不可能的情况：一个有环，一个没有环</strong></p>
<p>很好想的，如果两个链表一个有环，一个无环的话，那么它们不可能相交。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入探究JVM | 类加载器与双亲委派模型]]></title>
      <url>http://www.sczyh30.com/posts/Java/jvm-classloader-parent-delegation-model/</url>
      <content type="html"><![CDATA[<p>类的加载过程指通过一个类的全限定名来获取描述此类的二进制字节流，并将其转化为方法区的数据结构，进而生成一个<code>java.lang.Class</code>对象作为方法区这个类各种数据访问的入口。这个过程通过Java中的类加载器(ClassLoader)来完成。</p>
<h1 id="类与类加载器">类与类加载器</h1><p>类加载器非常重要，因为每个类加载器都有一个独立的类名称空间。比如我们要加载两个类，如果要比较两个类是否相等（包括<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法），只有在这两个类被<strong>同一个类加载器</strong>加载的前提下，比较才有意义。否则，即使两个类来自同一个class文件，被同一个JVM加载，但是加载它们的类加载器不同，则这两个类就不相等。这就相当于两个命名空间中的等价类<code>LoaderA::C</code>和<code>LoaderB::C</code>。</p>
<h1 id="类加载器的种类">类加载器的种类</h1><p>从一般角度来分的话，ClassLoader分为根加载器（Bootstrap ClassLoader）和其它的加载器。其中Bootstrap ClassLoader负责加载Java的核心类，由JVM实现(C++)，而其它类加载器都由Java层实现并继承<code>java.lang.ClassLoader</code>。</p>
<p>更细分的话，ClassLoader分为：</p>
<ul>
<li>Bootstrap ClassLoader（启动类加载器）负责将<code>%JAVA_HOME%/lib</code>目录中或<code>-Xbootclasspath</code>中参数指定的路径中的，并且是虚拟机识别的（按名称）类库加载到JVM中</li>
<li>Extension ClassLoader（扩展类加载器）负责加载<code>%JAVA_HOME%/lib/ext</code>中的所有类库</li>
<li>System ClassLoader（加载<code>%CLASSPATH%</code>路径的类库）以及其它自定义的ClassLoader</li>
</ul>
<h1 id="双亲委派模型">双亲委派模型</h1><p>JVM中类加载的机制——双亲委派模型。这个模型要求除了Bootstrap ClassLoader外，其余的类加载器都要有自己的父加载器。子加载器通过组合来复用父加载器的代码，而不是使用继承。在某个类加载器加载class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器(Bootstrap)。如果顶层加载不了（它的搜索范围中找不到此类），子加载器才会尝试加载这个类。</p>
<p>双亲委派模型最大的好处就是<strong>让Java类同其类加载器一起具备了一种带优先级的层次关系</strong>。这句话可能不好理解，我们举个例子。比如我们要加载顶层的Java类——<code>java.lang.Object</code>类，无论我们用哪个类加载器去加载Object类，这个加载请求最终都会委托给Bootstrap ClassLoader，这样就保证了所有加载器加载的Object类都是同一个类。如果没有双亲委派模型，那就乱了套了，完全可以搞出<code>Root::Object</code>和<code>L1::Object</code>这样两个不同的Object类。</p>
<p>双亲委派模型的实现比较简单，在<code>java.lang.ClassLoader</code>的<code>loadClass</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">        <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">            <span class="comment">// First, check if the class has already been loaded</span></div><div class="line">            Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        c = findBootstrapClassOrNull(name);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></div><div class="line">                    <span class="comment">// from the non-null parent class loader</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></div><div class="line">                    <span class="comment">// to find the class.</span></div><div class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line">                    c = findClass(name);</div><div class="line"></div><div class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (resolve) &#123;</div><div class="line">                resolveClass(c);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> c;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意JVM的双亲委派模型也会遭到破坏（Java自己就破坏好几次）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客搬迁咯~]]></title>
      <url>http://www.sczyh30.com/posts/Life/test-migrate/</url>
      <content type="html"><![CDATA[<h3 id="此文章仅为测试用">此文章仅为测试用</h3><p>以前那个VPS真的太慢了。。旧博客系统一时脑残用了WordPress，对md的支持很不好，所以这次换了支持md比较好的博客系统Hexo。<br>说起来发现Hexo这个博客系统还真是偶然，当时是练习Dockerfile构建的时候看到了这个玩意，构建完后便试用了一下发现很方便，很好用，正好以前的VPS到期了，所以就趁着这个机会把博客迁移到Hexo上。<br>至于以前的文章，有意义的还会贴上来，有些比较麻烦不好转换成md的就先不贴了。<br>新的开始~<br>（PS：期末考试终于快结束啦哈哈哈！！！）<br><img src="http://7xkkgd.com1.z0.glb.clouddn.com/pic57261028.JPG" alt=""><br>附赠薛定谔方程，测试一下LaTex引擎:<br>$$ i\hbar\frac{\partial \psi}{\partial t}<br>= \frac{-\hbar^2}{2m} \left(<br>\frac{\partial^2}{\partial x^2}+ \frac{\partial^2}{\partial y^2}+ \frac{\partial^2}{\partial z^2}<br>\right) \psi + V \psi $$</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入探究JVM | HotSpot JVM的GC实现]]></title>
      <url>http://www.sczyh30.com/posts/Java/jvm-gc-hotspot-implements/</url>
      <content type="html"><![CDATA[<p>HotSpot JVM中GC的实现主要有以下的几种：</p>
<ul>
<li>Serial/Serial Old</li>
<li>ParNew</li>
<li>Parallel Scavenge/Parallel Old</li>
<li>Concurrent Mark Sweep(CMS)</li>
<li>Garbage First(G1)</li>
</ul>
<p>分别简单总结一下。</p>
<hr>
<h1 id="Serial/Serial_Old">Serial/Serial Old</h1><p>Serial 收集器是最基本的、历史最悠久的收集器。从字面上就能看出，这是一个单线程的收集器，即在进行GC时必须STW。</p>
<p>Serial收集器在新生代采用复制算法，在老年代采用标记-清理-压缩算法(Serial Old)。</p>
<hr>
<h1 id="ParNew">ParNew</h1><p>ParNew收集器是Serial收集器的多线程版本，采用多线程进行收集，但一样要STW。</p>
<p>与Serial类似，ParNew收集器在新生代采用复制算法，在老年代采用标记-清理-压缩算法。</p>
<p>ParNew比较重要，因为它可以配合CMS收集器一起使用(Parallel Scavenge则不行)。ParNew是<code>-XX:+UseConcMarkSweepGC</code>选项下默认的新生代收集器。</p>
<hr>
<h1 id="Parallel_Scavenge">Parallel Scavenge</h1><p>Parallel Scavenge是一个新生代收集器，它与ParNew最主要的区别是它的目标是<strong>吞吐量优先</strong>而不是时间优先（注意这两个不能兼得）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU运行总时间的比值。吞吐量优先适合在后台完成计算而不需要太多交互的业务，而时间优先适合需要交互和实时性的业务。<br>Parallel Scavenge可以精确控制吞吐量，通过两个参数：控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。它还可以通过打开<code>-XX:+UseAdaptiveSizePolicy</code>参数进行自适应调节(<strong>GC Ergonomics</strong>)，打开后JVM会根据当前运行状况收集监控信息并动态调整参数来提供最合适的吞吐量，配合前两个参数使用更好。</p>
<hr>
<h1 id="Parallel_Old">Parallel Old</h1><p>Parallel Old是Parallel Scavenge对应的老年代版本，目标也是吞吐量优先，可以与Parallel Scavenge结合。</p>
<hr>
<h1 id="Concurrent_Mark_Sweep">Concurrent Mark Sweep</h1><p>CMS是真正意义上的并发收集器，作用于老年代。CMS的目标是时间优先（最短停顿时间），像服务器之类的就很适合跑在CMS收集器下，因为互联网服务重视服务的响应速度，希望系统延迟时间短。CMS通常与ParNew配合使用。</p>
<h2 id="CMS的过程">CMS的过程</h2><p>CMS是基于标记-清除算法实现的，整个过程分几步：</p>
<ul>
<li>初始标记(initial-mark)：从GC Root开始，仅扫描与根节点直接关联的对象并标记，这个过程需要STW，但是GC Root数量有限，因此时间较短</li>
<li>并发标记(concurrent-marking)：这个阶段在初始标记的基础上继续向下进行遍历标记。这个阶段与用户线程并发执行，因此不停顿</li>
<li>并发预清理(concurrent-precleaning)：上一阶段执行期间，会出现一些刚刚晋升老年代的对象，该阶段通过重新扫描减少下一阶段的工作。该阶段并发执行，不停顿</li>
<li>重新标记(remark)：重新标记阶段会对CMS堆上的对象进行扫描，以对并发标记阶段遭到破坏的对象引用关系进行修复，以保证执行清理之前对象引用关系是正确的。这一阶段需要STW，时间也比较短暂</li>
<li>并发清理(concurrent-sweeping)：清理垃圾对象，这个过程与用户线程并发执行，不停顿</li>
<li>并发重置(reset)：重置CMS收集器的数据结构，等待下一次GC</li>
</ul>
<p>可以看到，整个过程中需要STW的阶段仅有<strong>初始标记</strong>和<strong>*重新标记</strong>阶段，所以可以说它的停顿时间比较短（当然吞吐量可能会受影响）。</p>
<h2 id="CMS的缺陷">CMS的缺陷</h2><p>由于CMS是基于 <strong>标记-清理</strong> 算法的，因此会产生大量的内存碎片。这很可能会出现老年代虽然有大量不连续的空闲内存，但很难找到连续的内存空间来给对象分配，不得不提前触发一次Full GC的情况。针对这一点，CMS提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关（默认开启），用于在CMS要gg的时候进行内存碎片整理从而得到连续的内存空间。这样内存碎片的问题可以解决，但STW的时间也相应变长。</p>
<p>另外，CMS收集器无法处理 <strong>浮动垃圾</strong>（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉，这一部分垃圾就称为“浮动垃圾”。由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了92%的空间后就会被激活(JDK 1.6)。可以通过设置<code>-XX:CMSInitiatingOccupancyFraction</code>的值来改变这个阈值。注意一定要结合实际的运行情况，不要设的太大，假如内存真的太满，CMS要gg的时候就会临时召唤出Serial Old对老年代进行Full GC，停顿时间长，因此一定要合理设置这个参数的值。</p>
<h2 id="日志分析">日志分析</h2><p>我们可以通过日志观察一次完整的CMS GC过程(参数：<code>-XX:+UseConcMarkSweepGC -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</code>)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">50.201: [GC (CMS Initial Mark) [1 CMS-initial-mark: 47452K(174784K)] 349898K(489344K), 0.0289564 secs] [Times: user=0.22 sys=0.00, real=0.03 secs]</div><div class="line">50.230: [CMS-concurrent-mark-start]</div><div class="line">50.265: [CMS-concurrent-mark: 0.035/0.035 secs] [Times: user=0.07 sys=0.00, real=0.03 secs]</div><div class="line">50.265: [CMS-concurrent-preclean-start]</div><div class="line">50.268: [CMS-concurrent-preclean: 0.003/0.003 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</div><div class="line">50.268: [CMS-concurrent-abortable-preclean-start]</div><div class="line"> CMS: abort preclean due to time 55.290: [CMS-concurrent-abortable-preclean: 1.618/5.022 secs] [Times: user=1.66 sys=0.02, real=5.02 secs]</div><div class="line">55.290: [GC (CMS Final Remark) [YG occupancy: 302446 K (314560 K)]55.290: [Rescan (parallel) , 0.0252109 secs]55.315: [weak refs processing, 0.0000131 secs]55.315: [class unloading, 0.0122450 secs]55.327: [scrub symbol table, 0.0103126 secs]55.338: [scrub string table, 0.0007051 secs][1 CMS-remark: 47452K(174784K)] 349898K(489344K), 0.0503070 secs] [Times: user=0.22 sys=0.00, real=0.05 secs]</div><div class="line">55.340: [CMS-concurrent-sweep-start]</div><div class="line">55.356: [CMS-concurrent-sweep: 0.016/0.016 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</div><div class="line">55.356: [CMS-concurrent-reset-start]</div><div class="line">55.357: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</div></pre></td></tr></table></figure>
<p><strong>【关于CMS-concurrent-abortable-preclean】</strong>：从日志中我们还发现了一个细节叫做<code>CMS-concurrent-abortable-preclean</code>，这就要从Concurrent precleaning阶段说起了。Concurrent precleaning阶段的实际行为是：针对新生代做抽样，等待新生代在某个时间段（默认5秒，可以通过<code>CMSMaxAbortablePrecleanTime</code>参数设置）执行一次Minor GC，如果这个时间段内GC没有发生，那么就继续进行下一阶段（Remark）；如果时间段内触发了Minor GC，则可能会执行一些优化（具体可以参考<a href="这篇文章">https://blogs.oracle.com/jonthecollector/entry/did_you_know</a>）</p>
<hr>
<h1 id="G1">G1</h1><p>G1(Garbage First)收集器是HotSpot JVM最新的垃圾收集器，它最大的特点就是将堆内存划分成多个连续的区域(region)，每个区域大小相等。因此在G1中新生代与老年代都是由若干个Region组成(不需要连续)。Region的大小是可以重新设置的。</p>
<p>G1的优点：可以<strong>非常精确地控制停顿</strong>；老年代采用<strong>标记-压缩</strong>算法，避免了内存碎片的问题。</p>
<p>G1会在内部维护一个优先列表，通过一个合理的模型，计算出每个Region的收集成本和收益期望并量化，这样每次进行GC时，G1总是会选择<strong>最适合</strong>的Region（通常垃圾比较多）进行回收，使GC时间满足设置的条件。</p>
<h2 id="G1新生代GC过程">G1新生代GC过程</h2><p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png" alt=""></p>
<p>G1的新生代收集类似于ParNew，同样是基于复制的算法（英文叫evacuation），存活的对象会被移至Survivor区，空间不够则一些对象需要晋升至老年代。新生代收集同样会有STW。</p>
<p>每次GC中，Eden区和Survivor区的大小都会被重新计算来提供给下一次Minor GC（根据内部记录的一些信息以及设置的期望停顿时间）。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png" alt=""><br><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png" alt=""></p>
<h2 id="Remembered_Set">Remembered Set</h2><p>G1通过引入Remembered Set来避免全堆扫描。Remembered Set用于<strong>跟踪对象引用</strong>。G1中每个Region都有对应的Remembered Set。当JVM发现内部的一个引用关系需要更新（对Reference类型进行写操作），则立即产生一个Write Barrier中断这个写操作，并检查Reference引用的对象是否处于不同的Region之间（用分代的思想，就是新生代和老年代之间的引用）。如果是，则通过CardTable通知G1，G1根据CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中，并将Remembered Set加入GC Root。这样，在G1进行根节点枚举时就可以扫描到该对象而不会出现遗漏。</p>
<h2 id="G1老年代GC过程">G1老年代GC过程</h2><p>一共六步，直接放上官方的解释：</p>
<h3 id="Initial_Mark(STW)">Initial Mark(STW)</h3><p>This is a stop the world event. With G1, it is piggybacked on a normal young GC. Mark survivor regions (root regions) which may have references to objects in old generation.</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide13.png" alt="Initial Marking Phase"></p>
<h3 id="Root_Region_Scanning">Root Region Scanning</h3><p>Scan survivor regions for references into the old generation. This happens while the application continues to run. The phase must be completed before a young GC can occur.</p>
<h3 id="Concurrent_Marking">Concurrent Marking</h3><p>Find live objects over the entire heap. This happens while the application is running. This phase can be interrupted by young generation garbage collections.</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide14.png" alt=""></p>
<h3 id="Remark(STW)">Remark(STW)</h3><p>Completes the marking of live object in the heap. Uses an algorithm called snapshot-at-the-beginning (<strong>SATB</strong>) which is much faster than what was used in the CMS collector.</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide15.png" alt=""></p>
<h3 id="Cleanup(STW_and_concurrent)">Cleanup(STW and concurrent)</h3><ul>
<li>Performs accounting on live objects and completely free regions. (Stop the world)</li>
<li>Scrubs the Remembered Sets. (Stop the world)</li>
<li>Reset the empty regions and return them to the free list. (Concurrent)</li>
</ul>
<h3 id="Copying(STW)">Copying(STW)</h3><p>These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as [GC pause (young)]. Or both young and old generation regions which are logged as [GC Pause (mixed)].</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide16.png" alt=""><br><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide17.png" alt=""></p>
<h3 id="总结">总结</h3><p>G1老年代收集的几个要点：</p>
<ul>
<li>Concurrent Marking Phase<ul>
<li>Liveness information is calculated concurrently while the application is running.</li>
<li>This liveness information identifies which regions will be best to reclaim during an evacuation pause.</li>
<li>There is no sweeping phase like in CMS.</li>
</ul>
</li>
<li>Remark Phase<ul>
<li>Uses the Snapshot-at-the-Beginning (SATB) algorithm which is much faster then what was used with CMS.</li>
<li>Completely empty regions are reclaimed.</li>
</ul>
</li>
<li>Copying/Cleanup Phase<ul>
<li>Young generation and old generation are reclaimed at the same time.</li>
<li>Old generation regions are selected based on their liveness.</li>
</ul>
</li>
</ul>
<h2 id="日志分析-1">日志分析</h2><p>分析日志可以清晰地观察G1的收集阶段（JVM参数<code>-XX:+UseG1GC -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</code>）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="number">5.891</span>: [<span class="function">GC <span class="title">pause</span> <span class="params">(G1 Evacuation Pause)</span> <span class="params">(young)</span>, 0.0288342 secs]</span></div><div class="line">   [Parallel Time: 22.9 ms, GC Workers: 8]</div><div class="line">      [GC Worker <span class="title">Start</span> <span class="params">(ms)</span>: Min: 5891.4, Avg: 5891.4, Max: 5891.5, Diff: 0.1]</div><div class="line">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 1.1, Avg: 3.0, Max: 13.6, Diff: 12.5, Sum: 24.1]</div><div class="line">      [Update <span class="title">RS</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.3, Max: 0.7, Diff: 0.7, Sum: 2.1]</div><div class="line">         [Processed Buffers: Min: 0, Avg: 3.9, Max: 10, Diff: 10, Sum: 31]</div><div class="line">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.5, Max: 0.8, Diff: 0.7, Sum: 3.8]</div><div class="line">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.1, Max: 0.4, Diff: 0.4, Sum: 1.0]</div><div class="line">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>: Min: 3.3, Avg: 13.8, Max: 20.2, Diff: 16.9, Sum: 110.5]</div><div class="line">      [<span class="title">Termination</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 5.1, Max: 5.8, Diff: 5.8, Sum: 40.8]</div><div class="line">         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 8]</div><div class="line">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</div><div class="line">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>: Min: 22.8, Avg: 22.8, Max: 22.8, Diff: 0.1, Sum: 182.4]</div><div class="line">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>: Min: 5914.2, Avg: 5914.2, Max: 5914.3, Diff: 0.0]</div><div class="line">   [Code Root Fixup: 0.2 ms]</div><div class="line">   [Code Root Purge: 0.0 ms]</div><div class="line">   [Clear CT: 0.3 ms]</div><div class="line">   [Other: 5.4 ms]</div><div class="line">      [Choose CSet: 0.0 ms]</div><div class="line">      [Ref Proc: 4.8 ms]</div><div class="line">      [Ref Enq: 0.1 ms]</div><div class="line">      [Redirty Cards: 0.2 ms]</div><div class="line">      [Humongous Register: 0.0 ms]</div><div class="line">      [Humongous Reclaim: 0.0 ms]</div><div class="line">      [Free CSet: 0.2 ms]</div><div class="line">   [Eden: 251.0<span class="title">M</span><span class="params">(<span class="number">251.0</span>M)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">273.0</span>M)</span> Survivors: 14.0M-&gt;34.0M Heap: 286.6<span class="title">M</span><span class="params">(<span class="number">512.0</span>M)</span>-&gt;58.6<span class="title">M</span><span class="params">(<span class="number">512.0</span>M)</span>]</div><div class="line"> [Times: user=<span class="number">0.18</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</div><div class="line"></div><div class="line"> <span class="number">8.119</span>: [<span class="function">GC <span class="title">pause</span> <span class="params">(Metadata GC Threshold)</span> <span class="params">(young)</span> <span class="params">(initial-mark)</span>, 0.0240591 secs]</span></div><div class="line">   [Parallel Time: 14.9 ms, GC Workers: 8]</div><div class="line">      [GC Worker <span class="title">Start</span> <span class="params">(ms)</span>: Min: 8119.1, Avg: 8119.4, Max: 8120.3, Diff: 1.1]</div><div class="line">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.5, Avg: 2.3, Max: 9.7, Diff: 9.2, Sum: 18.2]</div><div class="line">      [Update <span class="title">RS</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.2, Max: 0.4, Diff: 0.4, Sum: 1.2]</div><div class="line">         [Processed Buffers: Min: 0, Avg: 2.5, Max: 6, Diff: 6, Sum: 20]</div><div class="line">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.7, Max: 0.9, Diff: 0.9, Sum: 5.4]</div><div class="line">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.2, Max: 0.4, Diff: 0.4, Sum: 1.3]</div><div class="line">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>: Min: 4.9, Avg: 11.1, Max: 12.4, Diff: 7.5, Sum: 89.2]</div><div class="line">      [<span class="title">Termination</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.7]</div><div class="line">         [Termination Attempts: Min: 1, Avg: 20.9, Max: 31, Diff: 30, Sum: 167]</div><div class="line">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</div><div class="line">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>: Min: 13.7, Avg: 14.5, Max: 14.8, Diff: 1.1, Sum: 116.1]</div><div class="line">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>: Min: 8133.9, Avg: 8134.0, Max: 8134.0, Diff: 0.0]</div><div class="line">   [Code Root Fixup: 0.3 ms]</div><div class="line">   [Code Root Purge: 0.0 ms]</div><div class="line">   [Clear CT: 0.2 ms]</div><div class="line">   [Other: 8.6 ms]</div><div class="line">      [Choose CSet: 0.0 ms]</div><div class="line">      [Ref Proc: 8.2 ms]</div><div class="line">      [Ref Enq: 0.0 ms]</div><div class="line">      [Redirty Cards: 0.1 ms]</div><div class="line">      [Humongous Register: 0.0 ms]</div><div class="line">      [Humongous Reclaim: 0.0 ms]</div><div class="line">      [Free CSet: 0.1 ms]</div><div class="line">   [Eden: 159.0<span class="title">M</span><span class="params">(<span class="number">273.0</span>M)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">291.0</span>M)</span> Survivors: 34.0M-&gt;16.0M Heap: 219.6<span class="title">M</span><span class="params">(<span class="number">512.0</span>M)</span>-&gt;68.1<span class="title">M</span><span class="params">(<span class="number">512.0</span>M)</span>]</div><div class="line"> [Times: user=<span class="number">0.11</span> sys=<span class="number">0.00</span>, real=<span class="number">0.03</span> secs]</div><div class="line"><span class="number">8.143</span>: [GC concurrent-root-region-scan-start]</div><div class="line"><span class="number">8.151</span>: [GC concurrent-root-region-scan-end, <span class="number">0.0081611</span> secs]</div><div class="line"><span class="number">8.151</span>: [GC concurrent-mark-start]</div><div class="line"><span class="number">8.191</span>: [GC concurrent-mark-end, <span class="number">0.0399863</span> secs]</div><div class="line"><span class="number">8.192</span>: [GC remark <span class="number">8.192</span>: [Finalize Marking, <span class="number">0.0005544</span> secs] <span class="number">8.192</span>: [GC ref-proc, <span class="number">0.0002680</span> secs] <span class="number">8.192</span>: [Unloading, <span class="number">0.0068146</span> secs], <span class="number">0.0079309</span> secs]</div><div class="line"> [Times: user=<span class="number">0.04</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</div><div class="line"><span class="number">8.200</span>: [GC cleanup <span class="number">74</span>M-&gt;<span class="number">66</span>M(<span class="number">512</span>M), <span class="number">0.0005223</span> secs]</div><div class="line"> [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</div><div class="line"><span class="number">8.201</span>: [GC concurrent-cleanup-start]</div><div class="line"><span class="number">8.201</span>: [GC concurrent-cleanup-end, <span class="number">0.0000154</span> secs]</div></pre></td></tr></table></figure></p>
<p>目前来说，大内存对G1支持的较好，其余的情况有待观察。是否将GC替换为G1还有待实验（何况很多公司还在用JDK 1.7）。有消息称JDK 9会把G1作为默认的GC。</p>
<hr>
<h1 id="其他的JVM_GC实现">其他的JVM GC实现</h1><p>关于低延时的GC实现，Azul的<strong>C4: The Continuously Concurrent Compacting Collector</strong>做的挺好的，STW时间非常低，而且对超大堆支持的很好（据说能支持2T的内存。。），当然吞吐量会稍弱。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》，周志明 著</li>
<li><em>Garbage Collection Understanding Java, Azul</em></li>
<li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="external">Getting Started with the G1 Garbage Collector</a></li>
<li><em>Garbage-First Garbage Collection, David Detlefs, Christine Flood, Steve Heller, Tony Printezis, Sun Microsystems, Inc.</em></li>
<li><a href="https://blogs.oracle.com/jonthecollector/entry/did_you_know" target="_blank" rel="external">Jon Masamitsu’s Weblog - an article about CMS</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入探究JVM | Safepoint及GC的触发条件]]></title>
      <url>http://www.sczyh30.com/posts/Java/jvm-gc-safepoint-condition/</url>
      <content type="html"><![CDATA[<p>最近看JVM看得火热。。在这里我们来总结一下HotSpot JVM里GC Safepoint以及触发GC的条件相关的一些知识。</p>
<h1 id="GC_Safepoint">GC Safepoint</h1><p>如果要触发一次GC，那么JVM中所有Java线程都必须到达GC Safepoint。</p>
<p>JVM只会在特定位置放置safepoint，比如：</p>
<ul>
<li>内存分配的地方（allocation，即new一个新对象的时候）</li>
<li>长时间执行区块结束的时刻（如方法调用，循环跳转等）</li>
</ul>
<p>之所以只在特定的位置放置safepoint，是因为OopMap要占用空间，如果设太多safepoint那么占用空间会太大；再者，safepoint会影响优化，如果某个无用的值处设置了safepoint，那么JIT就无法优化掉这些无用变量，这会影响性能。</p>
<p>HotSpot JVM在通过JIT编译时，会在所有方法返回之前以及循环跳转、异常跳转之前放置Safepoint，并且在每个Safepoint都生成一些信息存储哪些地方是引用（<strong>OopMap</strong>），以便JVM能找到需要的引用。</p>
<p>那么如何确保GC时所有线程都到达GC Safepoint呢？有两种方法：<strong>抢占式中断</strong>(Preemptive Suspension)和<strong>主动式中断</strong>(Voluntary Suspension)。</p>
<p>抢占式中断不需要线程的执行代码去主动配合，当触发GC时，JVM会中断所有线程，然后依次检查每个线程中断的位置是否为Safepoint，如果不是则恢复线程，让它执行至Safepoint再进行终端。</p>
<p>大部分JVM实现（如HotSpot JVM）都是采用<strong>主动式中断</strong>，即GC需要中断线程的时候，它仅仅简单地设个标志，执行线程会主动轮询这个标志位，如果标志位就绪的话就自行中断。Polling Point与Safepoint是重合的。主动式中断的思想是一种hand-shacking protocol的思想。</p>
<p>通过对Safepoint的研究，我们了解到了GC触发的时刻主要是在<strong>new一个新的对象</strong>或者在<strong>循环跳转或方法返回之前</strong>。</p>
<p>【扩展】Safepoint有好几种，比如还有<strong>deoptimization safepoint</strong>之类的，作用不同。</p>
<h1 id="Safe-Region">Safe-Region</h1><p>只有GC Safepoint是不足的，因为我们发现，有一种情况，线程无法响应JVM的中断请求，也无法去轮询标志位：</p>
<ul>
<li>线程处于阻塞或等待状态</li>
</ul>
<p>对于这种情况，引入了safe-region的概念。</p>
<p>Safe-Region是指在代码片段中，引用关系不会发生变化，因此GC可以随心所欲地在任何地方执行。在线程执行到Safe Region里面的代码时，首先标识自己已经进入了Safe Region，那样当这段时间里JVM要发起GC，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<p>另外，当一个线程在执行native方法时，由于此时该线程在执行JVM管理之外的代码，不能对JVM的执行状态做任何修改，因而JVM要进入safepoint不需要关心它。所以也可以把正在执行native函数的线程看作“已经进入了safepoint”，或者把这种情况叫做“在safe-region里”。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://www.infoq.com/cn/articles/jvm-memory-collection" target="_blank" rel="external">JVM内存回收理论与实现, 周志明</a></li>
<li><a href="http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html" target="_blank" rel="external">GC safe-point (or safepoint) and safe-region, Xiao-Feng Li</a></li>
<li><a href="https://www.zhihu.com/question/29268019" target="_blank" rel="external">现代JVM中的Safe Region和Safe Point到底是如何定义和划分的? - RednaxelaFX的回答</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入探究JVM | 初探GC算法]]></title>
      <url>http://www.sczyh30.com/posts/Java/jvm-gc-method-types/</url>
      <content type="html"><![CDATA[<p>GC算法的思想主要有三种：</p>
<ul>
<li>Mark-Sweep</li>
<li>Mark-Compact</li>
<li>Copying</li>
</ul>
<p>另外，当前JVM的GC一般都是分代收集，几种垃圾回收算法进行组合。</p>
<h1 id="分代收集">分代收集</h1><p>根据分代收集的模型，一般将内存区域分为<strong>新生代(Young Generation)</strong>和<strong>老年代(Old Generation)</strong>。</p>
<p>新生代对应那些<strong>新产生的，存活时间较短的对象</strong>。如果一个对象在新生代内经历了一定次数（默认15）的收集后，它就会晋升至老年代（大对象也可以直接进入老年代，可以调参数）。一般会把新生代划分为Eden区和Suvivor区，在HotSpot JVM中E:2S=8:2。后面会说到，新生代一般使用基于复制的GC算法。新生代对应Minor GC。</p>
<p>老年代对应那些存活时间较长，容量较大的对象。老年代GC对应Full GC，此时需要STW。</p>
<p>JDK1.8之前还存在永久代（PermGen），它用于存放类的元数据和常量，这里偶尔也会发生GC（回收无用的类和常量等等的）。由于永久代经常会OOM，JDK1.8移除了永久代，用Metaspace代替PermGen。具体可以看我之前总结的<a href="http://www.sczyh30.com/posts/Java/jvm-metaspace/">深入探究JVM | 探秘Metaspace</a>。</p>
<h1 id="基于标记-清理的GC">基于标记-清理的GC</h1><p>基于标记-清理(Mark-Sweep)的GC是比较基础的一种实现，它的思想比较简单，首先根据可达性分析对不可达对象进行标记，标记完成后统一清理这些对象。它的缺点有两个：</p>
<ul>
<li>标记和清理的效率都不算高</li>
<li>会产生大量的内存碎片，如果这时候有大对象需要连续的内存空间进行分配，很可能会因为没有足够的连续内存空间而又触发一次GC</li>
</ul>
<p>基于Mark-Sweep的GC多用于老年代。</p>
<h1 id="基于标记-压缩的GC">基于标记-压缩的GC</h1><p>基于标记-压缩(Mark-Compact)的GC可以解决内存碎片的问题。它的思想是，在标记好待回收对象后，将存活的对象移至一端(reallocate)然后对剩余的部分进行回收。这个过程需要进行<code>remapping</code>，即修复线程与对象之间的引用映射关系。</p>
<p>基于Mark-Compact的GC多用于老年代。</p>
<h1 id="基于复制的GC">基于复制的GC</h1><p>基于复制(Copy)的GC比较高效，它的思路是，将内存容量划分为相同的两份，每次只用一块。当这一块内存用完了，就把还存活的对象移到另一块内存，然后对这一块内存（整个半区）进行清理操作。这样内存分配时也就不用考虑内存碎片了，只需要移动指针，按顺序分配即可。但是这种算法是拿空间换时间，而且一下子就是50%的内存空间，一般受不了。并且这种算法需要频繁GC。而新生代的对象一般是存活时间较短的对象，GC频率较高，占内存较少，因此新生代一般都采用基于复制的GC。</p>
<p>HotSpot JVM将新生代划分为一个Eden区和两个Survivor区，默认比例为8:2，其中对象可使用1E+1S，留出空闲的1S。每次进行GC的时候收集器就会将存活对象移至那个空闲S区，然后将其余的部分进行回收，这样默认空间利用率可达90%。当然也有很多时候一个S区无法容纳所有的存货对象，那么某些对象就需要通过分配担保机制(Handle Promotion)直接进入老年代。</p>
<h1 id="当前商用实现">当前商用实现</h1><p>这是现有的商用GC对应的算法：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/jvm-gc-impl-all-algo.PNG" alt=""></p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》，周志明 著</li>
<li><em>Garbage Collection Understanding Java, Azul</em></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的几种引用 | 弱引用、软引用、虚引用]]></title>
      <url>http://www.sczyh30.com/posts/Java/java-reference-type/</url>
      <content type="html"><![CDATA[<p>Java中存在四种引用：强引用、软引用、弱引用、虚引用，这里来分别分析一下。</p>
<h1 id="StrongReference">StrongReference</h1><p><strong>StrongReference</strong>（强引用）是最普通的引用类型，只要强引用存在，GC就不会进行垃圾回收。</p>
<h1 id="SoftReference">SoftReference</h1><p><strong>SoftReference</strong>（软引用）用来描述一些有用但是非必需的对象。如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM就会把这个软引用加入到与之关联的引用队列中。软引用可用来实现内存敏感的高速缓存。</p>
<h1 id="WeakReference">WeakReference</h1><p><strong>WeakReference</strong>（弱引用）是一种生命周期比软引用更短的引用。当GC扫描启动时，只要扫描到只具有弱引用的对象，<strong>无论内存是否够用都会执行GC</strong>，但由于GC线程优先级很低，因此并不一定能迅速发现这些弱引用对象。弱引用也可以和一个引用队列联合使用。<br>WeakReference在Android中用的挺多。</p>
<h1 id="PhantomReference">PhantomReference</h1><p><strong>PhantomReference</strong>（虚引用）不同于其余三种引用，虚引用不会影响对象的生命周期，也无法通过虚引用获得对象的一个实例；如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动，它必须和引用队列联合使用。</p>
<p>【2015-7-16补充】逛InfoQ的时候又发现了一种FinalReference。。用的不多就不总结了，文章：<a href="http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference" target="_blank" rel="external">JVM源码分析之FinalReference完全解读</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入探究JVM | 初探GC - 引用计数 VS 可达分析]]></title>
      <url>http://www.sczyh30.com/posts/Java/jvm-gc-intro-count-vs-reachability/</url>
      <content type="html"><![CDATA[<p>主流的垃圾回收主要分两大类：引用计数和可达性分析。</p>
<h1 id="引用计数法">引用计数法</h1><p>引用计数的实现很简单，它的思想就是给一个对象增加一个引用计数器，每当一个新的对象引用它时就给计数器加1，不引用了就减1，当计数器为0时即可认为对象无用了，可进行回收。</p>
<p>这个思想很简单，而且很多语言的底层（如Swift，Python）都是基于引用计数法进行回收的。但是引用计数法有一个很大的缺陷：它无法解决循环引用的问题，比如A引用B，B引用A，这样两对象的引用计数器永远不为0，两对象不能被回收，从而造成内存不能被及时清理。</p>
<p>JVM没有使用引用计数法，而是使用了可达性分析来进行GC。</p>
<p>题外话：C++ 11的智能指针就是基于引用计数的，它提供了<code>weak_ptr</code>来解决循环引用的问题。（类似于Java中的<code>WeakReference</code>，作用类似）</p>
<h1 id="可达性分析">可达性分析</h1><p>可达性分析是基于图论的分析方法，它会找一组对象作为GC Root（根结点），并从根结点进行遍历，遍历结束后如果发现某个对象是不可达的（即从GC Root到此对象没有路径），那么它就会被标记为不可达对象，等待GC。比如，假设下图中obj1位GC Root，那么obj5和obj6就是不可达的：</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/graph-gc-reachable.png" alt=""></p>
<h1 id="哪些对象可以作为GC_Root">哪些对象可以作为GC Root</h1><p>能作为GC Root的对象必定为可以存活的对象，比如全局性的引用（<strong>静态变量和常量</strong>）以及某些方法的<strong>局部变量</strong>（栈帧中的本地变量表）。</p>
<p>以下对象通常可以作为GC Root：</p>
<ul>
<li>存活的线程</li>
<li><strong>虚拟机栈(栈桢中的本地变量表)中的引用的对象</strong></li>
<li><strong>方法区中的类静态属性以及常量引用的对象</strong></li>
<li><strong>本地方法栈中JNI引用的局部变量以及全局变量</strong></li>
</ul>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="https://www.yourkit.com/docs/java/help/gc_roots.jsp" target="_blank" rel="external">GC roots</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入探究JVM | 探秘Metaspace]]></title>
      <url>http://www.sczyh30.com/posts/Java/jvm-metaspace/</url>
      <content type="html"><![CDATA[<p>Java 8彻底将永久代移除出了HotSpot JVM，将其原有的数据迁移至Java Heap或Metaspace。这一篇文章我们来总结一下Metaspace（元空间）的特性。如有错误，敬请指出，谢谢~</p>
<hr>
<h1 id="引言：永久代为什么被移出HotSpot_JVM了？">引言：永久代为什么被移出HotSpot JVM了？</h1><p>在HotSpot JVM中，永久代中用于存放类和方法的元数据以及常量池，在Java中对应能通过反射获取到的数据，比如<code>Class</code>和<code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p>
<p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <em>java.lang.OutOfMemoryError: PermGen</em> 。为此我们不得不对虚拟机做调优<br>那么，Java 8中永久代为什么被移出HotSpot JVM了？<br>详见：<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a><br>原因主要有两个：</p>
<ul>
<li>1、由于Permanent Generation内存经常不够用或发生内存泄露，引发恼人的<em>java.lang.OutOfMemoryError: PermGen</em> （在Java Web开发中非常常见）。</li>
<li>2、移除Permanent Generation可以促进HotSpot JVM与JRockit VM的融合，因为JRockit没有永久代。</li>
</ul>
<p>根据上面的各种原因，永久代最终被移除，<strong>方法区移至Metaspace，字符串常量移至Java Heap</strong>。</p>
<h1 id="探秘元空间">探秘元空间</h1><p>由于Metaspace的资料比较少，这里主要是依据Oracle官方的Java虚拟机规范及Oracle Blog里的几篇文章来总结的。</p>
<p>首先，Metaspace（元空间）是哪一块区域？官方的解释是：</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p>
</blockquote>
<p>也就是说，JDK 8开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。</p>
<h2 id="1、优点">1、优点</h2><p>使用本地内存有什么好处呢？最直接的表现就是OOM问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让Metaspace变得无限大显然是不现实的，因此我们也要限制Metaspace的大小：使用<strong>-XX:MaxMetaspaceSize</strong>参数来指定Metaspace区域的大小。JVM默认在运行时根据需要动态地设置<strong>MaxMetaspaceSize</strong>的大小。</p>
<p>除此之外，它还有以下优点：</p>
<ul>
<li>Take advantage of Java Language Specification property : Classes and associated metadata lifetimes match class loader’s</li>
<li>Linear allocation only</li>
<li>No individual reclamation (except for RedefineClasses and class loading failure)</li>
<li>No GC scan or compaction</li>
<li>No relocation for metaspace objects</li>
</ul>
<h2 id="2、垃圾回收">2、垃圾回收</h2><p>如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）。</p>
<p>为了减少垃圾回收的频率及时间，控制吞吐量，对Metaspace进行适当的监控和调优是非常有必要的。如果在Metaspace区发生了频繁的Full GC，那么可能表示存在内存泄露或Metaspace区的空间太小了。</p>
<h2 id="3、新增参数">3、新增参数</h2><ul>
<li><strong>-XX:MetaspaceSize</strong>是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，<em>the initial high-water-mark</em> )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li>
<li><strong>-XX:MaxMetaspaceSize</strong>是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</li>
<li><strong>-XX:MinMetaspaceFreeRatio</strong>表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</li>
<li><strong>-XX:MaxMetaspaceFreeRatio</strong>表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</li>
</ul>
<h2 id="4、监控与调优（待补充）">4、监控与调优（待补充）</h2><p><code>VisualVM</code>, <code>jstat</code>, <code>jstack</code>可以监测元空间的动态，后续将更新这里。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li><em>The Java Virtual Machine Specification, Java SE 8 Edition, Oracle</em></li>
<li><a href="http://java-latte.blogspot.sg/2014/03/metaspace-in-java-8.html" target="_blank" rel="external">Metaspace in Java 8</a></li>
<li><a href="http://stackoverflow.com/questions/24074164/what-is-the-use-of-metaspace-in-java-8" target="_blank" rel="external">What is the use of Metaspace in Java 8? - StackOverflow</a></li>
<li><a href="https://blogs.oracle.com/poonam/entry/about_g1_garbage_collector_permanent" target="_blank" rel="external">About G1 Garbage Collector, Permanent Generation and Metaspace</a></li>
<li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a></li>
<li><a href="http://stackoverflow.com/questions/18339707/permgen-elimination-in-jdk-8/22509753#22509753" target="_blank" rel="external">PermGen elimination in JDK 8 - StackOverflow</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入解析Java反射（2） - invoke方法]]></title>
      <url>http://www.sczyh30.com/posts/Java/java-reflection-2/</url>
      <content type="html"><![CDATA[<p>上篇文章中回顾了一下Java反射相关的基础内容。这一节我们来深入研究Method类中的invoke方法，探寻它的奥秘。<br>注:本篇文章的所有源码都基于OpenJDK 1.8。</p>
<hr>
<h1 id="引入">引入</h1><p>即使没有学过反射，大家也一定会见过invoke方法。因为很多方法调用都是靠invoke方法，所以很多异常的抛出都会定位到invoke方法，比如下面的情形大家会很熟悉:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">java.lang.NullPointerException</div><div class="line">  at ......</div><div class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</div><div class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</div><div class="line">  at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</div></pre></td></tr></table></figure></p>
<p>大家在看到异常抛出时，除了想要排除Bug，是不是同时也对这个神秘的invoke乃至invoke0方法有一些好奇呢？我们下面就来揭开它神秘的面纱，探寻底层的机制。</p>
<h1 id="浅析invoke过程">浅析invoke过程</h1><p>上一篇文章我们讲过，invoke方法用来在运行时动态地调用某个实例的方法。它的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallerSensitive</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></div><div class="line">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</div><div class="line">       InvocationTargetException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!override) &#123;</div><div class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</div><div class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</div><div class="line">            checkAccess(caller, clazz, obj, modifiers);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></div><div class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</div><div class="line">        ma = acquireMethodAccessor();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们根据invoke方法的实现，将其分为以下几步：</p>
<h2 id="1、权限检查">1、权限检查</h2><p>invoke方法会首先检查AccessibleObject的override属性的值。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。<br>override的值默认是false,表示需要权限调用规则，调用方法时需要检查权限;我们也可以用setAccessible方法设置为true,若override的值为true，表示忽略权限规则，调用方法时无需检查权限（也就是说可以调用任意的private方法，违反了封装）。<br>如果override属性为默认值false，则进行进一步的权限检查：<br>（1）首先用Reflection.quickCheckMemberAccess(clazz, modifiers)方法检查方法是否为public，如果是的话跳出本步；如果不是public方法，那么用Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallerSensitive</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getCallerClass();</div></pre></td></tr></table></figure></p>
<p>在OpenJDK的源码中找到此方法的JNI入口(Reflection.c):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jclass JNICALL <span class="title">Java_sun_reflect_Reflection_getCallerClass__</span></span></div><div class="line"><span class="params">(JNIEnv *env, jclass unused)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> JVM_GetCallerClass(env, JVM_CALLER_DEPTH);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中JVM_GetCallerClass的源码如下，有兴趣的可以研究一下(位于jvm.cpp):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env, <span class="keyword">int</span> depth))</div><div class="line">  JVMWrapper(<span class="string">"JVM_GetCallerClass"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Pre-JDK 8 and early builds of JDK 8 don't have a CallerSensitive annotation; or</span></div><div class="line">  <span class="comment">// sun.reflect.Reflection.getCallerClass with a depth parameter is provided</span></div><div class="line">  <span class="comment">// temporarily for existing code to use until a replacement API is defined.</span></div><div class="line">  <span class="keyword">if</span> (SystemDictionary::reflect_CallerSensitive_klass() == <span class="literal">NULL</span> || depth != JVM_CALLER_DEPTH) &#123;</div><div class="line">    Klass* k = thread-&gt;security_get_caller_class(depth);</div><div class="line">    <span class="keyword">return</span> (k == <span class="literal">NULL</span>) ? <span class="literal">NULL</span> : (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Getting the class of the caller frame.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// The call stack at this point looks something like this:</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]</span></div><div class="line">  <span class="comment">// [1] [ @CallerSensitive API.method                                   ]</span></div><div class="line">  <span class="comment">// [.] [ (skipped intermediate frames)                                 ]</span></div><div class="line">  <span class="comment">// [n] [ caller                                                        ]</span></div><div class="line">  <span class="function">vframeStream <span class="title">vfst</span><span class="params">(thread)</span></span>;</div><div class="line">  <span class="comment">// Cf. LibraryCallKit::inline_native_Reflection_getCallerClass</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; !vfst.at_end(); vfst.security_next(), n++) &#123;</div><div class="line">    Method* m = vfst.method();</div><div class="line">    assert(m != <span class="literal">NULL</span>, <span class="string">"sanity"</span>);</div><div class="line">    <span class="keyword">switch</span> (n) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">      <span class="comment">// This must only be called from Reflection.getCallerClass</span></div><div class="line">      <span class="keyword">if</span> (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) &#123;</div><div class="line">        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), <span class="string">"JVM_GetCallerClass must only be called from Reflection.getCallerClass"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// fall-through</span></div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">      <span class="comment">// Frame 0 and 1 must be caller sensitive.</span></div><div class="line">      <span class="keyword">if</span> (!m-&gt;caller_sensitive()) &#123;</div><div class="line">        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(<span class="string">"CallerSensitive annotation expected at frame %d"</span>, n));</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">if</span> (!m-&gt;is_ignored_by_security_stack_walk()) &#123;</div><div class="line">        <span class="comment">// We have reached the desired frame; return the holder class.</span></div><div class="line">        <span class="keyword">return</span> (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">JVM_END</div></pre></td></tr></table></figure></p>
<p>获取了这个Class对象caller后用checkAccess方法做一次快速的权限校验，其实现为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> Object securityCheckCache;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkAccess</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; clazz, Object obj, <span class="keyword">int</span> modifiers)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalAccessException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (caller == clazz) &#123;  <span class="comment">// 快速校验</span></div><div class="line">            <span class="keyword">return</span>;             <span class="comment">// 权限通过校验</span></div><div class="line">        &#125;</div><div class="line">        Object cache = securityCheckCache;  <span class="comment">// read volatile</span></div><div class="line">        Class&lt;?&gt; targetClass = clazz;</div><div class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span></div><div class="line">            &amp;&amp; Modifier.isProtected(modifiers)</div><div class="line">            &amp;&amp; ((targetClass = obj.getClass()) != clazz)) &#123;</div><div class="line">            <span class="comment">// Must match a 2-list of &#123; caller, targetClass &#125;.</span></div><div class="line">            <span class="keyword">if</span> (cache <span class="keyword">instanceof</span> Class[]) &#123;</div><div class="line">                Class&lt;?&gt;[] cache2 = (Class&lt;?&gt;[]) cache;</div><div class="line">                <span class="keyword">if</span> (cache2[<span class="number">1</span>] == targetClass &amp;&amp;</div><div class="line">                    cache2[<span class="number">0</span>] == caller) &#123;</div><div class="line">                    <span class="keyword">return</span>;     <span class="comment">// ACCESS IS OK</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">// (Test cache[1] first since range check for [1]</span></div><div class="line">                <span class="comment">// subsumes range check for [0].)</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache == caller) &#123;</div><div class="line">            <span class="comment">// Non-protected case (or obj.class == this.clazz).</span></div><div class="line">            <span class="keyword">return</span>;             <span class="comment">// ACCESS IS OK</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If no return, fall through to the slow path.</span></div><div class="line">        slowCheckMemberAccess(caller, clazz, obj, modifiers, targetClass);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先先执行一次快速校验，一旦调用方法的Class正确则权限检查通过。<br>若未通过，则创建一个缓存，中间再进行一堆检查（比如检验是否为protected属性）。<br>如果上面的所有权限检查都未通过，那么将执行更详细的检查，其实现为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Keep all this slow stuff out of line:</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slowCheckMemberAccess</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; clazz, Object obj, <span class="keyword">int</span> modifiers,</span></span></div><div class="line">                           Class&lt;?&gt; targetClass)</div><div class="line">    <span class="keyword">throws</span> IllegalAccessException</div><div class="line">&#123;</div><div class="line">    Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);</div><div class="line"></div><div class="line">    <span class="comment">// Success: Update the cache.</span></div><div class="line">    Object cache = ((targetClass == clazz)</div><div class="line">                    ? caller</div><div class="line">                    : <span class="keyword">new</span> Class&lt;?&gt;[] &#123; caller, targetClass &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// Note:  The two cache elements are not volatile,</span></div><div class="line">    <span class="comment">// but they are effectively final.  The Java memory model</span></div><div class="line">    <span class="comment">// guarantees that the initializing stores for the cache</span></div><div class="line">    <span class="comment">// elements will occur before the volatile write.</span></div><div class="line">    securityCheckCache = cache;         <span class="comment">// write volatile</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大体意思就是，用Reflection.ensureMemberAccess方法继续检查权限，若检查通过就更新缓存，这样下一次同一个类调用同一个方法时就不用执行权限检查了，这是一种简单的缓存机制。由于JMM的happens-before规则能够保证缓存初始化能够在写缓存之前发生，因此两个cache不需要声明为volatile。<br>到这里，前期的权限检查工作就结束了。如果没有通过检查则会抛出异常，如果通过了检查则会到下一步。</p>
<h2 id="2、调用MethodAccessor的invoke方法">2、调用MethodAccessor的invoke方法</h2><p>Method.invoke()实际上并不是自己实现的反射调用逻辑，而是委托给sun.reflect.MethodAccessor来处理。<br>首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。root对象其声明及注释为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> MethodAccessor methodAccessor;</div><div class="line"><span class="comment">// For sharing of MethodAccessors. This branching structure is</span></div><div class="line"><span class="comment">// currently only two levels deep (i.e., one root Method and</span></div><div class="line"><span class="comment">// potentially many Method objects pointing to it.)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If this branching structure would ever contain cycles, deadlocks can</span></div><div class="line"><span class="comment">// occur in annotation code.</span></div><div class="line"><span class="keyword">private</span> Method  root;</div></pre></td></tr></table></figure></p>
<p>那么MethodAccessor到底是个啥玩意呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** This interface provides the declaration for</span></div><div class="line">    java.lang.reflect.Method.invoke(). Each Method object is</div><div class="line">    configured with a (possibly dynamically-generated) class which</div><div class="line">    implements this interface.</div><div class="line">*/</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</div><div class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Method&#125; */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到MethodAccessor是一个接口，定义了invoke方法。分析其Usage可得它的具体实现类有:</p>
<ul>
<li>sun.reflect.DelegatingMethodAccessorImpl</li>
<li>sun.reflect.MethodAccessorImpl</li>
<li>sun.reflect.NativeMethodAccessorImpl</li>
</ul>
<p>第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建；等第一次调用时才新创建MethodAccessor并更新给root，然后调用MethodAccessor.invoke()完成反射调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NOTE that there is no synchronization used here. It is correct</span></div><div class="line"><span class="comment">// (though not efficient) to generate more than one MethodAccessor</span></div><div class="line"><span class="comment">// for a given Method. However, avoiding synchronization will</span></div><div class="line"><span class="comment">// probably make the implementation more scalable.</span></div><div class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></div><div class="line">    <span class="comment">// if so</span></div><div class="line">    MethodAccessor tmp = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</div><div class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</div><div class="line">        methodAccessor = tmp;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></div><div class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</div><div class="line">        setMethodAccessor(tmp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到methodAccessor实例由reflectionFactory对象操控生成，它在AccessibleObject下的声明如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Reflection factory used by subclasses for creating field,</span></div><div class="line"><span class="comment">// method, and constructor accessors. Note that this is called</span></div><div class="line"><span class="comment">// very early in the bootstrapping process.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ReflectionFactory reflectionFactory =</div><div class="line">    AccessController.doPrivileged(</div><div class="line">        <span class="keyword">new</span> sun.reflect.ReflectionFactory.GetReflectionFactoryAction());</div></pre></td></tr></table></figure>
<p>再研究一下sun.reflect.ReflectionFactory类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Permission reflectionFactoryAccessPerm</div><div class="line">        = <span class="keyword">new</span> RuntimePermission(<span class="string">"reflectionFactoryAccess"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReflectionFactory soleInstance = <span class="keyword">new</span> ReflectionFactory();</div><div class="line">    <span class="comment">// Provides access to package-private mechanisms in java.lang.reflect</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LangReflectAccess langReflectAccess;</div><div class="line"></div><div class="line">    <span class="comment">// 这里设计得非常巧妙</span></div><div class="line">    <span class="comment">// "Inflation" mechanism. Loading bytecodes to implement</span></div><div class="line">    <span class="comment">// Method.invoke() and Constructor.newInstance() currently costs</span></div><div class="line">    <span class="comment">// 3-4x more than an invocation via native code for the first</span></div><div class="line">    <span class="comment">// invocation (though subsequent invocations have been benchmarked</span></div><div class="line">    <span class="comment">// to be over 20x faster). Unfortunately this cost increases</span></div><div class="line">    <span class="comment">// startup time for certain applications that use reflection</span></div><div class="line">    <span class="comment">// intensively (but only once per class) to bootstrap themselves.</span></div><div class="line">    <span class="comment">// To avoid this penalty we reuse the existing JVM entry points</span></div><div class="line">    <span class="comment">// for the first few invocations of Methods and Constructors and</span></div><div class="line">    <span class="comment">// then switch to the bytecode-based implementations.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Package-private to be accessible to NativeMethodAccessorImpl</span></div><div class="line">    <span class="comment">// and NativeConstructorAccessorImpl</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> noInflation        = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>     inflationThreshold = <span class="number">15</span>;</div><div class="line"></div><div class="line">    <span class="comment">//......</span></div><div class="line"></div><div class="line">	<span class="comment">//这是生成MethodAccessor的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">        checkInitted();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</div><div class="line">                generateMethod(method.getDeclaringClass(),</div><div class="line">                               method.getName(),</div><div class="line">                               method.getParameterTypes(),</div><div class="line">                               method.getReturnType(),</div><div class="line">                               method.getExceptionTypes(),</div><div class="line">                               method.getModifiers());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            NativeMethodAccessorImpl acc =</div><div class="line">                <span class="keyword">new</span> NativeMethodAccessorImpl(method);</div><div class="line">            DelegatingMethodAccessorImpl res =</div><div class="line">                <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</div><div class="line">            acc.setParent(res);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//......</span></div><div class="line"></div><div class="line">    <span class="comment">/** We have to defer full initialization of this class until after</span></div><div class="line">    the static initializer is run since java.lang.reflect.Method's</div><div class="line">    static initializer (more properly, that for</div><div class="line">    java.lang.reflect.AccessibleObject) causes this class's to be</div><div class="line">    run, before the system properties are set up. */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkInitted</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initted) <span class="keyword">return</span>;</div><div class="line">        AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="comment">// Tests to ensure the system properties table is fully</span></div><div class="line">                    <span class="comment">// initialized. This is needed because reflection code is</span></div><div class="line">                    <span class="comment">// called very early in the initialization process (before</span></div><div class="line">                    <span class="comment">// command-line arguments have been parsed and therefore</span></div><div class="line">                    <span class="comment">// these user-settable properties installed.) We assume that</span></div><div class="line">                    <span class="comment">// if System.out is non-null then the System class has been</span></div><div class="line">                    <span class="comment">// fully initialized and that the bulk of the startup code</span></div><div class="line">                    <span class="comment">// has been run.</span></div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (System.out == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// java.lang.System not yet fully initialized</span></div><div class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    String val = System.getProperty(<span class="string">"sun.reflect.noInflation"</span>);</div><div class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span> &amp;&amp; val.equals(<span class="string">"true"</span>)) &#123;</div><div class="line">                        noInflation = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    val = System.getProperty(<span class="string">"sun.reflect.inflationThreshold"</span>);</div><div class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            inflationThreshold = Integer.parseInt(val);</div><div class="line">                        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to parse property sun.reflect.inflationThreshold"</span>, e);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    initted = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>观察前面的声明部分的注释，我们可以发现一些有趣的东西。就像注释里说的，实际的MethodAccessor实现有两个版本，一个是Java版本，一个是native版本，两者各有特点。初次启动时Method.invoke()和Constructor.newInstance()方法采用native方法要比Java方法快3-4倍，而启动后native方法又要消耗额外的性能而慢于Java方法。也就是说，Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。这是HotSpot的优化方式带来的性能特性，同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。</p>
<p>为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。</p>
<p>研究ReflectionFactory.newMethodAccessor()生产MethodAccessor对象的逻辑，一开始(native版)会生产NativeMethodAccessorImpl和DelegatingMethodAccessorImpl两个对象。<br>DelegatingMethodAccessorImpl的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Delegates its invocation to another MethodAccessorImpl and can</span></div><div class="line">    change its delegate at run time. */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</div><div class="line"></div><div class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;</div><div class="line">        setDelegate(delegate);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl delegate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.delegate = delegate;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它其实是一个中间层，方便在native版与Java版的MethodAccessor之间进行切换。<br>然后下面就是native版MethodAccessor的Java方面的声明：<br>sun.reflect.NativeMethodAccessorImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Used only for the first few invocations of a Method; afterward,</span></div><div class="line">    switches to bytecode-based implementation */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Method method;</div><div class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</div><div class="line"></div><div class="line">    NativeMethodAccessorImpl(Method method) &#123;</div><div class="line">        <span class="keyword">this</span>.method = method;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// We can't inflate methods belonging to vm-anonymous classes because</span></div><div class="line">        <span class="comment">// that kind of class can't be referred to by name, hence can't be</span></div><div class="line">        <span class="comment">// found from the generated bytecode.</span></div><div class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</div><div class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</div><div class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</div><div class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</div><div class="line">                    generateMethod(method.getDeclaringClass(),</div><div class="line">                                   method.getName(),</div><div class="line">                                   method.getParameterTypes(),</div><div class="line">                                   method.getReturnType(),</div><div class="line">                                   method.getExceptionTypes(),</div><div class="line">                                   method.getModifiers());</div><div class="line">            parent.setDelegate(acc);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每次NativeMethodAccessorImpl.invoke()方法被调用时，程序调用计数器都会增加1，看看是否超过阈值；一旦超过，则调用MethodAccessorGenerator.generateMethod()来生成Java版的MethodAccessor的实现类，并且改变DelegatingMethodAccessorImpl所引用的MethodAccessor为Java版。后续经由DelegatingMethodAccessorImpl.invoke()调用到的就是Java版的实现了。<br>到这里，我们已经追寻到native版的invoke方法在Java一侧声明的最底层 - invoke0了，下面我们将深入到HotSpot JVM中去研究其具体实现。</p>
<h1 id="寻根溯源_-_在JVM层面探究invoke0方法">寻根溯源 - 在JVM层面探究invoke0方法</h1><p>invoke0方法是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jobject JNICALL <span class="title">Java_sun_reflect_NativeMethodAccessorImpl_invoke0</span></span></div><div class="line"><span class="params">(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> JVM_InvokeMethod(env, m, obj, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>openjdk/hotspot/src/share/vm/prims/jvm.cpp<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))</div><div class="line">  JVMWrapper("JVM_InvokeMethod");</div><div class="line">  Handle method_handle;</div><div class="line">  if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) &#123;</div><div class="line">    method_handle = Handle(THREAD, JNIHandles::resolve(method));</div><div class="line">    Handle receiver(THREAD, JNIHandles::resolve(obj));</div><div class="line">    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</div><div class="line">    oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);</div><div class="line">    jobject res = JNIHandles::make_local(env, result);</div><div class="line">    if (JvmtiExport::should_post_vm_object_alloc()) &#123;</div><div class="line">      oop ret_type = java_lang_reflect_Method::return_type(method_handle());</div><div class="line">      assert(ret_type != NULL, "sanity check: ret_type oop must not be NULL!");</div><div class="line">      if (java_lang_Class::is_primitive(ret_type)) &#123;</div><div class="line">        // Only for primitive type vm allocates memory for java object.</div><div class="line">        // See box() method.</div><div class="line">        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">  &#125; else &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_StackOverflowError());</div><div class="line">  &#125;</div><div class="line">JVM_END</div></pre></td></tr></table></figure></p>
<p>其关键部分为Reflection::invoke_method:<br>openjdk/hotspot/src/share/vm/runtime/reflection.cpp<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) &#123;</div><div class="line">  oop mirror             = java_lang_reflect_Method::clazz(method_mirror);</div><div class="line">  int slot               = java_lang_reflect_Method::slot(method_mirror);</div><div class="line">  bool override          = java_lang_reflect_Method::override(method_mirror) != 0;</div><div class="line">  objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));</div><div class="line"></div><div class="line">  oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);</div><div class="line">  BasicType rtype;</div><div class="line">  if (java_lang_Class::is_primitive(return_type_mirror)) &#123;</div><div class="line">    rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);</div><div class="line">  &#125; else &#123;</div><div class="line">    rtype = T_OBJECT;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));</div><div class="line">  Method* m = klass-&gt;method_with_idnum(slot);</div><div class="line">  if (m == NULL) &#123;</div><div class="line">    THROW_MSG_0(vmSymbols::java_lang_InternalError(), "invoke");</div><div class="line">  &#125;</div><div class="line">  methodHandle method(THREAD, m);</div><div class="line"></div><div class="line">  return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面又会涉及到Java的对象模型(klass和oop)，以后继续补充。(<strong>留坑</strong>)</p>
<h1 id="寻根溯源_-_Java版的实现">寻根溯源 - Java版的实现</h1><p>Java版MethodAccessor的生成使用MethodAccessorGenerator实现，由于代码太长，这里就不贴代码了，只贴一下开头的注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Generator for sun.reflect.MethodAccessor and</span></div><div class="line">    sun.reflect.ConstructorAccessor objects using bytecodes to</div><div class="line">    implement reflection. A java.lang.reflect.Method or</div><div class="line">    java.lang.reflect.Constructor object can delegate its invoke or</div><div class="line">    newInstance method to an accessor using native code or to one</div><div class="line">    generated by this class. (Methods and Constructors were merged</div><div class="line">    together in this class to ensure maximum code sharing.) */</div></pre></td></tr></table></figure></p>
<p>这里运用了asm动态生成字节码技术（sun.reflect.ClassFileAssembler)，原理比较复杂，后面讲到AOP要用到asm技术的时候再深入了解一下吧。</p>
<h1 id="本篇总结">本篇总结</h1><p>简单地画了个图表示invoke方法的过程，日后再更时序图：</p>
<p><img src="http://img.blog.csdn.net/20150626130739796" alt="invoke方法的过程"></p>
<h1 id="番外篇">番外篇</h1><ol>
<li>MagicAccessorImpl是什么鬼？</li>
</ol>
<p>原本Java的安全机制使得不同类之间不是任意信息都可见，但JDK里面专门设了个MagicAccessorImpl标记类开了个后门来允许不同类之间信息可以互相访问（由JVM管理）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** &lt;P&gt; MagicAccessorImpl (named for parity with FieldAccessorImpl and</span></div><div class="line">    others, not because it actually implements an interface) is a</div><div class="line">    marker class in the hierarchy. All subclasses of this class are</div><div class="line">    "magically" granted access by the VM to otherwise inaccessible</div><div class="line">    fields and methods of other classes. It is used to hold the code</div><div class="line">    for dynamically-generated FieldAccessorImpl and MethodAccessorImpl</div><div class="line">    subclasses. (Use of the word "unsafe" was avoided in this class's</div><div class="line">    name to avoid confusion with &#123;<span class="doctag">@link</span> sun.misc.Unsafe&#125;.) &lt;/P&gt;</div><div class="line"></div><div class="line">    &lt;P&gt; The bug fix for 4486457 also necessitated disabling</div><div class="line">    verification for this class and all subclasses, as opposed to just</div><div class="line">    SerializationConstructorAccessorImpl and subclasses, to avoid</div><div class="line">    having to indicate to the VM which of these dynamically-generated</div><div class="line">    stub classes were known to be able to pass the verifier. &lt;/P&gt;</div><div class="line"></div><div class="line">    &lt;P&gt; Do not change the name of this class without also changing the</div><div class="line">    VM's code. &lt;/P&gt; */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicAccessorImpl</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>@CallerSensitive注解又是什么鬼？</li>
</ol>
<p>详见：<a href="http://openjdk.java.net/jeps/176" target="_blank" rel="external">JEP 176: Mechanical Checking of Caller-Sensitive Methods</a></p>
<blockquote>
<p>Summary: Improve the security of the JDK’s method-handle implementation by replacing the existing hand-maintained list of caller-sensitive methods with a mechanism that accurately identifies such methods and allows their callers to be discovered reliably.</p>
</blockquote>
<p>JDK 1.8才引进了这个注解，因此在老版本的反射实现里并没有这个玩意。这是它的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A method annotated <span class="doctag">@CallerSensitive</span> is sensitive to its calling class,</div><div class="line"> * via &#123;<span class="doctag">@link</span> sun.reflect.Reflection#getCallerClass Reflection.getCallerClass&#125;,</div><div class="line"> * or via some equivalent.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> John R. Rose</div><div class="line"> */</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;METHOD&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CallerSensitive &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简而言之，用<code>@CallerSensitive</code>注解修饰的方法从一开始就知道具体调用它的对象，这样就不用再经过一系列的检查才能确定具体调用它的对象了。它实际上是调用<code>sun.reflect.Reflection.getCallerClass</code>方法。</p>
<p>Reflection类位于调用栈中的0帧位置，<code>sun.reflect.Reflection.getCallerClass()</code>方法返回调用栈中从0帧开始的第x帧中的类实例。该方法提供的机制可用于确定调用者类，从而实现“感知调用者（Caller Sensitive）”的行为，即允许应用程序根据调用类或调用栈中的其它类来改变其自身的行为。</p>
<hr>
<h1 id="Reference">Reference</h1><ul>
<li><a href="http://openjdk.java.net/jeps/176" target="_blank" rel="external">JEP 176: Mechanical Checking of Caller-Sensitive Methods</a></li>
<li><a href="http://stackoverflow.com/questions/22626808/what-does-the-sun-reflect-callersensitive-annotation-mean" target="_blank" rel="external">StackOverflow上关于@CallerSensitive的回答</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/548536" target="_blank" rel="external">关于反射调用方法的一个log (R大的一篇文章)</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入解析Java反射（1） - 基础]]></title>
      <url>http://www.sczyh30.com/posts/Java/java-reflection-1/</url>
      <content type="html"><![CDATA[<p>因为本人最近正筹备<a href="http://www.sczyh30.com/samsara">Samsara</a>框架的开发，而其中的IOC部分非常依靠反射，因此趁这个机会来总结一下关于Java反射的一些知识。本篇为基本篇，基于JDK 1.8。</p>
<hr>
<h2 id="一、回顾：什么是反射？">一、回顾：什么是反射？</h2><p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>Oracle官方对反射的解释是</p>
<blockquote>
<p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p>
</blockquote>
<p>&emsp;简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。<br>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br>&emsp;反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java反射框架主要提供以下功能：</p>
<ul>
<li>1.在运行时判断任意一个对象所属的类；</li>
<li>2.在运行时构造任意一个类的对象；</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>4.在运行时调用任意一个对象的方法<h5 id="重点：是运行时而不是编译时">重点：<strong>是运行时而不是编译时</strong></h5></li>
</ul>
<h2 id="二、反射的主要用途">二、反射的主要用途</h2><p>&emsp;很多人都认为反射在实际的Java开发应用中并不广泛，其实不然。<br>&emsp;当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。<br>&emsp;<strong>反射最重要的用途就是开发各种通用框架。</strong><br>&emsp;很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。<br>&emsp;举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span></span></div><div class="line">               <span class="attr">class</span>=<span class="string">"org.ScZyhSoft.test.action.SimpleLoginAction"</span></div><div class="line">               <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</div><div class="line">           <span class="tag">&lt;<span class="name">result</span>&gt;</span>/shop/shop-index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。<br>——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。<br>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
<h2 id="三、反射的基本运用">三、反射的基本运用</h2><p>上面我们提到了反射可以用于判断任意对象所属的类，获得Class对象，构造任意一个对象以及调用一个对象。这里我们介绍一下基本反射功能的实现(反射相关的类一般都在java.lang.relfect包里)。</p>
<h4 id="1、获得Class对象">1、获得Class对象</h4><p>方法有三种<br>(1)使用Class类的forName静态方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</div><div class="line">``` </div><div class="line">在JDBC开发中常用此方法加载数据库驱动:</div><div class="line">```java</div><div class="line"> Class.forName(driver);</div></pre></td></tr></table></figure></p>
<p>(2)直接获取某一个对象的class，比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</div><div class="line">Class&lt;?&gt; classInt = Integer.TYPE;</div></pre></td></tr></table></figure></p>
<p>(3)调用某个对象的getClass()方法,比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</div><div class="line">Class&lt;?&gt; klass = str.getClass();</div></pre></td></tr></table></figure></p>
<h4 id="2、判断是否为某个类的实例">2、判断是否为某个类的实例</h4><p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="3、创建实例">3、创建实例</h4><p>通过反射来生成对象主要有两种方式。<br>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line">Object str = c.newInstance();</div></pre></td></tr></table></figure></p>
<p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取String所对应的Class对象</span></div><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line"><span class="comment">//获取String类带一个String参数的构造器</span></div><div class="line">Constructor constructor = c.getConstructor(String.class);</div><div class="line"><span class="comment">//根据构造器创建实例</span></div><div class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</div><div class="line">System.out.println(obj);</div></pre></td></tr></table></figure></p>
<h4 id="4、获取方法">4、获取方法</h4><p>获取某个Class对象的方法集合，主要有以下几个方法：<br>getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></div></pre></td></tr></table></figure></p>
<p>只是这样描述的话可能难以理解，我们用例子来理解这三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.ScZyhSoft.common;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line">	        Class&lt;?&gt; c = methodClass.class;</div><div class="line">	        Object object = c.newInstance();</div><div class="line">	        Method[] methods = c.getMethods();</div><div class="line">	        Method[] declaredMethods = c.getDeclaredMethods();</div><div class="line">	        <span class="comment">//获取methodClass类的add方法</span></div><div class="line">	        Method method = c.getMethod(<span class="string">"add"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</div><div class="line">	        <span class="comment">//getMethods()方法获取的所有方法</span></div><div class="line">	        System.out.println(<span class="string">"getMethods获取的方法："</span>);</div><div class="line">	        <span class="keyword">for</span>(Method m:methods)</div><div class="line">	            System.out.println(m);</div><div class="line">	        <span class="comment">//getDeclaredMethods()方法获取的所有方法</span></div><div class="line">	        System.out.println(<span class="string">"getDeclaredMethods获取的方法："</span>);</div><div class="line">	        <span class="keyword">for</span>(Method m:declaredMethods)</div><div class="line">	            System.out.println(m);</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序运行的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">getMethods获取的方法：</div><div class="line">public int org.ScZyhSoft.common.methodClass.add(int,int)</div><div class="line">public int org.ScZyhSoft.common.methodClass.sub(int,int)</div><div class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</div><div class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</div><div class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</div><div class="line">public boolean java.lang.Object.equals(java.lang.Object)</div><div class="line">public java.lang.String java.lang.Object.toString()</div><div class="line">public native int java.lang.Object.hashCode()</div><div class="line">public final native java.lang.Class java.lang.Object.getClass()</div><div class="line">public final native void java.lang.Object.notify()</div><div class="line">public final native void java.lang.Object.notifyAll()</div><div class="line">getDeclaredMethods获取的方法：</div><div class="line">public int org.ScZyhSoft.common.methodClass.add(int,int)</div><div class="line">public int org.ScZyhSoft.common.methodClass.sub(int,int)</div></pre></td></tr></table></figure></p>
<p>可以看到，通过getMethods()获取的方法可以获取到父类的方法,比如java.lang.Object下定义的各个方法。</p>
<h4 id="5、获取构造器信息">5、获取构造器信息</h4><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></div></pre></td></tr></table></figure></p>
<p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例~</p>
<h4 id="6、获取类的成员变量（字段）信息">6、获取类的成员变量（字段）信息</h4><p>主要是这几个方法，在此不再赘述：<br><em>getFiled</em>: 访问公有的成员变量<br><em>getDeclaredField</em>：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）</p>
<h4 id="7、调用方法">7、调用方法</h4><p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</div><div class="line">           InvocationTargetException</div></pre></td></tr></table></figure></p>
<p>下面是一个实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line">        Class&lt;?&gt; klass = methodClass.class;</div><div class="line">        <span class="comment">//创建methodClass的实例</span></div><div class="line">        Object obj = klass.newInstance();</div><div class="line">        <span class="comment">//获取methodClass类的add方法</span></div><div class="line">        Method method = klass.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</div><div class="line">        <span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></div><div class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于invoke()方法的详解，后面我会专门写一篇文章来深入解析invoke的过程。</p>
<h4 id="8、利用反射创建数组">8、利用反射创建数组</h4><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);</div><div class="line">        Object array = Array.newInstance(cls,<span class="number">25</span>);</div><div class="line">        <span class="comment">//往数组里添加内容</span></div><div class="line">        Array.set(array,<span class="number">0</span>,<span class="string">"hello"</span>);</div><div class="line">        Array.set(array,<span class="number">1</span>,<span class="string">"Java"</span>);</div><div class="line">        Array.set(array,<span class="number">2</span>,<span class="string">"fuck"</span>);</div><div class="line">        Array.set(array,<span class="number">3</span>,<span class="string">"Scala"</span>);</div><div class="line">        Array.set(array,<span class="number">4</span>,<span class="string">"Clojure"</span>);</div><div class="line">        <span class="comment">//获取某一项的内容</span></div><div class="line">        System.out.println(Array.get(array,<span class="number">3</span>));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中的Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></div><div class="line">        <span class="keyword">throws</span> NegativeArraySizeException &#123;</div><div class="line">        <span class="keyword">return</span> newArray(componentType, length);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>而newArray()方法是一个Native方法，它在Hotspot JVM里的具体实现我们后边再研究，这里先把源码贴出来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newArray</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></div><div class="line">        <span class="keyword">throws</span> NegativeArraySizeException;</div></pre></td></tr></table></figure></p>
<p>源码目录:openjdk\hotspot\src\share\vm\runtime\reflection.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) &#123;</div><div class="line">  <span class="keyword">if</span> (element_mirror == <span class="literal">NULL</span>) &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_NullPointerException());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_NegativeArraySizeException());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (java_lang_Class::is_primitive(element_mirror)) &#123;</div><div class="line">    Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);</div><div class="line">    <span class="keyword">return</span> TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    Klass* k = java_lang_Class::as_Klass(element_mirror);</div><div class="line">    <span class="keyword">if</span> (k-&gt;oop_is_array() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) &#123;</div><div class="line">      THROW_0(vmSymbols::java_lang_IllegalArgumentException());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> oopFactory::new_objArray(k, length, THREAD);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外，Array类的set()和get()方法都为Native方法，在HotSpot JVM里分别对应Reflection::array_set和Reflection::array_get方法，这里就不详细解析了。</p>
<h2 id="四、反射的一些注意事项（待补充）">四、反射的一些注意事项（待补充）</h2><p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。<br>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。<br><img src="http://img.my.csdn.net/uploads/201508/02/1438529905_8952.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入探究JVM | Java的内存区域解析]]></title>
      <url>http://www.sczyh30.com/posts/Java/jvm-memory/</url>
      <content type="html"><![CDATA[<p>Java 虚拟机在执行Java程序的时候会把它管理的内存区域划为几部分，这一节我们就来解析一下Java的内存区域。</p>
<hr>
<p>有的人把JVM管理的内存简单地分为堆内存和栈内存，这样分未免有些太肤浅了。<br>Java的内存区域主要分为五部分：</p>
<ul>
<li>程序计数器(PC)</li>
<li>虚拟机栈(JVM Stack)</li>
<li>本地方法栈(Native Method Stack)</li>
<li>Java 堆内存(Java Heap)</li>
<li>方法区(Method Area)</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150626182021585" alt="Java内存区域"><br>（图转自网络）</p>
<p>下面我们来解析这几个区域。</p>
<h2 id="程序计数器">程序计数器</h2><p>相信学过计算机组成原理的人都知道，CPU内部的寄存器中就包含一个程序计数器（x86下为eip寄存器,ARM下为R15寄存器），存放程序执行的下一条指令地址。在程序开始执行前，将程序指令序列的起始地址，即程序的第一条指令所在的内存单元地址送入PC，CPU按照PC的地址从内存中读取第一条指令。每一条指令执行时，CPU会自动修改PC的量至下一条指令的地址，指令之间的跳转离不开PC。JVM内存中的程序计数器也是这样的作用，它储存JVM当前执行bytecode的地址。</p>
<p>Java虚拟机允许多个线程同时执行指令。如果有多个线程正在执行指令，那么每个线程都会有一个程序计数器，它是线程私有的。在任意时刻，一个线程只允许执行一个方法的代码。每当执行到一条Java方法的指令时，程序计数器保存当前执行字节码的地址；若执行的为native方法，则PC的值为undefined。</p>
<h2 id="Java_虚拟机栈">Java 虚拟机栈</h2><p>Java虚拟机栈也是线程私有的，每一条线程都拥有自己私有的Java 虚拟机栈，它与线程同时创建。它描述了Java方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong>，用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。每一个方法从调用直至完成的过程，都对应一个栈帧从入栈到出栈的过程。关于栈帧详细的内容在后边复习虚拟机字节码执行引擎的时候再说吧。<br>Java 虚拟机栈在方法调用和返回中也扮演了很重要的角色。因为除了栈帧的入栈和出栈之外，Java虚拟机栈不会再受其它因素的影响，因此栈帧可在<strong>系统的堆</strong>上分配内存（<strong>注意</strong>，是系统的Heap而不是Java Heap）。Java虚拟机栈所使用的内存不需要保证是连续的。</p>
<h2 id="本地方法栈">本地方法栈</h2><p>本地方法栈和Java虚拟机栈的作用相似，Java虚拟机栈执行的是字节码，而本地方法栈执行的是native方法。本地方法栈使用<strong>传统的栈</strong>（C Stack）来支持native方法。在HotSpot JVM中Java虚拟机栈和本地方法栈合二为一。</p>
<h2 id="Java_堆">Java 堆</h2><p>在JVM中，Java 堆是可供各线程共享的运行时内存区域，是Java 虚拟机所管理的内存区域中最大的一块。此区域非常重要，<strong>几乎所有的对象实例和数组实例都要在Java堆上分配</strong>，但随着JIT编译器及逃逸分析技术的发展，也可能会被优化为栈上分配，高大上。。。）。同时，Java 堆也是发生GC收集的主要区域。<br>从内存回收的角度来看，它可以分为<strong>新生代</strong>和<strong>老年代</strong>，再细分可以分为Eden Space,From Survivor Space,To Survivor Space区域。Java堆的容量可以是固定的，也可以随着需要来扩展，并且在用不到的时候自动收缩。</p>
<h2 id="方法区">方法区</h2><p>方法区是线程共享的，它储存了<strong>每一个类的结构信息</strong>，比如运行时常量池（runtime constant pool）、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些初始化的时候用到的特殊方法。<strong>方法区是堆的逻辑部分。</strong><br>在JDK1.7及以前的HotSpot JVM中，方法区位于<em>永久代</em>（Permanent Generation，<em>PermGen</em>）中。由于永久代内可能会发生内存泄露或溢出等问题而导致的<em>java.lang.OutOfMemoryError: PermGen </em>，JEP小组从JDK1.7开始就筹划移除永久代（<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a>），并且在JDK 1.7中把字符串常量，符号引用等移出了永久代。到了Java 8，永久代被彻底地移出了JVM，取而代之的是<em>元空间</em>（Metaspace）：</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.</p>
</blockquote>
<p>所以从Java 8开始，方法区被移至 <em>Metaspace</em> 内。有关Metaspace的相关总结，见下一篇文章。</p>
<h2 id="运行时常量池">运行时常量池</h2><p>运行时常量池是class文件中每一个类或接口的常量池表的运行时表示形式，是方法区的一部分。它包括了若干种不同的常量。常量池表存放<strong>编译器生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池具有动态性，运行期间也可以将新的量放到运行时常量池中，典型的应用是String类的intern方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p>
<p>JDK 1.7开始，字符串常量和符号引用等就被移出永久代：</p>
<ul>
<li>符号引用迁移至系统堆内存(<em>Native Heap</em>)</li>
<li>字符串字面量迁移至Java堆(<em>Java Heap</em>)</li>
</ul>
<p><strong>下一篇文章我将会总结Java 8中的Metaspace相关知识</strong>。</p>
<hr>
<h1 id="参考资料">参考资料</h1><ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》，周志明 著</li>
<li><a href="http://stackoverflow.com/questions/24074164/what-is-the-use-of-metaspace-in-java-8" target="_blank" rel="external">What is the use of Metaspace in Java 8? - StackOverflow</a></li>
<li><a href="https://blogs.oracle.com/poonam/entry/about_g1_garbage_collector_permanent" target="_blank" rel="external">About G1 Garbage Collector, Permanent Generation and Metaspace</a></li>
<li><em>The Java Virtual Machine Specification, Java SE 8 Edition, Oracle</em></li>
<li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker入门学习札记]]></title>
      <url>http://www.sczyh30.com/posts/Architecture/docker-tutorial/</url>
      <content type="html"><![CDATA[<p>很早之前就听说过Docker，但一直木有实践过。前一阵子参加OSC的源创会时，里面嘉宾讲的东西提到了Docker，感觉Docker是一个很有意义的工具，于是就学习了一下它的基本用法，在此总结一下。</p>
<p>以我的理解，Docker是一种虚拟化容器，这个容器里可以运行各种程序，是一种轻量级的虚拟化技术，使用Golang编写。它与传统的虚拟化技术（KVM和Xen）的区别是，Docker容器是操作系统层面上的虚拟化（<strong>内核级</strong>），基于LXC技术，直接服用本地操作系统，而传统的虚拟化技术则是从硬件方面进行虚拟化。它的好处是，启动特别快，而且对系统资源的利用率较高，一台机器上可以运行很多Docker容器，而且因为Docker非常轻量，它为快速部署提供了很好的技术支持。并且Docker引入了版本控制的思想，可以更好地持续构建和部署。</p>
<p>下面总结一下Docker的基本用法：</p>
<h2 id="安装">安装</h2><p>用apt-get或者yum安装都是坑，基本上都不是最新版本的。要安装还是用官方的命令安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.docker.com/ | sh</div></pre></td></tr></table></figure>
<p>不过由于Docker的安装文件存放在Amazon S3上，会间接性抽风，因此最好找个国内的源。</p>
<p>（2015-7 补充：DaoCloud是不错的选择，服务很好）</p>
<h2 id="容器与镜像">容器与镜像</h2><p>Docker容器可以理解为运行在沙盒里的进程。</p>
<p>通俗地讲，镜像（images）相当于一个类，而容器（container）相当于类的一个实例。容器可以不断地被修改，并通过commit化为一个镜像。</p>
<h2 id="基本命令">基本命令</h2><p>主要有：</p>
<h3 id="Docker信息">Docker信息</h3><p>查看Docker版本：<code>docker version</code><br>登录至远程库：<code>docker login</code></p>
<h3 id="镜像操作">镜像操作</h3><p>列出镜像列表：<code>docker images</code><br>删除镜像：<code>docker rmi [id]</code><br>搜索镜像：<code>docker search [name]</code><br>从远程拉取镜像：<code>docker pull [name]:[tag]</code><br>将镜像发布至远程：<code>docker push [name]</code></p>
<h3 id="容器运行"><strong>容器运行</strong></h3><p>容器运行用<code>docker run</code>命令，它有一些详细的参数很有用，比如：<br>以交互模式启动容器centos:latest : <code>docker run -i - t centos:latest /bin/bash</code><br><code>-i</code>表示支持输入，<code>-t</code>表示命令行交互。<br>以后台模式运行，并进行端口映射: <code>docker run -d -p 8080:8080 sczyh30/tomcat:v1 /start.sh</code><br><code>-d</code>表示daemon，即以后台方式运行。<code>-p</code>表示端口映射。<br>这里用的时候有个比较fucking的地方，如果运行容器的时候相应的命令不阻塞，那么容器会自动结束运行（比如resin）。看来以后运行命令要加个阻塞的命令咯~<br>另外对于在容器里自动执行apt-get命令时，一定要加上-y，否则容器虽然进入交互模式但却无法响应，运行完即退出。</p>
<h3 id="容器管理">容器管理</h3><p>查看正在运行的容器：<code>docker ps</code><br>查看所有容器：<code>docker ps -a</code><br>删除容器：<code>docker rm [name/id]</code><br>删除所有容器：<code>docker rm &#39;docker ps -a -q&#39;</code><br>停止、启动、杀死一个容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$docker</span> stop [Name/ID]</div><div class="line"><span class="variable">$docker</span> start [Name/ID]</div><div class="line"><span class="variable">$docker</span> <span class="built_in">kill</span> [Name/ID]</div></pre></td></tr></table></figure></p>
<p>从容器中读取日志：<code>docker logs [Name/ID]</code><br>列出更改项：<code>docker diff [Name/ID]</code><br>从容器中拷贝文件至本机：<code>docker cp ID:/container_path to_path</code><br>附加到一个运行的容器上：<code>docker attach [ID]</code></p>
<h2 id="容器的简单构建">容器的简单构建</h2><p>通过命令操作来部署容器显然很麻烦，所以通过Dockerfile进行自动化容器构建是非常方便的。<br>这里我自己写了一个简单的Dockerfile来练练手，这是一个用于构建Hexo博客的Dockerfile：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#构建的镜像基础</span></div><div class="line"><span class="keyword">FROM</span> node:slim</div><div class="line"><span class="comment">#维护者</span></div><div class="line"><span class="keyword">MAINTAINER</span> sczyh30 root@sczyh30.com</div><div class="line"><span class="comment">#执行命令用RUN，注意要遇到需要交互的地方加-y</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></div><div class="line">    &amp;&amp; apt-get install -y git ssh-client ca-certificates --no-install-recommends \</div><div class="line">    &amp;&amp; rm -r /var/lib/apt/lists/*</div><div class="line"><span class="comment">#更改时区</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone \</span></div><div class="line">    &amp;&amp; dpkg-reconfigure <span class="_">-f</span> noninteractive tzdata</div><div class="line"><span class="comment">#安装hexo</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> npm install hexo-cli -g</span></div><div class="line"><span class="comment">#初始化</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> / &amp;&amp; hexo init blog &amp;&amp; <span class="built_in">cd</span> blog &amp;&amp; npm install</span></div><div class="line"><span class="comment">#设定默认工作目录</span></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /blog</span></div><div class="line"><span class="comment">#设定暴露端口</span></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></div><div class="line"><span class="comment">#设定容器运行时执行的命令，只能有一条，若多条则执行最后一条</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> hexo s</span></div></pre></td></tr></table></figure></p>
<p>然后在此目录执行构建：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t sczyh30/simple_test:v1 .</div></pre></td></tr></table></figure></p>
<p>.表示在当前目录构建<br>docker build的一些参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">--no-cache=false Do not use cache when building the image</div><div class="line">     -q, --quiet=false Suppress the verbose output generated by the containers</div><div class="line">     --rm=true Remove intermediate containers after a successful build</div><div class="line">     -t, --tag=&quot;&quot; Repository name (and optionally a tag) to be applied to the resulting image in case of success</div></pre></td></tr></table></figure></p>
<p>执行后就会按照Dockerfile的内容进行构建，过几分钟构建成功，用docker run运行一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 80:4000 sczyh30/simple_test:v1</div></pre></td></tr></table></figure></p>
<p>运行成功~在docker ps里可以看到容器已成功运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS              PORTS                  NAMES</div><div class="line">45782259f2c3        sczyh30/simple_test:v1     <span class="string">"/bin/sh -c 'hexo s'"</span>   2 minutes ago        Up 2 minutes         0.0.0.0:80-&gt;4000/tcp   trusting_ramanujan</div></pre></td></tr></table></figure></p>
<p>在浏览器中打开，一个简单的Hexo已经搭好咯~</p>
<p>总结一下，Dockerfile非常方便，以后用它构建容器进行集群部署貌似是不错的选择呢~<br>后面将进行更多的关于Docker的实践。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UE4/CE3游戏引擎把玩总结]]></title>
      <url>http://www.sczyh30.com/posts/Develop/game-dev-ue4ce3/</url>
      <content type="html"><![CDATA[<p>记录我在2015.1 - 2015.3用Unreal Engine 4和CryEngine 3的简单体验~（仅为体验，不涉及具体开发）</p>
<h2 id="Prolouge">Prolouge</h2><p>UE4和CE3是游戏界中两大游戏引擎元老呀~两个游戏引擎都非常强大，广泛用于大型游戏的开发（像寒霜3、RAGE之类的引擎也是非常牛，但无奈只供内部使用，我们木有办法去体验开发的过程。。）这次寒假便体验了一下这两大引擎开发的魅力~而且3月份虚幻4引擎宣布开源，这真是喜大普奔呀！想研究游戏引擎的话可以看UE4的源代码了话说UE4的代码写的非常规范，不像传说中的CE3的代码风格凌乱（虽然性能比UE4好，代码风格这取决于公司的风格吧）<br>先来UE4吧~</p>
<h2 id="UE4使用体验">UE4使用体验</h2><p>UE4相比Unity而言真是复杂太多了，从各种组件和编辑器上就能看出。Unity还要自己写大气散射，UE4的组件里直接就有，而且可以根据需求自定义，真方便~不过每一次改动Map都要重新烘焙一次光照，组件多了会很慢。。</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-06.jpg" alt="部分组件"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-10.jpg" alt="编辑器界面"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-07.jpg" alt="一个虚拟现实的Demo"></p>
<p>体验了一番材质编辑器（Material Designer），非常高级（不是美工不会玩），而且翻译很有问题（Normal本该翻译成法线结果翻译成正常，然后我就愉快的把正常的贴图贴到了法线贴图通道上，然后。。。就没有然后了。。调成英文才发现不对劲。。。官方也玩机翻呀。。）</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-03.jpg" alt="这是自己搓的一个材质"></p>
<p>下面是系统自带的一个材质的一部分配置，注意是一个材质！！碉堡了。</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-08.jpg" alt="系统自带的一个材质 - 冰山一角"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-04.jpg" alt="系统自带材质 - 冰山一角"></p>
<p>UE4提供了可视化编程脚本 Blueprint（蓝图），可以很方便的通过拖拽来完成一些功能，甚至可以用Blueprint完成整个游戏的开发，不需要写代码。（感觉很适合美工诶。。掌握触发器相关蓝图，做个虚拟现实Demo不成问题）至于编程，UE4终于抛弃了UnrealScript，投向了C++的怀抱(C++大法好！)</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-02.jpg" alt="爆炸效果模拟蓝图"></p>
<p>贴图精度高了，不加法线贴图，立体感也很强：</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ue4-05.jpg" alt="对比图"></p>
<p>UE4特别适合做虚拟现实，如果美工给力，场景很真实，再自己搓个AI系统，做出一小个真实世界也是很有可能的~</p>
<p>这是一个虚拟现实的实例：</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-UE4Editor%202015-03-08%2020-15-01-24.png" alt="超级虚拟现实"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-UE4Editor%202015-03-08%2020-16-24-68.png" alt="超级虚拟现实"></p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-UE4Editor%202015-03-08%2020-16-34-74.png" alt="超级虚拟现实"></p>
<p>总之，UE4的各种特效做的特别好，再配上高精度的材质，智能的脚本，好的创意，细致的优化，定能用UE4做出一款好游戏。而且UE4开源，可以根据自己的需要定制引擎，这一点是CE3无法比拟的。（除非有钱，花几百万买下CE3源码，有这钱还不如自己研发一套呢。。）</p>
<p>由于接下来Web方面有任务，UE4的学习就告一段落咯~以后有机会做个虚拟现实系统还是很好的~</p>
<h2 id="CE3使用体验">CE3使用体验</h2><p>CE3的Editor就更强大了，各种特效、脚本设置满天飞，连一个昼夜循环的系统都做得非常心细，不得不说CE3在各方面非常强大。由于这玩意对电脑要求太高，怕把显卡烧了，因此最后就搓了搓demo，玩了玩系统自带的sample，体验了一把以后老老实实继续用UE4和U3D了（逃</p>
<p>CE3的资料甚少，学起来还是有些费事的，只好自己乱捣鼓着玩。</p>
<p>对于CE3的编程，貌似是Flowgraph(FG,类似于虚幻4的Blueprint)，扩展可以用C++、C#和lua，具体的不太了解。。</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ce3-01.png" alt="超级CE3"><br>研究Sample的时候，被它的各种控制组件惊呆了，各种分工明确，非常便于开发（没敢改组件，怕改坏了）</p>
<p><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ce3-02.png" alt="一个完整sample的各种控制"><br><img src="http://7xlgao.com1.z0.glb.clouddn.com/gamedev-ce3-03.png" alt="水面效果"></p>
<p>总之，CE3非常强大，但难度系数也很高，对硬件要求也很高。做大型游戏可以用，要不然授权费太高受不了。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity游戏开发总结]]></title>
      <url>http://www.sczyh30.com/posts/Develop/game-dev-unity/</url>
      <content type="html"><![CDATA[<p>记录我在2014.11 - 2015.2用Unity开发独立游戏的体验~</p>
<h1 id="Prolouge">Prolouge</h1><p>这是一开始玩Unity的时候做的画面→_→现在看起来一分钟就可以堆出来。。然而当时处于探索的初级阶段，捣鼓了不少时间才捣鼓出来。。。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/Unityold%202014-11-24%2015-05-52-61.png" alt="2014.11.24 开发截图"></p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/Unityold%202014-11-25%2018-21-33-49.jpg" alt="2014.11.25 开发截图"></p>
<p>当时的艰辛呀！调个特效都调半天。。</p>
<h1 id="Good_Job">Good Job</h1><p>自己的独立游戏（开发代号XXJ）一共9个场景（部分场景未完成），美工素材大部分都来源于网络（美工渣没办法。。），古风类型的，渲染和游戏脚本为自创，开发用的Unity4.5.5f1。</p>
<h2 id="Scene_1">Scene 1</h2><p>先放一张最原汁原味的Scene 1的图吧~（地图还没来得及起名→_→我想要文艺的名字）</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/unity4-xxj-scene1-01.jpg" alt="XXJ-Scene 1-UltraRendering"></p>
<h2 id="Scene_2">Scene 2</h2><p>Scene 2 - Desert:</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/u3d-dev-s201.jpg" alt="XXJ-Scene 2-UltraRendering-Dev"></p>
<p>待更新~</p>
<h2 id="后记">后记</h2><p>今年3月份Unity 5也轰轰烈烈地发布了。说实话，Unity 5的特效方面改进非常大，特别是光照！然而Unity 5 Project结构貌似也有不小的变动（特别是用自带的Standard Assets，迁移版本都失败了，Shader和脚本的变化应该很大）。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/unity5-t1-20150731122353.jpg" alt="最近体验Unity 5随手搓的Scene"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2014晶体培养 - 硫酸铜单晶]]></title>
      <url>http://www.sczyh30.com/posts/Life/chemistry-jt-2014/</url>
      <content type="html"><![CDATA[<p>此文章记录14年暑假培养硫酸铜单晶的过程~<br>就是比13年强了那么一丁点而已。。一丁点。。。<br>另外还做了个硫酸铜心形晶簇。。。虽然做的不太好（铜丝好难弯成心形！！！）<br>刚翻了翻相册，发现硫酸铜心形晶簇的图片失传了→_→蛋疼。。<br>翻来倒去只找到一张。。残图。。（晶体已丢失。。）<br><img src="http://7xkkgd.com1.z0.glb.clouddn.com/jt-CuSO4-20140713_174218.jpg" alt="硫酸铜晶体+明矾晶体"><br>可能不小心手抖晃了晃蒸发皿，然后就。。。泛滥了。。。<br>15年再接再厉！力争培养出更优美的晶体！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2013寒假晶体培养 - 硫酸铜单晶]]></title>
      <url>http://www.sczyh30.com/posts/Life/chemistry-jt-2013/</url>
      <content type="html"><![CDATA[<p>此文章记录2013年寒假培养硫酸铜单晶的经历~</p>
<p>第一次培养硫酸铜单晶，由于没有按照实验室标准操作，连蒸发皿都没去买而用了个塑料容器代替的，所以→_→最后没有培养出特别好看的硫酸铜单晶。。</p>
<p>做的不好的原因，归结了一下，主要是由于没有密闭培养环境导致结晶时晶体环境不稳定导致的出刺。另外，没有很好地把握住CuSO4的溶解度。。。</p>
<p>附成品图一张献丑，比晶体化学吧的大神做的差远了。。。</p>
<p><img src="http://7xkkgd.com1.z0.glb.clouddn.com/CuSO4-20130222-A1.jpg" alt="变形记·硫酸铜晶体"></p>
]]></content>
    </entry>
    
  
  
</search>
