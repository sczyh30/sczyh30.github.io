<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分） —— 「千载弦歌，芳华如梦」 - sczyh30&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--<meta name="keywords" content="sczyh30, blog"/>-->
  <meta name="description" content="本文章是 Vert.x 蓝图系列 的第二篇教程。全系列：

Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程
Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程
Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践

前言欢迎回到Vert.x 蓝图系列～在本教程中，我们将利用Ver">
<meta property="og:type" content="article">
<meta property="og:title" content="Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）">
<meta property="og:url" content="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/index.html">
<meta property="og:site_name" content="「千载弦歌，芳华如梦」 - sczyh30's blog">
<meta property="og:description" content="本文章是 Vert.x 蓝图系列 的第二篇教程。全系列：

Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程
Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程
Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践

前言欢迎回到Vert.x 蓝图系列～在本教程中，我们将利用Ver">
<meta property="og:image" content="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/job_state_machine.png">
<meta property="og:image" content="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/event_emit_state_machine.png">
<meta property="og:image" content="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_diagram.png">
<meta property="og:image" content="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_future_based_methods.png">
<meta property="og:updated_time" content="2016-09-13T01:47:23.693Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）">
<meta name="twitter:description" content="本文章是 Vert.x 蓝图系列 的第二篇教程。全系列：

Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程
Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程
Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践

前言欢迎回到Vert.x 蓝图系列～在本教程中，我们将利用Ver">
  
    <link rel="alternative" href="/atom.xml" title="「千载弦歌，芳华如梦」 - sczyh30&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/AIO/" style="font-size: 10px;">AIO</a> <a href="/tags/AMQP/" style="font-size: 10px;">AMQP</a> <a href="/tags/APT/" style="font-size: 10px;">APT</a> <a href="/tags/Akka-Actor/" style="font-size: 10px;">Akka Actor</a> <a href="/tags/Algorithm/" style="font-size: 13px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 16px;">C++</a> <a href="/tags/C-11/" style="font-size: 10px;">C++ 11</a> <a href="/tags/CE3/" style="font-size: 10px;">CE3</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Category-Theory/" style="font-size: 10px;">Category Theory</a> <a href="/tags/Chemistry/" style="font-size: 11px;">Chemistry</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Docker/" style="font-size: 11px;">Docker</a> <a href="/tags/Engine/" style="font-size: 10px;">Engine</a> <a href="/tags/Euterpea/" style="font-size: 10px;">Euterpea</a> <a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/FRP/" style="font-size: 10px;">FRP</a> <a href="/tags/Functional-Programming/" style="font-size: 18px;">Functional Programming</a> <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/GC/" style="font-size: 13px;">GC</a> <a href="/tags/GDB/" style="font-size: 10px;">GDB</a> <a href="/tags/Game/" style="font-size: 11px;">Game</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/Haskell/" style="font-size: 14px;">Haskell</a> <a href="/tags/HotSpot/" style="font-size: 12px;">HotSpot</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 19px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Klass-oop/" style="font-size: 10px;">Klass-oop</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/MIDI/" style="font-size: 10px;">MIDI</a> <a href="/tags/Mathematical-Logic/" style="font-size: 10px;">Mathematical Logic</a> <a href="/tags/Metaspace/" style="font-size: 10px;">Metaspace</a> <a href="/tags/Netflix-Hystrix/" style="font-size: 10px;">Netflix Hystrix</a> <a href="/tags/Network/" style="font-size: 16px;">Network</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Object-Model/" style="font-size: 12px;">Object Model</a> <a href="/tags/Play-Framework/" style="font-size: 11px;">Play Framework</a> <a href="/tags/Quorum/" style="font-size: 10px;">Quorum</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Reflection/" style="font-size: 11px;">Reflection</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/STL/" style="font-size: 11px;">STL</a> <a href="/tags/Scala/" style="font-size: 19px;">Scala</a> <a href="/tags/Slick/" style="font-size: 11px;">Slick</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Struct/" style="font-size: 10px;">Struct</a> <a href="/tags/Summary/" style="font-size: 12px;">Summary</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/Type-Lambda/" style="font-size: 10px;">Type Lambda</a> <a href="/tags/Type-System/" style="font-size: 10px;">Type System</a> <a href="/tags/Type-Theory/" style="font-size: 12px;">Type Theory</a> <a href="/tags/UE4/" style="font-size: 10px;">UE4</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/Vert-x/" style="font-size: 19px;">Vert.x</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Web/" style="font-size: 12px;">Web</a> <a href="/tags/Web开发/" style="font-size: 12px;">Web开发</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/functional/" style="font-size: 10px;">functional</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/事务/" style="font-size: 10px;">事务</a> <a href="/tags/云服务/" style="font-size: 12px;">云服务</a> <a href="/tags/内存区域/" style="font-size: 10px;">内存区域</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/分布式系统/" style="font-size: 12px;">分布式系统</a> <a href="/tags/前端/" style="font-size: 12px;">前端</a> <a href="/tags/基础/" style="font-size: 10px;">基础</a> <a href="/tags/多线程/" style="font-size: 11px;">多线程</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/开发/" style="font-size: 17px;">开发</a> <a href="/tags/异步/" style="font-size: 13px;">异步</a> <a href="/tags/异步编程/" style="font-size: 18px;">异步编程</a> <a href="/tags/微服务/" style="font-size: 13px;">微服务</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 11px;">数据库</a> <a href="/tags/架构/" style="font-size: 11px;">架构</a> <a href="/tags/消息系统/" style="font-size: 10px;">消息系统</a> <a href="/tags/源码分析/" style="font-size: 14px;">源码分析</a> <a href="/tags/生活/" style="font-size: 10px;">生活</a> <a href="/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Fighting</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="http://7xkkgd.com1.z0.glb.clouddn.com/blog_default_avatar.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:sczyh16@gmail.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                                <li id="SegmentFault"><a class="SegmentFault" target="_blank" href="https://segmentfault.com/u/sczyh30" title="SegmentFault"></a></li>
                            
                                <li id="Google"><a class="Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a></li>
                            
                                <li id="Twitter"><a class="Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a></li>
                            
                                <li id="Medium"><a class="Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-vertx-blueprint-2-vertx-kue-core-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/" class="article-date">
      <time datetime="2016-07-24T06:00:00.000Z" itemprop="datePublished">2016-07-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Asynchronous/">Asynchronous</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/消息系统/">消息系统</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本文章是 <strong>Vert.x 蓝图系列</strong> 的第二篇教程。全系列：</p>
<ul>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</a></li>
<li>Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程</li>
<li><a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务应用实践</a></li>
</ul>
<h1 id="前言">前言</h1><p>欢迎回到Vert.x 蓝图系列～在本教程中，我们将利用Vert.x开发一个基于消息的应用 - Vert.x Kue，它是一个使用Vert.x开发的优先级工作队列，数据存储使用的是 <em>Redis</em> 。Vert.x Kue是<a href="https://github.com/Automattic/kue" target="_blank" rel="external">Automattic/kue</a>的Vert.x实现版本。我们可以使用Vert.x Kue来处理各种各样的任务，比如文件转换、订单处理等等。</p>
<p>通过本教程，你将会学习到以下内容：</p>
<ul>
<li>消息、消息系统以及事件驱动的运用</li>
<li>Vert.x <strong>Event Bus</strong> 的几种事件机制（发布/订阅、点对点模式）</li>
<li>设计 <strong>分布式</strong> 的Vert.x应用</li>
<li>工作队列的设计</li>
<li><strong>Vert.x Service Proxy</strong>（服务代理）的运用</li>
<li>更深层次的Redis运用</li>
</ul>
<p>本教程是 <a href="http://vertx.io/blog/vert-x-blueprint-tutorials/" target="_blank" rel="external">Vert.x 蓝图系列</a> 的第二篇教程，对应的Vert.x版本为 <strong>3.3.3</strong> 。本教程中的完整代码已托管至<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/tree/master" target="_blank" rel="external">GitHub</a>。</p>
<h1 id="Vert-x的消息系统">Vert.x的消息系统</h1><p>既然我们要用Vert.x开发一个基于消息的应用，那么我们先来瞅一瞅Vert.x的消息系统吧～在Vert.x中，我们可以通过 <strong>Event Bus</strong> 来发送和接收各种各样的消息，这些消息可以来自不同的<code>Vertx</code>实例。怎么样，很酷吧？我们都将消息发送至Event Bus上的某个<strong>地址</strong>上，这个地址可以是任意的字符串。</p>
<p>Event Bus支持三种消息机制：<strong>发布/订阅</strong>(Publish/Subscribe)、<strong>点对点</strong>(Point to point)以及<strong>请求/回应</strong>(Request-Response)模式。下面我们就来看一看这几种机制。</p>
<h2 id="发布/订阅模式">发布/订阅模式</h2><p>在<strong>发布/订阅模式</strong>中，消息被发布到Event Bus的某一个地址上，所有订阅此地址的<code>Handler</code>都会接收到该消息并且调用相应的处理逻辑。我们来看一看示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EventBus eventBus = vertx.eventBus();</span><br><span class="line"></span><br><span class="line">eventBus.consumer(<span class="string">"foo.bar.baz"</span>, r -&gt; &#123; <span class="comment">// subscribe to `foo.bar.baz` address</span></span><br><span class="line">  System.out.println(<span class="string">"1: "</span> + r.body());</span><br><span class="line">&#125;);</span><br><span class="line">eventBus.consumer(<span class="string">"foo.bar.baz"</span>, r -&gt; &#123; <span class="comment">// subscribe to `foo.bar.baz` address</span></span><br><span class="line">  System.out.println(<span class="string">"2: "</span> + r.body());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventBus.publish(<span class="string">"foo.bar.baz"</span>, <span class="string">"+1s"</span>); <span class="comment">// 向此地址发送消息</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过<code>vertx.eventBus()</code>方法获取<code>EventBus</code>的引用，然后我们就可以通过<code>consume</code>方法订阅某个地址的消息并且绑定一个<code>Handler</code>。接着我们通过<code>publish</code>向此地址发送消息。如果运行上面的例子，我们会得到一下结果：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2</span>: <span class="string">+1s</span></span><br><span class="line"><span class="attribute">1</span>: <span class="string">+1s</span></span><br></pre></td></tr></table></figure>
<h2 id="点对点模式">点对点模式</h2><p>如果我们把上面的示例中的<code>publish</code>方法替代成<code>send</code>方法，上面的实例就变成<strong>点对点模式</strong>了。在点对点模式中，消息被发布到Event Bus的某一个地址上。Vert.x会将此消息传递给其中监听此地址的<code>Handler</code>之一。如果有多个<code>Handler</code>绑定到此地址，那么就使用轮询算法随机挑一个<code>Handler</code>传递消息。比如在此示例中，程序只会打印<code>2: +1s</code>或者<code>1: +1s</code>之中的一个。</p>
<h2 id="请求/回应模式">请求/回应模式</h2><p>当我们绑定的<code>Handler</code>接收到消息的时候，我们可不可以给消息的发送者回复呢？当然了！当我们通过<code>send</code>方法发送消息的时候，我们可以同时指定一个回复处理函数(reply handler)。然后当某个消息的订阅者接收到消息的时候，它就可以给发送者回复消息；如果发送者接收到了回复，发送者绑定的回复处理函数就会被调用。这就是<strong>请求/回应模式</strong>。</p>
<p>好啦，现在我们已经粗略了解了Vert.x中的消息系统 - Event Bus的基本使用，下面我们就看看Vert.x Kue的基本设计。有关更多关于Event Bus的信息请参考<a href="http://vertx.io/docs/vertx-core/java/#event_bus" target="_blank" rel="external">Vert.x Core Manual - Event Bus</a>。</p>
<h1 id="Vert-x_Kue_架构设计">Vert.x Kue 架构设计</h1><h2 id="Vert-x_Kue_组件划分">Vert.x Kue 组件划分</h2><p>在我们的项目中，我们将Vert.x Kue划分为两个模块：</p>
<ul>
<li><code>kue-core</code>: 核心组件，提供优先级队列的功能</li>
<li><code>kue-http</code>: Web组件，提供Web UI以及REST API</li>
</ul>
<p>另外我们还提供一个示例模块<code>kue-example</code>用于演示以及阐述如何使用Vert.x Kue。</p>
<p>既然我们的项目有两个模块，那么你一定会好奇：两个模块之间是如何进行通信的？并且如果我们写自己的Kue应用的话，我们该怎样去调用Kue Core中的服务呢？不要着急，谜底将在后边的章节中揭晓:-)</p>
<h2 id="Vert-x_Kue_核心模块">Vert.x Kue 核心模块</h2><p>回顾一下Vert.x Kue的作用 - 优先级工作队列，所以在Vert.x Kue的核心模块中我们设计了以下的类：</p>
<ul>
<li><code>Job</code> - 任务（作业）数据实体</li>
<li><code>JobService</code> - 异步服务接口，提供操作任务以及获取数据的相关逻辑</li>
<li><code>KueWorker</code> - 用于处理任务的Verticle</li>
<li><code>Kue</code> - 工作队列</li>
</ul>
<p>前边我们提到过，我们的两个组件之间需要一种通信机制可以互相通信 - 这里我们使用Vert.x的<strong>集群模式</strong>，即以clustered的模式来部署Verticle。这样的环境下的Event Bus同样也是集群模式的，因此各个组件可以通过集群模式下的Event Bus进行通信。很不错吧？在Vert.x的集群模式下，我们需要指定一个集群管理器<code>ClusterManager</code>。这里我们使用默认的<code>HazelcastClusterManager</code>，使用<strong>Hazelcast</strong>作为集群管理。</p>
<p>在Vert.x Kue中，我们将<code>JobService</code>服务发布至分布式的Event Bus上，这样其它的组件就可以通过Event Bus调用该服务了。我们设计了一个<code>KueVerticle</code>用于注册服务。Vert.x提供了Vert.x Service Proxy（服务代理组件），可以很方便地将服务注册至Event Bus上，然后在其它地方获取此服务的代理并调用。我们将在下面的章节中详细介绍<strong>Vert.x Service Proxy</strong>。</p>
<h2 id="基于Future的异步模式">基于Future的异步模式</h2><p>在我们的Vert.x Kue中，大多数的异步方法都是基于<code>Future</code>的。如果您看过蓝图系列的第一篇文章的话，您一定不会对这种模式很陌生。在Vert.x 3.3.2中，我们的<code>Future</code>支持基本的响应式的操作，比如<code>map</code>和<code>compose</code>。它们用起来非常方便，因为我们可以将多个<code>Future</code>以响应式的方式组合起来而不用担心陷入回调地狱中。</p>
<h2 id="Vert-x_Kue中的事件">Vert.x Kue中的事件</h2><p>正如我们在<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">Vert.x Kue 特性介绍</a>中提到的那样，Vert.x Kue支持两种级别的事件：<strong>任务事件(job events)</strong> 以及 <strong>队列事件(queue events)</strong>。在Vert.x Kue中，我们设计了三种事件地址：</p>
<ul>
<li><code>vertx.kue.handler.job.{handlerType}.{addressId}.{jobType}</code>: 某个特定任务的任务事件地址</li>
<li><code>vertx.kue.handler.workers.{eventType}</code>: （全局）队列事件地址</li>
<li><code>vertx.kue.handler.workers.{eventType}.{addressId}</code>: 某个特定任务的内部事件地址</li>
</ul>
<p>在<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">特性介绍文档</a>中，我们提到了以下几种任务事件：</p>
<ul>
<li><code>start</code> 开始处理一个任务 (<code>onStart</code>)</li>
<li><code>promotion</code> 一个延期的任务时间已到，提升至工作队列中 (<code>onPromotion</code>)</li>
<li><code>progress</code> 任务的进度变化 (<code>onProgress</code>)</li>
<li><code>failed_attempt</code> 任务处理失败，但是还可以重试 (<code>onFailureAttempt</code>)</li>
<li><code>failed</code> 任务处理失败并且不能重试 (<code>onFailure</code>)</li>
<li><code>complete</code> 任务完成 (<code>onComplete</code>)</li>
<li><code>remove</code> 任务从后端存储中移除 (<code>onRemove</code>)</li>
</ul>
<p>队列事件也相似，只不过需要加前缀<code>job_</code>。这些事件都会通过<code>send</code>方法发送至Event Bus上。每一个任务都有对应的任务事件地址，因此它们能够正确地接收到对应的事件并进行相应的处理逻辑。</p>
<p>特别地，我们还有两个内部事件：<code>done</code>和<code>done_fail</code>。<code>done</code>事件对应一个任务在底层的处理已经完成，而<code>done_fail</code>事件对应一个任务在底层的处理失败。这两个事件使用第三种地址进行传递。</p>
<h2 id="任务状态">任务状态</h2><p>在Vert.x Kue中，任务共有五种状态：</p>
<ul>
<li><code>INACTIVE</code>: 任务还未开始处理，在工作队列中等待处理</li>
<li><code>ACTIVE</code>: 任务正在处理中</li>
<li><code>COMPLETE</code>: 任务处理完成</li>
<li><code>FAILED</code>: 任务处理失败</li>
<li><code>DELAYED</code>: 任务延时处理，正在等待计时器时间到并提升至工作队列中</li>
</ul>
<p>我们使用状态图来描述任务状态的变化：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/job_state_machine.png" alt="Job State Machine"></p>
<p>以及任务状态的变化伴随的事件：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/event_emit_state_machine.png" alt="Events with state change"></p>
<h2 id="整体设计">整体设计</h2><p>为了让大家对Vert.x Kue的架构有大致的了解，我用一幅图来简略描述整个Vert.x Kue的设计：</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_diagram.png" alt="Diagram - How Vert.x Kue works"></p>
<p>现在我们对Vert.x Kue的设计有了大致的了解了，下面我们就来看一看Vert.x Kue的代码实现了～</p>
<h1 id="项目结构">项目结构</h1><p>我们来开始探索Vert.x Kue的旅程吧！首先我们先从GitHub上clone源代码：</p>
<pre><code>git clone <span class="string">https:</span><span class="comment">//github.com/sczyh30/vertx-blueprint-job-queue.git</span>
</code></pre><p>然后你可以把项目作为Gradle项目导入你的IDE中。（如何导入请参考相关IDE帮助文档）</p>
<p>正如我们之前所提到的，我们的Vert.x Kue中有两个功能模块和一个实例模块，因此我们需要在Gradle工程文件中定义三个子工程。我们来看一下本项目中的<code>build.gradle</code>文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">configure(<span class="keyword">allprojects</span>) &#123; <span class="keyword">project</span> -&gt;</span><br><span class="line"></span><br><span class="line">  ext &#123;</span><br><span class="line">    vertxVersion = <span class="string">"3.3.2"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply plugin: <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-core:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-codegen:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-rx-java:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-hazelcast:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-lang-ruby:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line"></span><br><span class="line">    testCompile(<span class="string">"io.vertx:vertx-unit:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    testCompile <span class="keyword">group</span>: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.12'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">sourceSets</span> &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">      java &#123;</span><br><span class="line">        srcDirs += <span class="string">'src/main/generated'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  compileJava &#123;</span><br><span class="line">    <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></span><br><span class="line">    <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="string">"kue-core"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-redis-client:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-service-proxy:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jar &#123;</span><br><span class="line">    archiveName = <span class="string">'vertx-blueprint-kue-core.jar'</span></span><br><span class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.queue.KueVerticle'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">task</span> annotationProcessing(type: JavaCompile, <span class="keyword">group</span>: <span class="string">'build'</span>) &#123; <span class="comment">// codegen</span></span><br><span class="line">    <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.java</span><br><span class="line">    <span class="keyword">classpath</span> = <span class="keyword">configurations</span>.<span class="keyword">compile</span></span><br><span class="line">    <span class="keyword">destinationDir</span> = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">'src/main/generated'</span>)</span><br><span class="line">    <span class="keyword">options</span>.compilerArgs = [</span><br><span class="line">      <span class="string">"-proc:only"</span>,</span><br><span class="line">      <span class="string">"-processor"</span>, <span class="string">"io.vertx.codegen.CodeGenProcessor"</span>,</span><br><span class="line">      <span class="string">"-AoutputDirectory=$&#123;project.projectDir&#125;/src/main"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  compileJava &#123;</span><br><span class="line">    <span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></span><br><span class="line">    <span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">    dependsOn annotationProcessing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="string">"kue-http"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"io.vertx:vertx-web-templ-jade:$&#123;vertxVersion&#125;"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jar &#123;</span><br><span class="line">    archiveName = <span class="string">'vertx-blueprint-kue-http.jar'</span></span><br><span class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.http.KueHttpVerticle'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="string">"kue-example"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jar &#123;</span><br><span class="line">    archiveName = <span class="string">'vertx-blueprint-kue-example.jar'</span></span><br><span class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.example.LearningVertxVerticle'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> wrapper(type: Wrapper) &#123;</span><br><span class="line">  gradleVersion = <span class="string">'2.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(⊙o⊙)…比之前的待办事项服务项目中的长不少诶。。。我们来解释一下：</p>
<ul>
<li>在<code>configure(allprojects)</code>作用域中，我们配置了一些全局信息（对所有子工程都适用）。</li>
<li>我们定义了三个子工程：<code>kue-core</code>、<code>kue-http</code>以及<code>kue-example</code>。这里我们来解释一下里面用到的依赖。在<code>kue-core</code>中，<code>vertx-redis-client</code>用于Redis通信，<code>vertx-service-proxy</code>用于Event Bus上的服务代理。在<code>kue-http</code>中，我们将<code>kue-core</code>子工程作为它的一个依赖。<code>vertx-web</code>和<code>vertx-web-templ-jade</code>用于Kue Web端的开发。</li>
<li>任务<code>annotationProcessing</code>用于注解处理（Vert.x Codegen）。我们已经在上一篇教程中介绍过了，这里就不展开讲了。</li>
</ul>
<p>我们还需要在 <code>settings.gradle</code> 中配置工程：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name = <span class="string">'vertx-blueprint-job-queue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">"kue-core"</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"kue-http"</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"kue-example"</span></span><br></pre></td></tr></table></figure>
<p>看完了配置文件以后，我们再来浏览一下我们的项目目录结构：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── kue-core</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── <span class="keyword">main</span></span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   └── <span class="keyword">resources</span></span><br><span class="line">│       └── test</span><br><span class="line">│           ├── java</span><br><span class="line">│           └── <span class="keyword">resources</span></span><br><span class="line">├── kue-example</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── <span class="keyword">main</span></span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   └── <span class="keyword">resources</span></span><br><span class="line">│       └── test</span><br><span class="line">│           ├── java</span><br><span class="line">│           └── <span class="keyword">resources</span></span><br><span class="line">├── kue-http</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── <span class="keyword">main</span></span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   └── <span class="keyword">resources</span></span><br><span class="line">│       └── test</span><br><span class="line">│           ├── java</span><br><span class="line">│           └── <span class="keyword">resources</span></span><br><span class="line">└── <span class="keyword">settings</span>.gradle</span><br></pre></td></tr></table></figure>
<p>在Gradle中，项目的源码都位于<code>{projectName}/src/main/java</code>目录内。这篇教程是围绕Vert.x Kue Core的，所以我们的代码都在<code>kue-core</code>目录中。</p>
<p>好啦！现在我们已经对Vert.x Kue项目的整体结构有了大致的了解了，下面我们开始源码探索之旅！</p>
<h1 id="任务实体_-_不仅仅是一个数据对象">任务实体 - 不仅仅是一个数据对象</h1><p>Vert.x Kue是用来处理任务的，因此我们先来看一下代表任务实体的<code>Job</code>类。<code>Job</code>类位于<code>io.vertx.blueprint.kue.queue</code>包下。代码可能有点长，不要担心，我们把它分成几部分，分别来解析。</p>
<h2 id="任务成员属性">任务成员属性</h2><p>我们先来看一下<code>Job</code>类中的成员属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@DataObject</span>(generateConverter = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="comment">// job properties</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address_id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String zid;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> JsonObject data;</span><br><span class="line">    <span class="keyword">private</span> Priority priority = Priority.NORMAL;</span><br><span class="line">    <span class="keyword">private</span> JobState state = JobState.INACTIVE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delay = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max_attempts = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> removeOnComplete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ttl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> JsonObject backoff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> attempts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> progress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> JsonObject result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// job metrics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> created_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> promote_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> updated_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> failed_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> started_at;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> duration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我去。。。好多属性！我们一个一个地解释：</p>
<ul>
<li><code>address_id</code>: 一个UUID序列，作为Event Bus的地址</li>
<li><code>id</code>: 任务的编号(id)</li>
<li><code>type</code>: 任务的类型</li>
<li><code>data</code>: 任务携带的数据，以 <code>JsonObject</code> 类型表示</li>
<li><code>priority</code>: 任务优先级，以 <code>Priority</code> 枚举类型表示。默认优先级为正常(<code>NORMAL</code>)</li>
<li><code>delay</code>: 任务的延迟时间，默认是 <strong>0</strong></li>
<li><code>state</code>: 任务状态，以 <code>JobState</code> 枚举类型表示。默认状态为等待(<code>INACTIVE</code>)</li>
<li><code>attempts</code>: 任务已经尝试执行的次数</li>
<li><code>max_attempts</code>: 任务尝试执行次数的最大阈值</li>
<li><code>removeOnComplete</code>: 代表任务完成时是否自动从后台移除</li>
<li><code>zid</code>: <code>zset</code>操作对应的编号(zid)，保持先进先出顺序</li>
<li><code>ttl</code>: TTL(Time to live)</li>
<li><code>backoff</code>: 任务重试配置，以 <code>JsonObject</code> 类型表示</li>
<li><code>progress</code>: 任务执行的进度</li>
<li><code>result</code>: 任务执行的结果，以 <code>JsonObject</code> 类型表示</li>
</ul>
<p>还有这些统计数据：</p>
<ul>
<li><code>created_at</code>: 代表此任务创建的时间</li>
<li><code>promote_at</code>: 代表此任务从延时状态被提升至等待状态时的时间</li>
<li><code>updated_at</code>: 代表任务更新的时间</li>
<li><code>failed_at</code>: 代表任务失败的时间</li>
<li><code>started_at</code>: 代表任务开始的时间</li>
<li><code>duration</code>: 代表处理任务花费的时间，单位为毫秒(<code>ms</code>)</li>
</ul>
<p>你可能注意到在 <code>Job</code> 类中还存在着几个静态成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Job.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vertx vertx;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisClient client;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setVertx</span><span class="params">(Vertx v, RedisClient redisClient)</span> </span>&#123;</span><br><span class="line">  vertx = v;</span><br><span class="line">  client = redisClient;</span><br><span class="line">  eventBus = vertx.eventBus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>logger</code> 对象，我想大家应该都很熟悉，它代表一个Vert.x Logger实例用于日志记录。但是你一定想问为什么 <code>Job</code> 类中存在着一个<code>Vertx</code>类型的静态成员。<code>Job</code>类不应该是一个数据对象吗？当然咯！<code>Job</code>类代表一个数据对象，但<strong>不仅仅</strong>是一个数据对象。这里我模仿了一些Automattic/kue的风格，把一些任务相关逻辑方法放到了<code>Job</code>类里，它们大多都是基于<code>Future</code>的异步方法，因此可以很方便地去调用以及进行组合变换。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">job.save()</span><br><span class="line">    .compose(Job::updateNow)</span><br><span class="line">    .compose(j -&gt; j.log(<span class="string">"good!"</span>));</span><br></pre></td></tr></table></figure>
<p>由于我们不能在<code>Job</code>类被JVM加载的时候就获取<code>Vertx</code>实例，我们必须手动给<code>Job</code>类中的静态<code>Vertx</code>成员赋值。这里我们是在<code>Kue</code>类中对其进行赋值的。当我们创建一个工作队列的时候，<code>Job</code>类中的静态成员变量会被初始化。同时为了保证程序的正确性，我们需要一个方法来检测静态成员变量是否初始化。当我们在创建一个任务的时候，如果静态成员此时未被初始化，那么日志会给出警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">_checkStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vertx == <span class="keyword">null</span>) &#123;</span><br><span class="line">    logger.warn(<span class="string">"static Vertx instance in Job class is not initialized!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还注意到 <code>Job</code> 类也是由<code>@DataObject</code>注解修饰的。Vert.x Codegen可以处理含有<code>@DataObject</code>注解的类并生成对应的JSON转换器，并且Vert.x Service Proxy也需要数据对象。</p>
<p>在<code>Job</code>类中我们有四个构造函数。其中<code>address_id</code>成员必须在一个任务被创建时就被赋值，默认情况下此地址用一个唯一的UUID字符串表示。每一个构造函数中我们都要调用<code>_checkStatic</code>函数来检测静态成员变量是否被初始化。</p>
<h2 id="任务事件辅助函数">任务事件辅助函数</h2><p>正如我们之前所提到的那样，我们通过一个特定的地址<code>vertx.kue.handler.job.{handlerType}.{addressId}.{jobType}</code>在分布式的Event Bus上发送和接收任务事件(job events)。所以我们提供了两个用于发送和接收事件的辅助函数<code>emit</code>和<code>on</code>(类似于Node.js中的<code>EventEmitter</code>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Job <span class="title">on</span><span class="params">(String event, Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</span><br><span class="line">  logger.debug(<span class="string">"[LOG] On: "</span> + Kue.getCertainJobAddress(event, <span class="keyword">this</span>));</span><br><span class="line">  eventBus.consumer(Kue.getCertainJobAddress(event, <span class="keyword">this</span>), handler);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">emit</span><span class="params">(String event, Object msg)</span> </span>&#123;</span><br><span class="line">  logger.debug(<span class="string">"[LOG] Emit: "</span> + Kue.getCertainJobAddress(event, <span class="keyword">this</span>));</span><br><span class="line">  eventBus.send(Kue.getCertainJobAddress(event, <span class="keyword">this</span>), msg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在后面的代码中，我们将频繁使用这两个辅助函数。</p>
<h2 id="Redis中的存储形式">Redis中的存储形式</h2><p>在我们探索相关的逻辑函数之前，我们先来描述一下Vert.x Kue的数据在Redis中是以什么样的形式存储的：</p>
<ul>
<li>所有的key都在<code>vertx_kue</code>命名空间下(以<code>vertx_kue:</code>作为前缀)</li>
<li><code>vertx:kue:job:{id}</code>: 存储任务实体的map</li>
<li><code>vertx:kue:ids</code>: 计数器，指示当前最大的任务ID</li>
<li><code>vertx:kue:job:types</code>: 存储所有任务类型的列表</li>
<li><code>vertx:kue:{type}:jobs</code>: 指示所有等待状态下的某种类型任务的列表</li>
<li><code>vertx_kue:jobs</code>: 存储所有任务<code>zid</code>的有序集合</li>
<li><code>vertx_kue:job:{state}</code>: 存储所有指定状态的任务<code>zid</code>的有序集合</li>
<li><code>vertx_kue:jobs:{type}:{state}</code>: 存储所有指定状态和类型的任务<code>zid</code>的有序集合</li>
<li><code>vertx:kue:job:{id}:log</code>: 存储指定<code>id</code>的任务对应日志的列表</li>
</ul>
<p>OK，下面我们就来看看<code>Job</code>类中重要的逻辑函数。</p>
<h2 id="改变任务状态">改变任务状态</h2><p>我们之前提到过，Vert.x Kue中的任务一共有五种状态。所有的任务相关的操作都伴随着任务状态的变换，因此我们先来看一下<code>state</code>方法的实现，它用于改变任务的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">state</span><span class="params">(JobState newState)</span> </span>&#123;</span><br><span class="line">  Future&lt;Job&gt; future = Future.future();</span><br><span class="line">  RedisClient client = RedisHelper.client(vertx, <span class="keyword">new</span> JsonObject()); <span class="comment">// use a new client to keep transaction</span></span><br><span class="line">  JobState oldState = <span class="keyword">this</span>.state;</span><br><span class="line">  client.transaction().multi(r0 -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (r0.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldState != <span class="keyword">null</span> &amp;&amp; !oldState.equals(newState)) &#123; <span class="comment">// (2)</span></span><br><span class="line">        client.transaction().zrem(RedisHelper.getStateKey(oldState), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">          .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + oldState.name()), <span class="keyword">this</span>.zid, _failure());</span><br><span class="line">      &#125;</span><br><span class="line">      client.transaction().hset(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), <span class="string">"state"</span>, newState.name(), _failure()) <span class="comment">// (3)</span></span><br><span class="line">        .zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">        .zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + newState.name()), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (newState) &#123; <span class="comment">// dispatch different state</span></span><br><span class="line">        <span class="keyword">case</span> ACTIVE: <span class="comment">// (4)</span></span><br><span class="line">          client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</span><br><span class="line">            <span class="keyword">this</span>.priority.getValue() &lt; <span class="number">0</span> ? <span class="keyword">this</span>.priority.getValue() : -<span class="keyword">this</span>.priority.getValue(),</span><br><span class="line">            <span class="keyword">this</span>.zid, _failure());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DELAYED: <span class="comment">// (5)</span></span><br><span class="line">          client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</span><br><span class="line">            <span class="keyword">this</span>.promote_at, <span class="keyword">this</span>.zid, _failure());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> INACTIVE: <span class="comment">// (6)</span></span><br><span class="line">          client.transaction().lpush(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="string">"1"</span>, _failure());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.state = newState;</span><br><span class="line"></span><br><span class="line">      client.transaction().exec(r -&gt; &#123; <span class="comment">// (7)</span></span><br><span class="line">        <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">          future.complete(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          future.fail(r.cause());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      future.fail(r0.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> future.compose(Job::updateNow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先创建了一个<code>Future</code>对象。然后我们调用了 <code>client.transaction().multi(handler)</code> 函数开始一次Redis事务 (1)。在Vert.x 3.3.2中，所有的Redis事务操作都移至<code>RedisTransaction</code>类中，所以我们需要先调用<code>client.transaction()</code>方法去获取一个事务实例，然后调用<code>multi</code>代表事务块的开始。</p>
<p>在<code>multi</code>函数传入的<code>Handler</code>中，我们先判定当前的任务状态。如果当前任务状态不为空并且不等于新的任务状态，我们就将Redis中存储的旧的状态信息移除 (2)。为了方便起见，我们提供了一个<code>RedisHelper</code>辅助类，里面提供了一些生成特定地址以及编码解码<code>zid</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.JobState;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Vertx;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</span><br><span class="line"><span class="keyword">import</span> io.vertx.redis.RedisOptions;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERTX_KUE_REDIS_PREFIX = <span class="string">"vertx_kue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">RedisHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisClient <span class="title">client</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RedisClient.create(vertx, options(config));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisOptions <span class="title">options</span><span class="params">(JsonObject config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisOptions()</span><br><span class="line">      .setHost(config.getString(<span class="string">"redis.host"</span>, <span class="string">"127.0.0.1"</span>))</span><br><span class="line">      .setPort(config.getInteger(<span class="string">"redis.port"</span>, <span class="number">6379</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> VERTX_KUE_REDIS_PREFIX + <span class="string">":"</span> + key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStateKey</span><span class="params">(JobState state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> VERTX_KUE_REDIS_PREFIX + <span class="string">":jobs:"</span> + state.name();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createFIFO</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    String idLen = <span class="string">""</span> + (<span class="string">""</span> + id).length();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">2</span> - idLen.length();</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>)</span><br><span class="line">      idLen = <span class="string">"0"</span> + idLen;</span><br><span class="line">    <span class="keyword">return</span> idLen + <span class="string">"|"</span> + id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stripFIFO</span><span class="params">(String zid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zid.substring(zid.indexOf(<span class="string">'|'</span>) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">numStripFIFO</span><span class="params">(String zid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Long.parseLong(zid.substring(zid.indexOf(<span class="string">'|'</span>) + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的key都必须在<code>vertx_kue</code>命名空间下，因此我们封装了一个<code>getKey</code>方法。我们还实现了<code>createFIFO</code>和<code>stripFIFO</code>方法用于生成<code>zid</code>以及解码<code>zid</code>。<code>zid</code>的格式使用了Automattic/Kue中的格式。</p>
<p>回到<code>state</code>方法来。我们使用<code>zrem(String key, String member, Handler&lt;AsyncResult&lt;String&gt;&gt; handler)</code>方法将特定的数据从有序集合中移除。两个key分别是<code>vertx_kue:job:{state}</code> 以及 <code>vertx_kue:jobs:{type}:{state}</code>；<code>member</code>对应着任务的<code>zid</code>。</p>
<p>接下来我们使用<code>hset</code>方法来变更新的状态 (3)，然后用<code>zadd</code>方法往<code>vertx_kue:job:{state}</code> 和 <code>vertx_kue:jobs:{type}:{state}</code>两个有序集合中添加此任务的<code>zid</code>，同时传递一个<strong>权重</strong>(score)。这个非常重要，我们就是通过这个实现<strong>优先级</strong>队列的。我们直接使用<code>priority</code>对应的值作为<code>score</code>。这样，当我们需要从Redis中获取任务的时候，我们就可以通过<code>zpop</code>方法获取优先级最高的任务。我们会在后面详细讲述。</p>
<p>不同的新状态需要不同的操作。对于<code>ACTIVE</code>状态，我们通过<code>zadd</code>命令将<code>zid</code>添加至<code>vertx_kue:jobs:ACTIVE</code>有序集合中并赋予优先级权值 (4)。对于<code>DELAYED</code>状态，我们通过<code>zadd</code>命令将<code>zid</code>添加至<code>vertx_kue:jobs:DELAYED</code>有序集合中并赋予提升时间(<code>promote_at</code>)权值 (5)。对于<code>INACTIVE</code>状态，我们向<code>vertx:kue:{type}:jobs</code>列表中添加一个元素 (6)。这些操作都是在Redis事务块内完成的。最后我们通过<code>exec</code>方法一并执行这些事务操作 (7)。如果执行成功，我们给<code>future</code>赋值（当前任务）。最后我们返回<code>future</code>并且与<code>updateNow</code>方法相组合。</p>
<p><code>updateNow</code>方法非常简单，就是把<code>updated_at</code>的值设为当前时间，然后存到Redis中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;Job&gt; <span class="title">updateNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updated_at = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.set(<span class="string">"updated_at"</span>, String.valueOf(updated_at));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="保存任务">保存任务</h2><p>这里我们来看一下整个<code>Job</code>类中最重要的方法之一 - <code>save</code>方法，它的作用是保存任务至Redis中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// check</span></span><br><span class="line">  Objects.requireNonNull(<span class="keyword">this</span>.type, <span class="string">"Job type cannot be null"</span>); <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> update(); <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">  Future&lt;Job&gt; future = Future.future();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成id</span></span><br><span class="line">  client.incr(RedisHelper.getKey(<span class="string">"ids"</span>), res -&gt; &#123; <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.id = res.result();</span><br><span class="line">      <span class="keyword">this</span>.zid = RedisHelper.createFIFO(id); <span class="comment">// (4)</span></span><br><span class="line">      String key = RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = JobState.DELAYED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      client.sadd(RedisHelper.getKey(<span class="string">"job:types"</span>), <span class="keyword">this</span>.type, _failure()); <span class="comment">// (5)</span></span><br><span class="line">       <span class="keyword">this</span>.created_at = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">this</span>.promote_at = <span class="keyword">this</span>.created_at + <span class="keyword">this</span>.delay;</span><br><span class="line">       <span class="comment">// 保存任务</span></span><br><span class="line">       client.hmset(key, <span class="keyword">this</span>.toJson(), _completer(future, <span class="keyword">this</span>)); <span class="comment">// (6)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      future.fail(res.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> future.compose(Job::update); <span class="comment">// (7)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，任务类型不能为空所以我们要检查<code>type</code>是否为空 (1)。接着，如果当前任务的id大于0，则代表此任务已经存储过（因为id是存储时分配），此时只需执行更新操作(<code>update</code>)即可 (2)。然后我们创建一个<code>Future</code>对象，然后使用<code>incr</code>方法从<code>vertx_kue:ids</code>字段获取一个新的<code>id</code> (3)。同时我们使用<code>RedisHelper.createFIFO(id)</code>方法来生成新的<code>zid</code> (4)。接着我们来判断任务延时是否大于0，若大于0则将当前任务状态设置为<code>DELAYED</code>。然后我们通过<code>sadd</code>方法将当前任务类型添加至<code>vertx:kue:job:types</code>列表中 (5) 并且保存任务创建时间(<code>created_at</code>)以及任务提升时间(<code>promote_at</code>)。经过这一系列的操作后，所有的属性都已准备好，所以我们可以利用<code>hmset</code>方法将此任务实体存储至<code>vertx:kue:job:{id}</code>哈希表中 (6)。如果存储操作成功，那么将当前任务实体赋给<code>future</code>，否则记录错误。最后我们返回此<code>future</code>并且将其与<code>update</code>方法进行组合。</p>
<p><code>update</code>方法进行一些更新操作，它的逻辑比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;Job&gt; <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Future&lt;Job&gt; future = Future.future();</span><br><span class="line">  <span class="keyword">this</span>.updated_at = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  client.transaction().multi(_failure())</span><br><span class="line">    .hset(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), <span class="string">"updated_at"</span>, String.valueOf(<span class="keyword">this</span>.updated_at), _failure())</span><br><span class="line">    .zadd(RedisHelper.getKey(<span class="string">"jobs"</span>), <span class="keyword">this</span>.priority.getValue(), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">    .exec(_completer(future, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> future.compose(r -&gt;</span><br><span class="line">    <span class="keyword">this</span>.state(<span class="keyword">this</span>.state));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>update</code>方法只做了三件微小的工作：存储任务更新时间、存储<code>zid</code>以及更改当前任务状态（组合<code>state</code>方法）。</p>
<p>最后总结一下将一个任务存储到Redis中经过的步骤：<code>save -&gt; update -&gt; state</code> :-)</p>
<h2 id="移除任务">移除任务</h2><p>移除任务非常简单，借助<code>zrem</code>和<code>del</code>方法即可。我们来看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Void&gt; <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Future&lt;Void&gt; future = Future.future();</span><br><span class="line">  client.transaction().multi(_failure())</span><br><span class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.stateName()), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":"</span> + <span class="keyword">this</span>.stateName()), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">    .zrem(RedisHelper.getKey(<span class="string">"jobs"</span>), <span class="keyword">this</span>.zid, _failure())</span><br><span class="line">    .del(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id + <span class="string">":log"</span>), _failure())</span><br><span class="line">    .del(RedisHelper.getKey(<span class="string">"job:"</span> + <span class="keyword">this</span>.id), _failure())</span><br><span class="line">    .exec(r -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">"remove"</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"id"</span>, <span class="keyword">this</span>.id));</span><br><span class="line">        future.complete();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        future.fail(r.cause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到成功移除任务时，我们会向Event Bus上的特定地址发送<code>remove</code>任务事件。此事件包含着被移除任务的<code>id</code>。</p>
<h2 id="监听任务事件">监听任务事件</h2><p>我们可以通过几种 <code>onXXX</code> 方法来监听任务事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onComplete</span><span class="params">(Handler&lt;Job&gt; completeHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"complete"</span>, message -&gt; &#123;</span><br><span class="line">    completeHandler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onFailure</span><span class="params">(Handler&lt;JsonObject&gt; failureHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"failed"</span>, message -&gt; &#123;</span><br><span class="line">    failureHandler.handle((JsonObject) message.body());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onFailureAttempt</span><span class="params">(Handler&lt;JsonObject&gt; failureHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"failed_attempt"</span>, message -&gt; &#123;</span><br><span class="line">    failureHandler.handle((JsonObject) message.body());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onPromotion</span><span class="params">(Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"promotion"</span>, message -&gt; &#123;</span><br><span class="line">    handler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onStart</span><span class="params">(Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"start"</span>, message -&gt; &#123;</span><br><span class="line">    handler.handle(<span class="keyword">new</span> Job((JsonObject) message.body()));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onRemove</span><span class="params">(Handler&lt;JsonObject&gt; removeHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"start"</span>, message -&gt; &#123;</span><br><span class="line">    removeHandler.handle((JsonObject) message.body());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">onProgress</span><span class="params">(Handler&lt;Integer&gt; progressHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">"progress"</span>, message -&gt; &#123;</span><br><span class="line">    progressHandler.handle((Integer) message.body());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到不同的事件，对应接收的数据类型也有差异。我们来说明一下：</p>
<ul>
<li><code>onComplete</code>、<code>onPromotion</code> 以及 <code>onStart</code>: 发送的数据是对应的<code>Job</code>对象</li>
<li><code>onFailure</code> and <code>onFailureAttempt</code>: 发送的数据是<code>JsonObject</code>类型的，其格式类似于：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">job</span>": <span class="value">&#123;&#125;</span>,</span><br><span class="line">    "<span class="attribute">extra</span>": <span class="value">&#123;</span><br><span class="line">        "<span class="attribute">message</span>": <span class="value"><span class="string">"some_error"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>onProgress</code>: 发送的数据是当前任务进度</li>
<li><code>onRemove</code>: 发送的数据是<code>JsonObject</code>类型的，其中<code>id</code>代表被移除任务的编号</li>
</ul>
<h2 id="更新任务进度">更新任务进度</h2><p>我们可以通过<code>progress</code>方法来更新任务进度。看一下其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">progress</span><span class="params">(<span class="keyword">int</span> complete, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = Math.min(<span class="number">100</span>, complete * <span class="number">100</span> / total); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">"progress"</span>, n); <span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.setProgress(n) <span class="comment">// (3)</span></span><br><span class="line">    .set(<span class="string">"progress"</span>, String.valueOf(n))</span><br><span class="line">    .compose(Job::updateNow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>progress</code>方法接受两个参数：第一个是当前完成的进度值，第二个是完成状态需要的进度值。我们首先计算出当前的进度 (1)，然后向特定地址发送<code>progress</code>事件 (2)。最后我们将进度存储至Redis中并更新时间，返回<code>Future</code> (3)。</p>
<h2 id="任务失败以及重试机制">任务失败以及重试机制</h2><p>当一个任务处理失败时，如果它有剩余的重试次数，Vert.x Kue会自动调用<code>failAttempt</code>方法进行重试。我们来看一下<code>failAttempt</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;Job&gt; <span class="title">failedAttempt</span><span class="params">(Throwable err)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.error(err)</span><br><span class="line">    .compose(Job::failed)</span><br><span class="line">    .compose(Job::attemptInternal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(⊙o⊙)非常简短吧～实际上，<code>failAttempt</code>方法是三个异步方法的组合：<code>error</code>、<code>failed</code>以及<code>attemptInternal</code>。当一个任务需要进行重试的时候，我们首先向Event Bus发布 <code>error</code> 队列事件并且在Redis中记录日志，然后将当前的任务状态置为<code>FAILED</code>，最后重新处理此任务。</p>
<p>我们先来看一下<code>error</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">error</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.emitError(ex)</span><br><span class="line">    .set(<span class="string">"error"</span>, ex.getMessage())</span><br><span class="line">    .compose(j -&gt; j.log(<span class="string">"error | "</span> + ex.getMessage()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的逻辑很简单：首先我们向Event Bus发布 <strong>错误</strong> 事件，然后记录错误日志即可。这里我们封装了一个发布错误的函数<code>emitError</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">emitError</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">  JsonObject errorMessage = <span class="keyword">new</span> JsonObject().put(<span class="string">"id"</span>, <span class="keyword">this</span>.id)</span><br><span class="line">    .put(<span class="string">"message"</span>, ex.getMessage());</span><br><span class="line">  eventBus.publish(Kue.workerAddress(<span class="string">"error"</span>), errorMessage);</span><br><span class="line">  eventBus.send(Kue.getCertainJobAddress(<span class="string">"error"</span>, <span class="keyword">this</span>), errorMessage);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中发送的错误信息格式类似于下面的样子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">id</span>": <span class="value"><span class="number">2052</span></span>,</span><br><span class="line">    "<span class="attribute">message</span>": <span class="value"><span class="string">"some error"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们再来看一下<code>failed</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Job&gt; <span class="title">failed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.failed_at = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.updateNow()</span><br><span class="line">    .compose(j -&gt; j.set(<span class="string">"failed_at"</span>, String.valueOf(j.failed_at)))</span><br><span class="line">    .compose(j -&gt; j.state(JobState.FAILED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单，首先我们更新任务的更新时间和失败时间，然后通过<code>state</code>方法将当前任务状态置为<code>FAILED</code>即可。</p>
<p>任务重试的核心逻辑在<code>attemptInternal</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;Job&gt; <span class="title">attemptInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> remaining = <span class="keyword">this</span>.max_attempts - <span class="keyword">this</span>.attempts; <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">if</span> (remaining &gt; <span class="number">0</span>) &#123; <span class="comment">// 还有重试次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.attemptAdd() <span class="comment">// (2)</span></span><br><span class="line">      .compose(Job::reattempt) <span class="comment">// (3)</span></span><br><span class="line">      .setHandler(r -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.failed()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.emitError(r.cause()); <span class="comment">// (4)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123; <span class="comment">// (5)</span></span><br><span class="line">    <span class="keyword">return</span> Future.failedFuture(<span class="string">"No more attempts"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// (6)</span></span><br><span class="line">    <span class="keyword">return</span> Future.failedFuture(<span class="keyword">new</span> IllegalStateException(<span class="string">"Attempts Exceeded"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的<code>Job</code>数据对象中，我们存储了最大重试次数<code>max_attempts</code>以及已经重试的次数<code>attempts</code>，所以我们首先根据这两个数据计算剩余的重试次数<code>remaining</code> (1)。如果还有剩余次数的话，我们就先调用<code>attemptAdd</code>方法增加一次已重试次数并 (2)，然后我们调用<code>reattempt</code>方法执行真正的任务重试逻辑 (3)。最后返回这两个异步方法组合的<code>Future</code>。如果其中一个过程出现错误，我们就发布<code>error</code>事件 (4)。如果没有剩余次数了或者超出剩余次数了，我们直接返回错误。</p>
<p>在我们解析<code>reattempt</code>方法之前，我们先来回顾一下Vert.x Kue中的任务失败恢复机制。Vert.x Kue支持延时重试机制(retry backoff)，并且支持不同的策略（如 <strong>fixed</strong> 以及 <strong>exponential</strong>）。之前我们提到<code>Job</code>类中有一个<code>backoff</code>成员变量，它用于配置延时重试的策略。它的格式类似于这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">type</span>": <span class="value"><span class="string">"fixed"</span></span>,</span><br><span class="line">    "<span class="attribute">delay</span>": <span class="value"><span class="number">5000</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>延时重试机制的实现在<code>getBackoffImpl</code>方法中，它返回一个<code>Function&lt;Integer, Long&gt;</code>对象，代表一个接受<code>Integer</code>类型（即<code>attempts</code>），返回<code>Long</code>类型（代表计算出的延时值）的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Function&lt;Integer, Long&gt; getBackoffImpl() &#123;</span><br><span class="line">  String type = <span class="keyword">this</span>.backoff.getString(<span class="string">"type"</span>, <span class="string">"fixed"</span>); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">long</span> _delay = <span class="keyword">this</span>.backoff.getLong(<span class="string">"delay"</span>, <span class="keyword">this</span>.delay); <span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"exponential"</span>: <span class="comment">// (3)</span></span><br><span class="line">      <span class="keyword">return</span> attempts -&gt; Math.round(_delay * <span class="number">0.5</span> * (Math.pow(<span class="number">2</span>, attempts) - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"fixed"</span>:</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// (4)</span></span><br><span class="line">      <span class="keyword">return</span> attempts -&gt; _delay;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们从<code>backoff</code>配置中获取延迟重试策略。目前Vert.x Kue支持两种策略：<code>fixed</code> 和 <code>exponential</code>。前者采用固定延迟时间，而后者采用指数增长型延迟时间。默认情况下Vert.x Kue会采用<code>fixed</code>策略 (1)。接下来我们从<code>backoff</code>配置中获取延迟时间，如果配置中没有指定，那么就使用任务对象中的延迟时间<code>delay</code> (2)。接下来就是根据具体的策略进行计算了。对于指数型延迟，我们计算<code>[delay * 0.5 * 2^attempts]</code>作为延迟时间 (3)；对于固定型延迟策略，我们直接使用获取到的延迟时间 (4)。</p>
<p>好啦，现在回到“真正的重试”方法 —— <code>reattempt</code>方法来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;Job&gt; <span class="title">reattempt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.backoff != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> delay = <span class="keyword">this</span>.getBackoffImpl().apply(attempts); <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.setDelay(delay)</span><br><span class="line">      .setPromote_at(System.currentTimeMillis() + delay)</span><br><span class="line">      .update() <span class="comment">// (2)</span></span><br><span class="line">      .compose(Job::delayed); <span class="comment">// (3)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.inactive(); <span class="comment">// (4)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先检查<code>backoff</code>配置是否存在，若存在则计算出对应的延时时间 (1) 并且设定<code>delay</code>和<code>promote_at</code>属性的值然后保存至Redis中 (2)。接着我们通过<code>delayed</code>方法将任务的状态设为延时(<code>DELAYED</code>) (3)。如果延时重试配置不存在，我们就通过<code>inactive</code>方法直接将此任务置入工作队列中 (4)。</p>
<p>这就是整个任务重试功能的实现，也不是很复杂蛤？观察上面的代码，我们可以发现<code>Future</code>组合无处不在。这种响应式的组合非常方便。想一想如果我们用回调的异步方式来写代码的话，我们很容易陷入回调地狱中(⊙o⊙)。。。几个回调嵌套起来总显得不是那么优美和简洁，而用响应式的、可组合的<code>Future</code>就可以有效地避免这个问题。</p>
<p>不错！到现在为止我们已经探索完<code>Job</code>类的源码了～下面我们来看一下<code>JobService</code>类。</p>
<h1 id="Event_Bus_服务_-_JobService">Event Bus 服务 - JobService</h1><p>在本章节中我们来探索一下<code>JobService</code>接口及其实现 —— 它包含着各种普通的操作和统计<code>Job</code>的逻辑。</p>
<h2 id="异步RPC">异步RPC</h2><p>我们的<code>JobService</code>是一个通用逻辑接口，因此我们希望应用中的每一个组件都能访问此服务，即进行RPC。在Vert.x中，我们可以将服务注册至Event Bus上，然后其它组件就可以通过Event Bus来远程调用注册的服务了。</p>
<p>传统的RPC有一个缺点：消费者需要阻塞等待生产者的回应。你可能想说：这是一种阻塞模型，和Vert.x推崇的异步开发模式不相符。没错！而且，传统的RPC不是真正<strong>面向失败设计</strong>的。</p>
<p>还好，Vert.x提供了一种高效的、响应式的RPC —— 异步RPC。我们不需要等待生产者的回应，而只需要传递一个<code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code>参数给异步方法。这样当收到生产者结果时，对应的<code>Handler</code>就会被调用，非常方便，这与Vert.x的异步开发模式相符。并且，<code>AsyncResult</code>也是面向失败设计的。</p>
<p>所以讲到这里，你可能想问：到底怎么在Event Bus上注册服务呢？我们是不是需要写一大堆的逻辑去包装和发送信息，然后在另一端解码信息并进行调用呢？不，这太麻烦了！有了Vert.x 服务代理，我们不需要这么做！Vert.x提供了一个组件 <strong>Vert.x Service Proxy</strong> 来自动生成服务代理。有了它的帮助，我们就只需要按照规范设计我们的异步服务接口，然后用<code>@ProxyGen</code>注解修饰即可。</p>
<p>[NOTE <code>@ProxyGen</code>注解的限制 | <code>@ProxyGen</code>注解的使用有诸多限制。比如，所有的异步方法都必须是基于回调的，也就是说每个方法都要接受一个<code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code>类型的参数。并且，类型<code>R</code>也是有限制的 —— 只允许基本类型以及数据对象类型。详情请参考<a href="http://vertx.io/docs/vertx-service-proxy/" target="_blank" rel="external">官方文档</a>。 ]</p>
<h2 id="异步服务接口">异步服务接口</h2><p>我们来看一下<code>JobService</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ProxyGen</span></span><br><span class="line"><span class="annotation">@VertxGen</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> JobService <span class="title">create</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JobServiceImpl(vertx, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> JobService <span class="title">createProxy</span><span class="params">(Vertx vertx, String address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ProxyHelper.createProxy(JobService.class, vertx, address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取任务，按照优先级顺序</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> id      job id</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Job&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 删除任务</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> id      job id</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">removeJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Void&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 判断任务是否存在</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> id      job id</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">existsJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Boolean&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取任务日志</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> id      job id</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getJobLog</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;JsonArray&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取某一范围内某个指定状态下的任务列表</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> state   expected job state</span><br><span class="line">   * <span class="doctag">@param</span> from    from</span><br><span class="line">   * <span class="doctag">@param</span> to      to</span><br><span class="line">   * <span class="doctag">@param</span> order   range order</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">jobRangeByState</span><span class="params">(String state, <span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取某一范围内某个指定状态和类型下的任务列表</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type    expected job type</span><br><span class="line">   * <span class="doctag">@param</span> state   expected job state</span><br><span class="line">   * <span class="doctag">@param</span> from    from</span><br><span class="line">   * <span class="doctag">@param</span> to      to</span><br><span class="line">   * <span class="doctag">@param</span> order   range order</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">jobRangeByType</span><span class="params">(String type, String state, <span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取某一范围内的任务列表（按照顺序或倒序）</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> from    from</span><br><span class="line">   * <span class="doctag">@param</span> to      to</span><br><span class="line">   * <span class="doctag">@param</span> order   range order</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">jobRange</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> to, String order, Handler&lt;AsyncResult&lt;List&lt;Job&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取指定状态和类型下的任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type    job type</span><br><span class="line">   * <span class="doctag">@param</span> state   job state</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">cardByType</span><span class="params">(String type, JobState state, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取某个状态下的任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> state   job state</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">card</span><span class="params">(JobState state, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取COMPLETE状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type    job type; if null, then return global metrics</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">completeCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取FAILED状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">failedCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取INACTIVE状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">inactiveCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取ACTIVE状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">activeCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取DELAYED状态任务的数量</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> type job type; if null, then return global metrics</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">delayedCount</span><span class="params">(String type, Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取当前存在的所有任务类型</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getAllTypes</span><span class="params">(Handler&lt;AsyncResult&lt;List&lt;String&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取指定状态下的所有任务的ID</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> state   job state</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getIdsByState</span><span class="params">(JobState state, Handler&lt;AsyncResult&lt;List&lt;Long&gt;&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 工作队列运行时间（ms）</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> handler async result handler</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@Fluent</span></span><br><span class="line">  <span class="function">JobService <span class="title">getWorkTime</span><span class="params">(Handler&lt;AsyncResult&lt;Long&gt;&gt; handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们还为<code>JobService</code>接口添加了<code>@VertxGen</code>注解，Vert.x Codegen可以处理此注解生成多种语言版本的服务。</p>
<p>在<code>JobService</code>接口中我们还定义了两个静态方法：<code>create</code>用于创建一个任务服务实例，<code>createProxy</code>用于创建一个服务代理。</p>
<p><code>JobService</code>接口中包含一些任务操作和统计的相关逻辑，每个方法的功能都已经在注释中阐述了，因此我们就直接来看它的实现吧～</p>
<h2 id="任务服务的实现">任务服务的实现</h2><p><code>JobService</code>接口的实现位于<code>JobServiceImpl</code>类中，代码非常长，因此这里就不贴代码了。。。大家可以对照<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/kue-core/src/main/java/io/vertx/blueprint/kue/service/impl/JobServiceImpl.java" target="_blank" rel="external">GitHub中的代码</a>读下面的内容。</p>
<ul>
<li><code>getJob</code>: 获取任务的方法非常简单。直接利用<code>hgetall</code>命令从Redis中取出对应的任务即可。</li>
<li><code>removeJob</code>: 我们可以将此方法看作是<code>getJob</code>和<code>Job#remove</code>两个方法的组合。</li>
<li><code>existsJob</code>: 使用<code>exists</code>命令判断对应<code>id</code>的任务是否存在。</li>
<li><code>getJobLog</code>: 使用<code>lrange</code>命令从<code>vertx_kue:job:{id}:log</code>列表中取出日志。</li>
<li><code>rangeGeneral</code>: 使用<code>zrange</code>命令获取一定范围内的任务，这是一个通用方法。</li>
</ul>
<p>[NOTE <code>zrange</code> 操作 | <code>zrange</code> 返回某一有序集合中某个特定范围内的元素。详情请见<a href="http://redis.io/commands/zrange" target="_blank" rel="external">ZRANGE - Redis</a>。 ]</p>
<p>以下三个方法复用了<code>rangeGeneral</code>方法：</p>
<ul>
<li><code>jobRangeByState</code>: 指定状态，对应的key为<code>vertx_kue:jobs:{state}</code>。</li>
<li><code>jobRangeByType</code>: 指定状态和类型，对应的key为<code>vertx_kue:jobs:{type}:{state}</code>。</li>
<li><code>jobRange</code>: 对应的key为<code>vertx_kue:jobs</code>。</li>
</ul>
<p>这两个通用方法用于任务数量的统计：</p>
<ul>
<li><code>cardByType</code>: 利用<code>zcard</code>命令获取某一指定状态和类型下任务的数量。</li>
<li><code>card</code>: 利用<code>zcard</code>命令获取某一指定状态下任务的数量。</li>
</ul>
<p>下面五个辅助统计方法复用了上面两个通用方法：</p>
<ul>
<li><code>completeCount</code></li>
<li><code>failedCount</code></li>
<li><code>delayedCount</code></li>
<li><code>inactiveCount</code></li>
<li><code>activeCount</code></li>
</ul>
<p>接着看：</p>
<ul>
<li><code>getAllTypes</code>: 利用<code>smembers</code>命令获取<code>vertx_kue:job:types</code>集合中存储的所有的任务类型。</li>
<li><code>getIdsByState</code>: 使用<code>zrange</code>获取某一指定状态下所有任务的ID。</li>
<li><code>getWorkTime</code>: 使用<code>get</code>命令从<code>vertx_kue:stats:work-time</code>中获取Vert.x Kue的工作时间。</li>
</ul>
<h2 id="注册任务服务">注册任务服务</h2><p>既然完成了<code>JobService</code>的实现，接下来我们来看一下如何利用Service Proxy将服务注册至Event Bus上。这里我们还需要一个<code>KueVerticle</code>来创建要注册的服务实例，并且将其注册至Event Bus上。</p>
<p>打开<code>io.vertx.blueprint.kue.queue.KueVerticle</code>类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.service.JobService;</span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.util.RedisHelper;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.logging.Logger;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.logging.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> io.vertx.redis.RedisClient;</span><br><span class="line"><span class="keyword">import</span> io.vertx.serviceproxy.ProxyHelper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KueVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Job.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EB_JOB_SERVICE_ADDRESS = <span class="string">"vertx.kue.service.job.internal"</span>; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> JsonObject config;</span><br><span class="line">  <span class="keyword">private</span> JobService jobService;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config();</span><br><span class="line">    <span class="keyword">this</span>.jobService = JobService.create(vertx, config); <span class="comment">// (2)</span></span><br><span class="line">    <span class="comment">// create redis client</span></span><br><span class="line">    RedisClient redisClient = RedisHelper.client(vertx, config);</span><br><span class="line">    redisClient.ping(pr -&gt; &#123; <span class="comment">// (3) test connection</span></span><br><span class="line">      <span class="keyword">if</span> (pr.succeeded()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Kue Verticle is running..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (4) register job service</span></span><br><span class="line">        ProxyHelper.registerService(JobService.class, vertx, jobService, EB_JOB_SERVICE_ADDRESS);</span><br><span class="line"></span><br><span class="line">        future.complete();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"oops!"</span>, pr.cause());</span><br><span class="line">        future.fail(pr.cause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们需要定义一个地址用于服务注册 (1)。在<code>start</code>方法中，我们创建了一个任务服务实例 (2)，然后通过<code>ping</code>命令测试Redis连接 (3)。如果连接正常，那么我们就可以通过<code>ProxyHelper</code>类中的<code>registerService</code>辅助方法来将服务实例注册至Event Bus上 (4)。</p>
<p>这样，一旦我们在集群模式下部署<code>KueVerticle</code>，服务就会被发布至Event Bus上，然后我们就可以在其他组件中去远程调用此服务了。很奇妙吧！</p>
<h1 id="Kue_-_工作队列">Kue - 工作队列</h1><p><code>Kue</code>类代表着工作队列。我们来看一下<code>Kue</code>类的实现。首先先看一下其构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Kue</span><span class="params">(Vertx vertx, JsonObject config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vertx = vertx;</span><br><span class="line">  <span class="keyword">this</span>.config = config;</span><br><span class="line">  <span class="keyword">this</span>.jobService = JobService.createProxy(vertx, EB_JOB_SERVICE_ADDRESS);</span><br><span class="line">  <span class="keyword">this</span>.client = RedisHelper.client(vertx, config);</span><br><span class="line">  Job.setVertx(vertx, RedisHelper.client(vertx, config)); <span class="comment">// init static vertx instance inner job</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要注意两点：第一点，我们通过<code>createProxy</code>方法来创建一个<code>JobService</code>的服务代理；第二点，之前提到过，我们需要在这里初始化<code>Job</code>类中的静态成员变量。</p>
<h2 id="基于Future的封装">基于Future的封装</h2><p>我们的<code>JobService</code>是基于回调的，这是服务代理组件所要求的。为了让Vert.x Kue更加响应式，使用起来更加方便，我们在<code>Kue</code>类中以基于Future的异步模式封装了<code>JobService</code>中的所有异步方法。这很简单，比如这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Fluent</span></span><br><span class="line"><span class="function">JobService <span class="title">getJob</span><span class="params">(<span class="keyword">long</span> id, Handler&lt;AsyncResult&lt;Job&gt;&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以这么封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;Optional&lt;Job&gt;&gt; getJob(<span class="keyword">long</span> id) &#123;</span><br><span class="line">  Future&lt;Optional&lt;Job&gt;&gt; future = Future.future();</span><br><span class="line">  jobService.getJob(id, r -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">      future.complete(Optional.ofNullable(r.result()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      future.fail(r.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是加一层<code>Future</code>。其它的封装过程也类似所以我们就不细说了。</p>
<p><img src="https://raw.githubusercontent.com/sczyh30/vertx-blueprint-job-queue/master/docs/images/kue_future_based_methods.png" alt=""></p>
<h2 id="process和processBlocking方法">process和processBlocking方法</h2><p><code>process</code>和<code>processBlocking</code>方法用于处理任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">process</span><span class="params">(String type, <span class="keyword">int</span> n, Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The process times must be positive"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    processInternal(type, handler, <span class="keyword">false</span>);</span><br><span class="line">  &#125;<span class="function">f</span><br><span class="line">  <span class="title">setupTimers</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">process</span><span class="params">(String type, Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  processInternal(type, handler, <span class="keyword">false</span>);</span><br><span class="line">  setupTimers();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Kue <span class="title">processBlocking</span><span class="params">(String type, <span class="keyword">int</span> n, Handler&lt;Job&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The process times must be positive"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    processInternal(type, handler, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  setupTimers();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个<code>process</code>方法都类似 —— 它们都是使用<strong>Event Loop</strong>线程处理任务的，其中第一个方法还可以指定同时处理任务数量的阈值。我们来回顾一下使用<strong>Event Loop</strong>线程的注意事项 —— 我们不能阻塞Event Loop线程。因此如果我们需要在处理任务时做一些耗时的操作，我们可以使用<code>processBlocking</code>方法。这几个方法的代码看起来都差不多，那么区别在哪呢？之前我们提到过，我们设计了一种Verticle - <code>KueWorker</code>，用于处理任务。因此对于<code>process</code>方法来说，<code>KueWorker</code>就是一种普通的Verticle；而对于<code>processBlocking</code>方法来说，<code>KueWorker</code>是一种<strong>Worker Verticle</strong>。这两种Verticle有什么不同呢？区别在于，Worker Verticle会使用<strong>Worker线程</strong>，因此即使我们执行一些耗时的操作，Event Loop线程也不会被阻塞。</p>
<p>创建及部署<code>KueWorker</code>的逻辑在<code>processInternal</code>方法中，这三个方法都使用了<code>processInternal</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processInternal</span><span class="params">(String type, Handler&lt;Job&gt; handler, <span class="keyword">boolean</span> isWorker)</span> </span>&#123;</span><br><span class="line">  KueWorker worker = <span class="keyword">new</span> KueWorker(type, handler, <span class="keyword">this</span>); <span class="comment">// (1)</span></span><br><span class="line">  vertx.deployVerticle(worker, <span class="keyword">new</span> DeploymentOptions().setWorker(isWorker), r0 -&gt; &#123; <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">if</span> (r0.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.on(<span class="string">"job_complete"</span>, msg -&gt; &#123;</span><br><span class="line">        <span class="keyword">long</span> dur = <span class="keyword">new</span> Job(((JsonObject) msg.body()).getJsonObject(<span class="string">"job"</span>)).getDuration();</span><br><span class="line">        client.incrby(RedisHelper.getKey(<span class="string">"stats:work-time"</span>), dur, r1 -&gt; &#123; <span class="comment">// (3)</span></span><br><span class="line">          <span class="keyword">if</span> (r1.failed())</span><br><span class="line">            r1.cause().printStackTrace();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们创建一个<code>KueWorker</code>实例 (1)。我们将在稍后详细介绍<code>KueWorker</code>的实现。然后我们根据提供的配置来部署此<code>KueWorker</code> (2)。<code>processInternal</code>方法的第三个参数代表此<code>KueWorker</code>是否为worker verticle。如果部署成功，我们就监听<code>complete</code>事件。每当接收到<code>complete</code>事件的时候，我们获取收到的信息（处理任务消耗的时间），然后用<code>incrby</code>增加对应的工作时间 (3)。</p>
<p>再回到前面三个处理方法中。除了部署<code>KueWorker</code>以外，我们还调用了<code>setupTimers</code>方法，用于设定定时器以监测延时任务以及监测活动任务TTL。</p>
<h2 id="监测延时任务">监测延时任务</h2><p>Vert.x Kue支持延时任务，因此我们需要在任务延时时间到达时将任务“提升”至工作队列中等待处理。这个工作是在<code>checkJobPromotion</code>方法中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkJobPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout = config.getInteger(<span class="string">"job.promotion.interval"</span>, <span class="number">1000</span>); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">int</span> limit = config.getInteger(<span class="string">"job.promotion.limit"</span>, <span class="number">1000</span>); <span class="comment">// (2)</span></span><br><span class="line">  vertx.setPeriodic(timeout, l -&gt; &#123; <span class="comment">// (3)</span></span><br><span class="line">    client.zrangebyscore(RedisHelper.getKey(<span class="string">"jobs:DELAYED"</span>), String.valueOf(<span class="number">0</span>), String.valueOf(System.currentTimeMillis()),</span><br><span class="line">      <span class="keyword">new</span> RangeLimitOptions(<span class="keyword">new</span> JsonObject().put(<span class="string">"offset"</span>, <span class="number">0</span>).put(<span class="string">"count"</span>, limit)), r -&gt; &#123;  <span class="comment">// (4)</span></span><br><span class="line">        <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">          r.result().forEach(r1 -&gt; &#123;</span><br><span class="line">            <span class="keyword">long</span> id = Long.parseLong(RedisHelper.stripFIFO((String) r1));</span><br><span class="line">            <span class="keyword">this</span>.getJob(id).compose(jr -&gt; jr.get().inactive())  <span class="comment">// (5)</span></span><br><span class="line">              .setHandler(jr -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (jr.succeeded()) &#123;</span><br><span class="line">                  jr.result().emit(<span class="string">"promotion"</span>, jr.result().getId()); <span class="comment">// (6)</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  jr.cause().printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r.cause().printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们从配置中获取监测延时任务的间隔(<code>job.promotion.interval</code>，默认1000ms)以及提升数量阈值(<code>job.promotion.limit</code>，默认1000)。然后我们使用<code>vertx.setPeriodic</code>方法设一个周期性的定时器 (3)，每隔一段时间就从Redis中获取需要被提升的任务 (4)。这里我们通过<code>zrangebyscore</code>获取每个需要被提升任务的<code>id</code>。我们来看一下<code>zrangebyscore</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisClient <span class="title">zrangebyscore</span><span class="params">(String key, String min, String max, RangeLimitOptions options, Handler&lt;AsyncResult&lt;JsonArray&gt;&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>key</code>: 某个有序集合的key，即<code>vertx_kue:jobs:DELAYED</code></li>
<li><code>min</code> and <code>max</code>: 最小值以及最大值（按照某种模式）。这里<code>min</code>是<strong>0</strong>，而<code>max</code>是当前时间戳</li>
</ul>
<p>我们来回顾一下<code>Job</code>类中的<code>state</code>方法。当我们要把任务状态设为<code>DELAYED</code>的时候，我们将score设为<code>promote_at</code>时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> DELAYED:</span><br><span class="line">  client.transaction().zadd(RedisHelper.getKey(<span class="string">"jobs:"</span> + newState.name()),</span><br><span class="line">    <span class="keyword">this</span>.promote_at, <span class="keyword">this</span>.zid, _failure());</span><br></pre></td></tr></table></figure>
<p>因此我们将<code>max</code>设为当前时间(<code>System.currentTimeMillis()</code>)，只要当前时间超过需要提升的时间，这就说明此任务可以被提升了。</p>
<ul>
<li><code>options</code>: range和limit配置。这里我们需要指定<code>LIMIT</code>值所以我们用<code>new RangeLimitOptions(new JsonObject().put(&quot;offset&quot;, 0).put(&quot;count&quot;, limit)</code>创建了一个配置</li>
</ul>
<p><code>zrangebyscore</code>的结果是一个<code>JsonArray</code>，里面包含着所有等待提升任务的<code>zid</code>。获得结果后我们就将每个<code>zid</code>转换为<code>id</code>，然后分别获取对应的任务实体，最后对每个任务调用<code>inactive</code>方法来将任务状态设为<code>INACTIVE</code> (5)。如果任务成功提升至工作队列，我们就发送<code>promotion</code>事件 (6)。</p>
<h2 id="CallbackKue_-_提供多语言支持">CallbackKue - 提供多语言支持</h2><p>我们知道，Vert.x支持多种语言(如JS，Ruby)，因此如果能让我们的Vert.x Kue支持多种语言那当然是极好的！这没有问题～Vert.x Codegen可以处理含<code>@VertxGen</code>注解的异步接口，生成多语言版本。<code>@VertxGen</code>注解同样限制异步方法 —— 需要基于回调，因此我们设计了一个<code>CallbackKue</code>接口用于提供多语言支持。<code>CallbackKue</code>的设计非常简单，其实现复用了<code>Kue</code>和<code>jobService</code>的代码。大家可以直接看源码，一目了然，这里就不细说了。</p>
<p>注意要生成多语言版本的代码，需要添加相应的依赖。比如要生成Ruby版本的代码就要向<code>build.gradle</code>中添加<code>compile(&quot;io.vertx:vertx-lang-ruby:${vertxVersion}&quot;)</code>。</p>
<h1 id="KueWorker_-_任务在此处理">KueWorker - 任务在此处理</h1><p>好啦，我们已经对Vert.x Kue Core的几个核心部分有了大致的了解了，现在是时候探索一下任务处理的本源 - <code>KueWorker</code>了～</p>
<p>每一个worker都对应一个特定的任务类型，并且绑定着特定的处理函数(<code>Handler</code>)，所以我们需要在创建的时候指定它们。</p>
<h2 id="prepareAndStart方法">prepareAndStart方法</h2><p>在<code>KueWorker</code>中，我们使用<code>prepareAndStart</code>方法来准备要处理的任务并且开始处理任务的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAndStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.getJobFromBackend().setHandler(jr -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (jr.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (jr.result().isPresent()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.job = jr.result().get(); <span class="comment">// (2)</span></span><br><span class="line">        process(); <span class="comment">// (3)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, <span class="string">"job_not_exist"</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"job not exist"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, jr.cause().getMessage()));</span><br><span class="line">        jr.cause().printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较直观。首先我们通过<code>getJobFromBackend</code>方法从Redis中按照优先级顺序获取任务 (1)。如果成功获取任务，我们就把获取到的任务保存起来 (2) 然后通过<code>process</code>方法处理任务 (3)。如果中间出现错误，我们需要发送<code>error</code>错误事件，其中携带错误信息。</p>
<h2 id="使用zpop按照优先级顺序获取任务">使用zpop按照优先级顺序获取任务</h2><p>我们来看一下我们是如何从Redis中按照优先级顺序获取任务实体的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Future&lt;Optional&lt;Job&gt;&gt; getJobFromBackend() &#123;</span><br><span class="line">  Future&lt;Optional&lt;Job&gt;&gt; future = Future.future();</span><br><span class="line">  client.blpop(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="number">0</span>, r1 -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (r1.failed()) &#123;</span><br><span class="line">      client.lpush(RedisHelper.getKey(<span class="keyword">this</span>.type + <span class="string">":jobs"</span>), <span class="string">"1"</span>, r2 -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (r2.failed())</span><br><span class="line">          future.fail(r2.cause());</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.zpop(RedisHelper.getKey(<span class="string">"jobs:"</span> + <span class="keyword">this</span>.type + <span class="string">":INACTIVE"</span>)) <span class="comment">// (2)</span></span><br><span class="line">        .compose(kue::getJob) <span class="comment">// (3)</span></span><br><span class="line">        .setHandler(r -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">            future.complete(r.result());</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">            future.fail(r.cause());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我们已经了解到，每当我们保存一个任务的时候，我们都会向<code>vertx_kue:{type}:jobs</code>列表中插入一个新元素表示新的任务可供处理。因此这里我们通过<code>blpop</code>命令来等待可用的任务 (1)。一旦有任务可供处理，我们就利用<code>zpop</code>方法取出高优先级的任务的<code>zid</code> (2)。<code>zpop</code>命令是一个原子操作，用于从有序集合中弹出最小score值的元素。注意Redis没有实现<code>zpop</code>命令，因此我们需要自己实现。</p>
<p><a href="http://redis.io/topics/transactions#using-a-hrefcommandswatchwatcha-to-implement-zpop" target="_blank" rel="external">Redis官方文档</a>介绍了一种实现<code>zpop</code>命令的简单方法 - 利用 <code>WATCH</code>。这里我们利用另外一种思路实现<code>zpop</code>命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;Long&gt; <span class="title">zpop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  Future&lt;Long&gt; future = Future.future();</span><br><span class="line">  client.transaction()</span><br><span class="line">    .multi(_failure())</span><br><span class="line">    .zrange(key, <span class="number">0</span>, <span class="number">0</span>, _failure())</span><br><span class="line">    .zremrangebyrank(key, <span class="number">0</span>, <span class="number">0</span>, _failure())</span><br><span class="line">    .exec(r -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">        JsonArray res = r.result();</span><br><span class="line">        <span class="keyword">if</span> (res.getJsonArray(<span class="number">0</span>).size() == <span class="number">0</span>) <span class="comment">// empty set</span></span><br><span class="line">          future.fail(<span class="keyword">new</span> IllegalStateException(<span class="string">"Empty zpop set"</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            future.complete(Long.parseLong(RedisHelper.stripFIFO(</span><br><span class="line">              res.getJsonArray(<span class="number">0</span>).getString(<span class="number">0</span>))));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            future.fail(ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        future.fail(r.cause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的<code>zpop</code>的实现中，我们首先开始了一个事务块，然后依次执行<code>zrange</code>和<code>zremrangebyrank</code>命令。有关这些命令的详情我们就不细说了，可以参考<a href="http://redis.io/commands" target="_blank" rel="external">Redis官方文档</a>。然后我们提交事务，如果提交成功，我们会获得一个<code>JsonArray</code>类型的结果。正常情况下我们都可以通过<code>res.getJsonArray(0).getString(0)</code>获取到对应的<code>zid</code>值。获取到<code>zid</code>值以后我们就可以将其转换为任务的<code>id</code>了，最后我们将<code>id</code>置于<code>Future</code>内（因为<code>zpop</code>也是一个异步方法）。</p>
<p>接着回到<code>getJobFromBackend</code>方法中。获取到对应的<code>id</code>之后，我们就可以通过<code>Kue</code>的<code>getJob</code>函数获取任务实体了 (3)。由于<code>getJobFromBackend</code>也是一个异步方法，因此我们同样将结果置于<code>Future</code>中。</p>
<h2 id="真正的“处理”逻辑">真正的“处理”逻辑</h2><p>前边讲了那么多，都是在为处理任务做准备。。。不要着急，现在终于到了真正的“处理”逻辑咯！我们看一下<code>process</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> curTime = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">this</span>.job.setStarted_at(curTime)</span><br><span class="line">    .set(<span class="string">"started_at"</span>, String.valueOf(curTime)) <span class="comment">// (1) set start time</span></span><br><span class="line">    .compose(Job::active) <span class="comment">// (2) set the job state to ACTIVE</span></span><br><span class="line">    .setHandler(r -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">        Job j = r.result();</span><br><span class="line">        <span class="comment">// emit start event</span></span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"start"</span>, j, <span class="keyword">null</span>);  <span class="comment">// (3) emit job `start` event</span></span><br><span class="line">        <span class="comment">// (4) process logic invocation</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          jobHandler.handle(j);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">          j.done(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (5) consume the job done event</span></span><br><span class="line"></span><br><span class="line">        eventBus.consumer(Kue.workerAddress(<span class="string">"done"</span>, j), msg -&gt; &#123;</span><br><span class="line">          createDoneCallback(j).handle(Future.succeededFuture(</span><br><span class="line">            ((JsonObject) msg.body()).getJsonObject(<span class="string">"result"</span>)));</span><br><span class="line">        &#125;);</span><br><span class="line">        eventBus.consumer(Kue.workerAddress(<span class="string">"done_fail"</span>, j), msg -&gt; &#123;</span><br><span class="line">          createDoneCallback(j).handle(Future.failedFuture(</span><br><span class="line">            (String) msg.body()));</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.emitJobEvent(<span class="string">"error"</span>, <span class="keyword">this</span>.job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, r.cause().getMessage()));</span><br><span class="line">          r.cause().printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了最核心的函数了！首先我们先给开始时间赋值 (1) 然后将任务状态置为<code>ACTIVE</code> (2)。如果这两个操作成功的话，我们就向Event Bus发送任务开始(<code>start</code>)事件 (3)。接下来我们调用真正的处理逻辑 - 之前绑定的<code>jobHandler</code> (4)。如果处理过程中抛出异常的话，Vert.x Kue就会调用<code>job.done(ex)</code>方法发送<code>done_fail</code>内部事件来通知worker任务处理失败。但是似乎没有看到在哪里接收并处理<code>done</code>和<code>done_fail</code>事件呢？就在这 (5)！一旦Vert.x Kue接收到这两个事件，它就会调用对应的<code>handler</code>去进行任务完成或失败的相应操作。这里的<code>handler</code>是由<code>createDoneCallback</code>方法生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; createDoneCallback(Job job) &#123;</span><br><span class="line">  <span class="keyword">return</span> r0 -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (job == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r0.failed()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fail(r0.cause()); <span class="comment">// (1)</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> dur = System.currentTimeMillis() - job.getStarted_at();</span><br><span class="line">    job.setDuration(dur)</span><br><span class="line">      .set(<span class="string">"duration"</span>, String.valueOf(dur)); <span class="comment">// (2)</span></span><br><span class="line">    JsonObject result = r0.result();</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      job.setResult(result)</span><br><span class="line">        .set(<span class="string">"result"</span>, result.encodePrettily()); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.complete().setHandler(r -&gt; &#123; <span class="comment">// (4)</span></span><br><span class="line">      <span class="keyword">if</span> (r.succeeded()) &#123;</span><br><span class="line">        Job j = r.result();</span><br><span class="line">        <span class="keyword">if</span> (j.isRemoveOnComplete()) &#123; <span class="comment">// (5)</span></span><br><span class="line">          j.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"complete"</span>, j, <span class="keyword">null</span>); <span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.prepareAndStart(); <span class="comment">// (7) 准备处理下一个任务</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务处理有两种情况：完成和失败，因此我们先来看任务成功处理的情况。我们首先给任务的用时(<code>duration</code>)赋值 (2)，并且如果任务产生了结果，也给结果(<code>result</code>)赋值 (3)。然后我们调用<code>job.complete</code>方法将状态设置为<code>COMPLETE</code> (4)。如果成功的话，我们就检查<code>removeOnComplete</code>标志位 (5) 并决定是否将任务从Redis中移除。然后我们向Event Bus发送任务完成事件(<code>complete</code>)以及队列事件<code>job_complete</code> (6)。现在这个任务的处理过程已经结束了，worker需要准备处理下一个任务了，因此最后我们调用<code>prepareAndStart</code>方法准备处理下一个<code>Job</code>。</p>
<h2 id="处理失败了怎么办？">处理失败了怎么办？</h2><p>人生不如意事十之八九，任务处理过程中很可能会遇见各种各样的问题而失败。当任务处理失败时，我们调用<code>KueWorker</code>中的<code>fail</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">  job.failedAttempt(ex).setHandler(r -&gt; &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (r.failed()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.error(r.cause(), job); <span class="comment">// (2)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Job res = r.result();</span><br><span class="line">      <span class="keyword">if</span> (res.hasAttempts()) &#123; <span class="comment">// (3)</span></span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"failed_attempt"</span>, job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, ex.getMessage()));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.emitJobEvent(<span class="string">"failed"</span>, job, <span class="keyword">new</span> JsonObject().put(<span class="string">"message"</span>, ex.getMessage())); <span class="comment">// (4)</span></span><br><span class="line">      &#125;</span><br><span class="line">      prepareAndStart(); <span class="comment">// (5)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面对失败时，我们首先通过<code>failedAttempt</code>方法尝试从错误中恢复 (1)。如果恢复失败（比如没有重试次数了）就向Event Bus发送<code>error</code>队列事件 (2)。如果恢复成功，我们就根据是否还有剩余重试次数来发送对应的事件(<code>failed</code>或者<code>failed_attempt</code>)。搞定错误以后，worker同样需要准备处理下一个任务了，因此最后我们调用<code>prepareAndStart</code>方法准备处理下一个<code>Job</code> (5)。</p>
<p>这就是<code>KueWorker</code>的全部实现，是不是很有趣呢？看了这么久的代码也有些累了，下面是时候来写个Kue应用跑一下咯～</p>
<h1 id="展示时间！">展示时间！</h1><p>在<code>io.vertx.blueprint.kue.example</code>包下(<code>kue-example</code>子工程)创建一个<code>LearningVertxVerticle</code>类，然后编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.vertx.blueprint.kue.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.Kue;</span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.Job;</span><br><span class="line"><span class="keyword">import</span> io.vertx.blueprint.kue.queue.Priority;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearningVertxVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建工作队列</span></span><br><span class="line">    Kue kue = Kue.createQueue(vertx, config());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听全局错误事件</span></span><br><span class="line">    kue.on(<span class="string">"error"</span>, message -&gt;</span><br><span class="line">      System.out.println(<span class="string">"[Global Error] "</span> + message.body()));</span><br><span class="line"></span><br><span class="line">    JsonObject data = <span class="keyword">new</span> JsonObject()</span><br><span class="line">      .put(<span class="string">"title"</span>, <span class="string">"Learning Vert.x"</span>)</span><br><span class="line">      .put(<span class="string">"content"</span>, <span class="string">"core"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备学习Vert.x，爽！</span></span><br><span class="line">    Job j = kue.createJob(<span class="string">"learn vertx"</span>, data)</span><br><span class="line">      .priority(Priority.HIGH)</span><br><span class="line">      .onComplete(r -&gt; &#123; <span class="comment">// 完成任务事件监听</span></span><br><span class="line">        System.out.println(<span class="string">"Feeling: "</span> + r.getResult().getString(<span class="string">"feeling"</span>, <span class="string">"none"</span>));</span><br><span class="line">    &#125;).onFailure(r -&gt; &#123; <span class="comment">// 任务失败事件监听</span></span><br><span class="line">        System.out.println(<span class="string">"eee...so difficult..."</span>);</span><br><span class="line">    &#125;).onProgress(r -&gt; &#123; <span class="comment">// 任务进度变更事件监听</span></span><br><span class="line">        System.out.println(<span class="string">"I love this! My progress =&gt; "</span> + r);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存任务</span></span><br><span class="line">    j.save().setHandler(r0 -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (r0.succeeded()) &#123;</span><br><span class="line">        <span class="comment">// 开始学习！</span></span><br><span class="line">        kue.processBlocking(<span class="string">"learn vertx"</span>, <span class="number">1</span>, job -&gt; &#123;</span><br><span class="line">          job.progress(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">          <span class="comment">// 3秒速成</span></span><br><span class="line">          vertx.setTimer(<span class="number">3000</span>, r1 -&gt; &#123;</span><br><span class="line">            job.setResult(<span class="keyword">new</span> JsonObject().put(<span class="string">"feeling"</span>, <span class="string">"amazing and wonderful!"</span>)) <span class="comment">// 结果</span></span><br><span class="line">              .done(); <span class="comment">// 完成啦！</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">"Wow, something happened: "</span> + r0.cause().getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，一个Vert.x Kue应用可以分为几部分：创建工作队列、创建任务、保存任务以及处理任务。我们推荐开发者把应用写成<code>Verticle</code>的形式。</p>
<p>在这个例子中，我们要模拟一个学习Vert.x的任务！首先我们通过<code>Kue.createQueue</code>方法创建一个工作队列并且通过<code>on(error, handler)</code>方法监听全局错误(<code>error</code>)事件。接着我们通过<code>kue.createJob</code>方法创建学习任务，将优先级设定为<code>HIGH</code>，并且监听<code>complete</code>、<code>failed</code>以及<code>progress</code>事件。然后我们需要保存任务，保存完毕以后我们就可以通过<code>processBlocking</code>方法来执行耗时任务了。在处理逻辑中，我们首先通过<code>job.progress</code>方法将进度设为<code>10</code>，然后使用<code>vertx.setTimer</code>方法设一个3秒的定时器，定时器时间到以后赋予结果并完成任务。</p>
<p>像往常一样，我们还需要在<code>build.gradle</code>中配置一下。我们需要将<code>kue-example</code>子工程中的<code>Main-Verticle</code>属性设为刚才写的<code>io.vertx.blueprint.kue.example.LearningVertxVerticle</code>：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(<span class="string">"kue-example"</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="keyword">project</span>(<span class="string">":kue-core"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jar &#123;</span><br><span class="line">    archiveName = <span class="string">'vertx-blueprint-kue-example.jar'</span></span><br><span class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">      attributes <span class="string">'Main-Class'</span>: <span class="string">'io.vertx.core.Launcher'</span></span><br><span class="line">      attributes <span class="string">'Main-Verticle'</span>: <span class="string">'io.vertx.blueprint.kue.example.LearningVertxVerticle'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，到了展示时间了！打开终端，构建项目：</p>
<pre><code><span class="title">gradle</span> build
</code></pre><p>当然不要忘记运行Redis：</p>
<pre><code>redis-<span class="keyword">server</span>
</code></pre><p>然后我们先运行Vert.x Kue Core部分：</p>
<pre><code>java -jar kue-core<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-core.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>然后再运行我们的实例：</p>
<pre><code>java -jar kue-example<span class="regexp">/build/</span>libs<span class="regexp">/vertx-blueprint-kue-example.jar -cluster -ha -conf config/</span>config.json
</code></pre><p>这时终端应该会依次显示输出：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">INFO:</span> Kue Verticle is running...</span><br><span class="line">I love this! My progress =&gt; <span class="number">10</span></span><br><span class="line"><span class="label">Feeling:</span> amazing <span class="keyword">and</span> wonderful!</span><br></pre></td></tr></table></figure>
<p>当然你也可以在Vert.x Kue的Web端查看任务情况。</p>
<h1 id="完成我们的探索之旅！">完成我们的探索之旅！</h1><p>棒极了！我们终于结束了我们的Vert.x Kue核心部分探索之旅～～！从这篇超长的教程中，你学到了如何利用Vert.x去开发一个基于消息的应用！太酷了！</p>
<p>如果想了解<code>kue-http</code>的实现，请移步<a href="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/">Vert.x 蓝图 | Vert.x Kue 教程（Web部分）</a>。如果想了解更多的关于Vert.x Kue的特性，请移步<a href="https://github.com/sczyh30/vertx-blueprint-job-queue/blob/master/docs/zh-cn/vertx-kue-features.zh-cn.md" target="_blank" rel="external">Vert.x Kue 特性介绍</a>。</p>
<p>Vert.x能做的不仅仅是这些。想要了解更多的关于Vert.x的知识，请参考<a href="http://vertx.io/docs/" target="_blank" rel="external">Vert.x 官方文档</a> —— 这永远是资料最齐全的地方。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 sczyh30 的个人博客">sczyh30</a></p>
        <p><span>发布时间:</span>2016年07月24日</p>
        <!--<p><span>最后更新:</span>2016年09月13日 - 09时47分</p>-->
        <p>
            <span>原始链接:</span><a class="post-url" href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/" title="Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）">http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/</a>
            <span class="copy-path" data-clipboard-text="原文: http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/　　作者: sczyh30" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0" target = "_blank">知识共享-保持署名-非商用-相同方式共享 4.0 (CC BY-NC-SA 4.0)</a><br/>转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/">
                    Vert.x Blueprint 系列教程(二) | Vert.x Kue 教程（Web部分）
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">
                    Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vert-x的消息系统"><span class="toc-number">2.</span> <span class="toc-text">Vert.x的消息系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#发布/订阅模式"><span class="toc-number">2.1.</span> <span class="toc-text">发布/订阅模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点对点模式"><span class="toc-number">2.2.</span> <span class="toc-text">点对点模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求/回应模式"><span class="toc-number">2.3.</span> <span class="toc-text">请求/回应模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vert-x_Kue_架构设计"><span class="toc-number">3.</span> <span class="toc-text">Vert.x Kue 架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vert-x_Kue_组件划分"><span class="toc-number">3.1.</span> <span class="toc-text">Vert.x Kue 组件划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vert-x_Kue_核心模块"><span class="toc-number">3.2.</span> <span class="toc-text">Vert.x Kue 核心模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于Future的异步模式"><span class="toc-number">3.3.</span> <span class="toc-text">基于Future的异步模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vert-x_Kue中的事件"><span class="toc-number">3.4.</span> <span class="toc-text">Vert.x Kue中的事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务状态"><span class="toc-number">3.5.</span> <span class="toc-text">任务状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整体设计"><span class="toc-number">3.6.</span> <span class="toc-text">整体设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#项目结构"><span class="toc-number">4.</span> <span class="toc-text">项目结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#任务实体_-_不仅仅是一个数据对象"><span class="toc-number">5.</span> <span class="toc-text">任务实体 - 不仅仅是一个数据对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#任务成员属性"><span class="toc-number">5.1.</span> <span class="toc-text">任务成员属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务事件辅助函数"><span class="toc-number">5.2.</span> <span class="toc-text">任务事件辅助函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis中的存储形式"><span class="toc-number">5.3.</span> <span class="toc-text">Redis中的存储形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改变任务状态"><span class="toc-number">5.4.</span> <span class="toc-text">改变任务状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保存任务"><span class="toc-number">5.5.</span> <span class="toc-text">保存任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#移除任务"><span class="toc-number">5.6.</span> <span class="toc-text">移除任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#监听任务事件"><span class="toc-number">5.7.</span> <span class="toc-text">监听任务事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更新任务进度"><span class="toc-number">5.8.</span> <span class="toc-text">更新任务进度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务失败以及重试机制"><span class="toc-number">5.9.</span> <span class="toc-text">任务失败以及重试机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Event_Bus_服务_-_JobService"><span class="toc-number">6.</span> <span class="toc-text">Event Bus 服务 - JobService</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#异步RPC"><span class="toc-number">6.1.</span> <span class="toc-text">异步RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步服务接口"><span class="toc-number">6.2.</span> <span class="toc-text">异步服务接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务服务的实现"><span class="toc-number">6.3.</span> <span class="toc-text">任务服务的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注册任务服务"><span class="toc-number">6.4.</span> <span class="toc-text">注册任务服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kue_-_工作队列"><span class="toc-number">7.</span> <span class="toc-text">Kue - 工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基于Future的封装"><span class="toc-number">7.1.</span> <span class="toc-text">基于Future的封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#process和processBlocking方法"><span class="toc-number">7.2.</span> <span class="toc-text">process和processBlocking方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#监测延时任务"><span class="toc-number">7.3.</span> <span class="toc-text">监测延时任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CallbackKue_-_提供多语言支持"><span class="toc-number">7.4.</span> <span class="toc-text">CallbackKue - 提供多语言支持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KueWorker_-_任务在此处理"><span class="toc-number">8.</span> <span class="toc-text">KueWorker - 任务在此处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#prepareAndStart方法"><span class="toc-number">8.1.</span> <span class="toc-text">prepareAndStart方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用zpop按照优先级顺序获取任务"><span class="toc-number">8.2.</span> <span class="toc-text">使用zpop按照优先级顺序获取任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#真正的“处理”逻辑"><span class="toc-number">8.3.</span> <span class="toc-text">真正的“处理”逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理失败了怎么办？"><span class="toc-number">8.4.</span> <span class="toc-text">处理失败了怎么办？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#展示时间！"><span class="toc-number">9.</span> <span class="toc-text">展示时间！</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#完成我们的探索之旅！"><span class="toc-number">10.</span> <span class="toc-text">完成我们的探索之旅！</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




    <div class="share">
    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
    <a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
    <a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
    </div>
    <script>
        window._bd_share_config={
            "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>
</div>



    
      <div class="duoshuo" id="comments">
    <!-- duoshuo comment start -->
    <div class="ds-thread" data-thread-key="posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/" data-title="Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）" data-url="http://www.sczyh30.com/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/"></div>
    <!-- duoshuo comment end -->
    <!-- duoshuo public js start -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name: 'sczyh30'};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        /*ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';*/
        ds.src = 'http://www.sczyh30.com/assets/embed.js'
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- duoshuo public js end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/" title="上一篇: Vert.x Blueprint 系列教程(二) | Vert.x Kue 教程（Web部分）">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/" title="下一篇: Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-demystifying-thread-model/">Vert.x 技术内幕 | 解道Vert.x线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-execute-blocking-internal/">Vert.x 技术内幕 | executeBlocking 实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-async-rpc/">Vert.x 技术内幕 | 异步RPC实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-clustered-event-bus-internal/">Vert.x 技术内幕 | Event Bus 源码分析 (集群模式)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-local-event-bus-internal/">Vert.x 技术内幕 | Event Bus 源码分析 (Local模式)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Life/busy-enough-2016-08/">最近真忙～</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务实战</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/">Vert.x Blueprint 系列教程(二) | Vert.x Kue 教程（Web部分）</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Architecture/quorum-based-voting-for-replica-control/">基于Quorum投票机制的Replica Control算法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Microservice/netflix-hystrix-how-it-works-summary/">Netflix Hystrix | 工作流程浅析 && HystrixCircuitBreaker源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Concurrency/concurrency-treiber-stack/">并发编程算法 | Treiber Stack实现lock-free stack</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Architecture/service-with-docker-compose/">使用 Docker Compose 编排容器集群</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/gradle-annotation-processing-vertx-codegen/">在Gradle中使用Annotation Processing Tool | Vert.x Codegen 示例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Microservice/circuit-breaker-pattern/">微服务设计模式 | Circuit Breaker Pattern</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/type-system-existential-types-scala-java/">类型系统 | Existential Type | Scala ++ Java ++ Haskell</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Asynchronous/vertx-instance-internal-and-create/">Vert.x 异步编程 | Vertx实例的创建流程及内部实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/play-framework-2-5-summary-1/">Play Framework 2.5 | Web开发总结(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/type-system-refinement-types/">类型系统 | Refinement Type</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/scala-type-lambda/">Scala | 神奇的Type Lambda</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/akka-actor-sender-enclosing/">Akka Actor | 注意sender的闭包范围</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Miscellaneous/play-music-on-linux/">在Linux环境下玩转MIDI</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/slick-3-type-system-query-prolouge/">探索万恶的Slick 3 类型系统 | Prologue</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/slick-3-summary-functional-relational-mapping/">Slick 3总结 | Functional Relational Mapping</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/play-framework-2-5-dependency-injection-di/">Play Framework 2.5 | Dependency Injection总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/functional-programming-type-and-kind/">FP :: Type Theory | Type, Type Constructor 与 Kind</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-concurrent-threadlocal/">并发编程 | ThreadLocal源码深入分析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-8-completable-future/">并发编程 | JDK 1.8中的CompletableFuture | FRP风格</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/scala-fp-union-curry-howard-isomorphism/">Scala | 利用Curry-Howard Isomorphism实现union type</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/scala-fp-for-expression-detail/">Scala | for表达式的底层转换</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Algorithm/algorithm-quicksort/">快速排序实现及优化 | DualPivotQuicksort</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/network-io-model/">IO模型之阻塞、非阻塞、同步、异步浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-series/">TCP 相关知识总结目录</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-keepalive-heartbeat/">TCP Keepalive && Heartbeat</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-congestion-control/">TCP 拥塞控制</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-retransmission/">TCP Retransmission</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-flow-control/">TCP 流量控制</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/network-basis/">计算机网络相关知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-connection/">TCP连接的建立和终止</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-klass-oop/">深入探究JVM | klass-oop对象模型研究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/inside-cpp-object-model-summary-3/">Inside The C++ Object Model Summary III</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/cpp-stl-functional/">C++ 11 STL | functional 标准库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/cpp-move-semantic/">C++ 11 Move Sementics/Perfect Forwarding</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/inside-cpp-object-model-summary-1/">Inside The C++ Object Model Summary I</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Architecture/amqp-rabbitmq/">消息队列中间件 | RabbitMQ 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/haskell-category-basic/">Haskell学习笔记 | 范畴论与Haskell</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/android-event-dispatcher/">Android事件分发机制总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/android-view-draw-01/">Android View视图绘制总结（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Architecture/android-refactor-mvp/">Android MVP架构重构实践</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/cpp-stl-hashmap/">C++ STL之哈希表 | unordered_map</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/android-performance-1/">对Android应用性能优化的一些总结（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/android-aysnc-message/">Android异步消息处理机制总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Summary/struct_sizeof/">C/C++结构体字节对齐</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-hashcode-equal/">hashCode方法及equals方法的规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-basic-summary-01/">Java基础技术细节总结 - 语言规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/android_summary_2/">安卓开发中的一些总结（2）</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/gdb-simple/">gdb用法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Algorithm/algorithm-cache/">缓存算法（页面置换算法）总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-copyArray/">arrayCopy方法底层探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/os-learning-1/">操作系统相关知识杂谈</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Web/web-frontend-02/">Web开发笔记 - 前端总结 (性能篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Web/web-frontend-01/">Web开发笔记 - 前端总结(开发篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Algorithm/algorithm-linkedlist-cycle-join/">链表相关算法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Web/web-frontend-plan/">Web开发笔记 - 前端总结计划</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Summary/database-transaction-lock/">数据库事务中的隔离级别和锁</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-classloader-parent-delegation-model/">深入探究JVM | 类加载器与双亲委派模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Life/test-migrate/">博客搬迁咯~</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-gc-hotspot-implements/">深入探究JVM | HotSpot JVM的GC实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-gc-method-types/">深入探究JVM | 初探GC算法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-gc-safepoint-condition/">深入探究JVM | Safepoint及GC的触发条件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-reference-type/">Java中的几种引用 | 弱引用、软引用、虚引用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-gc-intro-count-vs-reachability/">深入探究JVM | 初探GC - 引用计数 VS 可达分析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Summary/compiler-a01/">编译原理相关 | C++编译器总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-metaspace/">深入探究JVM | 探秘Metaspace</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-reflection-2/">深入解析Java反射（2） - invoke方法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-reflection-1/">深入解析Java反射（1） - 基础</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-memory/">深入探究JVM | Java的内存区域解析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Architecture/docker-tutorial/">Docker入门学习札记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/game-dev-ue4ce3/">UE4/CE3游戏开发总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/game-dev-unity/">Unity游戏开发总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Life/chemistry-jt-2014/">2014晶体培养 - 硫酸铜单晶</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Life/chemistry-jt-2013/">2013寒假晶体培养 - 硫酸铜单晶</a></li></ul>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2016 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30.
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>