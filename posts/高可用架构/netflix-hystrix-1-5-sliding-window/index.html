<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="sczyh30" />



<meta name="description" content="总览Netflix Hystrix 通过类似滑动窗口的数据结构来统计调用的指标数据。Hystrix 1.5 将滑动窗口设计成了数据流（reactive stream, RxJava 中的 Observable）的形式。通过消费数据流的形式利用滑动窗口，并对数据流进行变换后进行后续的操作，可以让开发者更加灵活地去使用。由于 Hystrix 里大量使用了 RxJava，再加上滑动窗口本质就是不断变换的">
<meta property="og:type" content="article">
<meta property="og:title" content="Hystrix 1.5 滑动窗口实现原理总结">
<meta property="og:url" content="http://www.sczyh30.com/posts/高可用架构/netflix-hystrix-1-5-sliding-window/index.html">
<meta property="og:site_name" content="「浮生若梦」 - sczyh30's blog">
<meta property="og:description" content="总览Netflix Hystrix 通过类似滑动窗口的数据结构来统计调用的指标数据。Hystrix 1.5 将滑动窗口设计成了数据流（reactive stream, RxJava 中的 Observable）的形式。通过消费数据流的形式利用滑动窗口，并对数据流进行变换后进行后续的操作，可以让开发者更加灵活地去使用。由于 Hystrix 里大量使用了 RxJava，再加上滑动窗口本质就是不断变换的">
<meta property="og:image" content="http://www.sczyh30.com/assets/blog-img-k1/Hystrix-BucketedRollingCounterStream-hierarchy.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/publishRefCount.png">
<meta property="og:image" content="https://github.com/Netflix/Hystrix/wiki/images/rolling-stats-640.png">
<meta property="og:image" content="http://www.sczyh30.com/assets/blog-img-k1/hystrix-metrics-event-driven-flow.png">
<meta property="og:updated_time" content="2018-09-23T14:18:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hystrix 1.5 滑动窗口实现原理总结">
<meta name="twitter:description" content="总览Netflix Hystrix 通过类似滑动窗口的数据结构来统计调用的指标数据。Hystrix 1.5 将滑动窗口设计成了数据流（reactive stream, RxJava 中的 Observable）的形式。通过消费数据流的形式利用滑动窗口，并对数据流进行变换后进行后续的操作，可以让开发者更加灵活地去使用。由于 Hystrix 里大量使用了 RxJava，再加上滑动窗口本质就是不断变换的">
<meta name="twitter:image" content="http://www.sczyh30.com/assets/blog-img-k1/Hystrix-BucketedRollingCounterStream-hierarchy.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="「浮生若梦」 - sczyh30&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Hystrix 1.5 滑动窗口实现原理总结 | 「浮生若梦」 - sczyh30&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/assets/blog-default-lambda-avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">sczyh30</a></h1>
        </hgroup>

        
        <p class="header-subtitle">踏歌长行，梦想永在。</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about">About Me</a></li>
                        
                            <li><a href="/en/">Blog(EN)</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMQP/">AMQP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/APT/">APT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Akka/">Akka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-14/">C++ 14</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/">CAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPS/">CPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/">Cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Category-Theory/">Category Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Continuation/">Continuation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DI/">DI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Euterpea/">Euterpea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Loop/">Event Loop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GDB/">GDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game/">Game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Haskell/">Haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC/">JUC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Klass-oop/">Klass-oop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda-Calculus/">Lambda Calculus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIDI/">MIDI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mathematical-Logic/">Mathematical Logic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metaspace/">Metaspace</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netflix-Hystrix/">Netflix Hystrix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-Model/">Object Model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PLT/">PLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Play-Framework/">Play Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quorum/">Quorum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reflection/">Reflection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheme/">Scheme</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slick/">Slick</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sort/">Sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Summary/">Summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Class/">Type Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Lambda/">Type Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-System/">Type System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Type-Theory/">Type Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vert-x/">Vert.x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中间件/">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云服务/">云服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存区域/">内存区域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式系统/">分布式系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式计算/">分布式计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息系统/">消息系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/滑动窗口/">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程安全/">线程安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/限流降级/">限流降级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高可用架构/">高可用架构</a></li></ul>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Distributed System/Deep Learning/PLT</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">sczyh30</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/assets/blog-default-lambda-avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">sczyh30</a></h1>
            </hgroup>
            
            <p class="header-subtitle">踏歌长行，梦想永在。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about">About Me</a></li>
                
                    <li><a href="/en/">Blog(EN)</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/sczyh30" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/sczyh30" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Google" target="_blank" href="https://plus.google.com/u/0/117807083506391735472" title="Google"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/sczyh30" title="Twitter"></a>
                            
                                <a class="fa Medium" target="_blank" href="https://medium.com/@sczyh30" title="Medium"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-netflix-hystrix-1-5-sliding-window" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/高可用架构/netflix-hystrix-1-5-sliding-window/" class="article-date">
      <time datetime="2017-12-03T16:00:00.000Z" itemprop="datePublished">2017-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Hystrix 1.5 滑动窗口实现原理总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/高可用架构/">高可用架构</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netflix-Hystrix/">Netflix Hystrix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/滑动窗口/">滑动窗口</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/限流降级/">限流降级</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高可用架构/">高可用架构</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="总览">总览</h1><p>Netflix Hystrix 通过类似滑动窗口的数据结构来统计调用的指标数据。Hystrix 1.5 将滑动窗口设计成了数据流（reactive stream, RxJava 中的 <code>Observable</code>）的形式。通过消费数据流的形式利用滑动窗口，并对数据流进行变换后进行后续的操作，可以让开发者更加灵活地去使用。由于 Hystrix 里大量使用了 RxJava，再加上滑动窗口本质就是不断变换的数据流，滑动窗口中每个桶的数据都来自于源源不断的事件，因此滑动窗口非常适合用观察者模式和响应式编程思想的 RxJava 实现。使用 RxJava 实现有一大好处：可以通过 RxJava 的一系列操作符来实现滑动窗口，从而可以依赖 RxJava 的线程模型来保证数据写入和聚合的线程安全，将这一系列的机制交给 RxJava。所有的操作都是在 RxJava 的后台线程上进行的，RxJava 会保证操作的有序性和线程安全（参见 <a href="http://reactivex.io/documentation/contract.html" target="_blank" rel="external">The Observable Contract</a>）。</p>
<p>这里我们就以 Hystrix 熔断器依赖的记录调用情况统计的 <code>HealthCountsStream</code> 为例来看一下 Hystrix 1.5 是如何利用 RxJava 将滑动窗口抽象并实现成 reactive stream 的，以及如何去消费对应的数据流。</p>
<p>滑动窗口的实现都位于 <code>com.netflix.hystrix.metric.consumer</code> 包下，这里只挑 <code>BucketedRollingCounterStream</code> 这条线的实现来分析。首先先看一下类的继承结构：</p>
<p><img src="/assets/blog-img-k1/Hystrix-BucketedRollingCounterStream-hierarchy.png" alt="Class hierarchy of BucketedRollingCounterStream"></p>
<p>最顶层的 <code>BucketedCounterStream</code> 抽象类提供了基本的桶计数器实现，按配置的时间间隔将所有事件聚合成桶；<code>BucketedRollingCounterStream</code> 抽象类在其基础上实现滑动窗口，并聚合成指标数据；而最底下一层的类则是各种具体的实现，比如 <code>HealthCountsStream</code> 最终会聚合成健康检查数据（<code>HystrixCommandMetrics.HealthCounts</code>，统计调用成功和失败的计数），供 <code>HystrixCircuitBreaker</code> 使用。</p>
<h1 id="BucketedCounterStream">BucketedCounterStream</h1><h2 id="总览-1">总览</h2><p><code>BucketedCounterStream</code> 抽象类提供了基本的桶计数器实现。用户在使用 Hystrix 的时候一般都要配两个值：<code>timeInMilliseconds</code> 和 <code>numBuckets</code>，前者代表滑动窗口的长度（时间间隔），后者代表滑动窗口中桶的个数，那么每个桶对应的窗口长度就是 <code>bucketSizeInMs = timeInMilliseconds / numBuckets</code>（记为一个单元窗口周期）。<code>BucketedCounterStream</code> 每隔一个单元窗口周期（<code>bucketSizeInMs</code>）就把这段时间内的所有调用事件聚合到一个桶内。我们来看一下它的实现，首先来看一下它的泛型定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketedCounterStream</span>&lt;<span class="title">Event</span> <span class="keyword">extends</span> <span class="title">HystrixEvent</span>, <span class="title">Bucket</span>, <span class="title">Output</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>BucketedCounterStream</code> 的泛型里接受三个类型参数，其中第一个 <code>Event</code> 类型代表 Hystrix 中的调用事件，如命令开始执行、命令执行完成等。这种事件驱动的设计也非常符合 RxJava 的思想，每个调用者都向订阅者发布事件，订阅者将事件聚合成调用指标；第二个 <code>Bucket</code> 类型代表桶的类型，第三个 <code>Output</code> 类型代表数据聚合的最终输出类型。</p>
<p><code>BucketedCounterStream</code> 核心代码在构造函数里（为了可读性起见，将所有可以用 lambda expression 的地方都转换成了 lambda expression，下同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> numBuckets;</div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Observable&lt;Bucket&gt; bucketedStream;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Func1&lt;Observable&lt;Event&gt;, Observable&lt;Bucket&gt;&gt; reduceBucketToSummary;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BucketedCounterStream</span><span class="params">(<span class="keyword">final</span> HystrixEventStream&lt;Event&gt; inputEventStream, <span class="keyword">final</span> <span class="keyword">int</span> numBuckets, <span class="keyword">final</span> <span class="keyword">int</span> bucketSizeInMs,</span></span></div><div class="line">                                <span class="keyword">final</span> Func2&lt;Bucket, Event, Bucket&gt; appendRawEventToBucket) &#123;</div><div class="line">    <span class="keyword">this</span>.numBuckets = numBuckets;</div><div class="line">    <span class="keyword">this</span>.reduceBucketToSummary = eventBucket -&gt; eventBucket.reduce(getEmptyBucketSummary(), appendRawEventToBucket);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> List&lt;Bucket&gt; emptyEventCountsToStart = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numBuckets; i++) &#123;</div><div class="line">        emptyEventCountsToStart.add(getEmptyBucketSummary());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.bucketedStream = Observable.defer(() -&gt; &#123;</div><div class="line">        <span class="keyword">return</span> inputEventStream</div><div class="line">                .observe()</div><div class="line">                .window(bucketSizeInMs, TimeUnit.MILLISECONDS) <span class="comment">//bucket it by the counter window so we can emit to the next operator in time chunks, not on every OnNext</span></div><div class="line">                .flatMap(reduceBucketToSummary)                <span class="comment">//for a given bucket, turn it into a long array containing counts of event types</span></div><div class="line">                .startWith(emptyEventCountsToStart);           <span class="comment">//start it with empty arrays to make consumer logic as generic as possible (windows are always full)</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>bucketedStream</code> 即为本次得到的数据流（类型为 RxJava 中的 <code>Observable</code>，即观察者模式中的 Publisher，会源源不断地产生事件/数据），里面最核心的逻辑就是如何将一个一个的事件按一段时间聚合成一个桶。我们可以看到 <code>bucketedStream</code> 是经事件源 <code>inputEventStream</code> 变换而成的，事件源的类型为 <code>HystrixEventStream&lt;Event&gt;</code>，它代表事件流接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HystrixEventStream</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">HystrixEvent</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Observable&lt;E&gt; <span class="title">observe</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>observe</code> 方法返回这个事件流对应的发布者 <code>Observable</code>，订阅者可以对事件进行变换并消费。</p>
<h2 id="事件流的写入">事件流的写入</h2><p>Hystrix 中执行函数以命令模式封装成了一个一个命令（<code>Command</code>），每个命令执行时都会触发某个事件，其中命令执行完成事件（<code>HystrixCommandCompletion</code>）是 Hystrix 中最核心的事件，它可以代表某个命令执行成功、超时、异常等等的各种的状态，与服务调用的熔断息息相关。熔断器的计数依赖于 <code>HystrixCommandCompletion</code> 事件，因此这里我们只关注这个事件对应的事件流，其余类型的事件流原理类似。</p>
<p>那么这个事件流中的事件是从哪里发布的呢？我们来看一下相关的具体实现 - <code>HystrixCommandCompletionStream</code>（仅核心代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCommandCompletionStream</span> <span class="keyword">implements</span> <span class="title">HystrixEventStream</span>&lt;<span class="title">HystrixCommandCompletion</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCommandKey commandKey;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;HystrixCommandCompletion, HystrixCommandCompletion&gt; writeOnlySubject;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observable&lt;HystrixCommandCompletion&gt; readOnlyStream;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, HystrixCommandCompletionStream&gt; streams = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HystrixCommandCompletionStream&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixCommandCompletionStream <span class="title">getInstance</span><span class="params">(HystrixCommandKey commandKey)</span> </span>&#123;</div><div class="line">        <span class="comment">// 此段代码略，大致逻辑为：若对应的 CommandKey 的事件流已创建就从缓存中取出，否则就新创建并缓存起来，保证每个 CommandKey 只有一个实例</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    HystrixCommandCompletionStream(<span class="keyword">final</span> HystrixCommandKey commandKey) &#123;</div><div class="line">        <span class="keyword">this</span>.commandKey = commandKey;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.writeOnlySubject = <span class="keyword">new</span> SerializedSubject&lt;HystrixCommandCompletion, HystrixCommandCompletion&gt;(PublishSubject.&lt;HystrixCommandCompletion&gt;create());</div><div class="line">        <span class="keyword">this</span>.readOnlyStream = writeOnlySubject.share();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">        streams.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(HystrixCommandCompletion event)</span> </span>&#123;</div><div class="line">        writeOnlySubject.onNext(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;HystrixCommandCompletion&gt; <span class="title">observe</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> readOnlyStream;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码里我们可以看到 <code>write</code> 方法里通过向某个 <code>Subject</code> 发布事件来实现了发布的逻辑，那么 <code>Subject</code> 又是什么呢？简单来说，<a href="http://reactivex.io/documentation/subject.html" target="_blank" rel="external"><code>Subject</code></a> 就像是一个桥梁，既可以作为发布者 <code>Observable</code>，又可以作为订阅者 <code>Observer</code>。它可以作为发布者和订阅者之间的一个“代理”，提供额外的功能（如流量控制、缓存等）。这里的 <code>writeOnlySubject</code> 是经过 <code>SerializedSubject</code> 封装的 <code>PublishSubject</code>。<code>PublishSubject</code> 可以看做 hot observable。为了保证调用的顺序（根据 <a href="http://reactivex.io/documentation/contract.html" target="_blank" rel="external">The Observable Contract</a>，每个事件的产生需要满足顺序上的偏序关系，即使是在不同线程产生），需要用 <code>SerializedSubject</code> 封装一层来保证事件真正地串行地产生。这里还有一个问题，就是不同的发布者调用 <code>write</code> 方法发布事件时，线程上下文可能都不同，那么如何保证其线程安全呢？Hystrix 1.5 通过使用 ThreadLocal 来保证每个线程都有一份 <code>Subject</code> 的实例，确保事件发布的线程安全。相关代码位于 <code>HystrixThreadEventStream</code> 内（已略去其它事件的代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixThreadEventStream</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> threadId;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String threadName;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;HystrixCommandExecutionStarted, HystrixCommandExecutionStarted&gt; writeOnlyCommandStartSubject;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;HystrixCommandCompletion, HystrixCommandCompletion&gt; writeOnlyCommandCompletionSubject;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;HystrixCollapserEvent, HystrixCollapserEvent&gt; writeOnlyCollapserSubject;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;HystrixThreadEventStream&gt; threadLocalStreams = <span class="keyword">new</span> ThreadLocal&lt;HystrixThreadEventStream&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> HystrixThreadEventStream <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HystrixThreadEventStream(Thread.currentThread());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Action1&lt;HystrixCommandCompletion&gt; writeCommandCompletionsToShardedStreams = commandCompletion -&gt; &#123;</div><div class="line">        HystrixCommandCompletionStream commandStream = HystrixCommandCompletionStream.getInstance(commandCompletion.getCommandKey());</div><div class="line">        commandStream.write(commandCompletion);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (commandCompletion.isExecutedInThread() || commandCompletion.isResponseThreadPoolRejected()) &#123;</div><div class="line">            HystrixThreadPoolCompletionStream threadPoolStream = HystrixThreadPoolCompletionStream.getInstance(commandCompletion.getThreadPoolKey());</div><div class="line">            threadPoolStream.write(commandCompletion);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/* package */</span> HystrixThreadEventStream(Thread thread) &#123;</div><div class="line">        <span class="keyword">this</span>.threadId = thread.getId();</div><div class="line">        <span class="keyword">this</span>.threadName = thread.getName();</div><div class="line">        writeOnlyCommandCompletionSubject = PublishSubject.create();</div><div class="line"></div><div class="line">        writeOnlyCommandCompletionSubject</div><div class="line">                .onBackpressureBuffer()</div><div class="line">                .doOnNext(writeCommandCompletionsToShardedStreams)</div><div class="line">                .unsafeSubscribe(Subscribers.empty());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixThreadEventStream <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> threadLocalStreams.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        writeOnlyCommandStartSubject.onCompleted();</div><div class="line">        writeOnlyCommandCompletionSubject.onCompleted();</div><div class="line">        writeOnlyCollapserSubject.onCompleted();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 执行完毕/异常/超时都会调用此方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executionDone</span><span class="params">(ExecutionResult executionResult, HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey)</span> </span>&#123;</div><div class="line">        HystrixCommandCompletion event = HystrixCommandCompletion.from(executionResult, commandKey, threadPoolKey);</div><div class="line">        writeOnlyCommandCompletionSubject.onNext(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 Hystrix 通过 ThreadLocal 为每个不同的线程都创建了不同的 <code>HystrixThreadEventStream</code>，里面的 <code>Subject</code> 都是 write-only, thread-safe 的。Hystrix 在这里额外加了一层 <code>writeOnlyCommandCompletionSubject</code>，提供额外的流量控制机制（<code>onBackpressureBuffer</code>），消费者太慢时这里会积压。其中会调用 <code>HystrixCommandCompletionStream</code> 的 <code>write</code> 方法产生对应的事件。</p>
<p><code>executionDone</code> 方法最后会经 <code>HystrixCommandMetrics</code> 类的 <code>markCommandDone</code> 方法进行调用。<code>HystrixCommandMetrics</code> 是 Hystrix 中另一个重要的类，从中可以获取各种指标数据的流的实例。最后 Hystrix 会在对应命令执行完毕后，调用 <code>markCommandDone</code> 进行数据记录，并发布对应的事件。相关代码位于 <a href="https://github.com/Netflix/Hystrix/blob/master/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L947" target="_blank" rel="external"><code>AbstractCommand</code></a> 类内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCommandEnd</span><span class="params">(<span class="keyword">boolean</span> commandExecutionStarted)</span> </span>&#123;</div><div class="line">    Reference&lt;TimerListener&gt; tl = timeoutTimer.get();</div><div class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span>) &#123;</div><div class="line">        tl.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> userThreadLatency = System.currentTimeMillis() - commandStartTimestamp;</div><div class="line">    executionResult = executionResult.markUserThreadCompletion((<span class="keyword">int</span>) userThreadLatency);</div><div class="line">    <span class="keyword">if</span> (executionResultAtTimeOfCancellation == <span class="keyword">null</span>) &#123;</div><div class="line">        metrics.markCommandDone(executionResult, commandKey, threadPoolKey, commandExecutionStarted);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        metrics.markCommandDone(executionResultAtTimeOfCancellation, commandKey, threadPoolKey, commandExecutionStarted);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (endCurrentThreadExecutingCommand != <span class="keyword">null</span>) &#123;</div><div class="line">        endCurrentThreadExecutingCommand.call();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AbstractCommand</code> 类是 Hystrix 命令模式执行模型的实现，整合了资源隔离、熔断器等各种高可用机制，是整个 Hystrix 的核心。</p>
<h2 id="共享的事件流">共享的事件流</h2><p>上面我们探究了事件流的发布原理，以及如何保证写的线程安全。那么事件流写入到 <code>writeOnlySubject</code> 以后，如何被订阅者消费呢？如何保证多个订阅者都可以对事件流进行消费，并且序列一致呢？我们回到之前的 <code>observe</code> 方法，<code>observe</code> 方法返回的是一个 <code>readOnlyStream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Observable&lt;HystrixCommandCompletion&gt; <span class="title">observe</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> readOnlyStream;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>readOnlyStream</code> 是 <code>writeOnlySubject</code> 的只读版本，它是通过 <code>share</code> 操作符产生的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.readOnlyStream = writeOnlySubject.share();</div></pre></td></tr></table></figure>
<p>Hystrix 通过 RxJava 的 <a href="http://reactivex.io/documentation/operators/refcount.html" target="_blank" rel="external"><code>share</code></a> 操作符产生一种特殊的 <code>Observable</code>：当有一个订阅者去消费事件流时它就开始产生事件，可以有多个订阅者去订阅，同一时刻收到的事件是一致的；直到最后一个订阅者取消订阅以后，事件流才停止产生事件。其底层实现非常有意思：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">share</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> publish().refCount();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在执行 <code>publish</code> 的时候，<code>Observable</code> 会被变换成为一个 <code>ConnectableObservable</code>。这种 <code>ConnectableObservable</code> 只会在进行连接操作（<code>connect</code>）以后才会产生数据（连接后行为类似于 hot observable）。而 <code>share</code> 操作底层的 <code>refCount</code> 操作符就帮我们做了这样的操作：<code>refCount</code> 底层维护着一个引用计数器，代表绑定的订阅者数目。当第一个订阅者去消费事件流的时候，引用计数大于 0，<code>refCount</code> 底层会自动进行 <code>connect</code>，从而触发事件流产生事件；当最后一个订阅者取消订阅以后，引用计数归零，<code>refCount</code> 底层就会自动进行 <code>disconnect</code>，事件流停止产生事件。也就是说，这样的一个可以被多个订阅者共享的事件流，底层是基于引用计数法来管理事件的产生的，和智能指针的思想类似。</p>
<p><img src="http://reactivex.io/documentation/operators/images/publishRefCount.png" alt="Reactive stream of refCount"></p>
<h2 id="事件流聚合为桶">事件流聚合为桶</h2><p>上面我们研究完了事件流是如何产生的，接下来就回归到事件流聚合为桶的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.bucketedStream = Observable.defer(() -&gt; &#123; <span class="comment">// defer 的意思是 lazy 创建</span></div><div class="line">    <span class="keyword">return</span> inputEventStream</div><div class="line">            .observe()</div><div class="line">            .window(bucketSizeInMs, TimeUnit.MILLISECONDS) <span class="comment">// 按单元窗口长度来将某个时间段内的调用事件聚集起来</span></div><div class="line">            .flatMap(reduceBucketToSummary)                <span class="comment">// 将每个单元窗口内聚集起来的事件集合聚合成桶</span></div><div class="line">            .startWith(emptyEventCountsToStart);           <span class="comment">// 为了保证窗口的完整性，开始的时候先产生一串空的桶</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其中的核心是 <a href="http://reactivex.io/documentation/operators/window.html" target="_blank" rel="external"><code>window</code></a> 操作符，它可以按单元窗口长度来将某个时间段内的调用事件聚集起来，此时数据流里每个对象都是一个集合：<code>Observable&lt;Event&gt;</code>，所以需要将其聚集成桶类型以将其扁平化。Hystrix 通过 RxJava 的 <code>reduce</code> 操作符进行“归纳”操作，将一串事件归纳成一个桶：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.reduceBucketToSummary = eventBucket -&gt; eventBucket.reduce(getEmptyBucketSummary(), appendRawEventToBucket);</div></pre></td></tr></table></figure>
<p>其中我们需要提供桶的初值（即空桶），并要提供聚合函数来进行聚合，类型为 <code>Bucket -&gt; Event -&gt; Bucket</code>（代表对于每个 <code>Event</code>，都将其聚合到 <code>Bucket</code> 中，并返回聚合后的 <code>Bucket</code>）。不同的实现对应的 <code>Bucket</code> 和规约函数不同，比如熔断器依赖的 <code>HealthCountsStream</code> 就以 <code>long[]</code> 来作为每个桶。</p>
<blockquote>
<p>注：此处的 <code>window(timespan, unit)</code> 操作符属于计算型操作符，默认会在 <code>Schedulers.computation()</code> 调度器下执行（CPU 密集型），其底层本质是线程数为 CPU 核数的线程池。RxJava 会确保其线程安全。</p>
</blockquote>
<h1 id="BucketedRollingCounterStream">BucketedRollingCounterStream</h1><p><code>BucketedRollingCounterStream</code> 按照滑动窗口的大小对每个单元窗口产生的桶进行聚合，这也是 Hystrix 1.5 中滑动窗口的抽象实现。其核心实现仍然位于构造函数内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketedRollingCounterStream</span>&lt;<span class="title">Event</span> <span class="keyword">extends</span> <span class="title">HystrixEvent</span>, <span class="title">Bucket</span>, <span class="title">Output</span>&gt; <span class="keyword">extends</span> <span class="title">BucketedCounterStream</span>&lt;<span class="title">Event</span>, <span class="title">Bucket</span>, <span class="title">Output</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> Observable&lt;Output&gt; sourceStream;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isSourceCurrentlySubscribed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BucketedRollingCounterStream</span><span class="params">(HystrixEventStream&lt;Event&gt; stream, <span class="keyword">final</span> <span class="keyword">int</span> numBuckets, <span class="keyword">int</span> bucketSizeInMs,</span></span></div><div class="line">                                           <span class="keyword">final</span> Func2&lt;Bucket, Event, Bucket&gt; appendRawEventToBucket,</div><div class="line">                                           <span class="keyword">final</span> Func2&lt;Output, Bucket, Output&gt; reduceBucket) &#123;</div><div class="line">        <span class="keyword">super</span>(stream, numBuckets, bucketSizeInMs, appendRawEventToBucket);</div><div class="line">        Func1&lt;Observable&lt;Bucket&gt;, Observable&lt;Output&gt;&gt; reduceWindowToSummary = window -&gt; window.scan(getEmptyOutputValue(), reduceBucket).skip(numBuckets);</div><div class="line">        <span class="keyword">this</span>.sourceStream = bucketedStream      <span class="comment">// 数据流，每个对象代表单元窗口产生的桶</span></div><div class="line">                .window(numBuckets, <span class="number">1</span>)          <span class="comment">// 按照滑动窗口桶的个数进行桶的聚集</span></div><div class="line">                .flatMap(reduceWindowToSummary) <span class="comment">// 将一系列的桶聚集成最后的数据对象</span></div><div class="line">                .doOnSubscribe(() -&gt; isSourceCurrentlySubscribed.set(<span class="keyword">true</span>))</div><div class="line">                .doOnUnsubscribe(() -&gt; isSourceCurrentlySubscribed.set(<span class="keyword">false</span>))</div><div class="line">                .share()                        <span class="comment">// 不同的订阅者看到的数据是一致的</span></div><div class="line">                .onBackpressureDrop();          <span class="comment">// 流量控制，当消费者消费速度过慢时就丢弃数据，不进行积压</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;Output&gt; <span class="title">observe</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sourceStream;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* package-private */</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isSourceCurrentlySubscribed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isSourceCurrentlySubscribed.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造函数后两个参数参数分别代表两个函数：将事件流聚合成桶的函数（<code>appendRawEventToBucket</code>） 以及 将桶聚合成输出对象的函数（<code>reduceBucket</code>）。</p>
<p>我们看到 <code>BucketedRollingCounterStream</code> 实现了 <code>observe</code> 方法，返回了一个 <code>Observable&lt;Output&gt;</code> 类型的发布者 <code>sourceStream</code>，供订阅者去消费。这里的 <code>sourceStream</code> 应该就是滑动窗口的终极形态了，那么它是如何变换得到的呢？这里面的核心还是 <code>window</code> 和 <code>flatMap</code> 算子。这里的 <code>window</code> 算子和之前的版本不同，它可以将数据流中的一定数量的数据聚集成一个集合，它的第二个参数 <code>skip=1</code> 的意思就是按照步长为 1 在数据流中滑动，不断聚集对象，这即为滑动窗口的真正实现。到这里每个窗口都已经形成了，下一步就是要对窗口进行聚合了。注意这里聚合操作没有用 <code>reduce</code>，而是用了 <code>scan</code> + <code>skip(numBuckets)</code> 的组合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Func1&lt;Observable&lt;Bucket&gt;, Observable&lt;Output&gt;&gt; reduceWindowToSummary = window -&gt; window.scan(getEmptyOutputValue(), reduceBucket).skip(numBuckets);</div></pre></td></tr></table></figure>
<p>这里每个集合的大小都是 <code>numBuckets</code>，看起来用 <code>reduce</code> 和 <code>scan</code> + <code>skip(numBuckets)</code> 没有什么区别，但是注意当数据流终结时，最后面的窗口大小都不满 <code>numBuckets</code>，这时候就需要把这些不完整的窗口给过滤掉来确保数据不缺失。这个地方也是开发的时候容易忽略的地方，很值得思考。</p>
<p>聚合完毕以后，基本的滑动窗口数据就OK了，为了支持多订阅者，还要进行 <code>share</code>；并且利用 <code>onBackpressureDrop</code> 操作符实现流量控制，此处当消费者跟不上的时候就直接丢掉数据，不进行积压。</p>
<p><img src="https://github.com/Netflix/Hystrix/wiki/images/rolling-stats-640.png" alt="Rolling status"></p>
<h1 id="HealthCountsStream">HealthCountsStream</h1><p>前面滑动窗口的抽象实现都已经分析完了，现在我们就来看一下其中的一个具体实现 - <code>HealthCountsStream</code>，它提供实时的健康检查数据（<code>HystrixCommandMetrics.HealthCounts</code>，统计调用成功和失败的计数）。</p>
<p>之前我们提到 <code>BucketedRollingCounterStream</code> 里面有三个类型参数和两个重要函数参数。<code>HealthCountsStream</code> 对应的三个类型参数分别为：</p>
<ul>
<li><code>Event</code>: <code>HystrixCommandCompletion</code>，代表命令执行完成。可以从中获取执行结果，并从中提取所有产生的事件（<code>HystrixEventType</code>）</li>
<li><code>Bucket</code>: 桶的类型为 <code>long[]</code>，里面统计了各种事件的个数。其中 index 为事件类型枚举对应的索引（<code>ordinal</code>），值为对应事件的个数</li>
<li><code>Output</code>: <code>HystrixCommandMetrics.HealthCounts</code>，里面统计了总的执行次数、失败次数以及失败百分比，供熔断器使用</li>
</ul>
<p>滑动窗口里用于将事件聚合成桶的函数实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Func2&lt;<span class="keyword">long</span>[], HystrixCommandCompletion, <span class="keyword">long</span>[]&gt; appendEventToBucket = (initialCountArray, execution) -&gt; &#123;</div><div class="line">    ExecutionResult.EventCounts eventCounts = execution.getEventCounts();</div><div class="line">    <span class="keyword">for</span> (HystrixEventType eventType: ALL_EVENT_TYPES) &#123;</div><div class="line">        <span class="keyword">switch</span> (eventType) &#123;</div><div class="line">            <span class="keyword">case</span> EXCEPTION_THROWN: <span class="keyword">break</span>; <span class="comment">//this is just a sum of other anyway - don't do the work here</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                initialCountArray[eventType.ordinal()] += eventCounts.getCount(eventType);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> initialCountArray;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>滑动窗口里用于将每个窗口聚合成最终的统计数据的的函数实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Func2&lt;HystrixCommandMetrics.HealthCounts, <span class="keyword">long</span>[], HystrixCommandMetrics.HealthCounts&gt; healthCheckAccumulator = HystrixCommandMetrics.HealthCounts::plus;</div><div class="line"></div><div class="line"><span class="comment">// 具体的实现，位于 HystrixCommandMetrics.HealthCounts 类内</span></div><div class="line"><span class="function"><span class="keyword">public</span> HealthCounts <span class="title">plus</span><span class="params">(<span class="keyword">long</span>[] eventTypeCounts)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> updatedTotalCount = totalCount; <span class="comment">// 之前的请求总数</span></div><div class="line">    <span class="keyword">long</span> updatedErrorCount = errorCount; <span class="comment">// 之前的失败个数</span></div><div class="line"></div><div class="line">    <span class="keyword">long</span> successCount = eventTypeCounts[HystrixEventType.SUCCESS.ordinal()];</div><div class="line">    <span class="keyword">long</span> failureCount = eventTypeCounts[HystrixEventType.FAILURE.ordinal()];</div><div class="line">    <span class="keyword">long</span> timeoutCount = eventTypeCounts[HystrixEventType.TIMEOUT.ordinal()];</div><div class="line">    <span class="keyword">long</span> threadPoolRejectedCount = eventTypeCounts[HystrixEventType.THREAD_POOL_REJECTED.ordinal()];</div><div class="line">    <span class="keyword">long</span> semaphoreRejectedCount = eventTypeCounts[HystrixEventType.SEMAPHORE_REJECTED.ordinal()];</div><div class="line"></div><div class="line">    <span class="comment">// 加上所有事件的总数</span></div><div class="line">    updatedTotalCount += (successCount + failureCount + timeoutCount + threadPoolRejectedCount + semaphoreRejectedCount);</div><div class="line">    <span class="comment">// 加上失败事件的总数（包括请求失败、超时、线程池满、信号量满）</span></div><div class="line">    updatedErrorCount += (failureCount + timeoutCount + threadPoolRejectedCount + semaphoreRejectedCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HealthCounts(updatedTotalCount, updatedErrorCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hystrix 熔断器里会实时地去消费每个窗口产生的健康统计数据，并根据指标来决定熔断器的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="class"><span class="keyword">class</span> <span class="title">HystrixCircuitBreakerImpl</span> <span class="keyword">implements</span> <span class="title">HystrixCircuitBreaker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCommandProperties properties;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCommandMetrics metrics;</div><div class="line"></div><div class="line">    <span class="keyword">enum</span> Status &#123;</div><div class="line">        CLOSED, OPEN, HALF_OPEN;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Status&gt; status = <span class="keyword">new</span> AtomicReference&lt;Status&gt;(Status.CLOSED);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong circuitOpened = <span class="keyword">new</span> AtomicLong(-<span class="number">1</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Subscription&gt; activeSubscription = <span class="keyword">new</span> AtomicReference&lt;Subscription&gt;(<span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HystrixCircuitBreakerImpl</span><span class="params">(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, <span class="keyword">final</span> HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.properties = properties;</div><div class="line">        <span class="keyword">this</span>.metrics = metrics;</div><div class="line"></div><div class="line">        <span class="comment">//On a timer, this will set the circuit between OPEN/CLOSED as command executions occur</span></div><div class="line">        Subscription s = subscribeToStream();</div><div class="line">        activeSubscription.set(s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Subscription <span class="title">subscribeToStream</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This stream will recalculate the OPEN/CLOSED status on every onNext from the health stream</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> metrics.getHealthCountsStream()</div><div class="line">                .observe()</div><div class="line">                .subscribe(<span class="keyword">new</span> Subscriber&lt;HealthCounts&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(HealthCounts hc)</span> </span>&#123;</div><div class="line">                        <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></div><div class="line">                        <span class="keyword">if</span> (hc.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</div><div class="line">                            <span class="comment">// we are not past the minimum volume threshold for the stat window,</span></div><div class="line">                            <span class="comment">// so no change to circuit status.</span></div><div class="line">                            <span class="comment">// if it was CLOSED, it stays CLOSED</span></div><div class="line">                            <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></div><div class="line">                            <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hc.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</div><div class="line">                                <span class="comment">//we are not past the minimum error threshold for the stat window,</span></div><div class="line">                                <span class="comment">// so no change to circuit status.</span></div><div class="line">                                <span class="comment">// if it was CLOSED, it stays CLOSED</span></div><div class="line">                                <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></div><div class="line">                                <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                <span class="comment">// our failure rate is too high, we need to set the state to OPEN</span></div><div class="line">                                <span class="keyword">if</span> (status.compareAndSet(Status.CLOSED, Status.OPEN)) &#123;</div><div class="line">                                    circuitOpened.set(System.currentTimeMillis());</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结">总结</h1><p>Hystrix 1.5 使用 RxJava 1.x 来实现滑动窗口，将滑动窗口抽象成响应式数据流的形式，既适合 Hystrix 事件驱动的特点，又易于实现和使用。滑动窗口的实现的要点就是每个桶的聚合以及滑动窗口的形成，Hystrix 巧妙地运用了 RxJava 中的 <a href="http://reactivex.io/documentation/operators/window.html" target="_blank" rel="external"><code>window</code></a> 操作符来将单位窗口时间内的事件，以及将一个窗口大小内的桶聚集到一起，并通过 <a href="http://reactivex.io/documentation/operators/reduce.html" target="_blank" rel="external"><code>reduce</code></a> 等折叠操作将事件集合聚集为桶，将滑动窗口内的桶聚集成指标数据，非常巧妙。同时，Hystrix 利用 ThreadLocal<subject> 作为一个线程安全的“代理”，可以确保多个发布者写的线程安全；通过 RxJava 的 <a href="http://reactivex.io/documentation/operators/refcount.html" target="_blank" rel="external"><code>share</code></a> 操作符可以确保多个订阅者从某个共享的 Observable 中观察的序列一致。</subject></p>
<p>最后用一张图来总结 Hystrix Metrics 事件驱动的流程：</p>
<p><img src="/assets/blog-img-k1/hystrix-metrics-event-driven-flow.png" alt="Event driven flow of Hystrix"></p>
<hr>
<h1 id="References">References</h1><ul>
<li><a href="https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring" target="_blank" rel="external">Metrics and Monitoring - Hystrix Wiki</a></li>
<li><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" target="_blank" rel="external">How it Works - Hystrix Wiki</a></li>
<li><a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">ReactiveX Operators</a></li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/posts/高可用架构/netflix-hystrix-1-5-sliding-window/">Hystrix 1.5 滑动窗口实现原理总结</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">sczyh30</a></p>
        <p><span>发布时间:</span>2017年12月04日</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/posts/高可用架构/netflix-hystrix-1-5-sliding-window/" title="Hystrix 1.5 滑动窗口实现原理总结">http://www.sczyh30.com/posts/高可用架构/netflix-hystrix-1-5-sliding-window/</a>
            <span class="copy-path" data-clipboard-text="原文: http://www.sczyh30.com/posts/高可用架构/netflix-hystrix-1-5-sliding-window/　　作者: sczyh30" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"知识共享-保持署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/posts/Functional-Programming/call-with-current-continuation/">
                    call/cc 总结 | Scheme
                </a>
            </div>
        
    </nav>


  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#总览"><span class="toc-number">1.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BucketedCounterStream"><span class="toc-number">2.</span> <span class="toc-text">BucketedCounterStream</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#总览-1"><span class="toc-number">2.1.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件流的写入"><span class="toc-number">2.2.</span> <span class="toc-text">事件流的写入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享的事件流"><span class="toc-number">2.3.</span> <span class="toc-text">共享的事件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件流聚合为桶"><span class="toc-number">2.4.</span> <span class="toc-text">事件流聚合为桶</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BucketedRollingCounterStream"><span class="toc-number">3.</span> <span class="toc-text">BucketedRollingCounterStream</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HealthCountsStream"><span class="toc-number">4.</span> <span class="toc-text">HealthCountsStream</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">6.</span> <span class="toc-text">References</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Hystrix 1.5 滑动窗口实现原理总结　| 「浮生若梦」 - sczyh30's blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://www.sczyh30.com/posts/高可用架构/netflix-hystrix-1-5-sliding-window/';
            this.page.identifier = 'posts/高可用架构/netflix-hystrix-1-5-sliding-window/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//sczyh30.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/posts/Functional-Programming/call-with-current-continuation/" title="下一篇: call/cc 总结 | Scheme">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/高可用架构/netflix-hystrix-1-5-sliding-window/">Hystrix 1.5 滑动窗口实现原理总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/call-with-current-continuation/">call/cc 总结 | Scheme</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Distributed-System/distributed-computing-system-gc-osdi16-yak/">分布式计算系统中的 GC 问题 | Yak (OSDI 2016) 学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Distributed-System/spark-rdd-paper-summary/">Distributed System | Spark RDD 论文总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-demystifying-thread-model/">Vert.x 技术内幕 | 解道 Vert.x 线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-execute-blocking-internal/">Vert.x 技术内幕 | executeBlocking 实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-async-rpc/">Vert.x 技术内幕 | 异步 RPC 实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Distributed-System/distributed-system-rpc-design/">Distributed System | RPC 模块设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-clustered-event-bus-internal/">Vert.x 技术内幕 | Event Bus 源码分析 (集群模式)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Vert-x/vertx-advanced-local-event-bus-internal/">Vert.x 技术内幕 | Event Bus 源码分析 (Local模式)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Life/busy-enough-2016-08/">最近真忙～</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Asynchronous/vertx-blueprint-3-micro-shop-microservice/">Vert.x Blueprint 系列教程(三) | Micro Shop 微服务实战</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-http-tutorial/">Vert.x Blueprint 系列教程(二) | Vert.x Kue 教程（Web部分）</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Asynchronous/vertx-blueprint-2-vertx-kue-core-tutorial/">Vert.x Blueprint 系列教程(二) | 开发基于消息的应用 - Vert.x Kue 教程（Core部分）</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Asynchronous/vertx-blueprint-1-todo-backend-tutorial/">Vert.x Blueprint 系列教程(一) | 待办事项服务开发教程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Architecture/quorum-based-voting-for-replica-control/">基于 Quorum 投票机制的 Replica Control 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Microservice/netflix-hystrix-how-it-works-summary/">Netflix Hystrix | 工作流程浅析 && HystrixCircuitBreaker 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Concurrency/concurrency-treiber-stack/">并发编程算法 | Treiber Stack 实现 lock-free stack</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Distributed-System/distributed-system-base/">分布式系统基础总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Architecture/service-with-docker-compose/">使用 Docker Compose 编排容器集群</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/gradle-annotation-processing-vertx-codegen/">在 Gradle 中使用 Annotation Processing Tool | Vert.x Codegen 示例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Microservice/circuit-breaker-pattern/">微服务设计模式 | Circuit Breaker Pattern</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/type-system-existential-types-scala-java/">类型系统 | Existential Type | Scala ++ Java ++ Haskell</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/type-system-refinement-types/">类型系统 | Refinement Type</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/play-framework-2-5-web-summary/">Play Framework 2.5 | Web 开发总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/scala-type-lambda/">Scala | Type Lambda</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/akka-actor-sender-enclosing/">Akka Actor | 注意 sender 的闭包范围</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Miscellaneous/play-music-on-linux/">在 Linux 环境下玩转 MIDI</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/slick-3-type-system-query-prolouge/">探索万恶的 Slick 3 类型系统 | Prologue</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/slick-3-summary-functional-relational-mapping/">Slick 3 总结 | Functional Relational Mapping</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/play-framework-2-5-dependency-injection-di/">Play Framework 2.5 | Dependency Injection 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/functional-programming-type-and-kind/">FP :: Type Theory | Type, Type Constructor 与 Kind</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/typeclass-scala-haskell/">Scala | Haskell | Type Class总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-concurrent-threadlocal/">并发编程 | ThreadLocal 源码深入分析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-8-completable-future/">并发编程 | JDK 1.8 中的 CompletableFuture | FRP风格</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/scala-fp-union-curry-howard-isomorphism/">Scala | 利用 Curry-Howard Isomorphism 实现 union type</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Scala/scala-for-comprehensions-detail/">Scala | for-comprehension 底层转换 | withFilter 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Algorithm/algorithm-quicksort/">快速排序实现及优化 | DualPivotQuicksort</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/network-io-model/">POSIX I/O 模型之阻塞、非阻塞、同步、异步浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-series/">TCP 相关知识总结目录</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-keepalive-heartbeat/">TCP Keepalive && Heartbeat</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-congestion-control/">TCP 拥塞控制</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-retransmission/">TCP Retransmission</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-flow-control/">TCP 流量控制</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/network-basis/">计算机网络相关知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Network/tcp-connection/">TCP 连接的建立和终止</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-klass-oop/">深入探究 JVM | klass-oop对象模型研究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/inside-cpp-object-model-summary-3/">Inside The C++ Object Model 学习笔记(III)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/cpp-stl-functional/">C++ 11 STL | functional 标准库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/cpp-move-semantic/">Modern C++ | 移动语义与完美转发 | Universal Reference</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/inside-cpp-object-model-summary-1/">Inside The C++ Object Model 学习笔记(I)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Architecture/rabbitmq-summary/">消息队列中间件 | RabbitMQ 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/y-combinator/">不动点组合子 | Y Combinator</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Functional-Programming/haskell-category-basic/">Haskell 学习笔记 | 范畴论与 Haskell（基础篇）</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Android/android-event-dispatcher/">Android 事件分发机制总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Android/android-refactor-mvp/">Android MVP 架构重构实践</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/C-C/cpp-stl-hashmap/">C++ STL 之哈希表 | unordered_map</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Android/android-performance-1/">Android 应用性能优化总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Android/android-aysnc-message/">Android 异步消息处理机制总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Summary/struct_sizeof/">C/C++ 结构体字节对齐</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-hashcode-equal/">hashCode 方法及 equals 方法的规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-basic-summary-01/">Java 基础技术细节总结 | 语言规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/gdb-simple/">gdb 用法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Algorithm/algorithm-cache/">缓存算法（页面置换算法）总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Web/web-frontend-02/">Web开发笔记 - 前端总结 (性能篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Web/web-frontend-01/">Web开发笔记 - 前端总结(开发篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Algorithm/algorithm-linkedlist-leetcode/">LeetCode | 链表相关算法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-classloader-parent-delegation-model/">深入探究 JVM | 类加载器与双亲委派模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Life/test-migrate/">博客搬迁咯~</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-gc-hotspot-implements/">深入探究 JVM | HotSpot JVM 的 GC 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-gc-safepoint-condition/">深入探究 JVM | Safepoint 及 GC 的触发条件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-gc-method-types/">深入探究 JVM | 初探 GC 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-reference-type/">Java 中的几种引用 | 弱引用、软引用、虚引用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-gc-intro-count-vs-reachability/">深入探究 JVM | 初探 GC - 引用计数 VS 可达分析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-metaspace/">深入探究 JVM | 探秘 Metaspace</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-reflection-2/">深入解析Java反射（2） - invoke方法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/java-reflection-1/">深入解析Java反射（1） - 基础</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Java/jvm-memory/">深入探究 JVM | Java 的内存区域解析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Architecture/docker-tutorial/">Docker 入门学习札记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Develop/game-dev-unity/">Unity游戏开发总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Life/chemistry-jt-2014/">2014晶体培养 - 硫酸铜单晶</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/Life/chemistry-jt-2013/">2013寒假晶体培养 - 硫酸铜单晶</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2015 - 2018 sczyh30's blog
            </div>
            <div class="footer-right">
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255963745'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255963745%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank">Yelee</a> by MOxFIVE. Enhanced by sczyh30 <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 7;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>